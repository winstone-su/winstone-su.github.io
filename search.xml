<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iOS 控件遮盖问题</title>
      <link href="/posts/3fd372c/"/>
      <url>/posts/3fd372c/</url>
      
        <content type="html"><![CDATA[<p>​ 在已经设置好布局的StoryBoard上面，添加一些新的空间，然后点击某个按钮弹窗的时候，发现新添加的空间还是显示在最上层</p><p>解决办法： 在Storyboard的列表中，越往下的控件，在屏幕显示就会越在上面，只需要把新加的控件拖动到上面即可</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/rmth2lk5ERwf1KU.png" alt="Storyboard"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024-05-21-Mapbox for Android - 去除水印Logo</title>
      <link href="/posts/2618ccec/"/>
      <url>/posts/2618ccec/</url>
      
        <content type="html"><![CDATA[<p>使用Mapbox样式地图，左下角有一个Logo和Attribution</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2024/05/21/pEIDKQoAF5OvUPs.png" alt="image-20240521151850335"></p><p>那么怎么去除这个水印呢</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mapView <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    binding.mapView</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去除mapbox的Logo</span></span><br><span class="line">mapView.logo.enabled = <span class="literal">false</span></span><br><span class="line"><span class="comment">//去除Attribution</span></span><br><span class="line">mapView.attribution.enabled = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>最终效果如图</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2024/05/21/CIO5huYs2RDVq9P.png" alt="image-20240521152133339"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-05-21-Mapbox for Android - 本地化地图</title>
      <link href="/posts/7c600644/"/>
      <url>/posts/7c600644/</url>
      
        <content type="html"><![CDATA[<h2 id="加载地图"><a href="#加载地图" class="headerlink" title="加载地图"></a>加载地图</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mapboxMap <span class="keyword">by</span> lazy &#123;</span><br><span class="line">mapView.mapboxMap</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">mapboxMap.apply &#123;</span><br><span class="line">    loadStyle(Style.MAPBOX_STREETS)</span><br><span class="line">    setCamera(</span><br><span class="line">        CameraOptions.Builder()</span><br><span class="line">        .center(Point.fromLngLat(LONGITUDE, LATITUDE))</span><br><span class="line">        .zoom(<span class="number">15.0</span>)</span><br><span class="line">        .build()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到地图的效果是</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2024/05/21/4rACiafbQyuOWId.png" alt="image-20240521094238076"></p><p>如何将这些注记用中文展示，需要修改mapboxMap的<code>style</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> locale: Locale</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">locale = resources.configuration.locales.<span class="keyword">get</span>(<span class="number">0</span>)</span><br><span class="line">mapboxMap.apply &#123;</span><br><span class="line">    loadStyle(Style.MAPBOX_STREETS)&#123;</span><br><span class="line">        <span class="comment">//或者这里的local 也可以直接使用Locale.CHINA</span></span><br><span class="line">        it.localizeLabels(locale)</span><br><span class="line">    &#125;</span><br><span class="line">    setCamera(</span><br><span class="line">        CameraOptions.Builder()</span><br><span class="line">        .center(Point.fromLngLat(LONGITUDE, LATITUDE))</span><br><span class="line">        .zoom(<span class="number">15.0</span>)</span><br><span class="line">        .build()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的效果如下:</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2024/05/21/dVBIKclLENq3Grj.png" alt="image-20240521095609486"></p><p>需要注意的是，这里并不是所有的注记都成了中文</p><p>更多可以参考：<a href="https://github.com/mapbox/mapbox-maps-android/tree/v11.3.1/extension-localization">https://github.com/mapbox/mapbox-maps-android/tree/v11.3.1/extension-localization</a></p><p>在这里它添加了</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.mapbox.extension:maps-localization:11.3.1&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个依赖，但是我们在直接使用Mapbox的依赖里面，已经包涵了上面的依赖</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.mapbox.maps:android:11.3.1&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mapbox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> mapbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-12-19-Arcgis Android WmsLayer添加cql_filter查询</title>
      <link href="/posts/2d07bdaa/"/>
      <url>/posts/2d07bdaa/</url>
      
        <content type="html"><![CDATA[<p>准备：<br> wms数据源：这里我使用的是geoserver发布的地图服务</p><blockquote><p>测试地址： <a href="http://218.77.59.2:6200/geoserver/ows?service=wms&version=1.3.0&request=GetCapabilities">http://218.77.59.2:6200/geoserver/ows?service=wms&amp;version=1.3.0&amp;request=GetCapabilities</a></p></blockquote><p>我的需求是,过滤出图层查询条件<code>status=1</code>的数据。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> wmsLayer = WmsLayer(url, names)</span><br><span class="line">wmsLayer.customParameters[<span class="string">&quot;CQL_FILTER&quot;</span>] = <span class="string">&quot;status=1&quot;</span></span><br><span class="line">wmsLayer.loadAsync()</span><br><span class="line">refreshIntervalMilliseconds?.run &#123; wmsLayer.refreshInterval = <span class="keyword">this</span> &#125;</span><br><span class="line">wmsLayer.addLoadStatusChangedListener &#123; loadStatusChangedEvent -&gt;</span><br><span class="line"><span class="keyword">if</span> (loadStatusChangedEvent.newLoadStatus != LoadStatus.LOADED) &#123;</span><br><span class="line">     <span class="keyword">val</span> error = loadStatusChangedEvent.newLoadStatus</span><br><span class="line">     <span class="keyword">if</span> (error != <span class="literal">null</span>) &#123;</span><br><span class="line">         Log.e(<span class="string">&quot;WMSLayer&quot;</span>, <span class="string">&quot;Failed to load WMSLayer: <span class="variable">$error</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里使用了<code>customParameters</code>这个方法，然后在里面添加了key为 <code>CQL_FILTER</code> 值为<code>status=1</code> 查询条件的结果.</p><p>放一下加了查询条件和不加的对比</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/12/19/9FTCjRlOmLADk4y.png" alt="未加CQL_FILTER"></p><p>加了<code>CQL_FILTER</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/12/19/KOYRseMSpg8Z1cG.png" alt="添加CQL_FILTER的数据"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023-11-13-Android 使用Retrofit下载文件</title>
      <link href="/posts/38874b4a/"/>
      <url>/posts/38874b4a/</url>
      
        <content type="html"><![CDATA[<h2 id="Retrofit-Service"><a href="#Retrofit-Service" class="headerlink" title="Retrofit Service"></a>Retrofit Service</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Streaming</span></span><br><span class="line"><span class="meta">@GET</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">downloadFile</span><span class="params">(<span class="meta">@Url</span> fileUrl: <span class="type">String</span>)</span></span>: Call&lt;ResponseBody&gt;</span><br></pre></td></tr></table></figure><p><strong>这里不能用<code>suspend</code>关键字</strong></p><ul><li><strong><code>@Streaming</code> 注解：</strong> 这个注解告知 Retrofit 不应将整个响应主体加载到内存中。它用于处理大文件或者流式数据，允许以流的方式逐段处理响应数据而不是一次性加载全部到内存中。它通常在下载大文件或者处理视频流等情况下使用。</li><li><strong><code>suspend</code> 关键字：</strong> 这是 Kotlin 协程的一部分，用于标记函数可以挂起执行。它允许在协程中使用挂起函数，使得异步操作更加方便和易于处理。</li></ul><p>因为它们的作用和机制不同，<code>@Streaming</code> 注解主要是为了告知 Retrofit 应该以流的方式处理响应数据，而 <code>suspend</code> 关键字用于标记可以挂起执行的函数。<code>@Streaming</code> 注解主要作用于 Retrofit 处理响应体的方式，而 <code>suspend</code> 关键字主要用于在协程中处理异步操作。</p><p>在 Retrofit 中，<code>@Streaming</code> 注解通常与 <code>Call&lt;ResponseBody&gt;</code> 结合使用，因为它们允许以流式方式处理响应体。而 <code>suspend</code> 关键字用于将 Retrofit 方法转换为可以在协程中使用的挂起函数，但由于其异步性质，与 <code>@Streaming</code> 注解在技术上并不兼容。</p><h2 id="Retrofit创建"><a href="#Retrofit创建" class="headerlink" title="Retrofit创建"></a>Retrofit创建</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: FileDownloadService &#123;</span><br><span class="line">       <span class="keyword">val</span> okHttpClient = OkHttpClient.Builder().build()</span><br><span class="line">       <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">           .baseUrl(<span class="string">&quot;http://218.77.59.2:6203/&quot;</span>)</span><br><span class="line">           .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">           .client(okHttpClient)</span><br><span class="line">           .build()</span><br><span class="line">       <span class="keyword">return</span> retrofit.create(FileDownloadService::<span class="keyword">class</span>.java)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="ViewModel中使用"><a href="#ViewModel中使用" class="headerlink" title="ViewModel中使用"></a>ViewModel中使用</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">download</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> response = withContext(Dispatchers.IO) &#123;</span><br><span class="line">                    fileDownloadService.downloadFile(MainActivity.DOWNLOAD_URL).execute()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (response.isSuccessful) &#123;</span><br><span class="line">                    <span class="keyword">val</span> body = response.body()</span><br><span class="line">                    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">val</span> url = response.raw().request().url().toString()</span><br><span class="line">                        <span class="keyword">val</span> fileName = getFileNameFromUrl(url)</span><br><span class="line">                        saveFile(body, fileName)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 文件下载失败处理</span></span><br><span class="line">                    LogUtils.d(<span class="string">&quot;文件处理失败： <span class="subst">$&#123;response.isSuccessful&#125;</span>&#125;&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">saveFile</span><span class="params">(body: <span class="type">ResponseBody</span>,fileName: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> inputStream: InputStream? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> outputStream: OutputStream? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> fileReader = ByteArray(<span class="number">4096</span>)</span><br><span class="line">            <span class="keyword">val</span> fileSize = body.contentLength()</span><br><span class="line">            <span class="keyword">val</span> fileSizeDownloaded: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">            inputStream = body.byteStream()</span><br><span class="line">            <span class="keyword">val</span> file = File(application.filesDir,fileName?:<span class="string">&quot;a.apk&quot;</span>)</span><br><span class="line">            LogUtils.d(<span class="string">&quot;保存文件位置: <span class="subst">$&#123;file.absolutePath&#125;</span>&quot;</span>)</span><br><span class="line">            outputStream = FileOutputStream(file) <span class="comment">// 替换成你想要保存文件的路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> read = inputStream.read(fileReader)</span><br><span class="line">                <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                outputStream.write(fileReader, <span class="number">0</span>, read)</span><br><span class="line">            &#125;</span><br><span class="line">            outputStream.flush()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> fileMD5 = FileUtils.getFileMD5ToString(file)</span><br><span class="line">            LogUtils.d(<span class="string">&quot;保存成功,<span class="subst">$&#123;fileMD5&#125;</span>&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            inputStream?.close()</span><br><span class="line">            outputStream?.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getFileNameFromUrl</span><span class="params">(url: <span class="type">String</span>)</span></span>: String? &#123;</span><br><span class="line">        <span class="keyword">var</span> fileName: String? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">val</span> lastPathSegment = Uri.parse(url).lastPathSegment</span><br><span class="line">        <span class="keyword">if</span> (!lastPathSegment.isNullOrEmpty()) &#123;</span><br><span class="line">            fileName = lastPathSegment</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fileName</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Retrofit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-11-10-Jetpack-Compose中加载WebView</title>
      <link href="/posts/6cf43688/"/>
      <url>/posts/6cf43688/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近在<code>Compose</code>里面使用<code>WebView</code>加载页面的时候发现页面元素加载不全</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressLint(<span class="string">&quot;SetJavaScriptEnabled&quot;</span>)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WebViewScreen</span><span class="params">(url: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> context = LocalContext.current</span><br><span class="line">    <span class="keyword">val</span> webView = WebView(context)</span><br><span class="line">    </span><br><span class="line">    webView.webViewClient = WebViewClient()</span><br><span class="line">    webView.webChromeClient = WebChromeClient()</span><br><span class="line"></span><br><span class="line">    webView.loadUrl(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create an AndroidView that wraps the WebView</span></span><br><span class="line">    AndroidView(</span><br><span class="line">        factory = &#123; webView &#125;,</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .fillMaxSize()</span><br><span class="line">            .background(color = MaterialTheme.colorScheme.primary),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载后效果</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://i.imgur.com/BM7rIae.png" alt="image-20231110111624867"></p><p>这个是在浏览器正常的效果</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://i.imgur.com/SpFXS8g.png" alt="image-20231110111816562"></p><p>对比之下，有很多元素没有加载出来。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在<code>webview</code>初始化的时候，设置它的<code>layoutParams</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> webView = WebView(context).apply &#123;</span><br><span class="line">        layoutParams = ViewGroup.LayoutParams(</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>同时把<code>loadurl</code>方法移动到<code>AndroidView</code>方法里面</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressLint(<span class="string">&quot;SetJavaScriptEnabled&quot;</span>)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WebViewScreen</span><span class="params">(url: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> context = LocalContext.current</span><br><span class="line">    <span class="keyword">val</span> webView = WebView(context).apply &#123;</span><br><span class="line">        layoutParams = ViewGroup.LayoutParams(</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    webView.setLayerType(View.LAYER_TYPE_HARDWARE, <span class="literal">null</span>)</span><br><span class="line">    webView.settings.run &#123;</span><br><span class="line">        javaScriptEnabled = <span class="literal">true</span></span><br><span class="line">        loadsImagesAutomatically = <span class="literal">true</span></span><br><span class="line">        mediaPlaybackRequiresUserGesture = <span class="literal">false</span></span><br><span class="line">        domStorageEnabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    webView.webViewClient = WebViewClient()</span><br><span class="line">    webView.webChromeClient = WebChromeClient()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create an AndroidView that wraps the WebView</span></span><br><span class="line">    AndroidView(</span><br><span class="line">        factory = &#123; webView &#125;,</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .fillMaxSize()</span><br><span class="line">            .background(color = MaterialTheme.colorScheme.primary),</span><br><span class="line">        update = &#123;</span><br><span class="line">            it.loadUrl(url)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack Compose </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-08-28-Mac下安装LabelImg</title>
      <link href="/posts/48460f42/"/>
      <url>/posts/48460f42/</url>
      
        <content type="html"><![CDATA[<p>官方地址： <a href="https://github.com/HumanSignal/labelImg">https://github.com/HumanSignal/labelImg</a></p><p>官方推荐方法</p><p>Virtualenv can avoid a lot of the QT &#x2F; Python version issues</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install python3</span><br><span class="line">pip3 install pipenv</span><br><span class="line">pipenv run pip install pyqt5==5.15.2 lxml</span><br><span class="line">pipenv run make qt5py3</span><br><span class="line">pipenv run python3 labelImg.py</span><br><span class="line">[Optional] rm -rf build dist; pipenv run python setup.py py2app -A;mv &quot;dist/labelImg.app&quot; /Applications</span><br></pre></td></tr></table></figure><p>因为官方推荐的是使用<code>pipenv</code>,而我是使用<code>conda</code></p><p>所以修改一下改为使用支持<code>conda</code>的方法</p><p>首先下载<code>labelimg的代码</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/HumanSignal/labelImg.git</span><br></pre></td></tr></table></figure><p>然后进入labelimg的目录</p><p>然后激活自己的<code>conda</code>环境</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install pyqt5==5.15.2 lxml</span><br><span class="line">make qt5py3</span><br><span class="line">python/python3  labelImg.py</span><br></pre></td></tr></table></figure><p>如果在<code>make qt5py3</code>的时候报错</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyrcc5 -o libs/resources.py resources.qrc</span><br><span class="line">make: pyrcc5: No such file or directory</span><br><span class="line">make: *** [qt5py3] Error 1</span><br></pre></td></tr></table></figure><p>可能是qt的环境安装有问题,建议卸载<code>pyqt5</code>、<code>qt</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda uninstall pyqt5</span><br><span class="line">conda uninstall qt</span><br></pre></td></tr></table></figure><p>重新安装即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023-08-25-一键激活下载利器IDM,支持官网最新版</title>
      <link href="/posts/a62f12dd/"/>
      <url>/posts/a62f12dd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载: <a href="https://cxapk.com/20338.html">https://cxapk.com/20338.html</a></p></blockquote><p>缺点就是试用到期后需要手动重置试用！不过重点是安全！</p><p>本文介绍另一种方法，直接将软件注册激活。目测还支持软件更新升级！重点是代码全部开源!</p><h2 id="试用到期"><a href="#试用到期" class="headerlink" title="试用到期"></a>试用到期</h2><p><code>Internet Download Manager</code> <strong>被用了 30 天，但仍未注册。试用期已满 IDM 正在退出.</strong>..</p><p>请注意，根据 IDM 的用户许可协议（您在安装 IDM 时已经阅读过），现在您必须卸载 IDM 或购买使用许可。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/08/25/wdG1el8ixCbsLv5.png" alt="一键激活下载利器IDM"></p><p>以上是试用到期弹框，无法启动软件！</p><h2 id="开源仓库"><a href="#开源仓库" class="headerlink" title="开源仓库"></a>开源仓库</h2><p>Github地址：<a href="https://cxapk.com/?golink=aHR0cHM6Ly9naXRodWIuY29tL2xzdHByamN0L0lETS1BY3RpdmF0aW9uLVNjcmlwdA==">https://github.com/lstprjct/IDM-Activation-Script</a></p><h2 id="简要操作"><a href="#简要操作" class="headerlink" title="简要操作"></a>简要操作</h2><p>1，下载官网最新版IDM：<a href="https://cxapk.com/?golink=aHR0cHM6Ly93d3cuaW50ZXJuZXRkb3dubG9hZG1hbmFnZXIuY29t">https://www.internetdownloadmanager.com</a></p><p>2，安装IDM软件</p><p>3，运行注册脚本【IAS_0.8.cmd】，选择【1】完成激活</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/08/25/rvfAqKsi8F3m2MX.png" alt="image-20230825095552975"></p><p>4，软件激活成功！</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-08-15-Mac下MonoProxy代理问题-Android Studio篇</title>
      <link href="/posts/9520e2f6/"/>
      <url>/posts/9520e2f6/</url>
      
        <content type="html"><![CDATA[<h2 id="Mac下开启了MonoProxy，怎么在Android-Studio中配置代理"><a href="#Mac下开启了MonoProxy，怎么在Android-Studio中配置代理" class="headerlink" title="Mac下开启了MonoProxy，怎么在Android Studio中配置代理"></a>Mac下开启了MonoProxy，怎么在Android Studio中配置代理</h2><p>MonoProxy设置</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/08/15/7gpIoJPFVLv1XaA.png" alt="Global Proxy"></p><p>Android Studio设置</p><p>在<code>Http Proxy</code>中设置</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/08/15/3bKw172qGfurk6W.png" alt="image-20230815155949644"></p><p>同时修改全局的<code>.gradle.properties</code>文件（路径在：<code>/Users/xxx/.gradle/.gradle.properties</code>）</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/08/15/huv9B3LsMZIJw6K.png" alt="image-20230815160119359"></p><p>如果Android Studio 弹出了提示，那么可以直接在这里设置，不需要上一步手动修改<code>.gradle.properties</code>了</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/08/15/zlFTuSdjsHpbMnO.png" alt="image-20230815160619739"></p>]]></content>
      
      
      <categories>
          
          <category> 网络代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MonoProxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-08-10-Windows下MonoProxy代理问题-idea篇</title>
      <link href="/posts/e4dee0d5/"/>
      <url>/posts/e4dee0d5/</url>
      
        <content type="html"><![CDATA[<h2 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h2><p><strong>在Windows下开启MonoProxy，Pycharm的Terminal无法通过pip install 安装第三方库</strong></p><ol><li>MonoProxy 已经开启了标准 或者 全局代理模式</li><li>Pycharm 的<code>Http Proxy</code> 也已经配置了代理</li></ol><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/08/10/S9RB4mWHJjC1nce.png" alt="image-20230810100330958"></p><p>然后在Pycharm 的<code>Terminal</code>适用<code>pip install</code> 还是会报网络错误</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">pip install shapely</span></span><br><span class="line">WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;ProxyError(&#x27;Cannot connect to proxy.&#x27;, OSError(0, &#x27;Error&#x27;))&#x27;: /simple/shapely/</span><br><span class="line">WARNING: Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;ProxyError(&#x27;Cannot connect to proxy.&#x27;, OSError(0, &#x27;Error&#x27;))&#x27;: /simple/shapely/</span><br><span class="line">WARNING: Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;ProxyError(&#x27;Cannot connect to proxy.&#x27;, OSError(0, &#x27;Error&#x27;))&#x27;: /simple/shapely/</span><br><span class="line">WARNING: Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;ProxyError(&#x27;Cannot connect to proxy.&#x27;, OSError(0, &#x27;Error&#x27;))&#x27;: /simple/shapely/</span><br><span class="line">WARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;ProxyError(&#x27;Cannot connect to proxy.&#x27;, OSError(0, &#x27;Error&#x27;))&#x27;: /simple/shapely/</span><br><span class="line">ERROR: Could not find a version that satisfies the requirement shapely (from versions: none)</span><br><span class="line">ERROR: No matching distribution found for shapely</span><br></pre></td></tr></table></figure><p> 推测不成功的原因可能是Windows配置的时候过滤了<code>Terminal</code>的代理，导致有问题</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/08/10/ZlnjMzH7cuIp8Wm.png" alt="image-20230810101116343"></p><p>  是否可以通过这里的配置修改，让终端也能够走代理，这里以后再去尝试。</p><p><strong>解决办法</strong></p><ol><li><p>Pycharm的<code>Http Proxy</code>可以关掉</p></li><li><p>在终端安装的时候使用<code>--proxy</code>来代理,例如:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">   pip install shapely --proxy=http://127.0.0.1:7078</span><br><span class="line"></span><br><span class="line">然后就可以愉快的安装了</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">Collecting shapely</span><br><span class="line">  Using cached shapely-2.0.1-cp37-cp37m-win_amd64.whl (1.4 MB)</span><br><span class="line">Collecting numpy&gt;=1.14</span><br><span class="line">  Downloading numpy-1.21.6-cp37-cp37m-win_amd64.whl (14.0 MB)</span><br><span class="line">     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 14.0/14.0 MB 7.4 MB/s eta 0:00:00</span><br><span class="line">Installing collected packages: numpy, shapely</span><br><span class="line">Successfully installed numpy-1.21.6 shapely-2.0.1</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>在PowerShell 和Anaconda 打开的终端中 安装第三方库也是一样的方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MonoProxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-08-08-GeoServer连接PG数据库发布服务</title>
      <link href="/posts/74ce3d34/"/>
      <url>/posts/74ce3d34/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GeoServer </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-07-20-YOLOv8训练模型</title>
      <link href="/posts/fa62927d/"/>
      <url>/posts/fa62927d/</url>
      
        <content type="html"><![CDATA[<h2 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yolo detect train data=coco128.yaml model=yolov8n.pt epochs=100 imgsz=640 device=mps</span><br></pre></td></tr></table></figure><p>coco128.yaml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/Users/carl/workspace/python/yolov5/sample/tunnel</span>  <span class="comment"># dataset root dir</span></span><br><span class="line"><span class="attr">train:</span> <span class="string">train2</span>  <span class="comment"># train images (relative to &#x27;path&#x27;) 128 images</span></span><br><span class="line"><span class="attr">val:</span> <span class="string">valid</span>  <span class="comment"># val images (relative to &#x27;path&#x27;) 128 images</span></span><br><span class="line"><span class="attr">test:</span>  <span class="comment"># test images (optional)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Classes</span></span><br><span class="line"><span class="attr">names:</span></span><br><span class="line">  <span class="attr">0:</span> <span class="string">KL</span></span><br><span class="line">  <span class="attr">1:</span> <span class="string">SS</span></span><br><span class="line">  <span class="attr">2:</span> <span class="string">TL</span></span><br><span class="line">  <span class="attr">3:</span> <span class="string">XB</span></span><br><span class="line">  <span class="attr">4:</span> <span class="string">XBHLF</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/20/Owhsg1B4ZNQJnu7.png" alt="目录结构"></p><p>如果训练异常中断了，需要重新训练，可以使用<code>resume</code>参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yolo detect train data=coco128.yaml model=yolov8n.pt epochs=100 imgsz=640 device=mps resume=True</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yolo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-07-19-Yolov5模型训练自己的数据集</title>
      <link href="/posts/d821665/"/>
      <url>/posts/d821665/</url>
      
        <content type="html"><![CDATA[<h2 id="下载yolov5"><a href="#下载yolov5" class="headerlink" title="下载yolov5"></a>下载yolov5</h2><p>Clone repo and install <a href="https://github.com/ultralytics/yolov5/blob/master/requirements.txt">requirements.txt</a> in a <a href="https://www.python.org/"><strong>Python&gt;&#x3D;3.7.0</strong></a> environment, including <a href="https://pytorch.org/get-started/locally/"><strong>PyTorch&gt;&#x3D;1.7</strong></a>.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/ultralytics/yolov5  # clone</span><br><span class="line">cd yolov5</span><br><span class="line">pip install -r requirements.txt  # install</span><br></pre></td></tr></table></figure><h2 id="下载模型"><a href="#下载模型" class="headerlink" title="下载模型"></a>下载模型</h2><p>在<a href="https://github.com/ultralytics/yolov5">https://github.com/ultralytics/yolov5</a>往下翻，找到<code>Pretrained Checkpoints</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/19/BHJfCF7qYt1asV8.png" alt="Model Download"></p><p>下载自己需要的模型,放到<code>weight</code>目录下(没有就新建一个)</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/19/5GfQytMpc4LosuW.png" alt="weight"></p><h3 id="测试自带模型"><a href="#测试自带模型" class="headerlink" title="测试自带模型"></a>测试自带模型</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">                            ①要测试的图片位置         ②权重文件的位置</span><br><span class="line">python .\detect.py --source .\data\images --weights .\weight\yolov5s.pt</span><br></pre></td></tr></table></figure><p>生成的结果如下，找到<code>runs\detect\exp16</code> 目录</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/19/3ULXJEsqa9oV58p.png" alt="image-20230719163022651"></p><p>可以看到这里的两张图片都已经标注完成了，但是这里多了一个<code>labels</code>目录，这个先不用管它，后面会讲。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/19/4ldqaEbPQ5Zn1wC.png" alt="image-20230719163201770"></p><h2 id="标记数据集"><a href="#标记数据集" class="headerlink" title="标记数据集"></a>标记数据集</h2><p>用<code>labelimg</code> 标记数据集，注意格式要保存为<code>YOLO</code>支持的<code>txt</code>格式</p><p><code>Change save format</code>改为<code>YOLO</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/19/K7a2FeuwLZnft5I.png" alt="image-20230719165846201"></p><p>**如果已经将标注设置为<code>PascalVOC</code>**，也就是<code>xml</code>格式，可以使用以下代码转换</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getcwd</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.</span></span><br><span class="line"><span class="comment"># 自己创建文件夹,例如：label_mal label_txt  也可以修改别的</span></span><br><span class="line">image_set = <span class="string">&#x27;folder_xml&#x27;</span>  <span class="comment"># 需要转换的文件夹名称（文件夹内放xml标签文件）</span></span><br><span class="line">imageset2 = <span class="string">&#x27;folder_txt&#x27;</span>  <span class="comment"># 保存txt的文件夹</span></span><br><span class="line"><span class="comment"># 2.</span></span><br><span class="line"><span class="comment"># 换成你的类别 当前的顺序，就txt 0,1,2,3,4 五个类别</span></span><br><span class="line">classes = [<span class="string">&#x27;XB&#x27;</span>, <span class="string">&#x27;TL&#x27;</span>, <span class="string">&#x27;KL&#x27;</span>, <span class="string">&#x27;XBHLF&#x27;</span>, <span class="string">&#x27;SS&#x27;</span>]  <span class="comment"># 标注时的标签 注意顺序一定不要错。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.</span></span><br><span class="line"><span class="comment"># # 转换文件夹的绝对路径</span></span><br><span class="line">data_dir = <span class="string">&#x27;F:&#x27;</span></span><br><span class="line"><span class="comment"># 或者 读取当前路径</span></span><br><span class="line"><span class="comment"># data_dir = getcwd()  # 当前路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xml中框的左上角坐标和右下角坐标(x1,y1,x2,y2)</span></span><br><span class="line"><span class="string">》》txt中的中心点坐标和宽和高(x,y,w,h)，并且归一化</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">size, box</span>):</span><br><span class="line">    dw = <span class="number">1.</span> / size[<span class="number">0</span>]</span><br><span class="line">    dh = <span class="number">1.</span> / size[<span class="number">1</span>]</span><br><span class="line">    x = (box[<span class="number">0</span>] + box[<span class="number">1</span>]) / <span class="number">2.0</span></span><br><span class="line">    y = (box[<span class="number">2</span>] + box[<span class="number">3</span>]) / <span class="number">2.0</span></span><br><span class="line">    w = box[<span class="number">1</span>] - box[<span class="number">0</span>]</span><br><span class="line">    h = box[<span class="number">3</span>] - box[<span class="number">2</span>]</span><br><span class="line">    x = x * dw</span><br><span class="line">    w = w * dw</span><br><span class="line">    y = y * dh</span><br><span class="line">    h = h * dh</span><br><span class="line">    <span class="keyword">return</span> x, y, w, h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_annotation</span>(<span class="params">data_dir, imageset1, imageset2, image_id</span>):</span><br><span class="line">    in_file = <span class="built_in">open</span>(data_dir + <span class="string">&#x27;/%s/%s.xml&#x27;</span> % (imageset1, image_id), <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)   <span class="comment"># 读取xml</span></span><br><span class="line">    out_file = <span class="built_in">open</span>(data_dir + <span class="string">&#x27;/%s/%s.txt&#x27;</span> % (imageset2, image_id), <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># 保存txt</span></span><br><span class="line">    <span class="built_in">print</span>(in_file)</span><br><span class="line"></span><br><span class="line">    tree = ET.parse(in_file)</span><br><span class="line">    root = tree.getroot()</span><br><span class="line">    size = root.find(<span class="string">&#x27;size&#x27;</span>)</span><br><span class="line">    w = <span class="built_in">int</span>(size.find(<span class="string">&#x27;width&#x27;</span>).text)</span><br><span class="line">    h = <span class="built_in">int</span>(size.find(<span class="string">&#x27;height&#x27;</span>).text)</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> root.<span class="built_in">iter</span>(<span class="string">&#x27;object&#x27;</span>):</span><br><span class="line">        difficult = obj.find(<span class="string">&#x27;difficult&#x27;</span>).text</span><br><span class="line">        cls = obj.find(<span class="string">&#x27;name&#x27;</span>).text</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> classes <span class="keyword">or</span> <span class="built_in">int</span>(difficult) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        cls_id = classes.index(cls)  <span class="comment"># 获取类别索引</span></span><br><span class="line">        xmlbox = obj.find(<span class="string">&#x27;bndbox&#x27;</span>)</span><br><span class="line">        b = (<span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;xmin&#x27;</span>).text), <span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;xmax&#x27;</span>).text), <span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;ymin&#x27;</span>).text),</span><br><span class="line">             <span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;ymax&#x27;</span>).text))</span><br><span class="line">        bb = convert((w, h), b)</span><br><span class="line">        out_file.write(<span class="built_in">str</span>(cls_id) + <span class="string">&quot; &quot;</span> + <span class="string">&quot; &quot;</span>.join([<span class="built_in">str</span>(<span class="string">&#x27;%.6f&#x27;</span> % a) <span class="keyword">for</span> a <span class="keyword">in</span> bb]) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">image_ids = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> glob.glob(data_dir + <span class="string">&#x27;/%s&#x27;</span> % image_set + <span class="string">&#x27;/*.xml&#x27;</span>):</span><br><span class="line">    image_ids.append(os.path.basename(x)[:-<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n%s数量:&#x27;</span> % image_set, <span class="built_in">len</span>(image_ids))  <span class="comment"># 确认数量</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> image_id <span class="keyword">in</span> image_ids:</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    convert_annotation(data_dir, image_set, imageset2, image_id)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s 数据:%s/%s文件完成！&quot;</span> % (image_set, i, <span class="built_in">len</span>(image_ids)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!!!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="训练数据集"><a href="#训练数据集" class="headerlink" title="训练数据集"></a>训练数据集</h2><p>我是在<code>yolov5</code>的主目录下新建了一个<code>sample/tunnel</code>目录，专门用来存放数据集，可以自定义目录</p><p>注意这个<code>data.yaml</code> ，<code>names</code> 就是你在<code>labelImg</code> 标注时的标签，<code>nc</code> 是<code>names</code>的数量, <code>train</code>是用来训练的数据集,<code>val</code> 是用来验证的数据集,如果验证数据的误差过大，会重新计算。</p><p><code>train</code>和<code>val</code>目录下都有<code>images</code>和<code>labels</code>两个目录，其中<code>images</code>目录是用来存放图片的，<code>labels</code>是用来存放标注文件的。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/19/dAKx1FTJzfNVEqs.png" alt="image-20230719170520518"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">                            ①单次训练的数量</span><br><span class="line">                                      ②训练轮次     ③yaml文件位置                      ④训练的权重文件位置</span><br><span class="line">python train.py --batch-size 2 --epochs 200 --data sample/tunnel/data.yaml --weights weight/yolov5s.pt</span><br></pre></td></tr></table></figure><p>运行之后就是漫长的等待过程。</p><p>训练好之后，会在<code>runs/train</code>目录下生成训练好的文件</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/19/27kVKwCXDRlMLUP.png" alt="image-20230719171615409"></p><p>权重文件目录,这里的<code>best.pt</code> 就是训练批次最好的模型，<code>last.pt</code> 是最后一次的结果</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/19/WgC6EF2oR1L8ZPI.png" alt="image-20230719171630290"></p><h2 id="测试训练好模型"><a href="#测试训练好模型" class="headerlink" title="测试训练好模型"></a>测试训练好模型</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python .\detect.py --source F:\images --weights runs/train/exp15/weights/best.pt</span><br></pre></td></tr></table></figure><p>结果会在<code>runs\detect</code>目录下</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/19/Nk2GyIsgnJ1mWwb.png" alt="image-20230719171924810"></p><p>同时这里生成了一个<code>runs\detect\exp17\labels</code>，这个问题在上面提出过</p><p>这是因为我的需求是<strong>要求测试的模型，同时生成txt格式的标注</strong></p><p>在参数<code>--save-txt</code> 添加一个默认值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;--save-txt&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;save results to *.txt&#x27;</span>,default= <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/19/t8igU2vGIREDFSP.png" alt="image-20230719172243040"></p><p>这样运行<code>detect.py</code> 就会同时生成标注文件。</p><h3 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h3><p>同时如果觉得测试模型的命令太长了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python .\detect.py --source F:\images --weights runs/train/exp15/weights/best.pt</span><br></pre></td></tr></table></figure><p>可以手动修改<code>detect.py</code> ，可以修改<code>--source</code> 和<code>--weights</code> 为自定义的值</p><p>这样就只需要运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python .\detect.py</span><br></pre></td></tr></table></figure><p>修改<code>cuda device</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parser.add_argument(&#x27;--device&#x27;, default=&#x27;&#x27;, help=&#x27;cuda device, i.e. 0 or 0,1,2,3 or cpu&#x27;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yolov5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-07-10-MacOS:XX已损坏，无法打开</title>
      <link href="/posts/20ad0a3f/"/>
      <url>/posts/20ad0a3f/</url>
      
        <content type="html"><![CDATA[<p><strong>XX已经损坏，无法打开。您应该将它移到废纸篓。</strong></p><p>系统环境：</p><ul><li>MBP M1 Pro</li><li>MacOS Ventura 13.3.1</li></ul><p>下载<code>PicGo</code>，打开应用时提示已经损坏</p><p>解决办法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure><p>在<strong>安全与隐私</strong>里面允许<code>任何来源</code> 安装</p><p>如果还是弹出这个提示</p><p>运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xattr -cr /Applications/PicGo.app </span><br></pre></td></tr></table></figure><p>可以先输入<code>xattr -cr </code> 然后在<code>Finder</code> – <code>应用程序</code>里找到损坏的App，直接拖入终端。再次打开即可.</p>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-07-08-Android手动升级AGP</title>
      <link href="/posts/409df144/"/>
      <url>/posts/409df144/</url>
      
        <content type="html"><![CDATA[<p>打开Android Studio工程，有些项目会弹出升级AGP的提示，有些项目又不会。</p><p>最近因为升级了工程的某些依赖库，需要将 <code>compileSdk</code> 和<code>targetSdk</code>升级到<code>33</code>，同时工程会报错，显示AGP版本低了，需要升级。</p><p><strong>操作方法</strong> </p><p>在AS里面搜索<code>Upgrade Assistant</code></p><p>![截屏2023-07-08 22.48.45](&#x2F;Users&#x2F;carl&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2023-07-08 22.48.45.png)</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> AGP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-07-06-Windows下搭建MQTT服务器以及Android测试连接</title>
      <link href="/posts/2b43af4d/"/>
      <url>/posts/2b43af4d/</url>
      
        <content type="html"><![CDATA[<h2 id="MQTT服务器"><a href="#MQTT服务器" class="headerlink" title="MQTT服务器"></a>MQTT服务器</h2><p>MQTT开源服务器很多，比如:</p><ul><li>Mosquitto：Eclipse Mosquitto使用 C 语言实现的 MQTT 服务器</li><li>EMQX：使用 Erlang 语言开发的 MQTT 服务器，内置强大的规则引擎，支持许多其他 IoT 协议，比如MQTT-SN、CoAP、LwM2M 等。</li><li>Mosca：使用 Node.JS 开发的 MQTT 服务器，简单易用。</li><li>VerneMQ：使用 Erlang 开发的 MQTT 服务器。</li></ul><p>更多MQTT的本地服务器和云服务器可以参考<a href="https://mqtt.org/software/">https://mqtt.org/software/</a></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/VgueonIrf9YzL3J.png" alt="MQTT Broker"></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="下载EMQX"><a href="#下载EMQX" class="headerlink" title="下载EMQX"></a>下载EMQX</h3><p>这里使用的是<code>EMQX</code>,Windows下建议只是用于本地测试，不建议用于生产。</p><p><strong>下载地址</strong> <a href="https://www.emqx.io/zh/downloads?os=Windows">https://www.emqx.io/zh/downloads?os=Windows</a></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/Drpa9tGxXlqOR3k.png" alt="EMQX Download"></p><p>解压后如下：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/Xpg4m3RqlUWHjfh.png" alt="unzip"></p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><ol><li>打开PowerShell，进入bin目录</li><li>启动 EMQX（两种启动方式：<code>emqx start</code>守护进程模式、<code>emqx console</code>控制台模式）</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">emqx start</span><br></pre></td></tr></table></figure><ol start="3"><li>启动成功后，查看节点的运行状态（如返回 pong，则表示运行状态正常）</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">emqx ping</span><br></pre></td></tr></table></figure><p>停止服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">emqx stop</span><br></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">emqx restart</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/hiqQX4BfMSWIRe2.png" alt="service"></p><p>EMQX默认提供端口（可以在 <code>/emqx/etc/emqx.conf</code> 文件中修改端口号）：</p><table><thead><tr><th>EMQX端口</th><th>说明</th></tr></thead><tbody><tr><td>1883</td><td>MQTT TCP 协议端口</td></tr><tr><td>8883</td><td>MQTT&#x2F;TCP SSL 端口</td></tr><tr><td>8083</td><td>MQTT&#x2F;WebSocket 端口</td></tr><tr><td>8084</td><td>MQTT&#x2F;WebSocket with SSL 端口</td></tr><tr><td>18083</td><td>EMQX Dashboard 管理控制台端口</td></tr></tbody></table><h3 id="登录EMQX-Dashboard"><a href="#登录EMQX-Dashboard" class="headerlink" title="登录EMQX Dashboard"></a>登录EMQX Dashboard</h3><blockquote><p>EMQX 启动成功后，可以访问<code>http://127.0.0.1:18083</code> 进入EMQX Dashboard 管理控制台进行设备连接和相关指标监控管理。</p></blockquote><p><strong>初始账号：admin，初始密码：public</strong></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/1gReT9G5JjqLZrz.png" alt="dashboard"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="创建客户端认证"><a href="#创建客户端认证" class="headerlink" title="创建客户端认证"></a>创建客户端认证</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>按照下图步骤，创建客户端认证</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/or9wuP7Dh2tGyLW.png" alt="客户端认证"></p><p>认证方式：选择<code>Password-Based</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/zUbQuV9DAqnrNPX.png" alt="认证方式"></p><p>选择数据库:  并不是用于生产，所以直接用了内置数据库，也可以选择自己喜欢的</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/CDxSMqLQ6KV1Jym.png" alt="choose database"></p><p>加密方式： 直接用默认就可以了</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/olXpQKavHRfPhzu.png" alt="配置参数"></p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>选择用户管理</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/Apg9nXmUqZCB3JT.png" alt="用户管理"></p><p>添加用户</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/6fM7n1JI9TqyBOv.png" alt="create user"></p><p>我们这里创建一个测试用户 user 密码: 123456</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/Fqbh5C462oQvaR3.png" alt="create user"></p><h2 id="MQTT-fx连接测试"><a href="#MQTT-fx连接测试" class="headerlink" title="MQTT.fx连接测试"></a>MQTT.fx连接测试</h2><p>MQTT.fx 下载地址: <a href="https://softblade.de/en/welcome/">https://softblade.de/en/welcome/</a></p><h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>点击设置图标</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/pDVdnNiUytFPQjC.png" alt="setting"></p><p>输入Broker Address 和 Port，这里可以用127.0.0.1，如果是固定IP的话，也可以使用固定IP，我自己的IP就是<code>192.168.1.8</code></p><p>在<code>User Credentials</code>里面选择<code>Use Username/Password</code> ，输入我们刚才创建的用户<code>user/123456</code>(<strong>不是控制台的用户名密码</strong>)</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/KdVmHglxutTDEzB.png" alt="image-20230706152343008"></p><p>点击<code>Apply</code> -&gt; <code>OK</code></p><p>然后点击主界面的<code>connect</code>,如下表示连接成功</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/ewB92KMR5TNxmLJ.png" alt="mqtt connect"></p><p>我们在Dashboard可以看到总连接数&#x2F;在线连接数发生了变化(不需要刷新网页，会自动刷新)</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/U2OSf9r3Czg61Tl.png" alt="dashboard view"></p><p>再回到MQTT.fx</p><p>我们订阅一个主题: <code>/dev/myproject/topic</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/IoGbyZVK8TXeU1M.png" alt="image-20230706153246346"></p><p>主题数和订阅数也同步发生了变化</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/kVgcxpLwEHdhK5Z.png" alt="image-20230706153311779"></p><p>现在我们利用<code>Publish</code> 发布一条消息，点击<code>Publish</code>按钮</p><p>发布测试消息<code>hello world</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/V5tx2uEZ7F4Hzpa.png" alt="image-20230706153411161"></p><p>然后切换到<code>Subscribe</code>页签，可以看到在界面上已经显示了刚才发布的消息</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/Pb2rdMvEA53S6eL.png" alt="image-20230706153456080"></p><h2 id="Android连接测试"><a href="#Android连接测试" class="headerlink" title="Android连接测试"></a>Android连接测试</h2><p>Demo地址： <a href="https://github.com/winstone-su/MqttJava">https://github.com/winstone-su/MqttJava</a></p><p>这里我使用的是雷电模拟器，需要注意的是,这里的IP使用的是我本机的IP <code>192.168.1.8</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务器地址（协议+地址+端口号）</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;tcp://192.168.1.8:1883&quot;</span>;</span><br><span class="line"><span class="comment">//用户名</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line"><span class="comment">//密码</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="comment">//发布主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">PUBLISH_TOPIC</span> <span class="operator">=</span> <span class="string">&quot;/dev/myproject/topic&quot;</span>;</span><br></pre></td></tr></table></figure><p>在Android端发布一条消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyMqttService.publish(<span class="string">&quot;这是一条来自Android的消息&quot;</span>);</span><br></pre></td></tr></table></figure><p>在MQTT.fx中收到消息</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/06/zK9H6INQgyXnAJh.png" alt="image-20230706154758540"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-07-02-Mac下MonoProxy使用</title>
      <link href="/posts/f477121f/"/>
      <url>/posts/f477121f/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-Studio-使用"><a href="#Android-Studio-使用" class="headerlink" title="Android Studio 使用"></a>Android Studio 使用</h2><p>打开全局代理模式</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/02/SOM85zN7r1Y4H9s.png" alt="截屏2023-07-02 22.20.00"></p><p>如果还不行的的话，打开SOCK5</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/02/VOk1tKpWAPyv9zf.png" alt="截屏2023-07-02 22.24.56"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023-06-08-Charles-雷电模拟器抓包</title>
      <link href="/posts/881e8cd6/"/>
      <url>/posts/881e8cd6/</url>
      
        <content type="html"><![CDATA[<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><ul><li><p>Charles  (<a href="https://www.charlesproxy.com/download/">V4.6.4</a>)</p></li><li><p>雷电模拟器 (<a href="https://www.ldmnq.com/">V9.X</a>)</p></li></ul><h2 id="Charles设置"><a href="#Charles设置" class="headerlink" title="Charles设置"></a>Charles设置</h2><h3 id="电脑证书安装"><a href="#电脑证书安装" class="headerlink" title="电脑证书安装"></a>电脑证书安装</h3><p>按照以下步骤安装证书</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/X3IOyvN5K4Yg67M.png" alt="install certificate"></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/Q5go7zSethkWvy8.png" alt="cer"></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/tKeNrPWcsVBgDqk.png" alt="install "><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/RUhYEyvVoqOgJrf.png" alt="image-20230608161000858"></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/lngPzcLN6raQdsh.png" alt="image-20230608161042434"></p><h3 id="保存根证书到本地磁盘"><a href="#保存根证书到本地磁盘" class="headerlink" title="保存根证书到本地磁盘"></a>保存根证书到本地磁盘</h3><blockquote><p>雷电模拟器需要先开启Root设置</p></blockquote><ol><li>导出根证书</li></ol><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/QvnSDpWVh8jAIH7.png" alt="import root cer"><br>导出到本地计算机，<strong>选择cer格式</strong></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/j2H7mTsZOyaREWk.png" alt="local cer"></p><h3 id="代理端口和SSL设置"><a href="#代理端口和SSL设置" class="headerlink" title="代理端口和SSL设置"></a>代理端口和SSL设置</h3><ol><li>允许SSL</li></ol><p>Proxy –&gt; SSL Proxying Settings</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/qkz6AVa3B8JwHj9.png" alt="image-20230608164046839"></p><p>添加代理</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230608164121813.png" alt="SSL Proxying Settings"></p><p>配置所有的IP和端口都走代理</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/ncM35aIZrRzjb47.png" alt="image-20230608164236059"></p><ol start="2"><li>端口设置</li></ol><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/FiGrAenztcZxSa7.png" alt="Proxy Settings"></p><p>开启<code>Enable SOCKS proxy</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/YmgDpRJEBZoxU1C.png" alt="Enable SOCKS proxy"></p><h2 id="雷电模拟器设置"><a href="#雷电模拟器设置" class="headerlink" title="雷电模拟器设置"></a>雷电模拟器设置</h2><h3 id="导入根证书"><a href="#导入根证书" class="headerlink" title="导入根证书"></a>导入根证书</h3><p>将上面目录保存到<code>.cer</code>证书，直接拖到雷电模拟器的运行窗口。</p><p>打开雷电模拟器 设置 –&gt; 网络和互联网 –&gt; WLAN</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/9Lk6I2RCtTZayh1.png" alt="WLAN"></p><p>打开WLAN偏好设置</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/oJvtl2FBwEpY7eG.png" alt="image-20230608165403602"></p><p>打开<code>高级</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/wRW1iPDa4kdUryf.png" alt="image-20230608165631844"></p><p>点击<code>安装证书</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/JzBvQImcY4upZjO.png" alt="image-20230608165656044"></p><p>选择刚才导入的<code>cer</code>文件</p><blockquote><p>我的目录是在 Pictures目录 下</p></blockquote><p>随便输入一个名字</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/lwVgxXqEPIAo4SU.png" alt="image-20230608165841872"></p><p>如果弹出了以下弹框，先设置一个锁屏密码</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/C8ctuLrSXNowB3z.png" alt="image-20230608165942037"></p><h3 id="设置雷电模拟器代理"><a href="#设置雷电模拟器代理" class="headerlink" title="设置雷电模拟器代理"></a>设置雷电模拟器代理</h3><p>在网络连接里面设置连接网络的代理，代理服务器主机名就是本机电脑的IP，端口默认是：<code>8888</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/VozpWIeNqwfUOui.png" alt="image-20230608170216717"></p><h2 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h2><p>在第一次使用代理进行网络请求的时候，Charles会弹出以下选择框，这里选择<code>Allow</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/zITKMNJxbS8BEhO.png" alt="connection confirm"></p><p>在Charles里面可以看到获取到的网络请求了</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/06/08/YQhIx1rcNsZa6GA.png" alt="image-20230608170853069"></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-05-12-Hilt的使用</title>
      <link href="/posts/935bce3/"/>
      <url>/posts/935bce3/</url>
      
        <content type="html"><![CDATA[<h2 id="Hilt的作用"><a href="#Hilt的作用" class="headerlink" title="Hilt的作用"></a>Hilt的作用</h2><p><strong>Hilt是Dagger的最强辅助</strong></p><ul><li>Hilt简化了Dagger使用，<code>大量减少了使用Dagger时编写的模板代码</code>。</li><li>Hilt提供一套标准组件和作用域注解：不必再自定义组件和作用域。</li><li>Hilt提供几种预定义的的绑定(<code>提供对象实例的获取称为绑定</code>)：如Application和Activity。</li><li>Hilt提供集中预定义的限定符(Qualifier)： @ApplicationContext和@ActivityContext。</li></ul><h2 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h2><p>首先，将<code>hilt-android-gradle-plugi</code>添加到<code>Project</code>级的<code>build.gradle</code>文件中：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">&quot;com.google.dagger.hilt.android&quot;</span>) version <span class="string">&quot;2.44&quot;</span> apply <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，应用 Gradle 插件并在 <code>app/build.gradle</code> 文件中添加以下依赖项：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  kotlin(<span class="string">&quot;kapt&quot;</span>) <span class="comment">//报错的话使用  id &#x27;kotlin-kapt&#x27;</span></span><br><span class="line">  id(<span class="string">&quot;com.google.dagger.hilt.android&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation(<span class="string">&quot;com.google.dagger:hilt-android:2.44&quot;</span>)</span><br><span class="line">  kapt(<span class="string">&quot;com.google.dagger:hilt-android-compiler:2.44&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow references to generated code</span></span><br><span class="line">kapt &#123;</span><br><span class="line">  correctErrorTypes = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hilt 使用 <a href="https://developer.android.com/studio/write/java8-support?hl=zh-cn">Java 8 功能</a>。如需在项目中启用 Java 8，请将以下代码添加到 <code>app/build.gradle</code> 文件中：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  compileOptions &#123;</span><br><span class="line">    sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hilt-应用类"><a href="#Hilt-应用类" class="headerlink" title="Hilt 应用类"></a>Hilt 应用类</h2><p>所有使用 Hilt 的应用都必须包含一个带有 <code>@HiltAndroidApp</code> 注解的 <a href="https://developer.android.com/reference/android/app/Application?hl=zh-cn"><code>Application</code></a> 类。</p><p><code>@HiltAndroidApp</code> 会触发 Hilt 的代码生成操作，生成的代码包括应用的一个基类，该基类充当应用级依赖项容器。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HiltAndroidApp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span>: <span class="type">Application</span>() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>生成的这一 Hilt 组件会附加到 <code>Application</code> 对象的生命周期，并为其提供依赖项。此外，它也是应用的父组件，这意味着，其他组件可以访问它提供的依赖项。</p><h2 id="将依赖项注入-Android-类"><a href="#将依赖项注入-Android-类" class="headerlink" title="将依赖项注入 Android 类"></a>将依赖项注入 Android 类</h2><p>在 <code>Application</code> 类中设置了 Hilt 且有了应用级组件后，Hilt 可以为带有 <code>@AndroidEntryPoint</code> 注解的其他 Android 类提供依赖项：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Hilt 目前支持以下 Android 类：</p><ul><li><code>Application</code>（通过使用 <code>@HiltAndroidApp</code>）</li><li><code>ViewModel</code>（通过使用 <code>@HiltViewModel</code>）</li><li><code>Activity</code></li><li><code>Fragment</code></li><li><code>View</code></li><li><code>Service</code></li><li><code>BroadcastReceiver</code></li></ul><p>如果您使用 <code>@AndroidEntryPoint</code> 为某个 Android 类添加注解，则还必须为依赖于该类的 Android 类添加注解。例如，如果您为某个 fragment 添加注解，则还必须为使用该 fragment 的所有 activity 添加注解。</p><blockquote><p><strong>注意</strong>：在 Hilt 对 Android 类的支持方面适用以下几项例外情况：</p><ul><li>Hilt 仅支持扩展 <a href="https://developer.android.com/reference/kotlin/androidx/activity/ComponentActivity?hl=zh-cn"><code>ComponentActivity</code></a> 的 activity，如 <a href="https://developer.android.com/reference/kotlin/androidx/appcompat/app/AppCompatActivity?hl=zh-cn"><code>AppCompatActivity</code></a>。</li><li>Hilt 仅支持扩展 <code>androidx.Fragment</code> 的 Fragment。</li><li>Hilt 不支持保留的 fragment。</li></ul></blockquote><p><code>@AndroidEntryPoint</code> 会为项目中的每个 Android 类生成一个单独的 Hilt 组件。这些组件可以从它们各自的父类接收依赖项，如<a href="https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn#component-hierarchy">组件层次结构</a>中所述。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-05-08-Dagger使用</title>
      <link href="/posts/ca4fb970/"/>
      <url>/posts/ca4fb970/</url>
      
        <content type="html"><![CDATA[<h2 id="IOC及依赖注入"><a href="#IOC及依赖注入" class="headerlink" title="IOC及依赖注入"></a>IOC及依赖注入</h2><p>IOC： Inversion Of Control</p><p>DI: Dependency Inject</p><h3 id="Mode-of-Injection"><a href="#Mode-of-Injection" class="headerlink" title="Mode of Injection:"></a>Mode of Injection:</h3><ol><li>Constructor Injection: Injecting the method parameters.</li><li>Field Injection: Injecting the member variable (must not be private).</li><li>Method Injection: Injecting the method parameter.</li></ol><p><strong>A dependency consumer asks for the dependency(Object) from a dependency provider through a connector.</strong></p><ol><li><strong>Dependency provider:</strong> Classes annotated with <code>@Module</code> are responsible for providing objects which can be injected. Such classes define methods annotated with <code>@Provides</code>. The returned objects from these methods are available for dependency injection.</li><li><strong>Dependency consumer:</strong> The <code>@Inject</code> annotation is used to define a dependency.</li><li><strong>Connecting consumer and producer:</strong> A <code>@Component</code> annotated interface defines the connection between the provider of objects (modules) and the objects which express a dependency. The class for this connection is generated by the Dagger.</li></ol><p>上面的意思就是，要使用依赖注入，需要有三个元素组成。</p><ol><li>依赖生产者，也就是我们用<code>@Module</code>标注的Module类</li><li>依赖关系消费者，使用<code>@Inject</code>用于定义依赖关系</li><li>连接消费者和生产者，也就是我们的<code>@Component</code>,在我们使用Dagger时，我们只需要定义接口，具体的类实现Dagger会帮我们实现</li></ol><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.google.dagger:dagger-android:2.46&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;com.google.dagger:dagger-android-support:2.46&#x27;</span> <span class="comment">// if you use the support libraries</span></span><br><span class="line">annotationProcessor <span class="string">&#x27;com.google.dagger:dagger-android-processor:2.46&#x27;</span></span><br><span class="line">annotationProcessor <span class="string">&#x27;com.google.dagger:dagger-compiler:2.46&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><h5 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h5><p>构建一个User实体类,在构造方法上使用@Inject注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.使用<span class="doctag">@Inject</span>注解在构造方法上，就是告知Dagger可以通过构造方法来创建并获取到User的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造<code>Component</code>,定义inject方法，参数选择需要注入的Activity</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationComponent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(MainActivity mainActivity)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用: 在Activity中需要执行注入动作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    User user;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    User user2;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.执行注入动作</span></span><br><span class="line">        DaggerApplicationComponent.builder().build().inject(<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">//        DaggerApplicationComponent.create().inject(this);</span></span><br><span class="line"></span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onCreate: user --&gt; &quot;</span> + user );</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onCreate: user2 --&gt; &quot;</span> + user2 );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用Modules提供对象实例"><a href="#使用Modules提供对象实例" class="headerlink" title="使用Modules提供对象实例"></a>使用Modules提供对象实例</h5><ol><li>创建Module,命名规则一般为 XXXModule</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetWorkModule</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种方式，告知Dagger，可以通过该方法来获取要注入对象的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> Retrofit <span class="title function_">provideRetrofit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">                .baseUrl(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> ApiService <span class="title function_">provideApiService</span><span class="params">(<span class="meta">@NonNull</span> Retrofit retrofit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit.create(ApiService.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在Component中添加module</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(modules = NetWorkModule.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationComponent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(MainActivity mainActivity)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用方法和用构造方法注入一样</li></ol><h3 id="Dagger作用域限定"><a href="#Dagger作用域限定" class="headerlink" title="Dagger作用域限定"></a>Dagger作用域限定</h3><ul><li>使用作用域限定，可以<code>将某个对象的生命周期限定为其组件的生命周期</code>。这样也就意味着，在<code>作用范围内，使用到的是同一实例</code>。</li><li><code>@Singleton</code>是Dagger提供的一种<code>默认的作用域注解</code>，其意义表示一个单例对象。也就是实例的生命周期和程序运行的生命周期保持一致。</li><li>使用<code>@Scope实现自定义作用域注解</code>。</li><li>作用域注解使用在@Inject、@Provides、@Binds、@Module、@Component注解上，表示其产生作用的范围。</li></ul><p>第一点的意思，举个例子，如果我们在上面的Module中，将Retrofit 和 ApiService 都标注为<code>@Singleton</code>,我们也需要在其装载的组件，也就是<code>ApplicationComponent</code>中限定生命周期。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetWorkModule</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种方式，告知Dagger，可以通过该方法来获取要注入对象的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Singleton</span> <span class="comment">//限定为单例</span></span><br><span class="line">    <span class="keyword">public</span> Retrofit <span class="title function_">provideRetrofit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">                .baseUrl(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Singleton</span>  <span class="comment">//限定为单例</span></span><br><span class="line">    <span class="keyword">public</span> ApiService <span class="title function_">provideApiService</span><span class="params">(<span class="meta">@NonNull</span> Retrofit retrofit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit.create(ApiService.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(modules = NetWorkModule.class)</span></span><br><span class="line"><span class="meta">@Singleton</span>  <span class="comment">//注意： 这里也要添加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationComponent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(MainActivity mainActivity)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看一下Singleton的完整代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Singleton &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当然，这里也不一定要使用@Singleton，可以自定义任何的注解。</p><p>在上面的例子中，我们的<code>Retrofit</code>和<code>ApiService</code>都指定了相同的作用域，在其装载的组件<code>ApplicationComponent</code>,也指定了相同的作用域，也就是在<code>ApplicationComponent</code>组件的作用范围内，获取到的<code>Retrofit</code>都是统一对象</p><blockquote><p>作用域和单例是两个不同的概念</p></blockquote><p>@Singleton是Dagger提供的一种作用域实现</p><p>作用域就是用来管理Component来获取对象实例的生命周期的。</p><h4 id="使用作用域遵循的一些规则"><a href="#使用作用域遵循的一些规则" class="headerlink" title="使用作用域遵循的一些规则"></a>使用作用域遵循的一些规则</h4><ul><li>在没有必要的情况下，尽量使用默认的作用域，即不指定作用域。</li><li>使用作用域注解的模块也只能在带有相同作用域注解的组件中使用。</li><li>作用域的指定，必须是上层对下层兼并的关系，这里把上下级分为三层：@Inject&#x2F;@Provides&#x2F;@Binds为第二层，@Module为一层，@Component为第三层。如果在上层指定了作用域，那么下层的作用域要么不指定，一旦指定只能保持和上层一致。</li><li>开发设计时，一定要有清晰的依赖图，不然很容易产生依赖死循环。</li></ul><h3 id="组件依赖"><a href="#组件依赖" class="headerlink" title="组件依赖"></a>组件依赖</h3><h4 id="重新为组件设置Module实例"><a href="#重新为组件设置Module实例" class="headerlink" title="重新为组件设置Module实例"></a>重新为组件设置Module实例</h4><p>存在这样的场景，需要重新设置Module实例：</p><ul><li>模块类中定义了一些需要用到的变量，这些变量不能通过Dagger直接注入，需要通过构造方法获得。</li><li>默认情况下组件创建Module的实例方法使用的是无参构造方法。</li><li>在执行注入动作时，需要通过重新设定组件的Module实例。</li></ul><h4 id="Dagger组件依赖与子组件"><a href="#Dagger组件依赖与子组件" class="headerlink" title="Dagger组件依赖与子组件"></a>Dagger组件依赖与子组件</h4><p>组件依赖与子组件主要解决了不同作用域时组件之间的复用问题：</p><ul><li>在一个组件指定作用域后，就已经确定了该组件创建对象的生命周期。但是有些对象的实例可能生命周期更短，这个时候就需要定义新的组件。</li><li>新组件需要使用原组件的部分资源。</li></ul><p>两种实现方式：</p><ul><li>为@Component添加dependencies参数，指定该组件依赖于新的组件。(示例代码： <a href="https://gitee.com/sliverfoxwb/dagger-demo/tree/component-dependency/">https://gitee.com/sliverfoxwb/dagger-demo/tree/component-dependency/</a>)</li><li>直接使用@SubComponent注解创建新的组件，并装载到父组件中。(示例代码： <a href="https://gitee.com/sliverfoxwb/dagger-demo/tree/subcomponent/">https://gitee.com/sliverfoxwb/dagger-demo/tree/subcomponent/</a>)</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023-05-06-MacOS破解软件安装</title>
      <link href="/posts/a0f3d852/"/>
      <url>/posts/a0f3d852/</url>
      
        <content type="html"><![CDATA[<h2 id="Parallels-Desktop"><a href="#Parallels-Desktop" class="headerlink" title="Parallels Desktop"></a>Parallels Desktop</h2><p><a href="https://download.parallels.com/desktop/v18/18.1.1-53328/ParallelsDesktop-18.1.1-53328.dmg">下载地址</a>：</p><blockquote><p>ParallelsDesktop-18 <a href="https://www.aliyundrive.com/s/4mSirytX14A">https://www.aliyundrive.com/s/4mSirytX14A</a> 提取码: 6ve9 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。</p></blockquote><p><strong>安装方式</strong></p><p>下载安装好软件后，不要登录账号。</p><p><strong>下载破解文件</strong></p><p>下载地址：<a href="https://github.com/dreamncn/ParallelsDesktopCrack/archive/refs/heads/main.zip">https://github.com/dreamncn/ParallelsDesktopCrack</a></p><p>备用地址；<a href="https://gitee.com/sliverfoxwb/ParallelsDesktopCrack">https://gitee.com/sliverfoxwb/ParallelsDesktopCrack</a></p><p>破解方法有两种：</p><p><strong>方式一</strong>： 自动破解</p><p>下载之后，解压，在终端进入对应的文件夹。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x ./install.sh &amp;&amp; sudo ./install.sh</span><br></pre></td></tr></table></figure><p>如果提示<code>Operation not permitted</code>，打开<code>Full Disk Access</code>权限设置</p><p><code>System Preferences ▸ Security &amp; Privacy ▸ Privacy ▸ Full Disk Access</code></p><p>If you got <code>codesign</code> error, ensure xcode command line tools installed. Install with command <code>xcode-select --install</code>.</p><p>重启电脑</p><p><strong>方式二：</strong> 手动破解</p><ol><li>退出<code>Parallels Desktop</code>账号并关闭程序</li><li>Ensure prl_disp_service not running.</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkill -9 prl_disp_service</span><br></pre></td></tr></table></figure><ol start="3"><li>Copy cracked <code>prl_disp_service</code> file.</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -f prl_disp_service &quot;/Applications/Parallels Desktop.app/Contents/MacOS/Parallels Service.app/Contents/MacOS/prl_disp_service&quot;</span><br><span class="line">sudo chown root:wheel &quot;/Applications/Parallels Desktop.app/Contents/MacOS/Parallels Service.app/Contents/MacOS/prl_disp_service&quot;</span><br><span class="line">sudo chmod 755 &quot;/Applications/Parallels Desktop.app/Contents/MacOS/Parallels Service.app/Contents/MacOS/prl_disp_service&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>Copy fake licenses.json.</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -f licenses.json &quot;/Library/Preferences/Parallels/licenses.json&quot;</span><br><span class="line">sudo chown root:wheel &quot;/Library/Preferences/Parallels/licenses.json&quot;</span><br><span class="line">sudo chmod 444 &quot;/Library/Preferences/Parallels/licenses.json&quot;</span><br><span class="line">sudo chflags uchg &quot;/Library/Preferences/Parallels/licenses.json&quot;</span><br><span class="line">sudo chflags schg &quot;/Library/Preferences/Parallels/licenses.json&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li>Sign <code>prl_disp_service</code> file.</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo codesign -f -s - --timestamp=none --all-architectures --entitlements ParallelsService.entitlements &quot;/Applications/Parallels Desktop.app/Contents/MacOS/Parallels Service.app/Contents/MacOS/prl_disp_service&quot;</span><br></pre></td></tr></table></figure><p>然后运行<code>Parallels Desktop</code>即可。</p><h2 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h2><p>下载地址:</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1hPRvhHUGwfcdfOQ-3-_ovA?pwd=u55v">https://pan.baidu.com/s/1hPRvhHUGwfcdfOQ-3-_ovA?pwd=u55v</a> 提取码: u55v</p></blockquote><p>如果安装好后，打开显示文件已损坏，在终端输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo xattr -rd com.apple.quarantine /Applications/Sublime\ Text.app</span><br></pre></td></tr></table></figure><p>填入注册码:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">----BEGIN LICENSE-----</span><br><span class="line">TNT Team</span><br><span class="line">Unlimited User License</span><br><span class="line">EA7E-2010859462</span><br><span class="line">6C5E525261BC8146AAAC8783279A74F5</span><br><span class="line">57BF1CB0C1944B5517D42C38DB2282F2</span><br><span class="line">E047071E334FEF878FFF09A3BB2B787B</span><br><span class="line">06CE14F6DDAFB7A8C1123C226C250323</span><br><span class="line">B45CC6567A2575668B94A3ACB773D963</span><br><span class="line">ED045D9F798CC023694AF1467FD51C75</span><br><span class="line">B05B81C8B226863915DC1140ADB97EC4</span><br><span class="line">1CFA3B0FD72AACB8DBA7B6204A7AC4C2</span><br><span class="line">-----END LICENSE-----</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-04-28-Github开源软件</title>
      <link href="/posts/edc3b74f/"/>
      <url>/posts/edc3b74f/</url>
      
        <content type="html"><![CDATA[<h2 id="Koodo-Reader"><a href="#Koodo-Reader" class="headerlink" title="Koodo Reader"></a>Koodo Reader</h2><p><strong>一个跨平台的电子书阅读器</strong></p><blockquote><p><a href="https://github.com/troyeguo/koodo-reader">https://github.com/troyeguo/koodo-reader</a></p></blockquote><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/28/lxVOmJavC9T8Edq.png" alt="img"></p><p><strong>特色</strong></p><ul><li>支持阅读格式：<ul><li>EPUB (<strong>.epub</strong>)</li><li>扫描文档 (<strong>.pdf</strong>, <strong>.djvu</strong>)</li><li>Kindle (<strong>.azw3</strong>, <strong>.mobi</strong>, <strong>.azw</strong>)</li><li>纯文本 (<strong>.txt</strong>)</li><li>漫画 (<strong>.cbr</strong>, <strong>.cbz</strong>, <strong>.cbt</strong>, <strong>.cb7</strong>)</li><li>富文本 (<strong>.md</strong>, <strong>.docx</strong>, <strong>.rtf</strong>)</li><li>FB2 (<strong>.fb2</strong>)</li><li>超文本 (<strong>.html</strong>, <strong>.xml</strong>, <strong>.xhtml</strong>, <strong>.mhtml</strong>, <strong>.htm</strong>, <strong>.htm</strong>)</li></ul></li><li>支持 <strong>Windows</strong>，<strong>macOS</strong>，<strong>Linux</strong> 和 <strong>网页版</strong></li><li>备份数据到 <strong>Dropbox</strong> 和 <strong>Webdav</strong></li><li>自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</li><li>双页模式，单页模式，滚动模式</li><li>听书功能，翻译功能，触控屏支持，批量导入图书</li><li>支持目录，书签，笔记，高亮，书架，标签</li><li>自定义字体，字体大小，行间距，段落间距，阅读背景色，文字颜色，屏幕亮度，文字下划线、斜体、文字阴影、字体粗细</li><li>黑夜模式和主题色设置</li></ul><h2 id="RustScan"><a href="#RustScan" class="headerlink" title="RustScan"></a>RustScan</h2><p>The Modern Port Scanner. <strong>Find ports quickly (3 seconds at its fastest)</strong>. Run scripts through our scripting engine (Python, Lua, Shell supported).</p><blockquote><p><a href="https://github.com/RustScan/RustScan">https://github.com/RustScan/RustScan</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac安装配置iTerm2</title>
      <link href="/posts/8dc14d06/"/>
      <url>/posts/8dc14d06/</url>
      
        <content type="html"><![CDATA[<p>安装环境</p><ul><li>Mac M1 Pro</li><li>Ventura 13.3</li></ul><h2 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h2><p>安装MacOS下包管理工具<a href="https://brew.sh/">homebrew</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>安装之后的软件都在 <code>/opt/homebrew/Cellar/</code>下,配置文件都在<code>/opt/homebrew/etc/</code>下</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew --version</span><br><span class="line">Homebrew 4.0.11</span><br></pre></td></tr></table></figure><p>目前最新的版本是<code>4.0.11</code></p><h2 id="下载iTerm2"><a href="#下载iTerm2" class="headerlink" title="下载iTerm2"></a>下载iTerm2</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install --cask iTerm2</span><br></pre></td></tr></table></figure><h2 id="iTerm2主题文件"><a href="#iTerm2主题文件" class="headerlink" title="iTerm2主题文件"></a>iTerm2主题文件</h2><h3 id="下载主题文件"><a href="#下载主题文件" class="headerlink" title="下载主题文件"></a>下载主题文件</h3><p><a href="https://github.com/mbadolato/iTerm2-Color-Schemes">iTerm2主题文件</a>在<code>schemes</code>目录中，这里我使用的是<code>Solarized Dark Higher Contrast.itermcolors</code>主题</p><h3 id="导入主题文件"><a href="#导入主题文件" class="headerlink" title="导入主题文件"></a>导入主题文件</h3><p>打开<code>Settings</code>页面，选择刚才下载的主题文件</p><p>路径：<code>Profiles</code> –&gt; <code>Colors</code> –&gt; <code>Color Presets</code> –&gt; <code>Import</code> –&gt; <code>选择你刚才下载的主题</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/05/neHCAsGzvqbYuLp.png" alt="themes"></p><h2 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">via curl</button><button type="button" class="tab">via wget</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="修改当前的shell为zsh"><a href="#修改当前的shell为zsh" class="headerlink" title="修改当前的shell为zsh"></a>修改当前的shell为zsh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前使用的Shell</span></span><br><span class="line">echo $SHELL</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改默认Shell为zsh,这一步需要输入用户密码</span></span><br><span class="line">chsh -s /bin/zsh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前使用的Shell</span></span><br><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><p>如果结果是<code>/bin/zsh</code>，就不需要修改。</p><h3 id="更换oh-my-zsh主题"><a href="#更换oh-my-zsh主题" class="headerlink" title="更换oh-my-zsh主题"></a>更换oh-my-zsh主题</h3><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">主题预览</a></p><p>进入编辑<code>~/.zshrc</code>，凡是修改了改文件，记得都要<code>source ~/.zshrc</code>刷新配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure><p>编辑<code>ZSH_THEME</code>的值为你喜欢的主题，例如我这里用的是<code>agnoster</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/05/2OygLncVZzA65xD.png" alt="modified theme"></p><h3 id="安装powerline-font"><a href="#安装powerline-font" class="headerlink" title="安装powerline font"></a>安装powerline font</h3><p>当更改主题后，可能会显示乱码，这是因为没有安装主题所需要的字体文件</p><p>这里我安装的是<a href="https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf">Meslo LG M Regular for Powerline.ttf</a></p><p>下载完成后，直接双击安装即可。</p><h3 id="安装git字体"><a href="#安装git字体" class="headerlink" title="安装git字体"></a>安装git字体</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先使用git命令克隆</span></span><br><span class="line">git clone https://ghproxy.com/https://github.com/powerline/fonts.git --depth=1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入克隆到本地的fonts目录进行安装</span></span><br><span class="line">cd fonts</span><br><span class="line">./install.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除克隆到本地的目录</span></span><br><span class="line">cd .. </span><br><span class="line">rm -rf fonts</span><br></pre></td></tr></table></figure><h3 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h3><p>打开iTerm2，打开Preferences配置界面，选择 Meslo LG M Regular for Powerline 字体。<br>路径：Profiles -&gt; Text -&gt; Font</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/05/HUki3X9sbDwRmPL.png" alt="change-font"></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>这里我安装了三个常用的插件<code>zsh-syntax-highlighting</code>、<code>zsh-autosuggestions</code>、<code>autojump</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装高亮插件</span></span><br><span class="line">brew install zsh-syntax-highlighting</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装自动填充建议插件</span></span><br><span class="line">brew install zsh-autosuggestions</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装快速跳转插件</span></span><br><span class="line">brew install autojump</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑~/.zshrc</span></span><br><span class="line">vi ~/.zshrc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">刷新~/.zshrc</span></span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p><code>~/.zshrc</code>追加内容,如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">on-my-zsh plugins</span></span><br><span class="line">source /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zsh-autosuggestions</span></span><br><span class="line">source /opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">autjump</span></span><br><span class="line">[ -f /opt/homebrew/etc/profile.d/autojump.sh ] &amp;&amp; . /opt/homebrew/etc/profile.d/autojump.sh</span><br></pre></td></tr></table></figure><blockquote><p>每个插件安装完成后，控制台会输出日志，提示你怎么激活</p></blockquote><p>例如 <code>zsh-syntax-highlighting</code>:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">To activate the syntax highlighting, add the following at the end of your .zshrc:</span><br><span class="line">  source /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class="line"></span><br><span class="line">If you receive &quot;highlighters directory not found&quot; error message,</span><br><span class="line">you may need to add the following to your .zshenv:</span><br><span class="line">  export ZSH_HIGHLIGHT_HIGHLIGHTERS_DIR=/opt/homebrew/share/zsh-syntax-highlighting/highlighters</span><br></pre></td></tr></table></figure><p>这个就告诉了你，需要把<code>source /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</code>这一行追加到<code>.zshrc</code>的末尾。</p><h2 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h2><h3 id="隐藏用户名"><a href="#隐藏用户名" class="headerlink" title="隐藏用户名"></a>隐藏用户名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编辑配置文件</span></span><br><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="comment">#在文件最后增加 DEFAULT_USER=$USER</span></span><br><span class="line">DEFAULT_USER=<span class="variable">$USER</span></span><br><span class="line"><span class="comment">#退出编辑后执行使配置生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc </span><br></pre></td></tr></table></figure><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/06/RJ7aYVcs6NzFqLj.png" alt="default user"></p><h3 id="设置Status-Bar"><a href="#设置Status-Bar" class="headerlink" title="设置Status Bar"></a>设置Status Bar</h3><p><code>Profiles</code> -&gt; <code>session</code>-&gt; 勾选 <code>Status bar enable</code>-&gt; <code>configure Status bar</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/06/wPxdpY2E9sToFbH.png" alt="status bar"></p><p>根据需要，拖拽自己想要的状态栏显示</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/06/apSE671ukIGTLiP.png" alt="截屏2023-04-06 14.29.06"></p><h3 id="水印"><a href="#水印" class="headerlink" title="水印"></a>水印</h3><p><code>Profiles</code> -&gt; <code>General</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/06/dci9RX5s1B3IADb.png" alt="水印"></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-04-03-白嫖微软云电脑</title>
      <link href="/posts/7cc1528c/"/>
      <url>/posts/7cc1528c/</url>
      
        <content type="html"><![CDATA[<h3 id="微软云电脑配置"><a href="#微软云电脑配置" class="headerlink" title="微软云电脑配置"></a>微软云电脑配置</h3><ul><li>Windows Server 2019</li><li>12G内存</li><li>126G硬盘</li><li>Intel（R）Xeon（R）Gold 6230 @2.10GHz CPU</li></ul><h3 id="申请流程"><a href="#申请流程" class="headerlink" title="申请流程"></a>申请流程</h3><p>申请地址: <a href="https://learn.microsoft.com/zh-cn/training/modules/implement-common-integration-features-finance-ops/10-exercise-1">https://learn.microsoft.com/zh-cn/training/modules/implement-common-integration-features-finance-ops/10-exercise-1</a></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/03/DAVzu5Sk1fMY4RI.png" alt="完整路径"></p><p>如果网址打不开，参照以下步骤：</p><p>打开<a href="https://learn.microsoft.com/zh-cn/">https://learn.microsoft.com/zh-cn/</a></p><p>按照下图提示选择</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/03/Diku7JhNp5dZyUn.png" alt="image-20230403155153993"></p><p>然后在筛选器中输入<code>在财务和运营应用中实施通用集成功能</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230403155234950.png" alt="image-20230403155234950"></p><p>点击进入，页面往下翻可以看到下图中的<code>实验-使用Microsoft Office集成</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/03/aThBKpxCJr6vzmo.png" alt="image-20230403155338464"></p><p>可以找到入口</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/03/xGYFEwrRiqZhTab.png" alt="image-20230403155450646"></p><h3 id="启动VM模式"><a href="#启动VM模式" class="headerlink" title="启动VM模式"></a>启动VM模式</h3><p>我们点击上图的<code>启动VM模式</code></p><p>系统会要求我们登陆Microsoft账号，这里有点慢，稍微等待即可</p><p>按照提示输入你的信息。</p><blockquote><p>选择国家的时候，可以选择非中国地区，这个懂得都懂</p></blockquote><p>选择右侧的<code>Resources</code>页签，点击<code>Password</code>会自动输入密码，点击小箭头，即可登入系统。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/03/vrLa1pq32DPjAcX.png" alt="image-20230403155654953"></p><p>如果系统黑屏了，表示连接断开了，可以点击左上角，重新连接</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/03/qmAyUn9pg1Q7Mai.png" alt="image-20230403155930562"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>一个实例最大连接时长为2小时，2小时后，会删除实例，不可恢复。时长使用完成后，可以重新申请。</li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-03-30-Android-使用Chrome调试WebView</title>
      <link href="/posts/e911a731/"/>
      <url>/posts/e911a731/</url>
      
        <content type="html"><![CDATA[<p>为了调试WebView，需要在应用程序中启用WebView的调试模式。可以通过在应用程序的Java代码中添加以下代码实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javaCopy codeif(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    WebView.setWebContentsDebuggingEnabled(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，在WebView中打开的网页也可以通过Chrome开发者工具进行调试。具体步骤如下：</p><ol><li>在手机上打开应用程序并进入WebView页面。</li><li>在电脑上打开Chrome浏览器。</li><li>在地址栏输入 <code>chrome://inspect</code> 并回车。</li><li>点击 “设备” 按钮，会列出连接到电脑上的所有设备。</li><li>找到相应的应用程序并点击 “检查” 按钮，即可打开Chrome开发者工具进行WebView的调试。</li></ol><p>需要注意的是，Chrome开发者工具只能调试已经加载的网页，无法调试WebView中的本地HTML文件。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-03-30-Windows下PowerShell自定义函数</title>
      <link href="/posts/7098ebd6/"/>
      <url>/posts/7098ebd6/</url>
      
        <content type="html"><![CDATA[<p>因为一直使用的是Mac，在Mac下打开指定目录的文件，一般是用<code>open</code>函数，但是windows下的<code>powershell</code>不支持<code>open</code>函数</p><p>因此我们可以使用<code>Invoke-Item</code>命令来实现相同的功能。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Invoke-Item</span> /path/file.txt</span><br></pre></td></tr></table></figure><p>但是这个命令比较难以使用，因此想到了自定义一个<code>open</code>函数，来实现<code>Invoke-Item</code>同样的功能。</p><h3 id="策略支持"><a href="#策略支持" class="headerlink" title="策略支持"></a>策略支持</h3><p>首先，在<code>Windows PowerShell</code>中，执行以下命令</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> RemoteSigned</span><br></pre></td></tr></table></figure><blockquote><p>这个命令会将脚本执行策略设置为 <code>RemoteSigned</code>，允许你运行本地未签名的 PowerShell 脚本和函数。</p></blockquote><p>会显示信息：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">执行策略更改</span><br><span class="line">执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=<span class="number">135170</span></span><br><span class="line">中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?</span><br><span class="line">[<span class="type">Y</span>] 是(Y)  [<span class="type">A</span>] 全是(A)  [<span class="type">N</span>] 否(N)  [<span class="type">L</span>] 全否(L)  [<span class="type">S</span>] 暂停(S)  [?] 帮助 (默认值为“N”):</span><br></pre></td></tr></table></figure><p>输入<code>Y</code>即可。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在PowerShell中，你可以创建一个函数实现<code>Open</code>命令的功能</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Open</span></span> &#123;</span><br><span class="line">    <span class="keyword">param</span> (</span><br><span class="line">        [<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">        [<span class="built_in">string</span>]<span class="variable">$Path</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">Invoke-Item</span> <span class="variable">$Path</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数接受一个字符串类型的参数 <code>$Path</code>，并且使用 <code>Invoke-Item</code> 命令来打开指定路径的文件或者文件夹。使用时，只需要调用 <code>Open</code> 函数并传入需要打开的文件或文件夹的路径即可，例如：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Open C:\path\to\example.txt</span><br><span class="line">Open C:\path\to\folder</span><br></pre></td></tr></table></figure><p>但是当你重新打开PowerShell的时候，运行<code>Open</code>命令，还是不行，所以我们需要将函数保存在PowerShell的配置文件中。</p><h3 id="修改PowerShell配置文件"><a href="#修改PowerShell配置文件" class="headerlink" title="修改PowerShell配置文件"></a>修改PowerShell配置文件</h3><h4 id="查看PowerShell版本"><a href="#查看PowerShell版本" class="headerlink" title="查看PowerShell版本"></a>查看PowerShell版本</h4><p>不同PowerShell版本的配置文件路径不一样，因此我们可以先查看系统的<code>PowerShell</code>的版本。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$PSVersionTable</span></span><br></pre></td></tr></table></figure><p>会显示信息</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PSVersion                      <span class="number">5.1</span>.<span class="number">19041.1320</span> <span class="comment"># 这个是我们需要的版本号</span></span><br><span class="line">PSEdition                      Desktop</span><br><span class="line">PSCompatibleVersions           &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>...&#125;</span><br><span class="line">BuildVersion                   <span class="number">10.0</span>.<span class="number">19041.1320</span></span><br><span class="line">CLRVersion                     <span class="number">4.0</span>.<span class="number">30319.42000</span></span><br><span class="line">WSManStackVersion              <span class="number">3.0</span></span><br><span class="line">PSRemotingProtocolVersion      <span class="number">2.3</span></span><br><span class="line">SerializationVersion           <span class="number">1.1</span>.<span class="number">0.1</span></span><br></pre></td></tr></table></figure><ul><li><code>PSVersion</code>：PowerShell 的版本号。</li><li><code>PSEdition</code>：PowerShell 的版本类型，可能的值为 <code>Desktop</code>（桌面版）或 <code>Core</code>（核心版）。</li><li><code>CLRVersion</code>：PowerShell 运行时使用的 .NET CLR 版本。</li><li><code>BuildVersion</code>：PowerShell 内部版本号。</li><li><code>GitCommitId</code>：PowerShell 代码库的 Git 提交 ID。</li><li><code>OS</code>：当前运行 PowerShell 的操作系统。</li></ul><p>当然我们也可以只查看版本信息</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$PSVersionTable</span>.PSVersion</span><br></pre></td></tr></table></figure><p>会显示</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Major  Minor  Build  Revision</span><br><span class="line"><span class="literal">-----</span>  <span class="literal">-----</span>  <span class="literal">-----</span>  <span class="literal">--------</span></span><br><span class="line"><span class="number">5</span>      <span class="number">1</span>      <span class="number">19041</span>  <span class="number">1320</span></span><br></pre></td></tr></table></figure><p>上面显示我的PowerShell版本为<code>5.1.19041.1320</code></p><ul><li>对于 Windows PowerShell v1.0 和 v2.0，配置文件的路径是 <code>$HOME\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</code>。</li><li>对于 Windows PowerShell v3.0 及更高版本，配置文件的路径是 <code>$HOME\Documents\WindowsPowerShell\profile.ps1</code>。</li><li>对于 PowerShell 7 和更高版本，如果是通过 Microsoft Store 或 ZIP 文件安装的，配置文件的路径是 <code>$HOME\Documents\PowerShell\Microsoft.PowerShell_profile.ps1</code>；如果是通过 MSI 安装的，配置文件的路径是 <code>$HOME\Documents\PowerShell\profile.ps1</code>。</li></ul><p>其中，<code>$HOME</code> 表示当前用户的主目录，也可以使用 <code>$env:USERPROFILE</code> 变量来表示。</p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>如果你无法找到 PowerShell 配置文件，可以通过在 PowerShell 中运行以下命令来创建一个新的配置文件：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">New-Item</span> <span class="literal">-ItemType</span> File <span class="literal">-Path</span> <span class="variable">$PROFILE</span> <span class="literal">-Force</span></span><br></pre></td></tr></table></figure><p>这个命令会在默认的 PowerShell 配置文件路径中创建一个名为 <code>profile.ps1</code> 的文件。你可以在这个文件中添加你的自定义函数和别名。</p><blockquote><p>输入命令后，会在控制台输出配置文件的路径，直接进去目录看即可。</p><p>我的配置文件路径是<code>C:\Users\Administrator\Documents\WindowsPowerShell/Microsoft.PowerShell_profile.ps1</code>。</p></blockquote><p>打开配置文件，在其中输入</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Open</span></span> &#123;</span><br><span class="line">    <span class="keyword">param</span> (</span><br><span class="line">        [<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">        [<span class="built_in">string</span>]<span class="variable">$Path</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">Invoke-Item</span> <span class="variable">$Path</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Open 别名</span></span><br><span class="line"><span class="built_in">New-Alias</span> open Open</span><br></pre></td></tr></table></figure><p>在这个示例中，我们先定义了 <code>Open</code> 函数，然后使用 <code>New-Alias</code> 命令创建了一个名为 <code>open</code> 的别名，使其等同于 <code>Open</code> 函数。这样，无论你是在 PowerShell 中还是在命令行中，都可以使用 <code>open</code> 命令来打开指定路径的文件或文件夹了。</p><p>保存好 <code>$PROFILE</code> 文件后，下次打开 PowerShell 时，你就可以直接使用 <code>open</code> 命令了，无需再次定义 <code>Open</code> 函数。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>如果按照上面的步骤操作，使用<code>open</code>命令，还是不能正常运行的话，可能是因为 <code>$PROFILE</code> 文件存在语法错误或者权限问题。</p><p>你可以检查一下 <code>$PROFILE</code> 文件中是否有语法错误。如果有语法错误，PowerShell 会在启动时显示错误信息，并且不会加载 <code>$PROFILE</code> 文件。你可以使用以下命令检查 <code>$PROFILE</code> 文件中的语法错误：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Test-Path</span> <span class="variable">$PROFILE</span> <span class="literal">-IsValid</span></span><br></pre></td></tr></table></figure><p>如果这个命令返回 <code>False</code>，说明 <code>$PROFILE</code> 文件存在语法错误。你需要检查 <code>$PROFILE</code> 文件中的语法，并修复错误。</p><p>另外，你还需要确保你有足够的权限来运行自定义函数和别名。如果你使用的是普通用户账户，可能需要以管理员权限运行 PowerShell 才能正常加载 <code>$PROFILE</code> 文件中定义的函数和别名。</p><p>如果你已经修复了 <code>$PROFILE</code> 文件中的语法错误，并以管理员权限运行了 PowerShell，但仍然无法正常加载 <code>open</code> 命令，可以尝试在 PowerShell 中显式地加载 <code>$PROFILE</code> 文件，看看是否能够正常运行 <code>open</code> 命令。你可以使用以下命令显式地加载 <code>$PROFILE</code> 文件：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">. <span class="variable">$PROFILE</span></span><br></pre></td></tr></table></figure><p>这个命令会立即加载 <code>$PROFILE</code> 文件中的函数和别名，无需退出 PowerShell 并重新启动。如果 <code>open</code> 命令能够正常运行，说明 <code>$PROFILE</code> 文件本身没有问题，可能是自动加载 <code>$PROFILE</code> 文件的机制出了问题。你可以尝试重新打开一个新的 PowerShell 会话，看看是否能够正常加载 <code>$PROFILE</code> 文件中定义的函数和别名。</p><p>如果运行<code>. $PROFILE</code>显示错误</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">New-Alias</span> : 不允许使用该别名，因为名为“open”的别名已存在</span><br></pre></td></tr></table></figure><p>那么在配置文件里面删掉<code>New-Alias open Open</code>这段即可。再次重新打开PowerShell，应该能够正常运行了。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-03-30-Funny Github</title>
      <link href="/posts/e6af74ea/"/>
      <url>/posts/e6af74ea/</url>
      
        <content type="html"><![CDATA[<p>开始记录分享好用好玩的Github项目</p><h2 id="密文解析-Ciphey"><a href="#密文解析-Ciphey" class="headerlink" title="密文解析 Ciphey"></a>密文解析 Ciphey</h2><p>这是一个知名老项目，当你输入一段文字，甚至你不知道它是否加密过，Ciphey 都能帮你输出解密之后的文本。如果你对密码学不太了解，或者想在自己进行密文处理之前快速检查密文，不妨试试它。</p><blockquote><p><a href="https://github.com/Ciphey/Ciphey">https://github.com/Ciphey/Ciphey</a></p></blockquote><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/30/UyjqbTQELrJgi9N.gif" alt="Ciphey"></p><blockquote><p>注意事项： Ciphey 仅支持 Python3.7 及以上版本。 如果您的版本低于 3.7，请升级 Python 或使用 Docker 映像。</p><p>Ciphey <strong>不适用于 Python 3.9+ 的 Windows</strong>，请使用 Python 3.7 或 Python 3.8。 其他平台可以使用 Python 3.9，但 Python 3.10 不起作用。</p><p>Windows Python 默认安装 32 位。 Ciphey 仅支持 64 位。 确保您使用的是 64 位 Python。</p></blockquote><p>这里一定要注意：Python的版本最好使用 <code>3.7</code>或者<code>3.8</code>，不然可能导致异常。</p><p><strong>在使用中，如果报错</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">UnicodeDecodeError: <span class="string">&#x27;gbk&#x27;</span> codec can<span class="string">&#x27;t decode byte 0xbf in position 695: illegal multibyte sequence</span></span><br></pre></td></tr></table></figure><p>需要找到python中<code>pywhat</code>模块的<code>regex_identifier.py</code>文件，并对第10行进行修改：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(fullpath, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> myfile:</span><br><span class="line">改为：</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(fullpath, <span class="string">&quot;r&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>,errors=<span class="string">&#x27;ignore&#x27;</span>) <span class="keyword">as</span> myfile:</span><br></pre></td></tr></table></figure><p>如果不知道怎么查找<code>pywhat</code>模块路径，可以参考以下解决办法：</p><p>我是在conda中虚拟了一个环境</p><p>激活对应的环境</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda activate &lt;your_env_name&gt;</span><br></pre></td></tr></table></figure><p>在控制台输入</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> pywhat</span><br><span class="line"><span class="built_in">print</span>(pywhat.__file__)</span><br></pre></td></tr></table></figure><p>会输出路径</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C:\ProgramData\anaconda3\envs\v3<span class="number">.7</span>\lib\site-packages\pywhat\__init__.py</span><br></pre></td></tr></table></figure><h2 id="Tabby"><a href="#Tabby" class="headerlink" title="Tabby"></a>Tabby</h2><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/28/mwuhpONE3CdRTlS.png" alt="tabby" style="zoom: 33%;" /><p>一个可用于替代XShell的远程终端连接工具，下载地址</p><blockquote><p><a href="https://github.com/Eugeny/tabby">https://github.com/Eugeny/tabby</a></p></blockquote><p><a href="https://tabby.sh/"><strong>Tabby</strong></a> (前身是 <strong>Terminus</strong>) 是一个可高度配置的终端模拟器和 SSH 或串口客户端，支持 Windows，macOS 和 Linux</p><ul><li>集成 SSH，Telnet 客户端和连接管理器</li><li>集成串行终端</li><li>定制主题和配色方案</li><li>完全可配置的快捷键和多键快捷键</li><li>分体式窗格</li><li>自动保存标签页</li><li>支持 PowerShell（和 PS Core）、WSL、Git-Bash、Cygwin、MSYS2、Cmder 和 CMD</li><li>在 SSH 会话中通过 Zmodem 进行直接文件传输</li><li>完整的 Unicode 支持，包括双角字符</li><li>不会因快速的输出而卡住</li><li>Windows 上舒适的 shell 体验，包括 tab 自动补全（通过 Clink）</li><li>为 SSH secrets 和设置集成了加密容器</li><li>SSH、SFTP 和 Telnet 客户端可用作 <a href="https://tabby.sh/app">Web 应用</a>（也可<a href="https://github.com/Eugeny/tabby-web">托管</a>）</li></ul><h2 id="微信防撤回"><a href="#微信防撤回" class="headerlink" title="微信防撤回"></a>微信防撤回</h2><p>适用于 Windows 下 PC 版微信&#x2F;QQ&#x2F;TIM的防撤回补丁。<strong>支持最新版微信&#x2F;QQ&#x2F;TIM</strong>，其中微信能够选择安装多开功能</p><p>下载地址： <a href="https://github.com/huiyadanli/RevokeMsgPatcher">https://github.com/huiyadanli/RevokeMsgPatcher</a></p><h2 id="N-m3u8DL-RE"><a href="#N-m3u8DL-RE" class="headerlink" title="N_m3u8DL-RE"></a>N_m3u8DL-RE</h2><p>跨平台的DASH&#x2F;HLS&#x2F;MSS下载工具。支持点播、直播(DASH&#x2F;HLS)。</p><p>地址： <a href="https://github.com/nilaoda/N_m3u8DL-RE">https://github.com/nilaoda/N_m3u8DL-RE</a></p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://github.com/nilaoda/N_m3u8DL-RE/raw/main/img/RE.gif"/>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-03-29-CE修改器加速百度网盘下载</title>
      <link href="/posts/7028d55e/"/>
      <url>/posts/7028d55e/</url>
      
        <content type="html"><![CDATA[<h2 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h2><ul><li>Windows 10 (这个无所谓)</li><li>Cheat Engine 7.5</li><li>百度网盘 7.26.0以及以下</li></ul><blockquote><p>这个是我已经测试过的版本，不要随便升级百度网盘，以免软件不可用</p></blockquote><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p><a href="https://github.com/cheat-engine/cheat-engine">Cheat Engine</a>,找到旁边的Releases，获取最新版本的CE</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/29/LMXaD6HhRdncqjN.png" alt="CE下载地址"></p><p>如果不能访问github，可以使用我的阿里网盘链接下载</p><blockquote><p>Cheat Engine <a href="https://www.aliyundrive.com/s/nVngFfgNE1c">https://www.aliyundrive.com/s/nVngFfgNE1c</a> 提取码: 11av 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。</p></blockquote><p>在最近添加里面找到</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/29/dmMH9fKysQtiaO6.png" alt="最近添加"></p><h2 id="CE加速"><a href="#CE加速" class="headerlink" title="CE加速"></a>CE加速</h2><p>我们先来看一下未使用CE加速之前百度网盘的下载速度</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/29/y1vBaIF7xnufVl2.gif" alt="未加速"></p><p>可以看到是龟速下载，言归正传，我们开始加速</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/29/DTWSCoufhFpsHyI.gif" alt="过程"></p><p>上图的gif已经展示了如何使用CE来加速的过程，下面我们来详细介绍。</p><p>打开CE加速器,按照下图的顺序找到<code>baidunetdiskhost.exe</code>的进程。可以看到这里有两个<code>baidunetdiskhost.exe</code>，只有一个是有用的，这里我们把两个都进行同样的操作。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/29/NbJzCaVR24IqXZE.png" alt="CE"></p><p>我们打开进程后，勾选<code>Enable Speedhark</code>，可以看到默认的速度是<code>1.0</code>，这里我们<code>500</code>(当然，如果你的宽带够宽，可以在<code>Speed</code>输入更大的数值，例如<code>50000</code>)</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/29/KWxdJrchqkXUNZS.png" alt="Enable Speedhark"></p><p>处理完两个进程后，再次查看百度网盘的下载速度<br><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/29/jn2MuhNtBaqoCVb.gif" alt="已加速"></p><p>可以看到，虽然显示下载的速度没有变化，还是几十KB，但是查看总进度和详细的进度，还是可以发现速度变化很快的。</p><h2 id="百度网盘禁止自动更新"><a href="#百度网盘禁止自动更新" class="headerlink" title="百度网盘禁止自动更新"></a>百度网盘禁止自动更新</h2><p>找到百度网盘对应的安装目录</p><p>1.找到目录<code>AutoUpdate</code>,将其改名或者删除。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/28/QqcUzLAE6PlGos1.png" alt="image-20230728093020816"></p><ol start="2"><li>找到<code>autoDiagnoseUpdate.exe</code>，把这个文件删除或者重命名。</li></ol><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/28/iKSlAhf8aMx2oE6.png" alt="微信截图_20230728092144"></p><ol start="3"><li>找到<code>kernelUpdate.exe</code>，把这个文件删除或者重命名。</li></ol><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/07/28/lXEcIRzeMv1USP5.png" alt="kernelUpdate.exe"></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-03-27-Hilt基本用法</title>
      <link href="/posts/bf1f0a14/"/>
      <url>/posts/bf1f0a14/</url>
      
        <content type="html"><![CDATA[<h2 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h2><p>首先，将 <code>hilt-android-gradle-plugin</code> 插件添加到项目的根级 <code>build.gradle</code> 文件中：</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">Groovy</button><button type="button" class="tab">Kotlin</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  ...</span><br><span class="line">  id <span class="string">&#x27;com.google.dagger.hilt.android&#x27;</span> version <span class="string">&#x27;2.44&#x27;</span> apply <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  ...</span><br><span class="line">  id(<span class="string">&quot;com.google.dagger.hilt.android&quot;</span>) version <span class="string">&quot;2.44&quot;</span> apply <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>然后，应用 Gradle 插件并在 <code>app/build.gradle</code> 文件中添加以下依赖项：</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">Groovy</button><button type="button" class="tab">Kotlin</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">plugins &#123;</span><br><span class="line">  id <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line">  id <span class="string">&#x27;com.google.dagger.hilt.android&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation <span class="string">&quot;com.google.dagger:hilt-android:2.44&quot;</span></span><br><span class="line">  kapt <span class="string">&quot;com.google.dagger:hilt-compiler:2.44&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow references to generated code</span></span><br><span class="line">kapt &#123;</span><br><span class="line">  correctErrorTypes <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  kotlin(<span class="string">&quot;kapt&quot;</span>)</span><br><span class="line">  id(<span class="string">&quot;com.google.dagger.hilt.android&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation(<span class="string">&quot;com.google.dagger:hilt-android:2.44&quot;</span>)</span><br><span class="line">  kapt(<span class="string">&quot;com.google.dagger:hilt-android-compiler:2.44&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow references to generated code</span></span><br><span class="line">kapt &#123;</span><br><span class="line">  correctErrorTypes = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><blockquote><p><strong>注意</strong>：同时使用 Hilt 和<a href="https://developer.android.com/topic/libraries/data-binding?hl=zh-cn">数据绑定</a>的项目需要 Android Studio 4.0 或更高版本。</p></blockquote><p>Hilt 使用 <a href="https://developer.android.com/studio/write/java8-support?hl=zh-cn">Java 8 功能</a>。如需在项目中启用 Java 8，请将以下代码添加到 <code>app/build.gradle</code> 文件中：</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">Groovy</button><button type="button" class="tab">Kotlin</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  compileOptions &#123;</span><br><span class="line">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  compileOptions &#123;</span><br><span class="line">    sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>如果配置有异常，可以参考 <a href="https://dagger.dev/hilt/gradle-setup">Gradle Build Setup</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-03-23-CentOS新建定时任务</title>
      <link href="/posts/6f434e78/"/>
      <url>/posts/6f434e78/</url>
      
        <content type="html"><![CDATA[<h2 id="模拟场景"><a href="#模拟场景" class="headerlink" title="模拟场景"></a>模拟场景</h2><p>  <code>在CentOS中，新建一个定时任务，在每天的8、12、14、18点自动执行shell脚本</code></p><p>可以使用<code>crontab</code>命令来</p><ol><li>打开终端，输入以下命令来编辑<code>crontab</code>文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不是root用户，需要使用 <span class="built_in">sudo</span> crontab -e</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在编辑器中添加以下命令：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 8,12,14,18 * * * /path/to/your/script.sh</span><br></pre></td></tr></table></figure><p>如果你想每隔6个小时执行一次，可以使用以下方式:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 */6 * * * /path/to/your/script.sh</span><br></pre></td></tr></table></figure><p>这个语句的含义是每隔6小时执行一次 <code>/path/to/your/script.sh</code> 脚本。<code>0</code>表示每次执行的开始时间是整点，<code>*/6</code>表示每隔6小时执行一次，<code>* * *</code>表示每天、每月、每周都执行。</p><blockquote><p><code>/path/to/your/script.sh</code> 这里最好使用你的shell脚本的绝对路径</p></blockquote><p>script.sh</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span> <span class="comment"># /root</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/jenkins/workspace/IMCS </span><br><span class="line"><span class="built_in">echo</span> $(<span class="built_in">date</span>) &gt;&gt; /var/lib/jenkins/workspace/log.txt</span><br><span class="line"><span class="comment"># echo $(pwd) &gt;&gt; /var/lib/jenkins/workspace/log.txt</span></span><br><span class="line">git svn rebase &gt;&gt; /var/lib/jenkins/workspace/log.txt</span><br><span class="line">git push origin master &gt;&gt; /var/lib/jenkins/workspace/log.txt</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，第一行命令的<code>pwd</code>这里的输出结果是<code>/root</code>，不是<code>script.sh</code>所在的目录，我们如果要执行其他的命令，需要<code>cd</code>到相应的文件夹</p></blockquote><h2 id="检测crontab服务"><a href="#检测crontab服务" class="headerlink" title="检测crontab服务"></a>检测crontab服务</h2><p>为了使 <code>crontab</code> 的任务生效，确保已经启用了 <code>crond</code> 服务。可以通过以下命令检查服务是否已经启动：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status crond</span><br></pre></td></tr></table></figure><p>如果没有启动，可以通过以下命令启动服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start crond</span><br></pre></td></tr></table></figure><p>如果想要每次任务执行时收到执行的结果，可以在脚本中添加输出语句或将输出重定向到日志文件中。</p><h2 id="查看crontab日志"><a href="#查看crontab日志" class="headerlink" title="查看crontab日志"></a>查看crontab日志</h2><p>可以使用以下命令来查看crontab最近的几条日志</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> /var/log/cron</span><br></pre></td></tr></table></figure><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p><strong>脚本没有按时执行</strong></p><p>运行完脚本后，系统控制台显示了一个日志</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">You have mail <span class="keyword">in</span> /var/spool/mail/root</span><br></pre></td></tr></table></figure><p>我们查看内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">From root@ztkj-03.localdomain  Thu Mar 30 10:49:01 2023</span><br><span class="line">Return-Path: &lt;root@ztkj-03.localdomain&gt;</span><br><span class="line">X-Original-To: root</span><br><span class="line">Delivered-To: root@ztkj-03.localdomain</span><br><span class="line">Received: by ztkj-03.localdomain (Postfix, from userid 0)</span><br><span class="line"><span class="built_in">id</span> 91DE3A0F39; Thu, 30 Mar 2023 10:49:01 +0800 (CST)</span><br><span class="line">From: <span class="string">&quot;(Cron Daemon)&quot;</span> &lt;root@ztkj-03.localdomain&gt;</span><br><span class="line">To: root@ztkj-03.localdomain</span><br><span class="line">Subject: Cron &lt;root@ztkj-03&gt; /var/lib/jenkins/workspace/run.sh</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line">Auto-Submitted: auto-generated</span><br><span class="line">Precedence: bulk</span><br><span class="line">X-Cron-Env: &lt;XDG_SESSION_ID=3466&gt;</span><br><span class="line">X-Cron-Env: &lt;XDG_RUNTIME_DIR=/run/user/0&gt;</span><br><span class="line">X-Cron-Env: &lt;LANG=en_US.UTF-8&gt;</span><br><span class="line">X-Cron-Env: &lt;SHELL=/bin/sh&gt;</span><br><span class="line">X-Cron-Env: &lt;HOME=/root&gt;</span><br><span class="line">X-Cron-Env: &lt;PATH=/usr/bin:/bin&gt;</span><br><span class="line">X-Cron-Env: &lt;LOGNAME=root&gt;</span><br><span class="line">X-Cron-Env: &lt;USER=root&gt;</span><br><span class="line">Message-Id: &lt;20230330024901.91DE3A0F39@ztkj-03.localdomain&gt;</span><br><span class="line">Date: Thu, 30 Mar 2023 10:49:01 +0800 (CST)</span><br><span class="line"></span><br><span class="line">/bin/sh: /var/lib/jenkins/workspace/run.sh: Permission denied</span><br></pre></td></tr></table></figure><p>如果你确认脚本内容是正确的，可能是因为脚本的权限不够</p><p>这里我们给脚本提权</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /var/lib/jenkins/workspace/run.sh</span><br></pre></td></tr></table></figure><blockquote><p> 同时要注意脚本里面的命令，如果有需要提权的，也要处理。</p></blockquote><p>例如，我们脚本文件里面使用了一个日志文件<code>log.txt</code></p><p>我们给这个文件也提权</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 666 /path/to/your/file/log.txt</span><br></pre></td></tr></table></figure><p><code>/path/to/your/file/log.txt</code>是你的文件路径。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git错误</title>
      <link href="/posts/96fbcf3b/"/>
      <url>/posts/96fbcf3b/</url>
      
        <content type="html"><![CDATA[<h2 id="Can’t-open-path-to-authors-file-No-such-file-or-directory"><a href="#Can’t-open-path-to-authors-file-No-such-file-or-directory" class="headerlink" title="Can’t open &#x2F;path&#x2F;to&#x2F;authors&#x2F;file No such file or directory"></a>Can’t open &#x2F;path&#x2F;to&#x2F;authors&#x2F;file No such file or directory</h2><p>在Centos下执行<code>git svn fetch</code> 和<code>git svn rebase</code>命令，提示错误</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git svn fetch</span><br><span class="line">Can&#x27;t open /path/to/authors/file No such file or directory</span><br></pre></td></tr></table></figure><p>之前一直以为是SVN配置出了问题，后面查了很久才发现是Git缺少<code>authors.txt</code>的配置</p><p>有两种解决办法：</p><p><strong>第一种：</strong></p><ol><li>检查Git仓库的根目录下(也就是你的Git仓库clone下来的地址)是否存在一个名为<code>authors.txt</code>文件</li><li>确保 <code>authors.txt</code> 文件中包含了 SVN 用户名到 Git 用户名和电子邮件地址的映射规则。例如：</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># SVN 用户名到 Git 用户名和电子邮件地址的映射</span><br><span class="line">svn_user1 <span class="operator">=</span> Git <span class="keyword">User</span> <span class="operator">&lt;</span>git_user1<span class="variable">@example</span>.com<span class="operator">&gt;</span></span><br><span class="line">svn_user2 <span class="operator">=</span> Git <span class="keyword">User</span> <span class="operator">&lt;</span>git_user2<span class="variable">@example</span>.com<span class="operator">&gt;</span></span><br><span class="line"># username <span class="operator">=</span> <span class="keyword">user</span><span class="variable">@gmail</span>.com</span><br></pre></td></tr></table></figure><ol start="3"><li>如果 authors.txt 文件存在，但 Git SVN 仍然无法找到它，请确保指定了正确的文件路径。可以使用 –authors-file 选项显式指定作者映射文件的路径。例如：</li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git svn fetch <span class="literal">--authors-file</span>=/path/to/authors.txt</span><br></pre></td></tr></table></figure><p>这里的<code>/path/to/authors.txt</code> 就是刚才的<code>authors.txt</code>的绝对路径</p><p><strong>第二种：</strong></p><p>设置Git全局选项,使用以下命令：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git config <span class="literal">--global</span> svn.authorsfile /path/to/authors.txt</span><br></pre></td></tr></table></figure><p>其中，<code>/path/to/authors.txt</code> 是作者映射文件的完整路径。</p><blockquote><p>请注意，如果您在本地仓库或项目级别设置了 <code>svn.authorsfile</code>，则该设置将覆盖全局设置。</p></blockquote><p>如果这些都设置好了，使用<code>git svn fetch</code>出现错误</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">user001 not defined <span class="keyword">in</span> /var/lib/jenkins/workspace/authors.txt file</span><br></pre></td></tr></table></figure><p>这个说明<code>user001</code>这个用户没有添加在<code>authors.txt</code>中，我们将<code>user001</code>按照以下方法添加到<code>authors.txt</code>中。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">user001 = User001 &lt;user001@example.com&gt;</span><br></pre></td></tr></table></figure><p>再次执行<code>git svn fetch</code>应该就不会出错了。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-03-21- CentOS安装Jenkins</title>
      <link href="/posts/df591b49/"/>
      <url>/posts/df591b49/</url>
      
        <content type="html"><![CDATA[<h2 id="连接云服务器"><a href="#连接云服务器" class="headerlink" title="连接云服务器"></a>连接云服务器</h2><ul><li>Windows： 使用<code>XShell</code>工具连接，下载地址</li></ul><blockquote><p>XShell <a href="https://www.aliyundrive.com/s/WJUygShyfvP">https://www.aliyundrive.com/s/WJUygShyfvP</a> 提取码: 77by 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。</p></blockquote><p>设置连接名称和主机地址,默认端口<code>22</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/21/n5WRbZzdohcKraX.png" alt="XShell"></p><h2 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h2><p>如果是安装最新版本，按照<a href="https://www.jenkins.io/download/">官网链接</a>，选择对应的平台安装即可</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/21/mqOCsarNd9QXfL8.png" alt="image-20230321170654379"></p><p>我的安装服务器是</p>]]></content>
      
      
      <categories>
          
          <category> jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVN代码同步到Git仓库</title>
      <link href="/posts/c19cd852/"/>
      <url>/posts/c19cd852/</url>
      
        <content type="html"><![CDATA[<h2 id="同步仓库"><a href="#同步仓库" class="headerlink" title="同步仓库"></a>同步仓库</h2><p>要将 SVN 服务器上的代码同步到 Git 仓库中，可以使用 <code>git svn</code> 命令。该命令可以从 SVN 仓库中导入历史记录，并将其转换为 Git 提交</p><p>创建一个空的 Git 仓库：(<code>这一步也可以直接新建一个文件夹，不需要使用 git init</code>)</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">init</span> my-git-repo</span><br><span class="line">cd my-git-repo</span><br></pre></td></tr></table></figure><p>将 SVN 仓库的 URL 添加到 Git 仓库中：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git svn init &lt;svn<span class="literal">-repo-url</span>&gt;</span><br><span class="line"><span class="comment"># git svn init svn://IP/path/LMYHSG_IMCS_HTML</span></span><br></pre></td></tr></table></figure><p>使用 <code>git svn fetch</code> 命令从 SVN 仓库中导入历史记录：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git svn fetch</span><br></pre></td></tr></table></figure><p>将导入的历史记录推送到 Git 仓库中：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;git<span class="literal">-repo-url</span>&gt;</span><br><span class="line"><span class="comment"># git remote add origin https://gitee.com/xxx/lmyhsg_-imcs_-html.git</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><blockquote><p>如果添加的git-repo-url 更改或者错误了，使用 <code>git remote rm origin</code>删除</p></blockquote><h2 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h2><p>在本地 Git 仓库中，使用 <code>git svn rebase</code> 命令从 SVN 仓库中拉取最新的代码：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git svn rebase</span><br></pre></td></tr></table></figure><p>使用 <code>git push</code> 命令将本地 Git 仓库中的更改推送到远程 Git 仓库：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h2 id="定时同步"><a href="#定时同步" class="headerlink" title="定时同步"></a>定时同步</h2><p>如果SVN服务器的代码有了新的提交，我们手动把代码更新再推送到Git仓库，这个效率会很低，那么有没有办法定时把SVN代码同步到Git仓库呢。</p><p>因为我使用的服务器是Centos,因此我利用CentOS的<code>crontab</code>来新建了一个定时任务。</p><p>利用<code>crontab</code>来新建定时任务的方法，可以<a href="https://devsu.top/posts/6f434e78/">参考我的另外一篇博客</a>。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-分类和标签的区别</title>
      <link href="/posts/4e1a01e7/"/>
      <url>/posts/4e1a01e7/</url>
      
        <content type="html"><![CDATA[<p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：<strong>分类具有顺序性和层次性而标签没有顺序和层次</strong>。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Android</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Kotlin</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Foundation</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Kotlin</span></span><br></pre></td></tr></table></figure><p>分类的话会呈现层级：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/Nprzi7lV1LnmF2I.png" alt="categories"></p><blockquote><p>WordPress支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。下面的指定方法： categories:</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-03-1-Hexo-scaffolds的用法</title>
      <link href="/posts/ed2af1cb/"/>
      <url>/posts/ed2af1cb/</url>
      
        <content type="html"><![CDATA[<p>在讲解<code>scaffolds</code>之前，我们先了解创建新文章的命令</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> hexo new [<span class="type">layout</span>] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>可以在命令中指定文章的布局（layout），不指定默认为 <code>post</code>，也可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。<strong>创建的新文章会自动加上指定布局对应的模板文件中的内容。</strong></p><h3 id="布局Layout"><a href="#布局Layout" class="headerlink" title="布局Layout"></a><code>布局Layout</code></h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，它们分别对应不同的路径，而自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><blockquote><p>如果你不想你的文章被处理，你可以将 Front-Matter 中的<code>layout:</code> 设为 <code>false</code></p></blockquote><p>我们新建一篇文章</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;demo&quot;</span></span><br></pre></td></tr></table></figure><p>Hexo会在<code>source\_posts\</code>创建<code>demo.md</code>这个文件。打开<code>demo.md</code>，我们可以看到在<code>demo.md</code>设置了默认的<code>Front Matter</code>。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/oeLSDEzwrcud4ya.png" alt="demo.md"></p><p>这里的<code>Front Matter</code>与<code>scaffolds\post.md</code>里面设置的<code>Front Matter</code>相同。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/GhAV7q4LWUwQzrb.png" alt="post.md"></p><p>同理，我们用模板<code>draft</code>来新建一篇文章。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo new draft draft<span class="literal">-demo</span></span><br></pre></td></tr></table></figure><p>我们查看，<code>scaffolds\draft.md</code>里面设置的<code>Front Matter</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/KbAnBVuvd5JRjgh.png" alt="draft.md"></p><p>对比刚才新建的<code>draft-demo.md</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/8ZFhI6UsJ1cDgQA.png" alt="draft-demo.md"></p><p>我们可以看到它们的<code>Front Matter</code>是一致的。</p><p>因此我们可以创建属于自己的<code>scaffolds</code></p><p>我们在根目录的<code>scaffolds</code>文件夹下，新建一个<code>diary.md</code>的文件，内容如下：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/TLApj16sOHIZuqY.png" alt="diary.md"></p><p>我们想使用这个模板来创建新文件，使用命令</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo new diary my<span class="literal">-diary</span></span><br></pre></td></tr></table></figure><p><strong>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>diary.md</code>，并根据其内容建立文章</strong></p><p>我们查看新建好的<code>my-diary.md</code>的内容</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">my-diary</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">diary</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">life</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-03-15 16:46:25</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>可以看到，会自动填写<code>Front Matter</code>的内容。</p><p>因为创建的文章默认会放在<code>_post</code>目录下，如果我们需要将文章放在指定目录的话，可以使用以下命令：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="literal">-p</span> Hexo/<span class="number">2023</span><span class="literal">-03-15-Hexo-</span>分类和标签的区别</span><br><span class="line"><span class="comment"># 这里的post可以修改为你自己的模板</span></span><br></pre></td></tr></table></figure><p>会在<code>_post/Hexo/</code>目录下新建<code>2023-03-15-Hexo-分类和标签的区别.md</code>文件。具体使用方法，参照：<a href="https://devsu.top/posts/4ba9f8aa/">https://devsu.top/posts/4ba9f8aa/</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-子目录新建文章</title>
      <link href="/posts/4ba9f8aa/"/>
      <url>/posts/4ba9f8aa/</url>
      
        <content type="html"><![CDATA[<p>执行<code>hexo new </code>，会默认在<code>_post</code>目录下新建文章，但是如果文章数量很多，会发现难以统一管理，因此想让文章按照目录结构排列。</p><p>例如，我们先想将Hexo相关的文章，放在<code>_post/Hexo/</code>目录下，可以用一下命令</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="literal">-p</span> Hexo/hexo-新建文章</span><br></pre></td></tr></table></figure><p>其中,<code>hexo-新建文章</code>是我们新建的文章的名称。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/TwvUHuLGd7APnar.png" alt="hexo子目录"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-03-10-Hexo - 文章短链</title>
      <link href="/posts/472cb326/"/>
      <url>/posts/472cb326/</url>
      
        <content type="html"><![CDATA[<p>在Hexo发布好服务后，我们可以在浏览器输入<code>http://&lt;用户名&gt;.github.io</code>就可以访问我们的网站，但是我们在浏览文章的时候，会发现地址栏的因为有中文标题，url会变得很长，例如: <code>https://devsu.top/2023/03/08/2020-07-10-Markdown%E7%94%A8%E6%B3%95/</code>，复制访问的时候，非常不友好。</p><p>因此，我们在<a href="https://hexo.io/plugins/">hexo插件中心</a>，找到了 <a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 短链生成工具：</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-abbrlink</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><h2 id="修改-permalink"><a href="#修改-permalink" class="headerlink" title="修改 permalink"></a>修改 permalink</h2><p>在Hexo根目录的<code>_config.xml</code>中修改<code>permalink</code></p><p>默认的规则是:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">year/:month/:day/:title/</span></span><br></pre></td></tr></table></figure><p>修改为:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span> </span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span></span><br></pre></td></tr></table></figure><h3 id="设置permalink生成的算法和进制"><a href="#设置permalink生成的算法和进制" class="headerlink" title="设置permalink生成的算法和进制"></a>设置permalink生成的算法和进制</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新增</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>      <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>        <span class="comment">#support dec(default) and hex</span></span><br><span class="line">  <span class="attr">drafts:</span> <span class="literal">false</span>   <span class="comment">#(true)Process draft,(false)Do not process draft. false(default) </span></span><br><span class="line">  <span class="comment"># Generate categories from directory-tree</span></span><br><span class="line">  <span class="comment"># depth: the max_depth of directory-tree you want to generate, should &gt; 0</span></span><br><span class="line">  <span class="attr">auto_category:</span></span><br><span class="line">     <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment">#true(default)</span></span><br><span class="line">     <span class="attr">depth:</span>        <span class="comment">#3(default)</span></span><br><span class="line">     <span class="attr">over_write:</span> <span class="literal">false</span> </span><br><span class="line">  <span class="attr">auto_title:</span> <span class="literal">false</span> <span class="comment">#enable auto title, it can auto fill the title by path</span></span><br><span class="line">  <span class="attr">auto_date:</span> <span class="literal">false</span> <span class="comment">#enable auto date, it can auto fill the date by time today</span></span><br><span class="line">  <span class="attr">force:</span> <span class="literal">false</span> </span><br></pre></td></tr></table></figure><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/10/Q98JIUjuXM6OfEC.png" alt="短链配置"></p><h2 id="生成样例"><a href="#生成样例" class="headerlink" title="生成样例"></a>生成样例</h2><p>官方短链生成的样例是：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https://post.zz173.com/posts/<span class="number">66</span>c8.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https://post.zz173.com/posts/<span class="number">65535</span>.html</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在文章的<code>Front-matter</code>内新增<code>abbrlink</code>字段，值为生成的ID。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址。如果不增加这个字段的话，我们的URL就会变成<code>https://xxx/posts/undefined/</code>,并且打开文章的链接不会跳转到对应的文章页。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span></span><br><span class="line"><span class="attr">date:</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"> <span class="bullet">-</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"> <span class="bullet">-</span></span><br><span class="line"><span class="attr">abbrlink:</span>  <span class="comment">#留空就好，会自动生成，并不会因下次更新文章而变动</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><blockquote><p>因为每篇文章都需要修改<code>abbrlink</code>，因此我们需要修改<code>Front-matter</code>的统一设置，在Hexo根目录的<code>scaffolds</code>文件夹下，修改<code>post.md</code>的内容</p></blockquote><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/10/NvpC9q5glBTdJ7D.png" alt="front-matter设置"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo - 部署到Github</title>
      <link href="/posts/d287c587/"/>
      <url>/posts/d287c587/</url>
      
        <content type="html"><![CDATA[<h2 id="连接到Github"><a href="#连接到Github" class="headerlink" title="连接到Github"></a>连接到Github</h2><h3 id="配置git用户名和密码"><a href="#配置git用户名和密码" class="headerlink" title="配置git用户名和密码"></a>配置git用户名和密码</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><h3 id="生成SSH-Key"><a href="#生成SSH-Key" class="headerlink" title="生成SSH Key"></a>生成SSH Key</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p>SSH Key的位置:</p><blockquote><p>Windows下： C&#x2F;Users&#x2F;Administrator&#x2F;.ssh&#x2F;id_ras.pub</p><p>MacOS:   ~&#x2F;.ssh&#x2F;id_ras.pub</p></blockquote><h3 id="在Github添加SSH"><a href="#在Github添加SSH" class="headerlink" title="在Github添加SSH"></a>在Github添加SSH</h3><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/09/sC5cmX9hygEIS7M.png"></p><h3 id="验证SSH配置是否成功"><a href="#验证SSH配置是否成功" class="headerlink" title="验证SSH配置是否成功"></a>验证SSH配置是否成功</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果成功会提示:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hi XXX! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><h2 id="Github创建同名仓库"><a href="#Github创建同名仓库" class="headerlink" title="Github创建同名仓库"></a>Github创建同名仓库</h2><p>在github上创建一个和用户名相同的仓库，以<code>.github.io</code>结尾，<code>&lt;用户名&gt;.github.io</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/09/tPRhNoIZYDuLFnW.png" alt="仓库"></p><h2 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>为了正常部署到github仓库，需要先安装<code>hexo-deployer-git</code>插件。在Hexo根目录输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>如果没有安装的话会报错</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO Validating config</span><br><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>修改Hexo根目录的<code>_config.xml</code>文件，修改<code>deploy</code>的内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment"># 这里填写自己的github的名称即可</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">ssh://git@github.com/用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="comment"># 注意这里，检查github的默认分支是 main 还是 master</span></span><br><span class="line">  <span class="attr">brandh:</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">messge:</span></span><br></pre></td></tr></table></figure><h2 id="部署到远程仓库"><a href="#部署到远程仓库" class="headerlink" title="部署到远程仓库"></a>部署到远程仓库</h2><p>每次重新开一个新的终端都要重新连接git：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>执行下面的命令，然后再次进入Pages的链接<code>https://用户名.github.io</code>就可以看到你的博客了。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo generate <span class="comment"># 也可以使用缩写  hexo g</span></span><br><span class="line">hexo deploy  <span class="comment"># 缩写 hexo d</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/09/fmQJkUOg9s4xK3W.png" alt="winstone.su"></p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol><li><h3 id="remote-rejected-HEAD-master-protected-branch-hook-declined"><a href="#remote-rejected-HEAD-master-protected-branch-hook-declined" class="headerlink" title="[remote rejected] HEAD -&gt; master (protected branch hook declined)"></a>[remote rejected] HEAD -&gt; master (protected branch hook declined)</h3></li></ol><p>错误信息:</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/09/omSGCYTfMb54cpJ.png" alt="deploy error"></p><p>出现这种问题的原因是，github仓库的branch添加了<code>protection rules</code>，在当前仓库的<code>Settings</code> –&gt; <code>Branches</code> 删除 <code>Branch protection rules</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/09/lxzegs7rG8yfYoU.png" alt="Delte Branch protection Rules"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo - 自定义域名</title>
      <link href="/posts/9e415fdd/"/>
      <url>/posts/9e415fdd/</url>
      
        <content type="html"><![CDATA[<h2 id="添加解析记录"><a href="#添加解析记录" class="headerlink" title="添加解析记录"></a>添加解析记录</h2><p>在阿里云<a href="https://dc.console.aliyun.com/next/index?spm=5176.ecscore_overview.recommend.ddomain.787c4df5UKF8CR#/domain-list/all">域名管理</a> <code>解析设置</code>添加两条记录。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/09/Kzr7eiTgPBqEIZa.png" alt="域名解析记录"></p><table><thead><tr><th>主机记录</th><th>记录类型</th><th>记录值</th><th>TTL</th></tr></thead><tbody><tr><td>@</td><td>A</td><td>185.199.109.153</td><td>10分钟</td></tr><tr><td>www</td><td>A</td><td>185.199.109.153</td><td>10分钟</td></tr></tbody></table><p>将上表中的两条记录，添加进去。</p><h2 id="Github-Pages设置"><a href="#Github-Pages设置" class="headerlink" title="Github Pages设置"></a>Github Pages设置</h2><p>在运行<code>hexo delpoy</code>之后，hexo会将<code>public/</code>文件夹下的所有文件上传到github，在<code>Settings</code> –&gt; <code>Pages</code>里设置自定义域名<code>Custom Domain</code>。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/09/zHLMNARiOJmVa8s.png" alt="custom domain"></p><p>在<code>Custom domain</code>里面输入已经购买的域名，打开<code>Enforce HTTPS</code>。保存成功后，会在仓库的根目录新建一个<code>CNAME</code>,里面的内容就是我们的域名。</p><p>这个时候，输入域名，就可以打开构建好的网站了。</p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><p>当我们在github设置了<code>Custom domain</code>后，重新运行<code>hexo deploy</code>，会发现无法推送，参考<a href="https://devsu.top/2023/03/09/2023-03-08-Hexo%20-%20%E9%83%A8%E7%BD%B2%E5%88%B0Github/">部署到Github</a></p><p>这就会引发另外一个问题，是不是每次部署都需要删掉规则，部署之后再重新设置<code>Custom domain</code>呢？</p><p>在运行<code>hexo generate</code>后，<code>public</code>文件夹下的固定资源不会每次都更新，所以我们把<code>CNAME</code>文件，放在<code>public</code>文件夹下，同时删掉github pages的规则。</p><p>再次运行<code>hexo deploy</code>，这个时候能够正常推送了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown利器</title>
      <link href="/posts/490899c0/"/>
      <url>/posts/490899c0/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown利器"><a href="#Markdown利器" class="headerlink" title="Markdown利器"></a>Markdown利器</h1><p>工具：</p><ul><li>PicGo</li><li>Typora</li><li>图床服务</li></ul><h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>图床服务，支持列表：</p><ul><li>腾讯云COS</li><li>阿里云OSS</li><li>SM.MS</li><li>GitHub</li><li>七牛云</li><li>Imgur</li><li>又拍云</li></ul><h3 id="Github图床"><a href="#Github图床" class="headerlink" title="Github图床"></a>Github图床</h3><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/09/hS85jyNYAmaIFoc.png" alt="Github设置"></p><h3 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h3><blockquote><p>限制： 需要绑定已备案的域名</p></blockquote><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/09/zHb8cpGL2RMTEnW.png" alt="七牛云设置"></p><h3 id="SM-MS"><a href="#SM-MS" class="headerlink" title="SM.MS"></a>SM.MS</h3><p>​免费用户有5G的使用空间</p><blockquote><p>如果 <a href="https://sm.ms/">https://sm.ms</a>无法访问，就改用国内的域名<a href="https://smms.app/">https://smms.app/</a></p></blockquote><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/09/OPZD64E79IVy58R.png" alt="SM.MS设置"></p><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>在 <code>文件 </code> –&gt; <code>偏好设置</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/09/iDQtS4ymeljNEF1.png" alt="Typora Picgo设置"></p><p>这样在每次插入本地图片的时候，就可以支持把图片上传到指定的图床服务上。大大提高了写文档的效率。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题 - Butterfly(三) 主题配置-1</title>
      <link href="/posts/1970255d/"/>
      <url>/posts/1970255d/</url>
      
        <content type="html"><![CDATA[<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>修改站点配置文件<code> _config.yml</code></p><p>默认语言是 <code>en</code></p><p>主题支持三种语言</p><ul><li>default(en)</li><li>zh-CN (简体中文)</li><li>zh-TW (繁体中文)</li></ul><h2 id="网站资料"><a href="#网站资料" class="headerlink" title="网站资料"></a>网站资料</h2><p>修改网站各种资料，例如标题、副标题和邮箱等个人资料，请修改博客根目录的<code> _config.yml</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://file.crazywong.com/gh/jerryc127/CDN/img/20191120000444.png"></p><h2 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a>导航菜单</h2><p>修改 <code>主题配置文件</code></p><blockquote><p>注意: 如果我们前面配置了<code>_config.butterfly.yml</code>，那么就修改根目录的<code>_config.butterfly.yml</code></p><p>如果没有配置<code>_config.butterfly.yml</code>,就修改<code>node_modules\hexo-theme-butterfly\_config.xml</code></p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line"><span class="attr">Archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line"><span class="attr">Tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line"><span class="attr">Categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line"><span class="string">List||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">  <span class="attr">Music:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">  <span class="attr">Movie:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line"><span class="attr">Link:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line"><span class="attr">About:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><p>必须是<code> /xxx/</code>，后面<code> ||</code>分开，然后写图标名。</p><p>如果不希望显示图标，图标名可不写。</p><p>默认子目录是展开的，如果你想要隐藏，在子目录里添加 <code> hide</code>。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">List||fas</span> <span class="string">fa-list||hide:</span></span><br><span class="line">  <span class="attr">Music:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">  <span class="attr">Movie:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br></pre></td></tr></table></figure><p>注意： 导航的文字可自行更改</p><p>例如：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  首页: / || fas fa-home</span><br><span class="line">  时间轴: /archives/ || fas fa-archive</span><br><span class="line">  标签: /tags/ || fas fa-tags</span><br><span class="line">  分类: /categories/ || fas fa-folder-open</span><br><span class="line">  清单||fa fa-heartbeat:</span><br><span class="line"><span class="code">    音乐: /music/ || fas fa-music</span></span><br><span class="line"><span class="code">    照片: /Gallery/ || fas fa-images</span></span><br><span class="line"><span class="code">    电影: /movies/ || fas fa-video</span></span><br><span class="line"><span class="code">  友链: /link/ || fas fa-link</span></span><br><span class="line"><span class="code">  关于: /about/ || fas fa-heart</span></span><br></pre></td></tr></table></figure><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://file.crazywong.com/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-menu.png" style="zoom: 80%;" /><h2 id="导航栏设置"><a href="#导航栏设置" class="headerlink" title="导航栏设置"></a>导航栏设置</h2><p>主题配置文件中</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="comment">#image</span></span><br><span class="line">  <span class="attr">display_title:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">fixed:</span> <span class="literal">false</span> <span class="comment"># fixed navigation bar</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>logo</td><td>网站的 logo，支持图片，直接填入图片链接</td></tr><tr><td>display_title</td><td>是否显示网站标题，填写 true 或者 false</td></tr><tr><td>fixed</td><td>是否固定状态栏，填写 true 或者 false</td></tr></tbody></table><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>代码块中的所有功能只适用于 Hexo 自带的代码渲染</p><p>如果使用第三方的渲染器，不一定会有效</p></blockquote><h3 id="代码高亮主题"><a href="#代码高亮主题" class="headerlink" title="代码高亮主题"></a>代码高亮主题</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">默认主题</button><button type="button" class="tab">自定义主题</button></div><div class="tab-contents"><div class="tab-item-content active"><p><code>Butterfly</code> 支持6种代码高亮样式：</p><ul><li>darker</li><li>pale night</li><li>light</li><li>ocean</li><li>mac</li><li>mac light</li></ul><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">light</span></span><br></pre></td></tr></table></figure><blockquote><p>darker</p></blockquote><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071629682.png"></p><blockquote><p>pale night</p></blockquote><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071645203.png"></p><blockquote><p>light</p></blockquote><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071645523.png"></p><blockquote><p>ocean</p></blockquote><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071646214.png"></p><blockquote><p>mac</p></blockquote><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071646352.png"></p><blockquote><p>mac light</p></blockquote><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071647614.png"></p></div><div class="tab-item-content"><p>主题从 3.0 开始，支持使用自定义的代码顔色。</p><p>如何自定义主题，请查看下面这篇文章。</p><p><a href="https://butterfly.js.org/posts/b37b5fe3/">自定义代码配色</a></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="代码复制"><a href="#代码复制" class="headerlink" title="代码复制"></a>代码复制</h3><p>主题支持代码复制功能</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071651983.png"></p><h3 id="代码框展开-关闭"><a href="#代码框展开-关闭" class="headerlink" title="代码框展开&#x2F;关闭"></a>代码框展开&#x2F;关闭</h3><p>在默认情况下，代码框自动展开，可设置是否所有代码框都关闭状态，点击<code>&gt;</code>可展开代码</p><ul><li>true 全部代码框不展开，需点击<code>&gt;</code>打开</li><li>false 代码框展开，有<code>&gt;</code>点击按钮</li><li>none 不显示<code>&gt;</code>按钮</li></ul><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_shrink:</span> <span class="literal">true</span> <span class="comment">#代码框不展开，需点击 &#x27;&gt;&#x27; 打开</span></span><br></pre></td></tr></table></figure><blockquote><p>你也可以在post&#x2F;page页对应的markdown文件front-matter添加highlight_shrink来独立配置。</p><p>当主题配置文件中的 <code>highlight_shrink</code> 设为true时，可在front-matter添加 <code>highlight_shrink: false</code>来单独配置文章展开代码框。</p><p>当主题配置文件中的  <code>highlight_shrink</code>  设为false时，可在front-matter添加 <code>highlight_shrink: true</code>来单独配置文章收缩代码框。</p></blockquote><p> <code>highlight_shrink: true</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071655866.png"></p><p> <code>highlight_shrink: false</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071655593.png"></p><p> <code>highlight_shrink: none</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071655529.png"></p><h3 id="代码换行"><a href="#代码换行" class="headerlink" title="代码换行"></a>代码换行</h3><p>在默认情况下，Hexo 在编译的时候不会实现代码自动换行。如果你不希望在代码块的区域里有横向滚动条的话，那么你可以考虑开启这个功能。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">修改</span> <span class="string">主题配置文件</span></span><br></pre></td></tr></table></figure><p>如果你是使用 highlight 渲染，需要找到你站点的 Hexo 配置文件 <code>_config.yml</code>，将 <code>line_number</code>改成 <code>false</code>:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span> <span class="comment"># &lt;- 改这里</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span></span><br></pre></td></tr></table></figure><p>如果你是使用 prismjs 渲染，需要找到你站点的 Hexo 配置文件 <code>_config.yml</code>，将 <code>line_number</code>改成 <code>false</code>:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span> <span class="comment"># &lt;- 改这里</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>设置<code>code_word_wrap</code>之前:</p></blockquote><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071659102.png"></p><blockquote><p>设置<code>code_word_wrap</code>之后:</p></blockquote><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071659236.png" alt="img"></p><h3 id="代码高度限制"><a href="#代码高度限制" class="headerlink" title="代码高度限制"></a>代码高度限制</h3><blockquote><p>3.7.0 及以上支持</p></blockquote><p>可配置代码高度限制，超出的部分会隐藏，并显示展开按钮。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_height_limit:</span> <span class="literal">false</span> <span class="comment"># unit: px</span></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>单位是<code> px</code>，直接添加数字，如 200</li><li>实际限制高度为<code> highlight_height_limit + 30 px</code> ，多增加 30px 限制，目的是避免代码高度只超出highlight_height_limit 一点时，出现展开按钮，展开没内容。</li><li>不适用于隐藏后的代码块（ css 设置 display: none）</li></ol><h2 id="社交图标"><a href="#社交图标" class="headerlink" title="社交图标"></a>社交图标</h2><p>Butterfly支持 <a href="https://fontawesome.com/icons?from=io">font-awesome v6</a>图标.</p><p>书写格式 <code>图标名：url || 描述性文字</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">fab fa-github:</span> <span class="string">https://github.com/xxxxx</span> <span class="string">||</span> <span class="string">Github</span></span><br><span class="line">  <span class="attr">fas fa-envelope:</span> <span class="string">mailto:xxxxxx@gmail.com</span> <span class="string">||</span> <span class="string">Email</span></span><br></pre></td></tr></table></figure><p>图标名可在这寻找</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071705210.png" alt="img"></p><p>PC:</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071704239.png" alt="img"></p><p>mobile:</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071705003.png" alt="1560603353743"></p><h2 id="主页文章节选-自动节选和文章页description"><a href="#主页文章节选-自动节选和文章页description" class="headerlink" title="主页文章节选(自动节选和文章页description)"></a>主页文章节选(自动节选和文章页description)</h2><p>因为主题UI的关係，主页文章节选只支持自动节选和文章页description。</p><p>在butterfly里，有四种可供选择</p><ol><li><strong>description</strong>： 只显示description</li><li><strong>both</strong>： 优先选择description，如果没有配置description，则显示自动节选的内容</li><li><strong>auto_excerpt</strong>：只显示自动节选</li><li><strong>false</strong>： 不显示文章内容</li></ol><p>修改<code> 主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index_post_content:</span></span><br><span class="line">  <span class="attr">method:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">500</span> <span class="comment"># if you set method to 2 or 3, the length need to config</span></span><br></pre></td></tr></table></figure><p><code>description</code>在front-matter里添加</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071706702.png" alt="img"></p><h2 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h2><blockquote><p>如果不要显示顶部图，可直接配置 <code>disable_top_img: true</code></p></blockquote><blockquote><p>顶部图的获取顺序，如果都没有配置，则不显示顶部图。</p><ol><li><p>页面顶部图的获取顺序：</p><p>各自配置的 top_img &gt; 配置文件的 default_top_img</p></li><li><p>文章页顶部图的获取顺序：</p><p>各自配置的 top_img &gt; cover &gt; 配置文件的 default_top_img</p></li></ol></blockquote><p>配置中的值：</p><table><thead><tr><th>配置</th><th>解释</th></tr></thead><tbody><tr><td>index_img</td><td>主页的 top_img</td></tr><tr><td>default_top_img</td><td>默认的 top_img，当页面的 top_img 没有配置时，会显示 default_top_img</td></tr><tr><td>archive_img</td><td>归档页面的 top_img</td></tr><tr><td>tag_img</td><td>tag 子页面 的 默认 top_img</td></tr><tr><td>tag_per_img</td><td>tag 子页面的 top_img，可配置每个 tag 的 top_img</td></tr><tr><td>category_img</td><td>category 子页面 的 默认 top_img</td></tr><tr><td>category_per_img</td><td>category 子页面的 top_img，可配置每个 category 的 top_img</td></tr></tbody></table><p>其它页面 （tags&#x2F;categories&#x2F;自建页面）和 文章页 的 <code>top_img</code> ，请到对应的 md 页面设置<code>front-matter</code>中的<code>top_img</code></p><p>以上所有的 top_img 可配置以下值</p><blockquote><p>3.2.0 以下版本的配置只支持</p><ul><li>留空，true 和 false - 显示默认的顔色</li><li>img链接 - 显示所配置的图片</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> Butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题 - Butterfly(二) 主题页面</title>
      <link href="/posts/39fb20f2/"/>
      <url>/posts/39fb20f2/</url>
      
        <content type="html"><![CDATA[<h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p><strong>Front-matter</strong> 是 <strong>markdown</strong> 文件最上方以 <font color='red'> — </font> 分隔的区域，用于指定个别档案的变数。</p><p>Page Front-matter 用于<font color='red'>页面</font> 配置<br>Post Front-matter 用于<font color='red'>文章页</font> 配置</p><blockquote><p>如果标注<font color='red'>可选</font>的参数，可根据自己需要添加，不用全部都写在markdown里</p></blockquote><h3 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">写法</th><th align="left">解释</th></tr></thead><tbody><tr><td align="center">title</td><td align="left">【必需】页面标题</td></tr><tr><td align="center">date</td><td align="left">【必需】页面创建日期</td></tr><tr><td align="center">type</td><td align="left">【必需】标签、分类和友情链接三个页面需要配置</td></tr><tr><td align="center">updated</td><td align="left">【可选】页面更新日期</td></tr><tr><td align="center">description</td><td align="left">【可选】页面描述</td></tr><tr><td align="center">keywords</td><td align="left">【可选】页面关键字</td></tr><tr><td align="center">comments</td><td align="left">【可选】显示页面评论模块(默认 true)</td></tr><tr><td align="center">top_img</td><td align="left">【可选】页面顶部图片</td></tr><tr><td align="center">mathjax</td><td align="left">【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td align="center">katex</td><td align="left">【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td align="center">aside</td><td align="left">【可选】显示侧边栏 (默认 true)</td></tr><tr><td align="center">aplayer</td><td align="left">【可选】在需要的页面加载aplayer的js和css,请参考文章下面的<font color='red'>音乐</font> 配置</td></tr><tr><td align="center">highlight_shrink</td><td align="left">【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table><h3 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments:</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">toc<span class="emphasis">_style_</span>simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright<span class="emphasis">_author:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:</span><br><span class="line">copyright<span class="emphasis">_info:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line"><span class="section">aside:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标签</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可选】显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td>toc_style_simple</td><td>【可选】显示 toc 简洁模式</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>copyright_author</td><td>【可选】文章版权模块的<font color='red'>文章作者</font></td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的<font color='red'>文章作者</font>链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的<font color='red'>文章连结</font>链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的<font color='red'>版权说明</font>文字</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的<font color='red'>音乐</font> 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr></tbody></table><h2 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h2><ol><li><p>前往你的 Hexo 博客的根目录</p></li><li><p>输入<font color='red'><code>hexo new page tags</code></font></p></li><li><p>找到<font color='red'><code>source/tags/index.md</code></font>这个文件</p></li><li><p>修改这个文件：</p><p><em>记得添加</em> <font color='red'><code>type: &quot;tags&quot;</code></font></p></li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">date: 2023-03-07 14:37:20</span><br><span class="line">orderby: random</span><br><span class="line">order: 1</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>type</td><td>【必须】页面类型，必须为<font color= "red"><code>tags</code></font></td></tr><tr><td>orderby</td><td>【可选】排序方式 ：random&#x2F;name&#x2F;length</td></tr><tr><td>order</td><td>【可选】排序次序： 1, asc for ascending; -1, desc for descending</td></tr></tbody></table><h2 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h2><ol><li><p>前往 Hexo 博客的根目录</p></li><li><p>输入<font color="red"><code>hexo new page categories</code></font></p></li><li><p>找到<font color="red"><code>source/categories/index.md</code></font>这个文件</p></li><li><p>修改这个文件：</p><p><em>记得添加</em> <font color='red'><code>type: &quot;categories&quot;</code></font></p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">date: 2023-03-07 14:49:03</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><p>为你的博客创建一个友情链接！</p><h3 id="创建友情链接页面"><a href="#创建友情链接页面" class="headerlink" title="创建友情链接页面"></a>创建友情链接页面</h3><ol><li><p>前往 Hexo 博客的根目录</p></li><li><p>输入 <font color="red"><code>hexo new page link</code></font></p></li><li><p>找到<font color="red"><code>source/link/index.md</code></font>这个文件</p></li><li><p>修改这个文件：</p><p><em>记得添加</em> <font color='red'><code>type: &quot;link&quot;</code></font></p></li></ol><h3 id="友情链接添加"><a href="#友情链接添加" class="headerlink" title="友情链接添加"></a>友情链接添加</h3><h4 id="本地生成"><a href="#本地生成" class="headerlink" title="本地生成"></a>本地生成</h4><p>在Hexo博客目录中的<font color="red"><code>source/_data</code></font>（如果没有 _data 文件夹，请自行创建），创建一个文件<font color="red"><code>link.yml</code></font></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">友情链接</span></span><br><span class="line">  <span class="attr">class_desc:</span> <span class="string">那些人，那些事</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://hexo.io/zh-tw/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">快速、简单且强大的网志框架</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">网站</span></span><br><span class="line">  <span class="attr">class_desc:</span> <span class="string">值得推荐的网站</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Youtube</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://www.youtube.com/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">视频网站</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Weibo</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://www.weibo.com/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">中国最大社交分享平台</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Twitter</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://twitter.com/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">社交分享平台</span></span><br></pre></td></tr></table></figure><p><font color="red"><code>class_name</code></font> 和<font color="red"><code> class_desc</code></font> 支持 html 格式书写，如不需要，也可以留空。</p><h4 id="远程拉取"><a href="#远程拉取" class="headerlink" title="远程拉取"></a>远程拉取</h4><p>从 <font color="red"><code>4.0.0</code></font>开始，支持从远程加载友情链接，远程拉取只支持 <font color="red"><code>json</code></font>。</p><p>注意： 选择远程加载后，本地生成的方法会无效。</p><p>在<font color="red"><code>source/link/index.md</code></font> 这个文件的 front-matter 添加远程链接</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">flink<span class="emphasis">_url: xxxxx</span></span><br></pre></td></tr></table></figure><p>Json 的格式</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;class_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;友情链接&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;class_desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;那些人，那些事&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;link_list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hexo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://hexo.io/zh-tw/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;descr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;快速、简单且强大的网志框架&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;class_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;网站&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;class_desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值得推荐的网站&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;link_list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Youtube&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.youtube.com/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;descr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;视频网站&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Weibo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.weibo.com/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;descr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国最大社交分享平台&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Twitter&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://twitter.com/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;descr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;社交分享平台&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h3 id="友情链接界面设置"><a href="#友情链接界面设置" class="headerlink" title="友情链接界面设置"></a>友情链接界面设置</h3><p>由 2.2.0 起，友情链接界面可以由用户自己自定义，只需要在友情链接的md档设置就行，以普通的Markdown格式书写。</p><h2 id="图库"><a href="#图库" class="headerlink" title="图库"></a>图库</h2><p>图库页面只是普通的页面，你只需要<font color="red"><code>hexo n page xxxxx </code></font>创建你的页面就行</p><p>然后使用标签外挂 <a href="https://butterfly.js.org/posts/4aa8abbe/#Gallery%E7%9B%B8%E5%86%8A%E5%9C%96%E5%BA%AB">galleryGroup</a>，具体用法请查看对应的内容。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;div</span> <span class="string">class=&quot;gallery-group-main&quot;&gt;</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">galleryGroup</span> <span class="string">&#x27;壁纸&#x27;</span> <span class="string">&#x27;收藏的一些壁纸&#x27;</span> <span class="string">&#x27;/Gallery/wallpaper&#x27;</span> <span class="string">https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png</span> <span class="string">%</span>&#125;</span><br><span class="line">&#123;<span class="string">%</span> <span class="string">galleryGroup</span> <span class="string">&#x27;漫威&#x27;</span> <span class="string">&#x27;关于漫威的图片&#x27;</span> <span class="string">&#x27;/Gallery/marvel&#x27;</span> <span class="string">https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg</span> <span class="string">%</span>&#125;</span><br><span class="line">&#123;<span class="string">%</span> <span class="string">galleryGroup</span> <span class="string">&#x27;OH MY GIRL&#x27;</span> <span class="string">&#x27;关于OH MY GIRL的图片&#x27;</span> <span class="string">&#x27;/Gallery/ohmygirl&#x27;</span> <span class="string">https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg</span> <span class="string">%</span>&#125;</span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><div class="gallery-group-main"><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src='https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png' alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">壁纸</div>      <p>收藏的一些壁纸</p>      <a href='/Gallery/wallpaper'></a>    </figcaption>  </figure><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src='https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg' alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">漫威</div>      <p>关于漫威的图片</p>      <a href='/Gallery/marvel'></a>    </figcaption>  </figure><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src='https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg' alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">OH MY GIRL</div>      <p>关于OH MY GIRL的图片</p>      <a href='/Gallery/ohmygirl'></a>    </figcaption>  </figure></div><h3 id="子页面"><a href="#子页面" class="headerlink" title="子页面"></a>子页面</h3><p>子页面也是普通的页面，你只需要<font color ="red"><code>hexo n page xxxxx</code></font> 创建你的页面就行</p><p>然后使用标签外挂 <a href="https://butterfly.js.org/posts/4aa8abbe/#Gallery%E7%9B%B8%E5%86%8A">gallery</a>，具体用法请查看对应的内容。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">%</span> <span class="string">gallery</span> <span class="string">%</span>&#125;</span><br><span class="line"><span class="type">![](https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg)</span></span><br><span class="line"><span class="type">![](https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg)</span></span><br><span class="line"><span class="type">![](https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg)</span></span><br><span class="line"><span class="type">![](https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg)</span></span><br><span class="line"><span class="type">![](https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg)</span></span><br><span class="line"><span class="type">![](https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg)</span></span><br><span class="line"><span class="type">![](https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg)</span></span><br><span class="line"><span class="type">![](https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg)</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">endgallery</span> <span class="string">%</span>&#125;</span><br></pre></td></tr></table></figure><p>有关图库和子页面的详细设置可以参考</p><p><code>https://butterfly.js.org/posts/dc584b87/#%E5%9C%96%E5%BA%AB</code> 和<code>https://butterfly.js.org/posts/4aa8abbe/#Gallery%E7%9B%B8%E5%86%8A%E5%9C%96%E5%BA%AB</code></p><blockquote><p>如果你想要使用 &#x2F;photo&#x2F;ohmygirl 这样的链接显示你的图片内容</p><p>你可以把创建好的 ohmygirl整个文件夹移到 photo文件夹里去</p></blockquote><h2 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h2><p>主题内置了一个简单的404页面，可在设置中开启</p><blockquote><p>本地预览时，访问出错的网站是不会跳到404页面的。</p><p>如需本地预览，请访问<a href="http://localhost:4000/404.html">http://localhost:4000/404.html</a></p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A simple 404 page</span></span><br><span class="line"><span class="attr">error_404:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">subtitle:</span> <span class="string">&quot;页面没有找到&quot;</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> Butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题 - Butterfly(一)--快速开始</title>
      <link href="/posts/a975a2b2/"/>
      <url>/posts/a975a2b2/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>在Hexo根目录</p><p>稳定版</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git clone <span class="literal">-b</span> master https://github.com/jerryc127/hexo<span class="literal">-theme-butterfly</span>.git themes/butterfly</span><br></pre></td></tr></table></figure><blockquote><p>升级方法：在主题目录下，运行 <code>git pull</code></p></blockquote><h3 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h3><blockquote><p>此方法只支持 Hexo 5.0.0 以上版本</p><p>通过npm安装不会在themes里生成主题文件夹，而是在<code>node_modules</code>里生成。</p></blockquote><p>在Hexo根目录</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm i hexo<span class="literal">-theme-butterfly</span></span><br></pre></td></tr></table></figure><blockquote><p>升级方法：在Hexo根目录下，运行 npm update hexo-theme-butterfly</p></blockquote><p>这里我是通过<code>npm</code>安装的。</p><h2 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h2><p>修改Hexo根目录下的 <code>_config.yml</code>，把主题改为<code>butterfly</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>如果你没有pug以及stylus的渲染器，需要安装:</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-renderer-pug</span> hexo<span class="literal">-renderer-stylus</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><h2 id="升级建议"><a href="#升级建议" class="headerlink" title="升级建议"></a>升级建议</h2><blockquote><p>升级完成后，请到Github的 Releases 界面查看新版的更新内容。 </p><p>里面有标注 _config 文件的变更内容，请根据实际情况更新你的配置内容。</p></blockquote><p>为了减少升级主题带来的不便，请使用以下方法(建议，可以不做)。</p><p>在hexo的根目录下创建一个文件 <code>_config.butterfly.yml</code>，并把主题目录的<code>_config.yml</code>内容复制到<code>_config.butterfly.yml</code>去（注意：复制的是主题下的<code>_config.yml</code>，而不是hexo的<code>_config.yml</code>）</p><blockquote><p><code>注意： 不要把主題目錄的 _config.yml 刪掉</code></p></blockquote><blockquote><p>注意： 以后只需要在<code>_config.butterfly.yml</code>进行配置就行。</p><p>如果使用了<code>_config.butterfly.yml</code>配置主题的<code>_config.yml</code>将不会有效果。</p></blockquote><p>Hexo会自动合并主题中的<code>_config.yml</code>和<code>_config.butterfly.yml</code>里的配置。如果存在同名配置，会使用<code>_config.butterfly.yml</code>的配置，其优先级较高。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/image/202303071151281.png"></p><p>更多设置：参考<a href="https://butterfly.js.org/page/2/#content-inner">butterfly官网</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> Butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo安装配置教程</title>
      <link href="/posts/8f5fee99/"/>
      <url>/posts/8f5fee99/</url>
      
        <content type="html"><![CDATA[<h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>安装使用hexo之前需要先安装Node.js和Git</p><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a><a href="https://nodejs.org/en/download/">Node.js</a></h3><p>(Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a><a href="http://git-scm.com/">Git</a></h3><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 <a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo">安装 Hexo</a> 步骤。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>可以通过以下命令查看主机中是否安装了node.js和npm</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> node <span class="literal">--version</span>    <span class="comment">#检查是否安装了node.js</span></span><br><span class="line"><span class="variable">$</span> npm <span class="literal">--version</span>     <span class="comment">#检查是否安装了npm</span></span><br></pre></td></tr></table></figure><p>如下所示表示已经安装了node.js和npm</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> node <span class="literal">--version</span></span><br><span class="line">v18.<span class="number">14.2</span></span><br><span class="line"><span class="variable">$</span> npm <span class="literal">--version</span></span><br><span class="line"><span class="number">9.5</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure><h3 id="进阶安装和使用"><a href="#进阶安装和使用" class="headerlink" title="进阶安装和使用"></a>进阶安装和使用</h3><p>对于熟悉 npm 的进阶用户，可以仅局部安装 <code>hexo</code> 包。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo</span><br></pre></td></tr></table></figure><p>安装以后，可以使用以下两种方式执行 Hexo：</p><ol><li><code>npx hexo &lt;command&gt;</code></li><li>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27; &gt;&gt; ~/.profile</span><br></pre></td></tr></table></figure><h2 id="Node-js-版本限制"><a href="#Node-js-版本限制" class="headerlink" title="Node.js 版本限制"></a>Node.js 版本限制</h2><p>我们强烈建议永远安装最新版本的 Hexo，以及 <a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90">推荐的 Node.js 版本</a>。</p><table><thead><tr><th align="left">Hexo 版本</th><th align="left">最低版本 (Node.js 版本)</th><th align="left">最高版本 (Node.js 版本)</th></tr></thead><tbody><tr><td align="left">6.2+</td><td align="left">12.13.0</td><td align="left">latest</td></tr><tr><td align="left">6.0+</td><td align="left">12.13.0</td><td align="left">18.5.0</td></tr><tr><td align="left">5.0+</td><td align="left">10.13.0</td><td align="left">12.0.0</td></tr><tr><td align="left">4.1 - 4.2</td><td align="left">8.10</td><td align="left">10.0.0</td></tr><tr><td align="left">4.0</td><td align="left">8.6</td><td align="left">8.10.0</td></tr><tr><td align="left">3.3 - 3.9</td><td align="left">6.9</td><td align="left">8.0.0</td></tr><tr><td align="left">3.2 - 3.3</td><td align="left">0.12</td><td align="left">未知</td></tr><tr><td align="left">3.0 - 3.1</td><td align="left">0.10 或 iojs</td><td align="left">未知</td></tr><tr><td align="left">0.0.1 - 2.8</td><td align="left">0.10</td><td align="left">未知</td></tr></tbody></table><h2 id="Hexo初始化配置"><a href="#Hexo初始化配置" class="headerlink" title="Hexo初始化配置"></a>Hexo初始化配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexp init &lt;folder&gt;</span><br><span class="line">cd &lt;floder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-03-03-MonoCloudProxy 代理问题</title>
      <link href="/posts/d3eb6915/"/>
      <url>/posts/d3eb6915/</url>
      
        <content type="html"><![CDATA[<h2 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h2><p>在配置Flutter安装环境时，运行<code>flutter doctor</code>时，有这个错误</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">X HTTP host &quot;https://maven.google.com/&quot; is not reachable. Reason: An error occurred while checking the HTTP host:</span><br><span class="line">   信号灯超时时间已到</span><br><span class="line"></span><br><span class="line"> X HTTP host &quot;https://pub.dev/&quot; is not reachable. Reason: An error occurred while checking the HTTP host: 信号灯超时 时间已到</span><br><span class="line"></span><br><span class="line"> X HTTP host &quot;https://cloud.google.com/&quot; is not reachable. Reason: An error occurred while checking the HTTP host:</span><br><span class="line">   信号灯超时时间已到</span><br></pre></td></tr></table></figure><p>原因是无法访问外网的服务器，直接打开MonoCloud，发现还是一样的结果</p><p>在Windows下：</p><p>使用 MonoCloud 客户端，打开代理设置。</p><p>发现打开PowerShell,还是无法访问外网。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netsh winhttp show proxy</span><br></pre></td></tr></table></figure><p>查看代理网络设置，这是可以看到，代理是通过<code>127.0.0.1:8888</code>这个端口发出去</p><h2 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netsh winhttp reset proxy</span><br></pre></td></tr></table></figure><p>然后重新运行<code>flutter doctor </code>，结果正常</p><h2 id="Windows下PowerShell走MonoProxy代理"><a href="#Windows下PowerShell走MonoProxy代理" class="headerlink" title="Windows下PowerShell走MonoProxy代理"></a>Windows下PowerShell走MonoProxy代理</h2><p>在<code>powershell</code>中运行</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$proxyAddress</span> = <span class="string">&quot;http://127.0.0.1:7078&quot;</span></span><br><span class="line"><span class="variable">$wc</span> = <span class="built_in">New-Object</span> System.Net.WebClient</span><br><span class="line"><span class="variable">$wc</span>.Proxy = <span class="built_in">New-Object</span> System.Net.WebProxy(<span class="variable">$proxyAddress</span>, <span class="variable">$true</span>)</span><br></pre></td></tr></table></figure><p>其中<code>proxyaddress</code>中的IP地址和端口为本机已经代理的地址。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/04/24/jGMDpunBdwyf13a.png" alt="image-20230424162547106"></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
          <category> MonoCloud </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python基础 - 高级特性</title>
      <link href="/posts/f7c8ca0c/"/>
      <url>/posts/f7c8ca0c/</url>
      
        <content type="html"><![CDATA[<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>取前面3个元素</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>]</span><br></pre></td></tr></table></figure><p>如果用循环过程十分繁琐，Python提供了切片(Slice)操作符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment"># [&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>L[0:3]</code>表示，从索引<code>0</code>开始取，直到索引<code>3</code>为止，但不包括索引<code>3</code>。即索引<code>0</code>，<code>1</code>，<code>2</code>，正好是3个元素。</p><p>如果第一个索引是<code>0</code>，还可以省略：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>也可以从索引1开始，取出2个元素出来：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment"># [&#x27;Sarah&#x27;, &#x27;Tracy&#x27;]</span></span><br></pre></td></tr></table></figure><p>类似的，既然Python支持<code>L[-1]</code>取倒数第一个元素，那么它同样支持倒数切片，试试：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[-<span class="number">2</span>:]</span><br><span class="line"><span class="comment"># [&#x27;Bob&#x27;, &#x27;Jack&#x27;]</span></span><br><span class="line">L[-<span class="number">2</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># [&#x27;Bob&#x27;]</span></span><br></pre></td></tr></table></figure><p>记住倒数第一个元素的索引是<code>-1</code>。</p><p>切片操作十分有用。我们先创建一个0-99的数列：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</span><br></pre></td></tr></table></figure><p>可以通过切片轻松取出某一段数列。比如前10个数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:10]</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><p>后10个数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[-10:]</span><br><span class="line">[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</span><br></pre></td></tr></table></figure><p>前11-20个数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[10:20]</span><br><span class="line">[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span><br></pre></td></tr></table></figure><p>前10个数，每两个取一个：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:10:2]</span><br><span class="line">[0, 2, 4, 6, 8]</span><br></pre></td></tr></table></figure><p>所有数，每5个取一个：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[::5]</span><br><span class="line">[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]</span><br></pre></td></tr></table></figure><p>甚至什么都不写，只写<code>[:]</code>就可以原样复制一个list：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:]</span><br><span class="line">[0, 1, 2, 3, ..., 99]</span><br></pre></td></tr></table></figure><p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]</span><br><span class="line">(0, 1, 2)</span><br></pre></td></tr></table></figure><p>字符串<code>&#39;xxx&#39;</code>也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;ABCDEFG&#x27;[:3]</span><br><span class="line">&#x27;ABC&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;ABCDEFG&#x27;[::2]</span><br><span class="line">&#x27;ACEG&#x27;</span><br></pre></td></tr></table></figure><p>在很多编程语言中，针对字符串提供了很多各种截取函数（例如，substring），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>如果给定一个<code>list</code>或<code>tuple</code>，我们可以通过<code>for</code>循环来遍历这个<code>list</code>或<code>tuple</code>，这种遍历我们称为迭代（Iteration）。</p><p>在Python中，迭代是通过<code>for ... in</code>来完成的，而很多语言比如C语言，迭代<code>list</code>是通过下标完成的。</p><p>可以看出，Python的<code>for</code>循环抽象程度要高于C的<code>for</code>循环，因为Python的<code>for</code>循环不仅可以用在<code>list</code>或<code>tuple</code>上，还可以作用在其他可迭代对象上。</p><p><code>list</code>这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如<code>dict</code>就可以迭代：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;,&#x27;</span>, d[key])</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># a , 1</span></span><br><span class="line"><span class="comment"># b , 2</span></span><br><span class="line"><span class="comment"># c , 3</span></span><br></pre></td></tr></table></figure><p>因为<code>dict</code>的存储不是按照<code>list</code>的方式顺序排列，所以，迭代出的结果顺序很可能不一样。</p><p>默认情况下，<code>dict</code>迭代的是key。如果要迭代value，可以用<code>for value in d.values()</code>，如果要同时迭代key和value，可以用<code>for k, v in d.items()</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d.values():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27; , &#x27;</span>, value)</span><br></pre></td></tr></table></figure><p>由于字符串也是可迭代对象，因此，也可以作用于<code>for</code>循环：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;ABC&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><p>所以，当我们使用<code>for</code>循环时，只要作用于一个可迭代对象，<code>for</code>循环就可以正常运行，而我们不太关心该对象究竟是<code>list</code>还是其他数据类型。</p><p>那么，如何判断一个对象是可迭代对象呢？方法是通过<code>collections.abc</code>模块的<code>Iterable</code>类型判断：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable) <span class="comment"># str是否可迭代</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterable) <span class="comment"># list是否可迭代</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">123</span>, Iterable) <span class="comment"># 整数是否可迭代</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>最后一个小问题，如果要对<code>list</code>实现类似Java那样的下标循环怎么办？Python内置的<code>enumerate</code>函数可以把一个<code>list</code>变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, value)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> A</span><br><span class="line"><span class="number">1</span> B</span><br><span class="line"><span class="number">2</span> C</span><br></pre></td></tr></table></figure><p>上面的<code>for</code>循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>)]:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(x, y)</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>请使用迭代查找一个list中最小和最大值，并返回一个tuple：</p><p>要求通过以下测试：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">if</span> findMinAndMax([]) != (<span class="literal">None</span>, <span class="literal">None</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> findMinAndMax([<span class="number">7</span>]) != (<span class="number">7</span>, <span class="number">7</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> findMinAndMax([<span class="number">7</span>, <span class="number">1</span>]) != (<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> findMinAndMax([<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>]) != (<span class="number">1</span>, <span class="number">9</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试成功!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>实现代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findMinAndMax</span>(<span class="params">L</span>):</span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(L) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="built_in">min</span> = L[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">max</span> = L[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> L[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="built_in">min</span>:</span><br><span class="line">            <span class="built_in">min</span> = x</span><br><span class="line">        <span class="keyword">elif</span> x &gt; <span class="built_in">max</span>:</span><br><span class="line">            <span class="built_in">max</span> = x</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>, <span class="built_in">max</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础 - 集合</title>
      <link href="/posts/a8878c51/"/>
      <url>/posts/a8878c51/</url>
      
        <content type="html"><![CDATA[<h1 id="Python基础-集合"><a href="#Python基础-集合" class="headerlink" title="Python基础 - 集合"></a>Python基础 - 集合</h1><h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>类似于Java的Map</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d[<span class="string">&#x27;Michael&#x27;</span>]</span><br></pre></td></tr></table></figure><p>如果key，不存在，就会报错</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:\Users\Administrator\PycharmProjects\pythonProject\forp.py&quot;</span>, line <span class="number">29</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    d[<span class="string">&#x27;Jason&#x27;</span>]</span><br><span class="line">KeyError: <span class="string">&#x27;Jason&#x27;</span></span><br></pre></td></tr></table></figure><p>解决办法：</p><ol><li>通过 <code>in</code>判断key是否存在<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Tomas&#x27;</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure></li><li>通过<code>get()</code>方法，如果key存在，可以返回<code>None</code>,或者自己指定的值。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;Tomas&#x27;</span>)  <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;Tomas&#x27;</span>, -<span class="number">1</span>)) <span class="comment"># -1</span></span><br></pre></td></tr></table></figure><p>注意：返回<code>None</code>的时候Python的交互环境不显示结果。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>要删除一个key，用<code>pop(key)</code>方法，对应的value也会从dict中删除：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d.pop(<span class="string">&#x27;Bob&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果pop的元素不存在，就会报出异常</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> d.pop(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:\Users\Administrator\PycharmProjects\pythonProject\forp.py&quot;</span>, line <span class="number">26</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    d.pop(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">KeyError: <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><p>可以在pop()方法里添加一个默认值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d.pop(<span class="string">&#x27;a&#x27;</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。</p><p>和list比较，dict有以下几个特点：</p><ol><li>查找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li></ol><p>而list相反：</p><ol><li>查找和插入的时间随着元素的增加而增加；</li><li>占用空间小，浪费内存很少。</li></ol><p>所以，dict是用空间来换取时间的一种方法。</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础 - 列表</title>
      <link href="/posts/db052f21/"/>
      <url>/posts/db052f21/</url>
      
        <content type="html"><![CDATA[<h1 id="Python基础-–-列表"><a href="#Python基础-–-列表" class="headerlink" title="Python基础 – 列表"></a>Python基础 – 列表</h1><h2 id="列表定义"><a href="#列表定义" class="headerlink" title="列表定义"></a>列表定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bicycles = [<span class="string">&#x27;trek&#x27;</span>, <span class="string">&#x27;cannondale&#x27;</span>, <span class="string">&#x27;redline&#x27;</span>, <span class="string">&#x27;specialized&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(bicycles)</span><br></pre></td></tr></table></figure><h2 id="列表访问"><a href="#列表访问" class="headerlink" title="列表访问"></a>列表访问</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(bicycles[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(bicycles[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p><em><strong>在不确定列表的长度时，访问最后一个元素</strong></em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(bicycles[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><em><strong>同理，这种约定也适用于其他负数索引，例如，索引 -2 返回倒数第二个列表元素，索引 -3 返回倒数第三个元素</strong></em></p><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><h3 id="在列表末尾添加元素"><a href="#在列表末尾添加元素" class="headerlink" title="在列表末尾添加元素"></a>在列表末尾添加元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">motorcycles.append(<span class="string">&#x27;ducati&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="在列表中插入元素"><a href="#在列表中插入元素" class="headerlink" title="在列表中插入元素"></a>在列表中插入元素</h3><p>使用方法<code>insert()</code>可以在列表的任何位置添加新元素。为此，你需要制定新元素的索引和值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">motorcycles.insert(<span class="number">0</span>, <span class="string">&#x27;ducati&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果需要将元素添加到末尾，可以使用下标<code>-1</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">motorcycles.insert(-<span class="number">1</span>, <span class="string">&#x27;ducati&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"><span class="comment"># [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;ducati&#x27;, &#x27;suzuki&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><h3 id="使用del语句删除元素"><a href="#使用del语句删除元素" class="headerlink" title="使用del语句删除元素"></a>使用del语句删除元素</h3><p>如果知道要删除的元素在列表中的位置，可以使用<code>del</code>语句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> motorcycles[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="使用方法pop-删除元素"><a href="#使用方法pop-删除元素" class="headerlink" title="使用方法pop()删除元素"></a>使用方法pop()删除元素</h3><p>有时候，你要将元素从列表中删除，并接着使用它的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">popped_motorcycle = motorcycles.pop()</span><br><span class="line"><span class="built_in">print</span>(popped_motorcycle)</span><br></pre></td></tr></table></figure><p><strong><code>默认情况下,pop()</code>会取出列表中的最后一个</strong></p><p>如果想要取出指定位置的元素</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">popped_motorcycle = motorcycles.pop(2)</span><br></pre></td></tr></table></figure><p><em><strong>别忘了，每当你使用pop()时，被弹出的元素就不再在列表中了。</strong></em></p><p><code>如果你不确定该使用del语句还是pop()方法，下面是一个简单的判断标准：如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还能继续使用它，就使用方法pop()。</code></p><h3 id="根据值删除元素"><a href="#根据值删除元素" class="headerlink" title="根据值删除元素"></a>根据值删除元素</h3><p>有时候，你不知道要从列表中删除的值所处的位置。如果只知道要删除的元素的值，可使用方法remove()。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">remove_motorcycle = motorcycles.remove(<span class="string">&#x27;yamaha&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"><span class="comment"># [&#x27;honda&#x27;, &#x27;suzuki&#x27;]</span></span><br></pre></td></tr></table></figure><p>同样，使用<code>remove()</code>从列表中删除元素时，也可以接着使用它的值。</p><p><em><strong>注意</strong></em> <code> 方法remove()只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来确保将每个值都删除</code></p><h2 id="组织列表"><a href="#组织列表" class="headerlink" title="组织列表"></a>组织列表</h2><h3 id="使用方法sort-对列表永久排序"><a href="#使用方法sort-对列表永久排序" class="headerlink" title="使用方法sort()对列表永久排序"></a>使用方法sort()对列表永久排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cars: <span class="built_in">list</span>[<span class="built_in">str</span>] = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line">cars.sort()</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"><span class="comment"># [&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]</span></span><br></pre></td></tr></table></figure><p>还可以按照字母顺序降序排列列表元素，只需要向sort()方法传递参数<code>reverse = True</code>即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cars.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"><span class="comment"># [&#x27;toyota&#x27;, &#x27;subaru&#x27;, &#x27;bmw&#x27;, &#x27;audi&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="使用函数sorted-对列表临时排序"><a href="#使用函数sorted-对列表临时排序" class="headerlink" title="使用函数sorted()对列表临时排序"></a>使用函数sorted()对列表临时排序</h3><p>要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用函数sorted()。函数sorted()让你能够按特定顺序显示列表元素，同时不影响它们在列表中的原始排列顺序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cars: <span class="built_in">list</span>[<span class="built_in">str</span>] = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(cars))</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"><span class="comment"># [&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]</span></span><br></pre></td></tr></table></figure><p>可以看到，原来列表的顺序并没有发生变化。如果要按与字母顺序相反的顺序显示列表，也可以向函数sorted()传递参数<code>reverse = True</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(cars, reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong> <code>注意　在并非所有的值都是小写时，按字母顺序排列列表要复杂些。决定排列顺序时，有多种解读大写字母的方式，要指定准确的排列顺序，可能比我们这里所做的要复杂。</code></p><h3 id="倒着打印列表"><a href="#倒着打印列表" class="headerlink" title="倒着打印列表"></a>倒着打印列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cars.reverse()</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"><span class="comment"># [&#x27;subaru&#x27;, &#x27;toyota&#x27;, &#x27;audi&#x27;, &#x27;bmw&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>方法reverse()永久性地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，只需对列表再次调用reverse()即可。</code></p><h3 id="确定列表的长度"><a href="#确定列表的长度" class="headerlink" title="确定列表的长度"></a>确定列表的长度</h3><p>使用函数len()可快速获悉列表的长度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(cars))</span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><h2 id="使用列表时避免索引错误"><a href="#使用列表时避免索引错误" class="headerlink" title="使用列表时避免索引错误"></a>使用列表时避免索引错误</h2><p><strong>注意</strong> <code>发生索引错误却找不到解决办法时，请尝试将列表或其长度打印出来。列表可能与你以为的截然不同，在程序对其进行了动态处理时尤其如此。通过查看列表或其包含的元素数，可帮助你找出这种逻辑错误。</code></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个简易的开机自动跳过广告App</title>
      <link href="/posts/42a62dc0/"/>
      <url>/posts/42a62dc0/</url>
      
        <content type="html"><![CDATA[<p><strong>借助Android的无障碍服务，实现打开App自动跳过广告</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdSkipAccessibilityService</span>: <span class="type">AccessibilityService</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAccessibilityEvent</span><span class="params">(event: <span class="type">AccessibilityEvent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> source = event?.source ?: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until source.childCount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source.getChild(i)?.text?.contains(<span class="string">&quot;跳过&quot;</span>) == <span class="literal">true</span>) &#123;</span><br><span class="line">                source.getChild(i).performAction(ACTION_CLICK)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        source.recycle()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInterrupt</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AndroidManifest.xml注册服务</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:name</span>=<span class="string">&quot;.AdSkipAccessibilityService&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:label</span>=<span class="string">&quot;开屏跳&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:permission</span>=<span class="string">&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.accessibilityservice.AccessibilityService&quot;</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:name</span>=<span class="string">&quot;android.accessibilityservice&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:resource</span>=<span class="string">&quot;@xml/serviceconfig&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>res/xml</code>下新建一个<code>serviceconfig.xml</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">accessibility-service</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:accessibilityEventTypes</span>=<span class="string">&quot;typeAllMask&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:accessibilityFeedbackType</span>=<span class="string">&quot;feedbackGeneric&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:accessibilityFlags</span>=<span class="string">&quot;flagDefault&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:canPerformGestures</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:canRetrieveWindowContent</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:description</span>=<span class="string">&quot;@string/accessibility_service_description&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:notificationTimeout</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:settingsActivity</span>=<span class="string">&quot;com.carl.adskip.MainActivity&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>跳转到无障碍服务设置页面</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">startActivity(Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS))</span><br></pre></td></tr></table></figure><p>打开设置后，这个App需要保活，不然服务会关闭。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读取excel的数据，向服务器插入</title>
      <link href="/posts/b7fa59ce/"/>
      <url>/posts/b7fa59ce/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-读取excel的数据，向服务器插入"><a href="#Python-读取excel的数据，向服务器插入" class="headerlink" title="Python - 读取excel的数据，向服务器插入"></a>Python - 读取excel的数据，向服务器插入</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_excel</span>():</span><br><span class="line">    workbook = xlrd.open_workbook(<span class="string">r&quot;D:\Downloads\用户数据模板.xlsx&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;包含的表单数量<span class="subst">&#123;workbook.nsheets&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;表单的名称为<span class="subst">&#123;workbook.sheet_names()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 表单索引从0开始，获取第一个表单对象</span></span><br><span class="line">    ds = workbook.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(workbook.sheets())</span><br><span class="line">    <span class="built_in">print</span>(ds.name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;行数：<span class="subst">&#123;ds.nrows&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;列数：<span class="subst">&#123;ds.ncols&#125;</span>&quot;</span>)</span><br><span class="line">    row: <span class="built_in">int</span> = <span class="number">1</span></span><br><span class="line">    first_row = ds.row_values(rowx=<span class="number">0</span>, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;表头:<span class="subst">&#123;first_row&#125;</span>&quot;</span>)</span><br><span class="line">    name_index = first_row.index(<span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">    phone_index = first_row.index(<span class="string">&quot;手机&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;姓名的下标： <span class="subst">&#123;name_index&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;手机号的下标： <span class="subst">&#123;phone_index&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> row &lt; ds.nrows:</span><br><span class="line">        row_value = ds.row_values(rowx=row, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># print(row_value)</span></span><br><span class="line">        name = row_value[name_index]</span><br><span class="line">        phone = <span class="built_in">int</span>(row_value[phone_index])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;name&#125;</span>,手机号: <span class="subst">&#123;phone&#125;</span>&quot;</span>)</span><br><span class="line">        add_user(name, phone)</span><br><span class="line">        row += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># while row &lt; ds.nrows:</span></span><br><span class="line">    <span class="comment">#     print(ds.row_values(rowx=row, start_colx=0, end_colx=None))</span></span><br><span class="line">    <span class="comment">#     row += 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(ds.col_values(colx=0, start_rowx=1, end_rowx=None))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加用户</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_user</span>(<span class="params">name: <span class="built_in">str</span>, phone: <span class="built_in">str</span></span>):</span><br><span class="line">    url = <span class="string">&#x27;接口地址&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;Chrome/94.0.4606.61 Safari/537.36 &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;authorization&#x27;</span>: <span class="string">&#x27;Basic c2FiZXI6c2FiZXJfc2VjcmV0&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;blade-auth&#x27;</span>: <span class="string">&#x27;XXXX &#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body = &#123;<span class="string">&quot;account&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;name&#125;</span>&quot;</span>, <span class="string">&quot;tenantName&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;realName&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;name&#125;</span>&quot;</span>, <span class="string">&quot;roleName&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;deptName&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;userTypeName&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;userType&quot;</span>: <span class="number">1</span>, <span class="string">&quot;tenantId&quot;</span>: <span class="string">&quot;000000&quot;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;password2&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;name&#125;</span>&quot;</span>, <span class="string">&quot;phone&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;phone&#125;</span>&quot;</span>, <span class="string">&quot;email&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;sex&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;statusName&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;code&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;roleId&quot;</span>: <span class="string">&quot;1535148319667490817&quot;</span>, <span class="string">&quot;deptId&quot;</span>: <span class="string">&quot;1531184201791483905&quot;</span>,</span><br><span class="line">            <span class="string">&quot;postId&quot;</span>: <span class="string">&quot;1123598817738675208&quot;</span>&#125;</span><br><span class="line">    response = requests.post(url, data=json.dumps(body), headers=headers).json()</span><br><span class="line">    <span class="built_in">print</span>(response)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    read_excel()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-02-24-Post提交数据格式</title>
      <link href="/posts/19c6ca6c/"/>
      <url>/posts/19c6ca6c/</url>
      
        <content type="html"><![CDATA[<h1 id="Post提交数据格式"><a href="#Post提交数据格式" class="headerlink" title="Post提交数据格式"></a>Post提交数据格式</h1><p><strong>最常见post提交数据的方式，以form表单形式提交数据。</strong><code>application/x-www-form-urlencoded</code><br>以json串提交数据。<code>application/json</code><br>上传文件。<code>multipart/form-data</code></p>]]></content>
      
      
      <categories>
          
          <category> Http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Selenium打开Chrome闪退的问题</title>
      <link href="/posts/9b7cc691/"/>
      <url>/posts/9b7cc691/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Selenium打开Chrome闪退的问题"><a href="#使用Selenium打开Chrome闪退的问题" class="headerlink" title="使用Selenium打开Chrome闪退的问题"></a>使用Selenium打开Chrome闪退的问题</h1><h2 id="检查驱动"><a href="#检查驱动" class="headerlink" title="检查驱动"></a>检查驱动</h2><p><a href="http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a> 下载驱动</p><p><code>将chromedriver.exe放在python的安装目录下</code></p><p>发现打开浏览器运行完程序后，浏览器会关闭</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">s = Service(r<span class="string">&quot;C:\python\chromedriver.exe&quot;</span>)</span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">&#x27;detach&#x27;</span>, True)</span><br><span class="line">driver = webdriver.Chrome(service=s, options=option)</span><br><span class="line">driver.<span class="keyword">get</span>(url)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UI自动化 </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Downie4 使用说明</title>
      <link href="/posts/77fc4f2a/"/>
      <url>/posts/77fc4f2a/</url>
      
        <content type="html"><![CDATA[<ol><li>安装Downie4 app</li><li>解压Downie4浏览器扩展压缩包</li><li>在Chrome浏览器的插件扩展中心选择刚才解压的文件夹</li><li>打开对应的视频网站，然后在插件中选择Downie，会使用<code>Downie app</code>打开</li><li>如果不能解析视频，可以选择Downie的自定义提取功能打开对应的网站。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
          <category> SoftWare </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Windows下安装Mac虚拟机</title>
      <link href="/posts/52269aa2/"/>
      <url>/posts/52269aa2/</url>
      
        <content type="html"><![CDATA[<h2 id="开启虚拟化"><a href="#开启虚拟化" class="headerlink" title="开启虚拟化"></a>开启虚拟化</h2><p>**步骤：关机 –&gt; 重启 –&gt; 进入BIOS界面 –&gt; 开启虚拟化 **</p><p>具体是AMD的还是Intel的CPU，请自行查阅文档设置.</p><p>设置完成后，可以在<strong>任务管理器 – 性能 – CPU</strong>里面查看虚拟化是否开启</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="http://rpheez113.hn-bkt.clouddn.com/course/kotlin/kotlin-first-lesson/image/202302141420768.png" style="zoom: 80%;" /><p><em><strong>同时禁用<code>Hyper-V</code>和<code>Credential Guard</code>。</strong></em></p><h2 id="MacOS镜像下载"><a href="#MacOS镜像下载" class="headerlink" title="MacOS镜像下载"></a>MacOS镜像下载</h2><p>镜像可以自行从苹果官网下载</p><p>已经上传12.2的系统至阿里网盘</p><h2 id="安装VMware虚拟机"><a href="#安装VMware虚拟机" class="headerlink" title="安装VMware虚拟机"></a>安装VMware虚拟机</h2><p>已上传至阿里网盘，可自行激活</p><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">VMwareworkstation16.0.0 https://www.aliyundrive.com/s/9uDsraHjsoB 提取码: 40oe 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。</span><br></pre></td></tr></table></figure><h2 id="创建MacOS虚拟机"><a href="#创建MacOS虚拟机" class="headerlink" title="创建MacOS虚拟机"></a>创建MacOS虚拟机</h2><p>打开<code>VMware Workstation</code>，在选项卡<code>文件</code>,<code>新建虚拟机</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="http://rpheez113.hn-bkt.clouddn.com/course/kotlin/kotlin-first-lesson/image/202302141429015.png"></p><p>选择刚才下载的iso镜像文件</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="http://rpheez113.hn-bkt.clouddn.com/course/kotlin/kotlin-first-lesson/image/202302141430945.png"></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="http://rpheez113.hn-bkt.clouddn.com/course/kotlin/kotlin-first-lesson/image/202302141430289.png"></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="http://rpheez113.hn-bkt.clouddn.com/course/kotlin/kotlin-first-lesson/image/202302141431689.png"></p><p>如果没有解锁过VMware，选择操作系统的时候是不会看到<code>Apple Mac OS X(M)</code>这个选项的。</p><p>这里我们用到一个github上的解锁神器<code>auto-unlocker</code></p><p><a href="https://github.com/paolo-projects/auto-unlocker/releases">https://github.com/paolo-projects/auto-unlocker/releases</a></p><p>打开之后，只有一个exe文件，点击执行。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="http://rpheez113.hn-bkt.clouddn.com/course/kotlin/kotlin-first-lesson/image/202302141435614.png"></p><p>如果打开了类似模拟器相关的程序，先关闭，否则可能出现异常。点击<code>Patch</code></p><p>等待下载文件，自动执行。<em>如果没有执行成功，多执行几次</em>。</p><p>执行成功后，重复执行之前的步骤，就可以看到MacOS的选项了。</p><p><em><strong>然后修改虚拟机设置，修改内存为8G或者以上，CPU内核修改为4以上</strong></em></p><p>启动虚拟机，安装系统。</p><h2 id="安装VMware-Tools"><a href="#安装VMware-Tools" class="headerlink" title="安装VMware Tools"></a>安装VMware Tools</h2><p>安装系统完以后，会发现系统非常卡顿，这是因为显卡内存只有3M。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="http://rpheez113.hn-bkt.clouddn.com/course/kotlin/kotlin-first-lesson/image/202302141444566.png"></p><p>如果这里可以安装VMware Tools,那么可以直接安装。</p><p>如果不能安装的话，需要手动选择iso文件。</p><p>打开虚拟机设置，在<code>CD/DVD</code>选项里选择ISO镜像文件</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="http://rpheez113.hn-bkt.clouddn.com/course/kotlin/kotlin-first-lesson/image/202302141446463.png" style="zoom:67%;" /><p>在VMware的安装目录下找到<code>darwin.iso</code>文件</p><p><code>我的VMware安装目录是：  D:\Program Files (x86)\VMware\VMware Workstation</code></p><p>然后，重启系统，在桌面可以看到<code>VMWare Tools</code>的安装程序</p><p>这里会弹出<code>系统扩展已被阻止</code>的弹框，在<code>安全偏好设置</code>里面允许即可。</p><p>安装完成后，重启虚拟机，可以看到显卡的容量已经变为 <code>128MB</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="http://rpheez113.hn-bkt.clouddn.com/course/kotlin/kotlin-first-lesson/image/202302141449408.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin协程</title>
      <link href="/posts/a20c9e06/"/>
      <url>/posts/a20c9e06/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin协程"><a href="#Kotlin协程" class="headerlink" title="Kotlin协程"></a>Kotlin协程</h1><h2 id="协程的作用域构建器"><a href="#协程的作用域构建器" class="headerlink" title="协程的作用域构建器"></a>协程的作用域构建器</h2><h3 id="coroutineScope与runBlocking"><a href="#coroutineScope与runBlocking" class="headerlink" title="coroutineScope与runBlocking"></a>coroutineScope与runBlocking</h3><ul><li>runBlocking是常规函数，而coroutineScope是挂起函数。</li><li>它们都会等待其协程体以及所有子协程结束，主要区别在于runBlocking方法会阻塞当前线程来等待，而coroutineScope只是挂起，会释放底层线程用于其他用途</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Coroutine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Coroutine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT注册使用教程</title>
      <link href="/posts/e07d411f/"/>
      <url>/posts/e07d411f/</url>
      
        <content type="html"><![CDATA[<h2 id="1-注册ChatGPT账号"><a href="#1-注册ChatGPT账号" class="headerlink" title="1. 注册ChatGPT账号"></a>1. 注册ChatGPT账号</h2><ul><li>将IP换成国外IP</li><li>打开 <a href="https://chat.openai.com/auth/login">https://chat.openai.com/auth/login</a>，并使用自己的邮箱注册,我这里使用的是gmail</li><li>打开邮箱，验证</li></ul><h2 id="2-短信接码"><a href="#2-短信接码" class="headerlink" title="2. 短信接码"></a>2. 短信接码</h2><p>注册ChatGPT账号，需要做短信验证,这里我使用的是<a href="https://sms-activate.org/">https://sms-activate.org/</a></p><p>使用支付宝充值0.5美元，在左侧的OpenAI里面搜索选择的国家，我使用的泰国，如果没有收到短信，可以在有效期内取消一次。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/13/QguFMvH4nh5Btpx.png" alt="image-20230313114444385"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin基础 -- 协变和逆变</title>
      <link href="/posts/f874960/"/>
      <url>/posts/f874960/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin基础-–-协变和逆变"><a href="#Kotlin基础-–-协变和逆变" class="headerlink" title="Kotlin基础 – 协变和逆变"></a>Kotlin基础 – 协变和逆变</h1><h3 id="Kotlin-里面："><a href="#Kotlin-里面：" class="headerlink" title="Kotlin 里面："></a>Kotlin 里面：</h3><ul><li>in   是指可以写但是不可以读，是消费者，逆变；</li><li>out  是只可以读不能写，是生产者，协变；</li></ul><p>对应Java</p><ul><li><p>out 协变 对应 ? extends 只能读取不能修改 生产者</p></li><li><p>in  逆变 对应 ? super   只能修改不能读取 消费者</p></li></ul><h2 id="out"><a href="#out" class="headerlink" title="out"></a>out</h2><p>out(协变)，如果泛型类只将泛型类型作为函数的返回(输出)，那么使用out，可以称之为生产类&#x2F;接口，因为它主要是用来生产(produce)制定的泛型对象。</p><p>我的理解:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoMiTV1</span>: <span class="type">TV</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里编译器会报错，Type mismatch: inferred type is TV but XiaoMiTV1 was expected</span></span><br><span class="line">    <span class="keyword">val</span> tv1: Controller&lt;TV&gt; = Controller&lt;XiaoMiTV1&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的方法，将Controller<XiaoMiTv1>转成Controller<TV>是不行的</p><p>我们在<code> Controller&lt;T&gt;</code>方法上加上<code>out</code>关键字</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span>&lt;<span class="type">out T</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>这就是泛型的一致性</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Tea</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreenTea</span>: <span class="type">Tea</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedTea</span>: <span class="type">Tea</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrinkTea</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> d1: DrinkTea&lt;<span class="keyword">out</span> Tea&gt; = DrinkTea&lt;RedTea&gt;()</span><br><span class="line">    <span class="keyword">val</span> d2: DrinkTea&lt;<span class="keyword">in</span> GreenTea&gt; = DrinkTea&lt;Tea&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，如果需要将子类 转为父类对象，就使用out，泛型的一致性，如果需要将父类转为子类，就使用in，父子关系颠倒了</p><table><thead><tr><th>Java</th><th>Kotlin</th><th>边界</th><th>场景</th></tr></thead><tbody><tr><td>&lt;? extend T&gt;</td><td>out(协变)</td><td>上边界</td><td>取值</td></tr><tr><td>&lt;? super T&gt;</td><td>in(逆变)</td><td>下边界</td><td>存值</td></tr><tr><td><T></td><td><T> 不变</td><td></td><td>存值&#x2F;取值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之美--(学习导读)03  面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？</title>
      <link href="/posts/3913e190/"/>
      <url>/posts/3913e190/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之美–-学习导读-03-面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"><a href="#设计模式之美–-学习导读-03-面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？" class="headerlink" title="设计模式之美–(学习导读)03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"></a>设计模式之美–(学习导读)03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？</h1><p>在上一节课中，我们讲到，要具备编写高质量代码的能力，你需要学习一些编程方法论，其中就包含面向对象（我们可以把它看成一种设计思想）、设计原则、设计模式、编程规范、重构技巧等。而我们整个专栏的内容也是围绕着这几块展开讲解的。所以，今天我就先来简单介绍一下这几个概念，并且说一说它们之间的联系。</p><p>今天的内容相当于专栏的一个教学大纲，或者说学习框架。它能让你对整个专栏所涉及的知识点，有一个全局性的了解，能帮你将后面零散的知识更系统地组织在大脑里。</p><p>话不多说，我们就一块来看一下，接下来的这 8 个月我们到底要学习哪些内容吧！</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>现在，主流的编程范式或者是编程风格有三种，它们分别是面向过程、面向对象和函数式编程。面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言。大部分项目也都是基于面向对象编程风格开发的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。</p><p>所以，在专栏的最开始，我们会详细地讲解面向对象编程的相关的知识，为学习后面的内容做铺垫。对于这部分内容，你需要掌握下面这 7 个大的知识点。</p><ul><li>面向对象的四大特性：封装、抽象、继承、多态</li><li>面向对象编程与面向过程编程的区别和联系</li><li>面向对象分析、面向对象设计、面向对象编程</li><li>接口和抽象类的区别以及各自的应用场景</li><li>基于接口而非实现编程的设计思想</li><li>多用组合少用继承的设计思想</li><li>面向过程的贫血模型和面向对象的充血模型</li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>设计原则是指导我们代码设计的一些经验总结。设计原则这块儿的知识有一个非常大的特点，那就是这些原则听起来都比较抽象，定义描述都比较模糊，不同的人会有不同的解读。所以，如果单纯地去记忆定义，对于编程、设计能力的提高，意义并不大。对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。只有这样，我们才能在项目中灵活恰当地应用这些原则。</p><p>对于这一部分内容，你需要透彻理解并且掌握，如何应用下面这样几个常用的设计原则。</p><ul><li>SOLID 原则 -SRP 单一职责原则</li><li>SOLID 原则 -OCP 开闭原则</li><li>SOLID 原则 -LSP 里式替换原则</li><li>SOLID 原则 -ISP 接口隔离原则</li><li>SOLID 原则 -DIP 依赖倒置原则</li><li>DRY 原则、KISS 原则、YAGNI 原则、LOD 法则</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。大部分设计模式要解决的都是代码的可扩展性问题。设计模式相对于设计原则来说，没有那么抽象，而且大部分都不难理解，代码实现也并不复杂。这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。</p><p>经典的设计模式有 23 种。随着编程语言的演进，一些设计模式（比如 Singleton）也随之过时，甚至成了反模式，一些则被内置在编程语言中（比如 Iterator），另外还有一些新的模式诞生（比如 Monostate）。</p><p>在专栏中，我们会重点讲解 23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。对于这 23 种设计模式的学习，我们要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。</p><p>我按照类型和是否常用，对专栏中讲到的这些设计模式，进行了简单的分类，具体如下所示。</p><h3 id="1-创建型"><a href="#1-创建型" class="headerlink" title="1. 创建型"></a>1. 创建型</h3><p>常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。不常用的有：原型模式。</p><h3 id="2-结构型"><a href="#2-结构型" class="headerlink" title="2.结构型"></a>2.结构型</h3><p>常用的有：代理模式、桥接模式、装饰者模式、适配器模式。不常用的有：门面模式、组合模式、享元模式。</p><h3 id="3-行为型"><a href="#3-行为型" class="headerlink" title="3.行为型"></a>3.行为型</h3><p>常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p><h2 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h2><p>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节。即便你可能对设计原则不熟悉、对设计模式不了解，但你最起码要掌握基本的编码规范，比如，如何给变量、类、函数命名，如何写代码注释，函数不宜过长、参数不能过多等等。</p><p>对于编码规范，考虑到很多书籍已经讲得很好了（比如《重构》《代码大全》《代码整洁之道》等）。而且，每条编码规范都非常简单、非常明确，比较偏向于记忆，你只要照着来做可以。它不像设计原则，需要融入很多个人的理解和思考。所以，在这个专栏中，我并没有花太多的篇幅来讲解所有的编码规范，而是总结了我认为的最能改善代码质量的 20 条规范。如果你暂时没有时间去看那些经典的书籍，看我这些就够了。</p><p>除此之外，专栏并没有将编码规范单独作为一个模块来讲解，而是跟重构放到了一起。之所以这样做，那是因为我把重构分为大重构和小重构两种类型，而小重构利用的知识基本上就是编码规范。</p><p>除了编码规范，我们还会介绍一些代码的坏味道，让你知道什么样的代码是不符合规范的，应该如何优化。参照编码规范，你可以写出可读性好的代码；参照代码的坏味道，你可以找出代码存在的可读性问题。</p><h2 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h2><p>在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样那样的问题。针对这些问题，我们就需要进行代码重构。重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步。</p><p>而重构的工具就是我们前面罗列的那些面向对象设计思想、设计原则、设计模式、编码规范。实际上，设计思想、设计原则、设计模式一个最重要的应用场景就是在重构的时候。我们前面讲过，虽然使用设计模式可以提高代码的可扩展性，但过度不恰当地使用，也会增加代码的复杂度，影响代码的可读性。在开发初期，除非特别必须，我们一定不要过度设计，应用复杂的设计模式。而是当代码出现问题的时候，我们再针对问题，应用原则和模式进行重构。这样就能有效避免前期的过度设计。</p><p>对于重构这部分内容，你需要掌握以下几个知识点：</p><ul><li>重构的目的（why）、对象（what）、时机（when）、方法（how）；</li><li>保证重构不出错的技术手段：单元测试和代码的可测试性；</li><li>两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。</li></ul><p>希望你学完这部分内容之后，不仅仅是掌握一些重构技巧、套路，更重要的是建立持续重构意识，把重构当作开发的一部分，融入到日常的开发中。</p><h2 id="五者之间的联系"><a href="#五者之间的联系" class="headerlink" title="五者之间的联系"></a>五者之间的联系</h2><p>关于面向对象、设计原则、设计模式、编程规范和代码重构，这五者的关系我们前面稍微提到了一些，我这里再总结梳理一下。</p><ul><li>面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</li><li>设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。</li><li>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。</li><li>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。</li><li>重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</li></ul><p>实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这一件事的。当我们追本逐源，看清这个本质之后，很多事情怎么做就清楚了，很多选择怎么选也清楚了。比如，在某个场景下，该不该用这个设计模式，那就看能不能提高代码的可扩展性；要不要重构，那就看重代码是否存在可读、可维护问题等。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>今天的内容到此就讲完了。我画了一张图，总结了专栏中所涉及的知识点。在学习后面的课程的时候，你可以经常翻出来看一下，建立全局意识，不至于迷失在零碎的知识点中。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png?wh=5013*3903" alt="img" style="zoom:33%;" /><h2 id="课堂讨论"><a href="#课堂讨论" class="headerlink" title="课堂讨论"></a>课堂讨论</h2><p>今天课堂讨论的话题有两个。</p><ol><li>在今天讲到的内容中，你觉得哪一部分内容对提高代码质量最有效？为什么？除了我罗列的这些内容之外，你还知道哪些可以提高代码质量的方法？</li><li>我们知道，最经典的设计模式书籍是 GoF 的《设计模式》，它的中文全称是《设计模式：可复用面向对象软件的基础》，英文全称是“Design Patterns: Elements of Reusable Object-Oriented Software”。为什么它在标题中会特意提到“面向对象”呢？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 设计模式之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之美--(学习导读)02  从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？</title>
      <link href="/posts/3d89516b/"/>
      <url>/posts/3d89516b/</url>
      
        <content type="html"><![CDATA[<p>在我的工作经历中，每当同事评论起项目代码质量的时候，听到的最多的评语就是：“代码写得很烂”或者“代码写得很好”。用“好”“烂”这样的字眼来描述，非常地笼统。当我具体问到底如何烂、如何好的时候，尽管大部分同事都能简单地罗列上几个点，但往往都不够全面、非常零碎，也切不中要害。</p><p>当然，也有一些工程师对如何评价代码质量有所认识，比如，好代码是易扩展、易读、简单、易维护的等等，但他们对于这些评价的理解往往只停留在表面概念上，对于诸多更深入的问题，比如，“怎么才算可读性好？什么样的代码才算易扩展、易维护？可读、可扩展与可维护之间有什么关系？可维护中‘维护’两字该如何理解？”等等，并没有太清晰的认识。</p><p>对于程序员来说，辨别代码写得“好”还是“烂”，是一个非常重要的能力。这也是我们写出好代码的前提。毕竟，如果我们连什么是好代码、什么是烂代码，都分辨不清，又谈何写出好代码呢？</p><p>所以，今天我们就聊一聊关于代码质量评判的相关问题，希望你在学完今天的内容之后，对代码质量的评判有个更加清晰、更加透彻的认识和理解。</p><h2 id="如何评价代码质量的高低？"><a href="#如何评价代码质量的高低？" class="headerlink" title="如何评价代码质量的高低？"></a>如何评价代码质量的高低？</h2><p>实际上，咱们平时嘴中常说的“好”和“烂”，是对代码质量的一种描述。“好”笼统地表示代码质量高，“烂”笼统地表示代码质量低。对于代码质量的描述，除了“好”“烂”这样比较简单粗暴的描述方式之外，我们也经常会听到很多其他的描述方式。这些描述方法语义更丰富、更专业、更细化。我搜集整理了一下，罗列在了下面。这些几乎涵盖我们所能听到的描述代码质量的所有常用词汇，你可以看一看。</p><p><code>灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）、可读性（readability）、可理解性（understandability）、易修改性（changeability）、可复用（reusability）、可测试性（testability）、模块化（modularity）、高内聚低耦合（high cohesion loose coupling）、高效（high effciency）、高性能（high performance）、安全性（security）、兼容性（compatibility）、易用性（usability）、整洁（clean）、清晰（clarity）、简单（simple）、直接（straightforward）、少即是多（less code is more）、文档详尽（well-documented）、分层清晰（well-layered）、正确性（correctness、bug free）、健壮性（robustness）、鲁棒性（robustness）、可用性（reliability）、可伸缩性（scalability）、稳定性（stability）、优雅（elegant）、好（good）、坏（bad）……</code></p><p>看到如此多的描述词，你可能要问了，我们到底该用哪些词来描述一段代码的质量呢？</p><p>实际上，我们很难通过其中的某个或者某几个词汇来全面地评价代码质量。因为这些词汇都是从不同维度来说的。这就好比，对于一个人的评价，我们需要综合各个方面来给出，比如性格、相貌、能力、财富等等。代码质量高低也是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码写的好坏。比如，即使一段代码的可扩展性很好，但可读性很差，那我们也不能说这段代码质量高。</p><p>除此之外，不同的评价维度也并不是完全独立的，有些是具有包含关系、重叠关系或者可以互相影响的。比如，代码的可读性好、可扩展性好，就意味着代码的可维护性好。而且，各种评价维度也不是非黑即白的。比如，我们不能简单地将代码分为可读与不可读。如果用数字来量化代码的可读性的话，它应该是一个连续的区间值，而非 0、1 这样的离散值。</p><p>不过，我们真的可以客观地量化一段代码质量的高低吗？答案是否定的。对一段代码的质量评价，常常有很强的主观性。比如，怎么样的代码才算可读性好，每个人的评判标准都不大一样。这就好比我们去评价一本小说写得是否精彩，本身就是一个很难量化的、非常主观的事情。</p><p>正是因为代码质量评价的主观性，使得这种主观评价的准确度，跟工程师自身经验有极大的关系。越是有经验的工程师，给出的评价也就越准确。相反，资历比较浅的工程师就常常会觉得，没有一个可执行的客观的评价标准作为参考，很难准确地判断一段代码写得好与坏。有的时候，自己觉得代码写得已经够好了，但实际上并不是。所以，这也导致如果没有人指导的话，自己一个人闷头写代码，即便写再多的代码，代码能力也可能一直没有太大提高。</p><h2 id="最常用的评价标准有哪几个？"><a href="#最常用的评价标准有哪几个？" class="headerlink" title="最常用的评价标准有哪几个？"></a>最常用的评价标准有哪几个？</h2><p>仔细看前面罗列的所有代码质量评价标准，你会发现，有些词语过于笼统、抽象，比较偏向对于整体的描述，比如优雅、好、坏、整洁、清晰等；有些过于细节、偏重方法论，比如模块化、高内聚低耦合、文档详尽、分层清晰等；有些可能并不仅仅局限于编码，跟架构设计等也有关系，比如可伸缩性、可用性、稳定性等。</p><p>为了做到有的放矢、有重点地学习，我挑选了其中几个最常用的、最重要的评价标准，来详细讲解，其中就包括：可维护性、可读性、可扩展性、灵活性、简洁性（简单、复杂）、可复用性、可测试性。接下来，我们逐一讲解一下。</p><h2 id="1-可维护性（maintainability）"><a href="#1-可维护性（maintainability）" class="headerlink" title="1.可维护性（maintainability）"></a>1.可维护性（maintainability）</h2><p>我们首先来看，什么是代码的“可维护性”？所谓的“维护代码”到底包含哪些具体工作？</p><p>落实到编码开发，所谓的“维护”无外乎就是修改 bug、修改老的代码、添加新的代码之类的工作。所谓“代码易维护”就是指，在不破坏原有代码设计、不引入新的 bug 的情况下，能够快速地修改或者添加代码。所谓“代码不易维护”就是指，修改或者添加代码需要冒着极大的引入新 bug 的风险，并且需要花费很长的时间才能完成。</p><p>我们知道，对于一个项目来说，维护代码的时间远远大于编写代码的时间。工程师大部分的时间可能都是花在修修 bug、改改老的功能逻辑、添加一些新的功能逻辑之类的工作上。所以，代码的可维护性就显得格外重要。</p><p>维护、易维护、不易维护这三个概念不难理解。不过，对于实际的软件开发来说，更重要的是搞清楚，如何来判断代码可维护性的好坏。</p><p>实际上，可维护性也是一个很难量化、偏向对代码整体的评价标准，它有点类似之前提到的“好”“坏”“优雅”之类的笼统评价。代码的可维护性是由很多因素协同作用的结果。代码的可读性好、简洁、可扩展性好，就会使得代码易维护；相反，就会使得代码不易维护。更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护。除此之外，代码的易维护性还跟项目代码量的多少、业务的复杂程度、利用到的技术的复杂程度、文档是否全面、团队成员的开发水平等诸多因素有关。</p><p>所以，从正面去分析一个代码是否易维护稍微有点难度。不过，我们可以从侧面上给出一个比较主观但又比较准确的感受。如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。相反，如果修改一个 bug，修改、添加一个功能，需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。</p><p>你可能会说，这样的评价方式也太主观了吧？没错，是否易维护本来就是针对维护的人来说的。不同水平的人对于同一份代码的维护能力并不是相同的。对于同样一个系统，熟悉它的资深工程师会觉得代码的可维护性还不错，而一些新人因为不熟悉代码，修改 bug、修改添加代码要花费很长的时间，就有可能会觉得代码的可维护性不那么好。这实际上也印证了我们之前的观点：代码质量的评价有很强的主观性。</p><h2 id="2-可读性（readability）"><a href="#2-可读性（readability）" class="headerlink" title="2.可读性（readability）"></a>2.可读性（readability）</h2><p>软件设计大师 Martin Fowler 曾经说过：“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”翻译成中文就是：“任何傻瓜都会编写计算机能理解的代码。好的程序员能够编写人能够理解的代码。”Google 内部甚至专门有个认证就叫作 Readability。只有拿到这个认证的工程师，才有资格在 code review 的时候，批准别人提交代码。可见代码的可读性有多重要，毕竟，代码被阅读的次数远远超过被编写和执行的次数。</p><p>我个人认为，代码的可读性应该是评价代码质量最重要的指标之一。我们在编写代码的时候，时刻要考虑到代码是否易读、易理解。除此之外，代码的可读性在非常大程度上会影响代码的可维护性。毕竟，不管是修改 bug，还是修改添加功能代码，我们首先要做的事情就是读懂代码。代码读不大懂，就很有可能因为考虑不周全，而引入新的 bug。</p><p>既然可读性如此重要，那我们又该如何评价一段代码的可读性呢？</p><p>我们需要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。你应该也能感觉到，从正面上，我们很难给出一个覆盖所有评价指标的列表。这也是我们无法量化可读性的原因。</p><p>实际上，code review 是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时，有很多疑问，那就说明你的代码可读性有待提高了。</p><h2 id="3-可扩展性（extensibility）"><a href="#3-可扩展性（extensibility）" class="headerlink" title="3.可扩展性（extensibility）"></a>3.可扩展性（extensibility）</h2><p>可扩展性也是一个评价代码质量非常重要的标准。它表示我们的代码应对未来需求变化的能力。跟可读性一样，代码是否易扩展也很大程度上决定代码是否易维护。那到底什么是代码的可扩展性呢？</p><p>代码的可扩展性表示，我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。说直白点就是，代码预留了一些功能扩展点，你可以把新功能代码，直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。</p><p>关于代码的扩展性，在后面讲到“对修改关闭，对扩展开放”这条设计原则的时候，我会来详细讲解，今天我们只需要知道，代码的可扩展性是评价代码质量非常重要的标准就可以了。</p><h2 id="4-灵活性（flexibility）"><a href="#4-灵活性（flexibility）" class="headerlink" title="4.灵活性（flexibility）"></a>4.灵活性（flexibility）</h2><p>灵活性也是描述代码质量的一个常用词汇。比如我们经常会听到这样的描述：“代码写得很灵活”。那这里的“灵活”该如何理解呢？</p><p>尽管有很多人用这个词汇来描述代码的质量。但实际上，灵活性是一个挺抽象的评价标准，要给灵活性下个定义也是挺难的。不过，我们可以想一下，什么情况下我们才会说代码写得好灵活呢？我这里罗列了几个场景，希望能引发你自己对什么是灵活性的思考。</p><ul><li>当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。</li><li>当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。</li><li>当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。</li></ul><p>从刚刚举的场景来看，如果一段代码易扩展、易复用或者易用，我们都可以称这段代码写得比较灵活。所以，灵活这个词的含义非常宽泛，很多场景下都可以使用。</p><h2 id="5-简洁性（simplicity）"><a href="#5-简洁性（simplicity）" class="headerlink" title="5.简洁性（simplicity）"></a>5.简洁性（simplicity）</h2><p>有一条非常著名的设计原则，你一定听过，那就是 KISS 原则：“Keep It Simple，Stupid”。这个原则说的意思就是，尽量保持代码简单。代码简单、逻辑清晰，也就意味着易读、易维护。我们在编写代码的时候，往往也会把简单、清晰放到首位。</p><p>不过，很多编程经验不足的程序员会觉得，简单的代码没有技术含量，喜欢在项目中引入一些复杂的设计模式，觉得这样才能体现自己的技术水平。实际上，<strong>思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。</strong></p><p>除此之外，虽然我们都能认识到，代码要尽量写得简洁，符合 KISS 原则，但怎么样的代码才算足够简洁？不是每个人都能很准确地判断出来这一点。所以，在后面的章节中，当我们讲到 KISS 原则的时候，我会通过具体的代码实例，详细给你解释，“为什么 KISS 原则看似非常简单、好理解，但实际上用好并不容易”。今天，我们就暂且不展开详细讲解了。</p><h2 id="6-可复用性（reusability）"><a href="#6-可复用性（reusability）" class="headerlink" title="6.可复用性（reusability）"></a>6.可复用性（reusability）</h2><p>代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码。在后面的很多章节中，我们都会经常提到“可复用性”这一代码评价标准。</p><p>比如，当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性；当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关；当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性。可见，可复用性也是一个非常重要的代码评价标准，是很多设计原则、思想、模式等所要达到的最终效果。</p><p>实际上，代码可复用性跟 DRY（Don’t Repeat Yourself）这条设计原则的关系挺紧密的，所以，在后面的章节中，当我们讲到 DRY 设计原则的时候，我还会讲更多代码复用相关的知识，比如，“有哪些编程方法可以提高代码的复用性”等。</p><h2 id="7-可测试性（testability）"><a href="#7-可测试性（testability）" class="headerlink" title="7.可测试性（testability）"></a>7.可测试性（testability）</h2><p>相对于前面六个评价标准，代码的可测试性是一个相对较少被提及，但又非常重要的代码质量评价标准。代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。关于代码的可测试性，我们在重构那一部分，会花两节课的时间来详细讲解。现在，你暂时只需要知道，代码的可测试性非常重要就可以了。</p><p><em><strong>如何才能写出高质量的代码？</strong></em></p><p>我相信每个工程师都想写出高质量的代码，不想一直写没有成长、被人吐槽的烂代码。那如何才能写出高质量的代码呢？针对什么是高质量的代码，我们刚刚讲到了七个最常用、最重要的评价指标。所以，问如何写出高质量的代码，也就等同于在问，如何写出易维护、易读、易扩展、灵活、简洁、可复用、可测试的代码。</p><p>要写出满足这些评价标准的高质量代码，我们需要掌握一些更加细化、更加能落地的编程方法论，包括面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。而所有这些编程方法论的最终目的都是为了编写出高质量的代码。</p><p>比如，面向对象中的继承、多态能让我们写出可复用的代码；编码规范能让我们写出可读性好的代码；设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可读性好、易扩展、易维护的代码；设计模式可以让我们写出易扩展的代码；持续重构可以时刻保持代码的可维护性等等。具体这些编程方法论是如何提高代码的可维护性、可读性、可扩展性等等的呢？我们在后面的课程中慢慢来学习。</p><p><strong>重点回顾</strong></p><p>今天的内容到此就讲完了。我们来一起回顾一下，你需要重点掌握的几个知识点。</p><h3 id="1-如何评价代码质量的高低？"><a href="#1-如何评价代码质量的高低？" class="headerlink" title="1. 如何评价代码质量的高低？"></a>1. 如何评价代码质量的高低？</h3><p>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁等，这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码的好坏。</p><h3 id="2-最常用的评价标准有哪几个？"><a href="#2-最常用的评价标准有哪几个？" class="headerlink" title="2.最常用的评价标准有哪几个？"></a>2.最常用的评价标准有哪几个？</h3><p>最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</p><h3 id="3-如何才能写出高质量的代码？"><a href="#3-如何才能写出高质量的代码？" class="headerlink" title="3.如何才能写出高质量的代码？"></a>3.如何才能写出高质量的代码？</h3><p>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等等，这也是我们后面课程学习的重点。</p><h2 id="课堂讨论"><a href="#课堂讨论" class="headerlink" title="课堂讨论"></a>课堂讨论</h2><p>除了我今天提到的这些，你觉得还有哪些其他的代码评价标准非常重要？聊一聊你心目中的好代码是什么样子的？</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 设计模式之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之美--(学习导读)01  为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？</title>
      <link href="/posts/8bf79f75/"/>
      <url>/posts/8bf79f75/</url>
      
        <content type="html"><![CDATA[<p>我相信，很多程序员都已经意识到基础知识的重要性，觉得要夯实基础，才能走得更远，但同时对于如何将基础知识转化成开发“生产力”仍然有些疑惑。所以，你可能看了很多基础的书籍，比如操作系统、组成原理、编译原理等，但还是觉得很迷茫，觉得在开发中用不上，起码在平时的 CRUD 业务开发中用不上。实际上，这些基础的知识确实很难直接转化成开发“生产力”。但是，它能潜移默化地、间接地提高你对技术的理解。</p><p>不过，我觉得，设计模式和操作系统、组成原理、编译原理等这些基础学科是不一样的。它虽然也算是一门基础知识，但是它和数据结构、算法更像是一道儿的，相比那些更加基础的学科，设计模式能更直接地提高你的开发能力。我在开篇词里也说了，如果说数据结构和算法是教你如何写出高效代码，那设计模式讲的是如何写出可扩展、可读、可维护的高质量代码，所以，它们跟平时的编码会有直接的关系，也会直接影响到你的开发能力。</p><p>不过，你可能还是会觉得设计模式是把屠龙刀，看起来很厉害，但平时的开发根本用不上。基于这种观点，接下来，我们就具体地聊一聊，我们为什么要学习设计模式？</p><h2 id="1-应对面试中的设计模式相关问题"><a href="#1-应对面试中的设计模式相关问题" class="headerlink" title="1.应对面试中的设计模式相关问题"></a>1.应对面试中的设计模式相关问题</h2><p>学习设计模式和算法一样，最功利、最直接的目的，可能就是应对面试了。</p><p>不管你是前端工程师、后端工程师，还是全栈工程师，在求职面试中，设计模式问题是被问得频率比较高的一类问题。特别是一些像 BAT、TMD 这样的大公司，比较重视候选人的基本功，经常会拿算法、设计模式之类的问题来考察候选人。</p><p>所以，我在求职面试的时候，都会提前准备、温习一遍设计模式。尽管并不是每次面试都会被问到，但一旦被问到，如果回答得不好，就是一个败笔，这场面试基本上也就凉凉了。所以，为了保证万无一失，摆脱一旦被问到答不出来的窘境，对于设计模式这种大概率被问到的问题，我都会未雨绸缪，提前准备一下。</p><p>当然，我并不是临时抱佛脚。我平时就比较重视设计模式相关知识的积累，所以底子比较好，只需要在每次面试前花很短的时间，重新温习一下，便可以自信满满地去面试，而不是心里老是担心被问到，影响正常的面试发挥。</p><p>所以，如果你也不想让设计模式相关问题成为你面试中的短板，那跟着我把专栏中的知识点都搞清楚，以后面试再遇到设计模式相关的问题，就不会惧怕了，甚至还会成为你面试中的亮点。</p><h2 id="2-告别写被人吐槽的烂代码"><a href="#2-告别写被人吐槽的烂代码" class="headerlink" title="2. 告别写被人吐槽的烂代码"></a>2. 告别写被人吐槽的烂代码</h2><p>我们经常说，“Talk is cheap，show me the code。”实际上，代码能力是一个程序员最基础的能力，是基本功，是展示一个程序员基础素养的最直接的衡量标准。你写的代码，实际上就是你名片。</p><p>尽管我已经工作近十年，但我一直没有脱离编码一线，现在每天也都在坚持写代码、review 指导同事写代码、重构遗留系统的烂代码。这些年的工作经历中，我见过太多的烂代码，比如命名不规范、类设计不合理、分层不清晰、没有模块化概念、代码结构混乱、高度耦合等等。这样的代码维护起来非常费劲，添加或者修改一个功能，常常会牵一发而动全身，让你无从下手，恨不得将全部的代码删掉重写！</p><p>当然，在这些年的工作经历中，我也看到过很多让我眼前一亮的代码。每当我看到这样的好代码，都会立刻对作者产生无比的好感和认可。且不管这个人处在公司的何种级别，从代码就能看出，他是一个基础扎实的高潜员工，值得培养，前途无量！因此，代码写得好，能让你在团队中脱颖而出。</p><p>所以，我的专栏，不仅仅只是讲解设计模式，更加重要的是，我会通过实战例子，手把手教你如何避免刚刚提到的代码问题，告别被人诟病的烂代码，写出令人称道的好代码，成为团队中的代码标杆！而且，写出一份漂亮的代码，你自己也会很有成就感。</p><h2 id="3-提高复杂代码的设计和开发能力"><a href="#3-提高复杂代码的设计和开发能力" class="headerlink" title="3. 提高复杂代码的设计和开发能力"></a>3. 提高复杂代码的设计和开发能力</h2><p>大部分工程师比较熟悉的都是编程语言、工具、框架这些东西，因为每天的工作就是在框架里根据业务需求，填充代码。实际上，我刚工作的时候，也是做这类事情。相对来说，这样的工作并不需要你具备很强的代码设计能力，只要单纯地能理解业务，翻译成代码就可以了。</p><p>但是，有一天，我的 leader 让我开发一个跟业务无关的比较通用的功能模块，面对这样稍微复杂的代码设计和开发，我就发现我有点力不从心，不知从何下手了。因为我知道只是完成功能、代码能用，可能并不复杂，但是要想写出易扩展、易用、易维护的代码，并不容易。</p><p>如何分层、分模块？应该怎么划分类？每个类应该具有哪些属性、方法？怎么设计类之间的交互？该用继承还是组合？该使用接口还是抽象类？怎样做到解耦、高内聚低耦合？该用单例模式还是静态方法？用工厂模式创建对象还是直接 new 出来？如何避免引入设计模式提高扩展性的同时带来的降低可读性问题？……各种问题，一下子挤到了我面前。</p><p>而我当时并没有对设计模式相关的知识（包括设计模式、设计原则、面向对象设计思想等）有太多的了解和积累，所以一时间搞得我手足无措。好在因此我意识到了这方面知识的重要性，所以在之后很多年的开发中，我都一直刻意锻炼、积累这方面的能力。面对复杂代码、功能、系统的设计和开发，我也越来越得心应手，游刃有余。写出高质量代码已经成为了我的习惯，不经意间写出来的代码，都能作为同事学习、临摹的范例，这也成为了我职场中最引以为豪的亮点之一。</p><h2 id="4-让读源码、学框架事半功倍"><a href="#4-让读源码、学框架事半功倍" class="headerlink" title="4. 让读源码、学框架事半功倍"></a>4. 让读源码、学框架事半功倍</h2><p>对于一个有追求的程序员来说，对技术的积累，既要有广度，也要有深度。很多技术人早早就意识到了这一点，所以在学习框架、中间件的时候，都会抽空去研究研究原理，读一读源码，希望能在深度上有所积累，而不只是略知皮毛，会用而已。</p><p>从我的经验和同事的反馈来看，有些人看源码的时候，经常会遇到看不懂、看不下去的问题。不知道你有没有遇到过这种情况？实际上，这个问题的原因很简单，那就是你积累的基本功还不够，你的能力还不足以看懂这些代码。为什么我会这么说呢？</p><p>优秀的开源项目、框架、中间件，代码量、类的个数都会比较多，类结构、类之间的关系极其复杂，常常调用来调用去。所以，为了保证代码的扩展性、灵活性、可维护性等，代码中会使用到很多设计模式、设计原则或者设计思想。如果你不懂这些设计模式、原则、思想，在看代码的时候，你可能就会琢磨不透作者的设计思路，对于一些很明显的设计思路，你可能要花费很多时间才能参悟。相反，如果你对设计模式、原则、思想非常了解，一眼就能参透作者的设计思路、设计初衷，很快就可以把脑容量释放出来，重点思考其他问题，代码读起来就会变得轻松了。</p><p>实际上，除了看不懂、看不下去的问题，还有一个隐藏的问题，你可能自己都发现不了，那就是你自己觉得看懂了，实际上，里面的精髓你并没有 get 到多少！因为优秀的开源项目、框架、中间件，就像一个集各种高精尖技术在一起的战斗机。如果你想剖析它的原理、学习它的技术，而你没有积累深厚的基本功，就算把这台战斗机摆在你面前，你也不能完全参透它的精髓，只是了解个皮毛，看个热闹而已。</p><p>因此，学好设计模式相关的知识，不仅能让你更轻松地读懂开源项目，还能更深入地参透里面的技术精髓，做到事半功倍。</p><h2 id="5-为你的职场发展做铺垫"><a href="#5-为你的职场发展做铺垫" class="headerlink" title="5. 为你的职场发展做铺垫"></a>5. 为你的职场发展做铺垫</h2><p>普通的、低级别的开发工程师，只需要把框架、开发工具、编程语言用熟练，再做几个项目练练手，基本上就能应付平时的开发工作了。但是，如果你不想一辈子做一个低级的码农，想成长为技术专家、大牛、技术 leader，希望在职场有更高的成就、更好的发展，那就要重视基本功的训练、基础知识的积累。</p><p>你去看大牛写的代码，或者优秀的开源项目，代码写得都非常的优美，质量都很高。如果你只是框架用得很溜，架构聊得头头是道，但写出来的代码很烂，让人一眼就能看出很多不合理的、可以改进的地方，那你永远都成不了别人心目中的“技术大牛”。</p><p>再者，在技术这条职场道路上，当成长到一定阶段之后，你势必要承担一些指导培养初级员工、新人，以及 code review 的工作。这个时候，如果你自己都对“什么是好的代码？如何写出好的代码？”不了解，那又该如何指导别人，如何让人家信服呢？</p><p>还有，如果你是一个技术 leader，负责一个项目整体的开发工作，你就需要为开发进度、开发效率和项目质量负责。你也不希望团队堆砌垃圾代码，让整个项目无法维护，添加、修改一个功能都要费老大劲，最终拉低整个团队的开发效率吧？</p><p>除此之外，代码质量低还会导致线上 bug 频发，排查困难。整个团队都陷在成天修改无意义的低级 bug、在烂代码中添补丁的事情中。而一个设计良好、易维护的系统，可以解放我们的时间，让我们做些更加有意义、更能提高自己和团队能力的事情。</p><p>最后，当你成为 leader、或者团队中的资深工程师、技术专家之后，你势必要负责一部分团队的招聘工作。这个时候，如果你要考察候选人的设计能力、代码能力，那设计模式相关的问题便是一个很好的考察点。</p><p>不过，我也了解到，很多面试官实际上对设计模式也并不是很了解，只能拿一些简单的单例模式、工厂模式来考察候选人，而且所出的题目往往都脱离实践，比如，如何设计一个餐厅系统、停车场系统、售票系统等。这些题目都是网上万年不变的老题目，几乎考察不出候选人的能力。在我的专栏中，有 200 多个真实项目开发中的设计模式相关问题，你跟着看下来，足以让你成为设计模式方面的大牛，再来面试候选人的时候，就不用因为题目老套、脱离实践而尴尬了！</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>今天，我们讲了为什么要学习设计模式相关的知识，总结一下的话，主要有这样五点：应对面试中的设计模式相关问题；告别写被人吐槽的烂代码；提高复杂代码的设计和开发能力；让读源码、学框架事半功倍；为你的职场发展做铺垫。</p><p>投资要趁早，这样我们才能尽早享受复利。同样，有些能力，要早点锻炼；有些东西，要早点知道；有些书，要早点读。这样在你后面的生活、工作、学习中，才能一直都发挥作用。不要等到好多年后，看到了，才恍然大悟，后悔没有早点去学、去看。</p><p>设计模式作为一门与编码、开发有着直接关系的基础知识，是你现在就要开始学习的。早点去学习，以后的项目就都可以拿来锻炼，每写一行代码都是对内功的利用和加深，是可以受益一整个职业生涯的事情。</p><h2 id="课堂讨论"><a href="#课堂讨论" class="headerlink" title="课堂讨论"></a>课堂讨论</h2><p>今天课堂讨论的话题有两个：</p><ol><li>聊一聊你对设计模式相关知识的重要性的看法；</li><li>在你过往的项目开发中，有没有用过某种设计模式？是在什么场景下应用的？解决了什么问题？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 设计模式之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio 导入项目错误 has been compiled by a more recent version of the Java Runtime</title>
      <link href="/posts/8c76577c/"/>
      <url>/posts/8c76577c/</url>
      
        <content type="html"><![CDATA[<p>错误日志：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">has been compiled <span class="keyword">by</span> a more recent version of the Java Runtime (<span class="keyword">class</span> <span class="title class_">file</span> <span class="title">version</span> 55.0), <span class="type">this</span> <span class="title">version</span> <span class="title">of</span> <span class="title">the</span> <span class="title">Java</span> <span class="title">Runtime</span> <span class="title">only</span> <span class="title">recognizes</span> <span class="title">class</span> <span class="title">file</span> <span class="title">versions</span> <span class="title">up</span> <span class="title">to</span> 52.0</span><br></pre></td></tr></table></figure><p>原因：<code>JDK版本不对</code>,对照关系如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">50--&gt;JDK1.6</span><br><span class="line">51--&gt;JDK1.7</span><br><span class="line">52--&gt;JDK1.8</span><br><span class="line">53--&gt;JDK  9</span><br><span class="line">54--&gt;JDK 10</span><br><span class="line">55--&gt;JDK 11</span><br><span class="line">56--&gt;JDK 12</span><br><span class="line">57--&gt;JDK 13</span><br><span class="line">58--&gt;JDK 14</span><br><span class="line">59--&gt;JDK 15</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-01-18-Kotlin协程 - 协程的启动</title>
      <link href="/posts/af4cc2aa/"/>
      <url>/posts/af4cc2aa/</url>
      
        <content type="html"><![CDATA[<h2 id="协程构建器"><a href="#协程构建器" class="headerlink" title="协程构建器"></a>协程构建器</h2><p><code>launch</code>与<code>async</code>构建器都用来启动新协程</p><ul><li>launch，返回一个Job并且不附带任何结果值</li><li>async，返回一个Deferred，Deferred也是一个Job，可以使用.await()在一个延期的值上得到它的最终结果。</li></ul><h2 id="join与await等待协程的作业"><a href="#join与await等待协程的作业" class="headerlink" title="join与await等待协程的作业"></a>join与await等待协程的作业</h2><h4 id="启动协程"><a href="#启动协程" class="headerlink" title="启动协程"></a>启动协程</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">test_coroutine_builder</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">       <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">           delay(<span class="number">1000L</span>)</span><br><span class="line">           println(<span class="string">&quot;job1 finished&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">val</span> async = async &#123;</span><br><span class="line">           delay(<span class="number">1000L</span>)</span><br><span class="line">           println(<span class="string">&quot;job2 finished&quot;</span>)</span><br><span class="line">           <span class="string">&quot;job2 result&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">       println(async.await())</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>async</code> 返回了一个<code>Deferred&lt;out T&gt;</code>(在上面的例子是<code>Deferred&lt;String&gt;</code>)的job对象，可以通过<code>async.await()</code>来获取这个String的值</p><h4 id="协作作业"><a href="#协作作业" class="headerlink" title="协作作业"></a>协作作业</h4><p><strong>启动三个协程，后面的协程需要等待前面的协程完成作业后才会启动</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_coroutine_join</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            println(<span class="string">&quot;Job One&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        job1.join()</span><br><span class="line">        <span class="keyword">val</span> job2 = launch &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            println(<span class="string">&quot;Job Two&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        job2.join()</span><br><span class="line">        <span class="keyword">val</span> job3= launch &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            println(<span class="string">&quot;Job Three&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//顺序输出 三个结果</span></span><br></pre></td></tr></table></figure><p>可以看到，首先输出结果<code>Job One</code>，等待完成后启动<code>job2</code>,<code>job2</code>完成后启动<code>job3</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin基础 - by</title>
      <link href="/posts/ecb20cc7/"/>
      <url>/posts/ecb20cc7/</url>
      
        <content type="html"><![CDATA[<p> 除了在类属性声明的时候时候，使用 <code>by</code> 来获取实例</p><p>也可以在实现接口上使用</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AService</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainService</span>: <span class="type">AService</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">AppClient</span>: <span class="type">AService</span> <span class="title">by</span> <span class="title">MainService</span>() &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，<code>AppClient</code> 实现了 <code>AService</code>接口，并且指定了<code>MainService</code>来实例化</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-01-17-Kotlin协程 -  结构化并发</title>
      <link href="/posts/83a7144c/"/>
      <url>/posts/83a7144c/</url>
      
        <content type="html"><![CDATA[<h2 id="CoroutineScope"><a href="#CoroutineScope" class="headerlink" title="CoroutineScope"></a>CoroutineScope</h2><p>定义协程必须指定其 CoroutineScope，它会跟踪所有协程，同样它还可以<code>取消由它所启动的所有协程</code>。</p><p>常用的相关API有：</p><ul><li>GlobalScope，生命周期是process级别的，及时Activity或Fragment已经被销毁，协程仍然在执行。</li><li>MainScope，在Activity中使用，可以在onDestroy()中取消协程。</li><li>viewModelScope，只能在ViewModel中使用，绑定ViewModel的生命周期。</li><li>lifecycleScope，只能在Activity、Fragment中使用，会绑定Activity和Fragment的生命周期</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Coroutine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin基础-@Jvm注解</title>
      <link href="/posts/3431615f/"/>
      <url>/posts/3431615f/</url>
      
        <content type="html"><![CDATA[<p>Kotlin基础 - @JvmName、@JvmField、@JvmOverloads、@JvmStatic等</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin基础 -- 变换函数、过滤函数、合并函数</title>
      <link href="/posts/39cb9e31/"/>
      <url>/posts/39cb9e31/</url>
      
        <content type="html"><![CDATA[<h2 id="变换函数"><a href="#变换函数" class="headerlink" title="变换函数"></a>变换函数</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li>map变换函数会遍历接收者集合，让变换器函数作用于集合里的各个函数，返回结果是包含已修改的集合，会作为链上下一个函数的输入</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> fruits: List&lt;String&gt; = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Lemon&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> ownFruits: List&lt;String&gt; =</span><br><span class="line">    fruits.map &#123; fruit -&gt; <span class="string">&quot;I have <span class="variable">$fruit</span>&quot;</span> &#125;</span><br><span class="line">        .map &#123; owner -&gt; <span class="string">&quot;<span class="variable">$owner</span>,and I love it&quot;</span> &#125;</span><br><span class="line">println(fruits)</span><br><span class="line">println(ownFruits)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">[Apple, Banana, Orange, Lemon]</span><br><span class="line">[I have Apple,and I love it, I have Banana,and I love it, I have Orange,and I love it, I have Lemon,and I love it]</span><br></pre></td></tr></table></figure><p>可以看到，原始集合并没有修改，map变换函数和你定义的变换器函数做完事情后，返回的是一个新集合，这样，变量就不用变来变去了。</p><ul><li><em><strong>事实上，函数式编程范式支持的设计理念就是不可变数据的副本在链上的函数间传递</strong></em></li></ul><p>map返回的集合中的<code>元素个数</code>和输入集合必须一样，不过，返回的新集合里的元素可以是<code>不同类型</code>的.</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> lengthList = fruits.map &#123;</span><br><span class="line">        it.length</span><br><span class="line">   &#125;</span><br><span class="line"> println(lengthList)</span><br><span class="line"> <span class="comment">//结果</span></span><br><span class="line"> [<span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><ul><li>flatMap函数操作一个集合的集合，将其中<code>多个集合的元素合并</code>后返回一个包含所有元素的单一集合</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> flatMap = listOf(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), listOf(<span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>)).flatMap &#123; it &#125;</span><br><span class="line">    println(flatMap)</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><h2 id="过滤函数"><a href="#过滤函数" class="headerlink" title="过滤函数"></a>过滤函数</h2><p>​过滤是函数式编程的第二大函数，过滤函数接收一个predicate函数，用它按给定条件检查接收者集合里的元素并给出true或false的判定。如果predicate函数返回<code>true</code>，受检元素就会<code>添加</code>到过滤函数返回的新集合里，如果predicate函数返回<code>false</code>，那么受检元素就被<code>移出</code>新集合</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>过滤集合中含有“J”的元素</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = listOf(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Lee&quot;</span>, <span class="string">&quot;Jim&quot;</span>, <span class="string">&quot;Jimy&quot;</span>, <span class="string">&quot;Tomas&quot;</span>).filter &#123;               it.contains(<span class="string">&quot;J&quot;</span>) &#125;</span><br><span class="line">println(result)</span><br><span class="line"> <span class="comment">//结果</span></span><br><span class="line">[Jack, Jim, Jimy]</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> items = listOf(</span><br><span class="line">    listOf(<span class="string">&quot;red apple&quot;</span>, <span class="string">&quot;green apple&quot;</span>, <span class="string">&quot;blue apple&quot;</span>),</span><br><span class="line">    listOf(<span class="string">&quot;red fish&quot;</span>, <span class="string">&quot;blue fish&quot;</span>),</span><br><span class="line">    listOf(<span class="string">&quot;yellow banana&quot;</span>, <span class="string">&quot;teal banana&quot;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> redItems = items.flatMap &#123;</span><br><span class="line">    it.filter &#123; item -&gt;</span><br><span class="line">        item.contains(<span class="string">&quot;red&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">println(redItems)</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[red apple, red fish]</span><br></pre></td></tr></table></figure><p>找素数</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">val</span> numbers = listOf(<span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">22</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">23</span>,<span class="number">18</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">121</span>,<span class="number">131</span>)</span><br><span class="line">    <span class="keyword">val</span> primes = numbers.filter &#123; number -&gt;</span><br><span class="line">        (<span class="number">2</span> until number).map &#123; number % it &#125;.none &#123; it == <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(primes)</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[<span class="number">7</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">23</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">131</span>]</span><br></pre></td></tr></table></figure><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>zip合并函数用来合并两个集合，返回一个包含键值对的新集合。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = listOf(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Jason&quot;</span>, <span class="string">&quot;Tommy&quot;</span>,<span class="string">&quot;Jimmy&quot;</span>)</span><br><span class="line">   <span class="keyword">val</span> shirtSize = listOf(<span class="string">&quot;large&quot;</span>, <span class="string">&quot;x-large&quot;</span>, <span class="string">&quot;medium&quot;</span>)</span><br><span class="line">   <span class="keyword">val</span> employeeMap = (employees zip shirtSize).toMap()</span><br><span class="line">   <span class="keyword">val</span> jack = employeeMap[<span class="string">&quot;Jack&quot;</span>]</span><br><span class="line">   println(jack)</span><br><span class="line">   println(employeeMap)</span><br><span class="line">   <span class="comment">//结果</span></span><br><span class="line">   large</span><br><span class="line">&#123;Jack=large, Jason=x-large, Tommy=medium&#125;</span><br></pre></td></tr></table></figure><p>通过对zip函数的定义</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">zip</span><span class="params">(other: <span class="type">Iterable</span>&lt;<span class="type">R</span>&gt;)</span></span>: List&lt;Pair&lt;T, R&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> zip(other) &#123; t1, t2 -&gt; t1 to t2 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，结果返回的是一个List集合，里面的值是键值对</p><p><em><strong>为了方便使用，我们可以自定义一个<code>zipMap</code>函数，直接将结果返回为Map</strong></em></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">zipMap</span><span class="params">(other: <span class="type">Iterable</span>&lt;<span class="type">R</span>&gt;)</span></span>: Map&lt;T, R&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> zip other).toMap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法也很简单:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> map = employees zipMap shirtSize</span><br><span class="line">println(map)</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">&#123;Jack=large, Jason=x-large, Tommy=medium&#125;</span><br></pre></td></tr></table></figure><h3 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h3><p>另一个可以用来合并至的合并类函数式<code>fold</code>，这个合并函数<code>接收一个初始累加器值，随后会根据匿名的结果更新</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将每个元素值乘以3后累加起来</span></span><br><span class="line"><span class="keyword">val</span> foldValue = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).fold(<span class="number">0</span>) &#123; accumulator, number -&gt;</span><br><span class="line">        println(<span class="string">&quot;Accumulated value: <span class="variable">$accumulator</span>,<span class="variable">$number</span>&quot;</span>)</span><br><span class="line">        accumulator + number * <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Final value: <span class="variable">$foldValue</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Accumulated value: <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">Accumulated value: <span class="number">3</span>,<span class="number">2</span></span><br><span class="line">Accumulated value: <span class="number">9</span>,<span class="number">3</span></span><br><span class="line">Accumulated value: <span class="number">18</span>,<span class="number">4</span></span><br><span class="line">Final value: <span class="number">30</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin基础 - infix关键字</title>
      <link href="/posts/94a31a19/"/>
      <url>/posts/94a31a19/</url>
      
        <content type="html"><![CDATA[<p> <code>infix</code>关键字适用于有单个参数的扩展和类函数，可以让你以更简洁的语法调用函数，如果一个函数定义使用了infix关键字，那么调用它时，接受者和函数之间的点操作以及参数的一对括号都可以不要。</p><p>参考</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt; = Pair(<span class="keyword">this</span>, that)</span><br><span class="line"><span class="comment">//使用 </span></span><br><span class="line">mapOf(<span class="string">&quot;Lee&quot;</span> to <span class="string">&quot;23&quot;</span>)</span><br></pre></td></tr></table></figure><p>自定义一个infix函数</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> String?.<span class="title">printWithDefault</span><span class="params">(default: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="keyword">this</span> ?: default)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用以下两种方法都可以</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="string">&quot;hfer&quot;</span>.printWithDefault(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="string">&quot;we&quot;</span> printWithDefault <span class="string">&quot;me&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>in和out</title>
      <link href="/posts/7d641008/"/>
      <url>/posts/7d641008/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin-in和out"><a href="#Kotlin-in和out" class="headerlink" title="Kotlin - in和out"></a>Kotlin - in和out</h1><p>子类泛型对象可以赋值给父类泛型对象，用out</p><p>父类泛型对象可以赋值给子类泛型对象，用in</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit： 自定义注解</title>
      <link href="/posts/850b3b63/"/>
      <url>/posts/850b3b63/</url>
      
        <content type="html"><![CDATA[<p><strong>场景：在网络请求中，有些接口需要添加token认证，有些接口不需要</strong></p><ol><li>自定义注解类</li></ol><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Token &#123;</span><br><span class="line">    boolean value() default <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在<code>Interceptor</code>拦截器中实现</li></ol><p>Java: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Request</span> <span class="variable">original</span> <span class="operator">=</span> chain.request();</span><br><span class="line">    <span class="comment">// 重新进行build</span></span><br><span class="line">    Request.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> original.newBuilder();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Token</span> <span class="variable">annotation</span> <span class="operator">=</span> Objects.requireNonNull(original.tag(Invocation.class)).method().getAnnotation(Token.class);</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> CacheUtil.getAccessToken();</span><br><span class="line">    <span class="comment">//Token注解为空，或者value 是 true的时候注入Token</span></span><br><span class="line">    <span class="keyword">if</span> (annotation == <span class="literal">null</span> || annotation.value()) &#123;</span><br><span class="line">        <span class="comment">//全局添加请求头token</span></span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(accessToken)) &#123;</span><br><span class="line">            <span class="comment">// 注入一个token</span></span><br><span class="line">            builder.addHeader(ACCESS_TOKEN_NAME, <span class="string">&quot;bearer  &quot;</span> + accessToken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    builder.addHeader(AUTHORIZATION,AUTHORIZATION_VALUE);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">        <span class="keyword">val</span> original = chain.request()</span><br><span class="line">        <span class="comment">//重新 build</span></span><br><span class="line">        <span class="keyword">val</span> builder = original.newBuilder()</span><br><span class="line">        <span class="comment">//获取Response</span></span><br><span class="line">        <span class="keyword">val</span> response = chain.proceed(builder.build())</span><br><span class="line">        <span class="comment">//添加公共头</span></span><br><span class="line">        builder.addHeader(AUTHORIZATION, AUTHORIZATION_VALUE)</span><br><span class="line">        <span class="comment">//拿到注解类Token.kt</span></span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">annotation</span> =</span><br><span class="line">            original.tag(Invocation::<span class="keyword">class</span>.java)?.method()?.getAnnotation(Token::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="comment">//没有注解，或者注解的属性 value 是 true的时候注入token</span></span><br><span class="line">        <span class="keyword">annotation</span>?.value.run &#123;</span><br><span class="line">            accessToken?.let &#123;</span><br><span class="line">                builder.addHeader(ACCESS_TOKEN_NAME,<span class="string">&quot;bearer  <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  3.使用：在 Service接口的方法上，添加注解</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Token(value = false)</span> <span class="comment">//或者 @Token 或者 @Token(value = true)</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="meta">@Field(<span class="string">&quot;username&quot;</span>)</span> username: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="meta">@Field(<span class="string">&quot;password&quot;</span>)</span> password: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: LoginClient</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Retrofit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin Retrifit解析数据包含enum类型</title>
      <link href="/posts/6213ab40/"/>
      <url>/posts/6213ab40/</url>
      
        <content type="html"><![CDATA[<p><strong>在项目中经常会遇到服务端返回的字段是 int类型，用来区分不同的状态，但是前端如果直接写 if( xx &#x3D;&#x3D; 1) else if( xx &#x3D;&#x3D; 2 )这样的判断，代码格式不美观，而且也容易出错,因此可以在定义数据结构的时候可以增加enum类型来判断 状态</strong></p><p>Json数据</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">100101</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>数据结构：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">TaskResponse</span>(</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> url: String,</span><br><span class="line">    <span class="keyword">var</span> photoStatus: PhotoStatus</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">PhotoStatus</span>(<span class="keyword">val</span> key: <span class="built_in">Int</span>,<span class="keyword">val</span> valueText: String) &#123;</span><br><span class="line">    <span class="meta">@SerializedName(<span class="string">&quot;0&quot;</span>)</span> <span class="comment">//注意这里的序列化必须添加</span></span><br><span class="line">    UN_PHOTOGRAPHED(<span class="number">0</span>,<span class="string">&quot;未拍照&quot;</span>),</span><br><span class="line">    <span class="meta">@SerializedName(<span class="string">&quot;1&quot;</span>)</span></span><br><span class="line">    PHOTOGRAPHED(<span class="number">1</span>,<span class="string">&quot;已拍照&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<strong>枚举类<code>PhotoStatus</code>中属性 需要加上 @SerializedName()的注解，不然会出现 <code>status = null</code>的情况</strong></p><p>而且在处理 <code>status</code>字段的时候，可以利用 <code>when</code>表达式来处理，更加方便</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">when</span>(photoStatus) &#123;</span><br><span class="line">            PhotoStatus.UN_PHOTOGRAPHED -&gt; &#123;&#125; <span class="comment">//photoStatus.valueText: String</span></span><br><span class="line">            PhotoStatus.PHOTOGRAPHED -&gt;  &#123;&#125;  <span class="comment">//photoStatus.key: Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetpack --(五)DataBinding</title>
      <link href="/posts/3d7c3e8a/"/>
      <url>/posts/3d7c3e8a/</url>
      
        <content type="html"><![CDATA[<h1 id="Jetpack-–-四-DataBinding"><a href="#Jetpack-–-四-DataBinding" class="headerlink" title="Jetpack –(四)DataBinding"></a>Jetpack –(四)DataBinding</h1><h2 id="DataBinding的意义"><a href="#DataBinding的意义" class="headerlink" title="DataBinding的意义"></a>DataBinding的意义</h2><p>让布局文件承担了部分原本属于页面的工作，使页面布局耦合度进一步降低</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BaseQuickAdapter]getBindingAdapterPosition异常</title>
      <link href="/posts/e163e416/"/>
      <url>/posts/e163e416/</url>
      
        <content type="html"><![CDATA[<p>最近在使用<code>BaseRecyclerViewAdapterHelper</code>的时候，在设置adapter的<code>setOnItemClickListener</code>方法时，点击item报错</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java.lang.NoSuchMethodError: No virtual method getBindingAdapterPosition()I in class Lcom/chad/library/adapter/base/viewholder/BaseViewHolder; or its super classes (declaration of &#x27;com.chad.library.adapter.base.viewholder.BaseViewHolder&#x27; appears in /data/app/</span><br></pre></td></tr></table></figure><p>问题原因是：</p><p><code>getAdapterPosition</code>这个方法已经被废弃了，详见<a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder#getAdapterPosition()">https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder#getAdapterPosition()</a></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">This method is deprecated.</span><br><span class="line">This method is confusing when adapters nest other adapters. If you are calling this <span class="keyword">in</span> the context of an Adapter, you probably want to call getBindingAdapterPosition or <span class="keyword">if</span> you want the position as RecyclerView sees it, you should call getAbsoluteAdapterPosition.</span><br></pre></td></tr></table></figure><p>解决办法：</p><p>  1.使用 不高于<code>com.github.CymChad:BaseRecyclerViewAdapterHelper:3.0.6</code>版本的库</p><ol start="2"><li>使用高于3.0.6版本的库，同时添加高于 <code>1.1.0</code>版本的recyclerview</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation &#x27;androidx.recyclerview:recyclerview:1.2.1&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鸿蒙 Mate30安装Google服务</title>
      <link href="/posts/dd1f623d/"/>
      <url>/posts/dd1f623d/</url>
      
        <content type="html"><![CDATA[<p> 视频网址： <a href="https://www.youtube.com/watch?v=qBDbKLnRzu0">https://www.youtube.com/watch?v=qBDbKLnRzu0</a></p><p>应用下载地址: <a href="https://ytf.lanzoui.com/ggkk">https://ytf.lanzoui.com/ggkk</a>  </p><p>​<a href="https://ytf.lanzoui.com/adb">https://ytf.lanzoui.com/adb</a></p><p>安装APK同时已上传百度网盘 </p>]]></content>
      
      
      
        <tags>
            
            <tag> harmmony </tag>
            
            <tag> google services </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin基础-继承与重载</title>
      <link href="/posts/b190e79b/"/>
      <url>/posts/b190e79b/</url>
      
        <content type="html"><![CDATA[<h1 id="继承与重载"><a href="#继承与重载" class="headerlink" title="继承与重载"></a>继承与重载</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>类默认都是封闭的，要让某个类开放继承，必须使用open关键字修饰它</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin-定义类与field关键字</title>
      <link href="/posts/5cf7dc28/"/>
      <url>/posts/5cf7dc28/</url>
      
        <content type="html"><![CDATA[<h1 id="定义类与field关键字"><a href="#定义类与field关键字" class="headerlink" title="定义类与field关键字"></a>定义类与field关键字</h1><p>​<strong>针对你定义的每一个属性，Kotlin都会产生一个field、一个getter、以及一个setter，field用来存储属性数据，你不能直接定义field，Kotlin会封装field，保护它里面的数据，只暴露给getter和setter使用。属性的getter方法决定你如何读取属性值，每个属性都有getter方法，setter方法决定你如何属性赋值，所以只有可变属性才会有setter方法，尽管Kotlin会自动提供默认的getter和setter方法，但<code>需要控制如何读取属性时</code>，你可以自定义它们</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;Jack&quot;</span></span><br><span class="line">        <span class="keyword">get</span>() = field.replaceFirstChar &#123; <span class="keyword">if</span> (it.isLowerCase()) it.titlecase(Locale.getDefault()) <span class="keyword">else</span> it.toString() &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value.trim()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> player = Player()</span><br><span class="line">    player.name = <span class="string">&quot;rose   &quot;</span></span><br><span class="line">    println(player.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p><strong>计算属性是通过一个覆盖的get或set运算符来定义，这时field就不需要了</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> rolledValue</span><br><span class="line">        <span class="keyword">get</span>() = (<span class="number">1.</span><span class="number">.6</span>).shuffled().first()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译成Java代码就是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getRolledValue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">byte</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> ((Number)CollectionsKt.first(CollectionsKt.shuffled((Iterable)(<span class="keyword">new</span> <span class="title class_">IntRange</span>(var1, <span class="number">6</span>))))).intValue();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以理解为计算属性，就是Java当中的普通方法.</p><h2 id="防范竞态条件"><a href="#防范竞态条件" class="headerlink" title="防范竞态条件"></a>防范竞态条件</h2><p><strong>如果一个类属性既可空又可变，那么引用它之前你必须保证它非空，一个办法是用also标准函数</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> words: String? = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">saySomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        words?.also &#123; println(<span class="string">&quot;Hello, <span class="subst">$&#123; it.uppercase(Locale.getDefault())&#125;</span>&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h2><pre><code> **我们在Player类的定义头中定义一个主构造函数，使用临时变量为Player的各个属性提供初始化，在Kotlin中，为方便识别，临时变量(包括仅引用一次的参数)，通常都会以`下划线开头的名字命名`**。</code></pre><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ex3</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Locale</span><br><span class="line"><span class="keyword">import</span> kotlin.math.absoluteValue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>(</span><br><span class="line">    _name: String,</span><br><span class="line">    _age: <span class="built_in">Int</span>,</span><br><span class="line">    _isNormal: <span class="built_in">Boolean</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = _name</span><br><span class="line">        <span class="keyword">get</span>() = field.replaceFirstChar &#123; <span class="keyword">if</span> (it.isLowerCase()) it.titlecase(Locale.getDefault()) <span class="keyword">else</span> it.toString() &#125;</span><br><span class="line">        <span class="comment">/**private**/</span> <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value.trim()</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">var</span> age = _age</span><br><span class="line">        <span class="keyword">get</span>() = field.absoluteValue</span><br><span class="line">        <span class="keyword">set</span>(value) &#123; value.absoluteValue &#125;</span><br><span class="line">    <span class="keyword">var</span> isNormal = _isNormal</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> player = Player(<span class="string">&quot;lee&quot;</span>,-<span class="number">20</span>,<span class="literal">true</span>)</span><br><span class="line">    println(player.name)</span><br><span class="line">    println(player.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在主构造函数里定义属性"><a href="#在主构造函数里定义属性" class="headerlink" title="在主构造函数里定义属性"></a>在主构造函数里定义属性</h2><p>​<strong>Kotlin允许你不使用临时变量赋值，而是直接用一个定义同时制定参数和类属性，通常我们更喜欢这种方式定义类属性，因为他会减少重复代码.</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player2</span>(</span><br><span class="line">    _name: String,</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">var</span> isNormal: <span class="built_in">Boolean</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = _name</span><br><span class="line">        <span class="keyword">get</span>() = field.replaceFirstChar &#123; <span class="keyword">if</span> (it.isLowerCase()) it.titlecase(Locale.getDefault()) <span class="keyword">else</span> it.toString() &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value.trim()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> player = Player2(<span class="string">&quot;lee&quot;</span>,<span class="number">20</span>,<span class="literal">true</span>)</span><br><span class="line">    println(player.name)</span><br><span class="line">    println(player.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h2><p>​<strong>有主就有次，对应主构造函数的是次构造函数，我们可以定义<code>多个次构造函数来配置不同的参数组合</code></strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player2</span>(</span><br><span class="line">    _name: String,</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">var</span> isNormal: <span class="built_in">Boolean</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = _name</span><br><span class="line">        <span class="keyword">get</span>() = field.replaceFirstChar &#123; <span class="keyword">if</span> (it.isLowerCase()) it.titlecase(Locale.getDefault()) <span class="keyword">else</span> it.toString() &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value.trim()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(_name: String): <span class="keyword">this</span>(_name,age = <span class="number">10</span>,isNormal = <span class="literal">false</span>)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> player = Player2(<span class="string">&quot;lee&quot;</span>,<span class="number">20</span>,<span class="literal">true</span>)</span><br><span class="line">    println(player.name)</span><br><span class="line">    println(player.age)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> p2 = Player2(<span class="string">&quot;chen&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;name is <span class="subst">$&#123;p2.name&#125;</span>, age is <span class="subst">$&#123;p2.age&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>使用次构造函数，定义初始化代码逻辑。</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(_name: String): <span class="keyword">this</span>(_name,age = <span class="number">10</span>,isNormal = <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name.uppercase(Locale.getDefault())</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p> <strong>定义构造函数时，可以给构造函数参数指定默认值，如果用户调用时不提供值参，就使用这个默认值。</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player3</span>(</span><br><span class="line">    _name: String,</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">18</span>,</span><br><span class="line">    <span class="keyword">var</span> isNormal: <span class="built_in">Boolean</span></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> player3 = Player3(<span class="string">&quot;Jack&quot;</span>, isNormal = <span class="literal">false</span>)</span><br><span class="line">    println(player3.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h2><p>​<strong>初始化块可以设置变量或值，以及执行有效性检查，如检查传给某构造函数的值是否有效，<code>初始化块代码会在构造类实例时执行。</code></strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player3</span>(</span><br><span class="line">    _name: String,</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">18</span>,</span><br><span class="line">    <span class="keyword">var</span> isNormal: <span class="built_in">Boolean</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        require( age &gt; <span class="number">0</span>)&#123;  <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;不合法的年龄参数&quot;</span>) &#125;</span><br><span class="line">        require(_name.isNotBlank())&#123;<span class="string">&quot;姓名不能为空&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> player = Player3(<span class="string">&quot;&quot;</span>, isNormal = <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">val</span> player3 = Player3(<span class="string">&quot;Lee&quot;</span>,-<span class="number">20</span>,<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><ul><li>主构造函数里声明的属性</li><li>类级别的属性赋值</li><li>init初始块里的属性赋值和函数调用</li><li>次构造函数里的属性赋值和函数调用</li></ul><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://github.com/winstone-su/imageHosting/blob/main/img/20221010-01.png?raw=true" alt="image"></p><h2 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h2><ul><li>使用lateninit关键字相当于做了一个约定: 在用它之前负责初始化</li><li>只要无法确认lateninit变量是否完成初始化，可以执行isInitialized检查</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player4</span> &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> equipment: String</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">ready</span><span class="params">()</span></span>&#123;</span><br><span class="line">        equipment = <span class="string">&quot;sharp knife&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">battle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (::equipment.isInitialized) println(equipment) <span class="comment">//判断是否初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h2><p>​<strong>延迟初始化并不是推后初始化的位移方式，你也可以暂时不初始化某个变量，直到首次使用它，这个叫做惰性初始化</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player5</span>(_name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = _name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> config <span class="keyword">by</span> lazy &#123; loadConfig() &#125; <span class="comment">// 3秒后打印 loading config   ConfigXX</span></span><br><span class="line"><span class="comment">//    val config = loadConfig()  //会先打印 loading config，3秒后打印ConfigXX</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadConfig</span><span class="params">()</span></span>: String&#123;</span><br><span class="line">        println(<span class="string">&quot;loading config&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ConfigXX&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> player5 = Player5(<span class="string">&quot;Lee&quot;</span>)</span><br><span class="line">    Thread.sleep(<span class="number">3000L</span>)</span><br><span class="line">    println(player5.config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化陷阱一"><a href="#初始化陷阱一" class="headerlink" title="初始化陷阱一"></a>初始化陷阱一</h2><p><strong>在使用初始化块时，顺序非常重要，你必须保证块中的所有属性已完成初始化</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player6</span> &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> bloodBouns = blood.times(<span class="number">4</span>) <span class="comment">//Error: Variable &#x27;blood&#x27; must be initialized</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> blood = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译成对应的Java代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Player6</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> blood;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getBlood</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.blood;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Player6</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="built_in">this</span>.blood * <span class="number">4</span>;</span><br><span class="line">      <span class="built_in">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>blood</code> 是先计算，再赋值的。编译顺序是从上到下的</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin-集合</title>
      <link href="/posts/73b9a5b9/"/>
      <url>/posts/73b9a5b9/</url>
      
        <content type="html"><![CDATA[<p>​集合可以方便你处理一组数据，也可以作为值参传给函数，和我们学过的其他变量类型一样，List、Set和Map类型的变量，也分为两种，<code>只读和可变</code>。</p><h2 id="List创建与元素获取"><a href="#List创建与元素获取" class="headerlink" title="List创建与元素获取"></a>List创建与元素获取</h2><ul><li><p>getOrElse是一个安全索引取值函数，它需要两个参数，第一个是索引值，，第二个是能提供默认值的lambda表达式，如果索引值不存在的话，可用来代替异常。</p></li><li><p>getOrNull是Kotlin提供的另一个安全索引取值函数，它返回null结果，而不是抛出异常</p></li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Jack&quot;</span>,<span class="string">&quot;Rose&quot;</span>,<span class="string">&quot;Lee&quot;</span>)</span><br><span class="line">    println(list.getOrElse(<span class="number">3</span>) &#123; <span class="string">&quot;Unknown&quot;</span> &#125;)  <span class="comment">// Unknown</span></span><br><span class="line">    println(list.getOrNull(<span class="number">3</span>) )  <span class="comment">// null</span></span><br><span class="line">    println(list.getOrNull(<span class="number">3</span>) ?: <span class="string">&quot;Unknown1&quot;</span>) <span class="comment">//Unknown1</span></span><br></pre></td></tr></table></figure><h2 id="可变列表"><a href="#可变列表" class="headerlink" title="可变列表"></a>可变列表</h2><p>​在Kotlin中，支持内容修改的列表叫可变列表，要创建可变列表，可以使用mutableListOf函数。List还支持toList和toMutableList函数动态实现<code>只读列表和可变列表的相互转换</code>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableList = mutableListOf(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Rose&quot;</span>, <span class="string">&quot;Lee&quot;</span>)</span><br><span class="line">    mutableList.add(<span class="string">&quot;Jimmy&quot;</span>)</span><br><span class="line">    mutableList.remove(<span class="string">&quot;Lee&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> toMutableList = list.toMutableList()</span><br></pre></td></tr></table></figure><h2 id="mutator函数"><a href="#mutator函数" class="headerlink" title="mutator函数"></a>mutator函数</h2><ul><li>能修改可变列表的函数有个统一的名字： mutator函数</li><li>添加元素运算符与元素删除运算符（+&#x3D; 、-&#x3D;）</li><li>基于lambda表达式指定的条件删除元素</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableList = mutableListOf(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Rose&quot;</span>, <span class="string">&quot;Lee&quot;</span>)</span><br><span class="line">mutableList += <span class="string">&quot;Carl&quot;</span></span><br><span class="line">   println(mutableList)</span><br><span class="line">   mutableList -= <span class="string">&quot;Rose&quot;</span></span><br><span class="line">   println(mutableList)</span><br><span class="line">   mutableList.removeIf &#123; it.contains(<span class="string">&quot;J&quot;</span>) &#125;</span><br><span class="line">   println(mutableList)</span><br></pre></td></tr></table></figure><h2 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h2><ul><li>for in 遍历</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Jack&quot;</span>,<span class="string">&quot;Rose&quot;</span>,<span class="string">&quot;Lee&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (s <span class="keyword">in</span> list) &#123;</span><br><span class="line">        println(s)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>forEach遍历</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">list.forEach&#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>forEachIndexed遍历时要获取索引</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">list.forEachIndexed &#123; index, s -&gt;</span><br><span class="line">       println(<span class="string">&quot;<span class="variable">$index</span>,<span class="variable">$s</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="解构语法过滤元素"><a href="#解构语法过滤元素" class="headerlink" title="解构语法过滤元素"></a>解构语法过滤元素</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Jack&quot;</span>,<span class="string">&quot;Rose&quot;</span>,<span class="string">&quot;Lee&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> (origin,_,proxy) = list</span><br></pre></td></tr></table></figure><p>使用<code>_</code> 符号过滤不需要的元素</p><h2 id="Set创建与元素获取"><a href="#Set创建与元素获取" class="headerlink" title="Set创建与元素获取"></a>Set创建与元素获取</h2><ul><li>通过setOf创建set集合，使用elementAt函数读取集合中的元素</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = setOf(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Rose&quot;</span>, <span class="string">&quot;Lee&quot;</span>, <span class="string">&quot;Jack&quot;</span>)</span><br><span class="line">    println(<span class="keyword">set</span>)</span><br><span class="line">    println(<span class="keyword">set</span>.elementAt(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><h2 id="可变集合"><a href="#可变集合" class="headerlink" title="可变集合"></a>可变集合</h2><p>通过mutableSetOf创建可变的set集合</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableSetOf = mutableSetOf(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Rose&quot;</span>, <span class="string">&quot;Lee&quot;</span>, <span class="string">&quot;Jack&quot;</span>)</span><br><span class="line">    mutableSetOf.add(<span class="string">&quot;Jack&quot;</span>)</span><br><span class="line">    mutableSetOf += <span class="string">&quot;Chen&quot;</span></span><br><span class="line">    println(mutableSetOf)</span><br></pre></td></tr></table></figure><h2 id="集合转换"><a href="#集合转换" class="headerlink" title="集合转换"></a>集合转换</h2><ul><li>把List转成Set，去掉重复元素</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Rose&quot;</span>, <span class="string">&quot;Lee&quot;</span>, <span class="string">&quot;Jack&quot;</span>)</span><br><span class="line">        .toSet()</span><br><span class="line">        .toList()</span><br><span class="line">    println(list)</span><br></pre></td></tr></table></figure><ul><li>快捷函数</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Rose&quot;</span>, <span class="string">&quot;Lee&quot;</span>, <span class="string">&quot;Jack&quot;</span>)</span><br><span class="line">        .distinct()  <span class="comment">//快速去重</span></span><br><span class="line">    println(list)</span><br></pre></td></tr></table></figure><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>Kotlin提供各种Array，虽然是引用类型，但是可以编译成Java基本数据类型</p><table><thead><tr><th>数组类型</th><th>创建函数</th></tr></thead><tbody><tr><td>IntArray</td><td>intArrayOf</td></tr><tr><td>DoubleArray</td><td>doubleArrayOf</td></tr><tr><td>LongArray</td><td>longArrayOf</td></tr><tr><td>ShortArray</td><td>shortArrayOf</td></tr><tr><td>ByteArray</td><td>byteArrayOf</td></tr><tr><td>FloatArray</td><td>floatArrayOf</td></tr><tr><td>BooleanArray</td><td>booleanArrayOf</td></tr><tr><td>Array</td><td>arrayOf</td></tr></tbody></table><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><ul><li>to看上去像关键字，但事实上，他是省略了点号和符号的特殊函数，to函数将它左边和右边的值转成一对Pair</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">&quot;Jack&quot;</span> to <span class="number">20</span>, <span class="string">&quot;Jason&quot;</span> to <span class="number">21</span>, <span class="string">&quot;Lee&quot;</span> to <span class="number">30</span>)</span><br><span class="line">    mapOf(Pair(<span class="string">&quot;Carl&quot;</span>,<span class="number">20</span>))</span><br></pre></td></tr></table></figure><h3 id="读取Map的值"><a href="#读取Map的值" class="headerlink" title="读取Map的值"></a>读取Map的值</h3><ul><li>[] 取值运算符，读取键对应的值，如果键不存在就返回null</li><li>getValue，读取键对应的值，如果键不存在就抛出异常</li><li>getOrElse，读取键对应的值，或者使用匿名函数返回默认值</li><li>getOrDefault，读取键对应的值，或者返回默认值</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(map[<span class="string">&quot;Lee&quot;</span>]) <span class="comment">//30</span></span><br><span class="line">println(map.getValue(<span class="string">&quot;Jason&quot;</span>)) <span class="comment">//21</span></span><br><span class="line">println(map.getOrElse(<span class="string">&quot;Rose&quot;</span>) &#123; <span class="string">&quot;Unknown&quot;</span> &#125;) <span class="comment">//Unknown</span></span><br><span class="line">println(map.getOrDefault(<span class="string">&quot;Jira&quot;</span>, <span class="number">0</span>)) <span class="comment">//0</span></span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul><li>forEach遍历Map</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">&quot;Jack&quot;</span> to <span class="number">20</span>, <span class="string">&quot;Jason&quot;</span> to <span class="number">21</span>, <span class="string">&quot;Lee&quot;</span> to <span class="number">30</span>)</span><br><span class="line">map.forEach&#123; <span class="comment">// it:Map.Entry&lt;String,Int&gt;</span></span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;it.key&#125;</span>, <span class="subst">$&#123;it.value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.forEach &#123;(key,value) -&gt;</span><br><span class="line">     println(<span class="string">&quot;<span class="variable">$key</span>, <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变集合-1"><a href="#可变集合-1" class="headerlink" title="可变集合"></a>可变集合</h3><ul><li>通过mutableMapOf创建可变的Map</li><li>getOrPut键值不存在，就添加并返回结果，否则就返回已有键对应的值</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableMap = mutableMapOf(<span class="string">&quot;Jack&quot;</span> to <span class="number">20</span>, <span class="string">&quot;Jason&quot;</span> to <span class="number">21</span>, <span class="string">&quot;Lee&quot;</span> to <span class="number">30</span>)</span><br><span class="line">    mutableMap += <span class="string">&quot;Lisa&quot;</span> to <span class="number">16</span></span><br><span class="line">    mutableMap.put(<span class="string">&quot;Jimmy&quot;</span>,<span class="number">22</span>)</span><br><span class="line">    mutableMap[<span class="string">&quot;Chris&quot;</span>] = <span class="number">28</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">mutableMap.getOrPut(<span class="string">&quot;Rose&quot;</span>)&#123; <span class="number">18</span> &#125;</span><br><span class="line">   println(mutableMap)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-08-string模板</title>
      <link href="/posts/e234ae88/"/>
      <url>/posts/e234ae88/</url>
      
        <content type="html"><![CDATA[<h1 id="string模板"><a href="#string模板" class="headerlink" title="string模板"></a>string模板</h1><ul><li>模板支持在字符串的引号内放入变量值</li><li>还支持字符串里计算表达式的值并插入结果，添加在<code>$&#123;&#125;</code>中的任表达式，都会作为字符串的一部分求值.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin-表达式</title>
      <link href="/posts/45860ec5/"/>
      <url>/posts/45860ec5/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin表达式"><a href="#Kotlin表达式" class="headerlink" title="Kotlin表达式"></a>Kotlin表达式</h1><ul><li>if&#x2F;else if 表达式</li><li>range表达式</li></ul><ol><li>in A .. B,in关键字用来检查某个值是否在指定范围内</li><li>当然，也可以用 <code>!</code>in A .. B 来反向判断</li></ol><ul><li><p>when表达式</p><ol><li>允许编写条件式，在某个条件满足时，对应执行的代码</li><li>只要代码包含 else if 分支，都建议改用<code>when</code> 表达式</li></ol></li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> school = <span class="string">&quot;小学1&quot;</span></span><br><span class="line">    <span class="keyword">val</span> level = <span class="keyword">when</span> (school) &#123;</span><br><span class="line">        <span class="string">&quot;学前班&quot;</span> -&gt; <span class="string">&quot;幼儿&quot;</span></span><br><span class="line">        <span class="string">&quot;小学&quot;</span> -&gt; <span class="string">&quot;少儿&quot;</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;未知&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin嵌套类</title>
      <link href="/posts/d82fa2ad/"/>
      <url>/posts/d82fa2ad/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h1><p>如果一个类只对另一个类有用，那么将其嵌入到该类并使这两个类保持在一起是合乎逻辑的，可以使用前套类</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Equipment</span>(<span class="keyword">var</span> name: String) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> = println(<span class="string">&quot;equipment: <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">battle</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Player2.Equipment(<span class="string">&quot;knife&quot;</span>).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h1><ul><li><p>数据类，是专门用来存储数据的类</p></li><li><p>数据类提供了toString的个性化实现</p></li><li><p><code>==</code>符号默认情况下，比较对象就是比较它们的引用值，数据类提供了<code>equals</code>和<code>hashCode</code>的个性化实现</p></li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Coordinate</span>(<span class="keyword">var</span> x: <span class="built_in">Float</span>, <span class="keyword">var</span> y: <span class="built_in">Float</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> isInBounds = x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(Coordinate(<span class="number">119.2f</span>,<span class="number">20.1f</span>))</span><br><span class="line">  println(Coordinate(<span class="number">119.2f</span>,<span class="number">20.1f</span>) == Coordinate(<span class="number">119.2f</span>,<span class="number">20.1f</span>)) <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么上面的 <code>==</code>符号会是true，如果用<code>data</code>修饰的话，会默认重写equals,而我们知道<code>==</code>比较的是内容，也就是<code>equals</code>,<code>===</code>比较的是引用，重写equals的方法如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="meta">@Nullable</span> Object var1)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> != var1) &#123;</span><br><span class="line">         <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Coordinate) &#123;</span><br><span class="line">            <span class="type">Coordinate</span> <span class="variable">var2</span> <span class="operator">=</span> (Coordinate)var1;</span><br><span class="line">            <span class="keyword">if</span> (Float.compare(<span class="built_in">this</span>.x, var2.x) == <span class="number">0</span> &amp;&amp; Float.compare(<span class="built_in">this</span>.y, var2.y) == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到，比较了类的每一个属性是否相等</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>如果我们在<code>Coordinate</code>类上加上另一个自定的类作为属性</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Coordinate</span>(<span class="keyword">var</span> x: <span class="built_in">Float</span>, <span class="keyword">var</span> y: <span class="built_in">Float</span>,<span class="keyword">val</span> user: User) &#123;</span><br><span class="line">    <span class="keyword">var</span> isInBounds = x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name:String,<span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>现在我们来判断，以下是否相等</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(Coordinate(<span class="number">119.2f</span>,<span class="number">20.1f</span>,User(<span class="string">&quot;Lee&quot;</span>,<span class="number">20</span>)) == Coordinate(<span class="number">119.2f</span>,<span class="number">20.1f</span>,User(<span class="string">&quot;Lee&quot;</span>,<span class="number">20</span>))) </span><br></pre></td></tr></table></figure><p>答案是<code>false</code>，因为会去比较两个user对象，是否相等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intrinsics.areEqual(<span class="built_in">this</span>.user, var2.user)</span><br></pre></td></tr></table></figure><p>如果把<code>User</code>类改为数据类，那么结果就会是<code>true</code>.</p><h1 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h1><p>除了重写Any类的部分函数，提供更好的默认实现外，数据类还提供了一个函数，它可以<code>用来方便地复制一个对象</code>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> s3</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String,<span class="keyword">val</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> hobby = <span class="string">&quot;music&quot;</span></span><br><span class="line">    <span class="keyword">val</span> subject: String</span><br><span class="line">    <span class="keyword">var</span> score: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        subject = <span class="string">&quot;math&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(_name: String): <span class="keyword">this</span>(_name,<span class="number">10</span>) &#123;</span><br><span class="line">        score = <span class="number">90</span> <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student(name=&#x27;<span class="variable">$name</span>&#x27;, age=<span class="variable">$age</span>, hobby=&#x27;<span class="variable">$hobby</span>&#x27;, subject=&#x27;<span class="variable">$subject</span>&#x27;, score=<span class="variable">$score</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> jack = Student(<span class="string">&quot;Jack&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> rose = jack.copy(name = <span class="string">&quot;Rose&quot;</span>)</span><br><span class="line">  <span class="comment">//rose.score = 90 //需要手动赋值</span></span><br><span class="line">    println(jack)<span class="comment">//Student(name=&#x27;Jack&#x27;, age=10, hobby=&#x27;music&#x27;, subject=&#x27;math&#x27;, score=90)</span></span><br><span class="line">    println(rose)<span class="comment">//Student(name=&#x27;Rose&#x27;, age=10, hobby=&#x27;music&#x27;, subject=&#x27;math&#x27;, score=0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，copy的时候会重新new一个对象，次构造函数里面的赋值操作并不会进行，所以需要手动赋值</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin--扩展</title>
      <link href="/posts/606bc819/"/>
      <url>/posts/606bc819/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 的扩展（Extension），主要分为两种语法：第一个是扩展函数，第二个是扩展属性。从语法上看，扩展看起来就像是我们从类的外部为它扩展了新的成员。</p><p>​这在实际编程当中是非常有用的功能。我们可以来想象一个场景：我们想修改 JDK 当中的 String，想在它的基础上增加一个方法“lastElement()”来获取末尾元素，如果使用 Java，我们是无法通过常规手段实现的，因为我们没办法修改 JDK 的源代码。<strong>任何第三方提供的 SDK，我们都无权修改。</strong></p><p>​不过，借助 Kotlin 的扩展函数，我们就完全可以在语义层面，来为第三方 SDK 的类扩展新的成员方法和成员属性。不管是为 JDK 的 String 增加新的成员方法，还是为 Android SDK 的 View 增加新成员属性，我们都可以实现。</p><h2>什么是扩展函数和扩展属性？<h2><p>​扩展函数，就是从类的外部扩展出来的一个函数，这个函数看起来就像是类的成员函数一样。这里，我们就以 JDK 当中的 String 为例，来看看如何通过 Kotlin 的扩展特性，为它新增一个 lastElement() 方法。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ①    ②      ③            ④</span></span><br><span class="line"><span class="comment"> ↓     ↓       ↓            ↓      */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;</span><br><span class="line">    <span class="comment">//    ⑤</span></span><br><span class="line">    <span class="comment">//    ↓</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = <span class="string">&quot;Hello Wolrd&quot;</span></span><br><span class="line">    <span class="comment">// lastElement就像String的成员方法一样可以直接调用</span></span><br><span class="line">    <span class="keyword">val</span> last = msg.lastElement() <span class="comment">// last = d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​我们先是定义了一个 String 的扩展函数“lastElement()”，然后在 main 函数当中调用了这个函数。并且，这个扩展函数是直接定义在 Kotlin 文件里的，而不是定义在某个类当中的。这种扩展函数，我们称之为“<strong>顶层扩展</strong>”，这么叫它是因为它并没有嵌套在任何的类当中，它自身就在最外层。</p><p>现在，我们依次来看看上面的五处注释。</p><ul><li>注释①，fun关键字，代表我们要定义一个函数。也就是说，不管是定义普通 Kotlin 函数，还是定义扩展函数，我们都需要 fun 关键字。</li><li>注释②，“String.”，代表我们的扩展函数是为 String 这个类定义的。在 Kotlin 当中，它有一个名字，叫做接收者（Receiver），也就是扩展函数的接收方。</li><li>注释③，lastElement()，是我们定义的扩展函数的名称。</li><li>注释④，“Char?”，代表扩展函数的返回值是可能为空的 Char 类型。</li><li>注释⑤，“this.”，代表“具体的 String 对象”，当我们调用 msg.lastElement() 的时候，this 就代表了 msg。</li></ul><p>​需要注意的是，<strong>在整个扩展函数的方法体当中，this 都是可以省略的</strong>。这一点，Kotlin 和 Java 是一样的，this 代表当前作用域，它可写可不写。</p><p>​另外，如果你足够细心的话，你会发现如果去掉注释②处的“String.”，这段代码就会变成一个普通的函数定义：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;&#125;</span><br><span class="line"><span class="comment">// 普通函数与扩展函数之间的差别</span></span><br></pre></td></tr></table></figure><p>​换句话说，就是如果我们在普通函数的名称前面加上一个“接收者类型”，比如“String.”，Kotlin 的“普通函数”就变成了“扩展函数”。</p><p>​可见，Kotlin 扩展语法设计得非常巧妙，只要你记住了普通函数的语法，那么，只需要再记住一点点细微的区别，你就能记住扩展函数的语法。而通过这个细微的语法差异，你也可以体会到，所谓的扩展函数，就是多了个“扩展接收者”的函数。</p><h3 id="扩展函数的实现原理"><a href="#扩展函数的实现原理" class="headerlink" title="扩展函数的实现原理"></a>扩展函数的实现原理</h3><p>以刚才写的 lastElement() 为例，一起来看看它反编译后的 Java 代码是什么样的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ExtKt</span> &#123;</span><br><span class="line">   <span class="comment">// ①</span></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> Character lastElement(String $<span class="keyword">this</span>) &#123;</span><br><span class="line">      CharSequence var1 = (CharSequence)$<span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (var1.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>  var1.charAt(var1.length() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">  String msg = <span class="string">&quot;Hello Wolrd&quot;</span>;</span><br><span class="line">  <span class="comment">//                        ②</span></span><br><span class="line">  <span class="comment">//                        ↓</span></span><br><span class="line">  Character last = ExtKt.lastElement(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​以上代码有两个地方需要注意，我分别用两个注释标记出来了。</p><p>​通过第一个注释，我们可以看到，原本定义在 String 类型上面的扩展函数 lastElement()，变成了一个<strong>普通的静态方法</strong>。另外，之前定义的扩展函数 lastElement() 是没有参数的，但反编译后的 Java 代码中，lastElement(String $this) <strong>多了一个 String 类型的参数。</strong></p><p>​还有第二个注释，这是扩展函数的调用处，原本 msg.lastElement() 的地方，变成了 ExtKt.lastElement(msg)。这说明，<strong>Kotlin 编写的扩展函数调用代码，最终会变成静态方法的调用</strong></p><p>​看到这里，也许你一下就能反应过来：Kotlin 的扩展函数只是从表面上将 lastElement() 变成 String 的成员，但它实际上并没有修改 String 这个类的源代码，lastElement() 也并没有真正变成 String 的成员方法。</p><p>​也就是说，<strong>由于 JVM 不理解 Kotlin 的扩展语法，所以 Kotlin 编译器会将扩展函数转换成对应的静态方法，而扩展函数调用处的代码也会被转换成静态方法的调用。</strong></p><p>而如果我们将上面的 ExtKt 修改成 StringUtils，它就变成了典型的 Java 工具类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringUtils</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Character <span class="title function_">lastElement</span><span class="params">(String $<span class="built_in">this</span>)</span> &#123;</span><br><span class="line">     <span class="comment">// 省略</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Character</span> <span class="variable">last</span> <span class="operator">=</span> StringUtils.lastElement(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何理解扩展属性？"><a href="#如何理解扩展属性？" class="headerlink" title="如何理解扩展属性？"></a>如何理解扩展属性？</h3><p>​在学习了 Kotlin 的扩展函数以后，扩展属性就很好理解了。扩展函数，是在类的外部为它定义一个<strong>新的成员方法</strong>；而扩展属性，则是在类的外部为它定义一个<strong>新的成员属性</strong>。</p><p>​那么，在研究了扩展的实现原理后，我们知道，我们从外部定义的成员方法和属性，都只是语法层面的，并没有实际修改那个类的源代码。</p><p>​还是以 lastElement 为例，在之前的案例当中，我们是通过扩展函数来实现的，这次我们以扩展属性的方式来实现。扩展函数的定义对比普通函数，其实就只是多了一个“接收者类型”。类似的，扩展属性，也就是在普通属性定义的时候多加一个“接收者类型”即可。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="keyword">val</span> String.lastElement: <span class="built_in">Char</span>?</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = <span class="string">&quot;Hello Wolrd&quot;</span></span><br><span class="line">    <span class="comment">// lastElement就像String的成员属性一样可以直接调用</span></span><br><span class="line">    <span class="keyword">val</span> last = msg.lastElement <span class="comment">// last = d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在这段的代码中，我们为 String 类型扩展了一个新的成员属性“lastElement”。然后在 main 函数当中，我们直接通过“msg.lastElement”方式使用了这个扩展属性，就好像它是一个成员一样。而如果你将以上的代码进行反编译，你会发现它反编译后的 Java 代码几乎和我们前面扩展函数的一模一样。</p><p>​所以也就是说，Kotlin 的扩展表面上看起来是为一个类扩展了新的成员，但是<strong>本质上，它还是静态方法</strong>。而且，不管是扩展函数还是扩展属性，它本质上都会变成一个静态的方法。那么，到底什么时候该用扩展函数，什么时候该用扩展属性呢？</p><p>​其实，我们只需要看扩展在语义上更适合作为函数还是属性就够了。比如这里的 lastElement，它更适合作为一个扩展属性。这样设计的话，在语义上，lastElement 就像是 String 类当中的属性一样，它代表了字符串里的最后一个字符。</p><h3 id="扩展的能力边界"><a href="#扩展的能力边界" class="headerlink" title="扩展的能力边界"></a>扩展的能力边界</h3><p>​在理解了扩展的使用与原理后，我们再来探讨一下扩展的能力边界：扩展能做什么，不能做什么。Kotlin 的扩展看起来很神奇，但它并不是无所不能的，通过探索它的能力边界，我们就能对它有一个更加深入的认识。</p><h3 id="扩展能做什么？"><a href="#扩展能做什么？" class="headerlink" title="扩展能做什么？"></a>扩展能做什么？</h3><p>​我们先从“扩展能做什么”说起。</p><p>​当我们想要从外部为一个类扩展一些方法和属性的时候，我们就可以通过扩展来实现了。在 Kotlin 当中，几乎所有的类都可以被扩展，包括普通类、单例类、密封类、枚举类、伴生对象，甚至还包括第三方提供的 Java 类。唯有匿名内部类，由于它本身不存在名称，我们无法指定“接收者类型”，所以不能被扩展，当然了，它也没必要被扩展。</p><p>​可以说，Kotlin 扩展的应用范围还是非常广的。它最主要的用途，就是用来取代 Java 当中的各种工具类，比如 StringUtils、DateUtils 等等。</p><h3 id="扩展不能做什么？"><a href="#扩展不能做什么？" class="headerlink" title="扩展不能做什么？"></a>扩展不能做什么？</h3><p>​我们再聊聊扩展不能做什么。</p><p>​Kotlin 的扩展，由于它本质上并没有修改接收类型的源代码，所以它的行为是无法与“类成员”完全一致的。那么它对比普通的类成员，就会有以下几个限制。</p><p>​<strong>第一个限制</strong>，Kotlin 扩展不是真正的类成员，因此它无法被它的子类重写。举个例子，我们定义一个这样的 Person 类，并且分别为它扩展了一个 isAdult 属性和 walk() 方法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> Person.isAdult: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;walk&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​由于 Person 类有 open 关键字修饰，所以我们可以继承这个 Person 类。不过，当我们尝试去重写它的成员时，会发现 isAdult 和 walk() 是无法被重写的，因为它们压根就不属于 Person 这个类。这个很好理解，让我们看下一个。</p><p><strong>第二个限制</strong>，扩展属性无法存储状态。就如前面代码当中的 isAdult 属性一般，它的值是由 age 这个成员属性决定的，它本身没有状态，也无法存储状态。这一点背后的根本原因，还是因为它们都是静态方法。</p><p><strong>第三个限制</strong>，扩展的访问作用域仅限于两个地方。第一，定义处的成员；第二，接收者类型的公开成员。我们以前面的代码为例：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ①</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> msg: String = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//       ②</span></span><br><span class="line">        <span class="comment">//       ↓</span></span><br><span class="line">        println(msg)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//            ③</span></span><br><span class="line">    <span class="comment">//            ↓</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码一共有三处注释，我们一个个看：</p><ul><li>在注释①的地方，我们在 Ext 这个 Kotlin 文件里定义了一个私有的变量 msg。</li><li>由于 lastElement() 与 msg 是定义在同一个文件当中的，因此，在注释②处我们可以直接访问 msg，即使它是私有的。</li><li>最后，是注释③，由于 length 是 String 类的公开属性，因此我们可以在扩展函数当中直接访问它。对应的，如果 length 是 String 的 private、protected 成员，那我们将无法在扩展函数当中访问它。归根结底，还是因为扩展函数并非真正的类成员。</li></ul><p>看到这里，也许你会冒出一个有趣的想法：<strong>如果将扩展定义在某个类的内部，它能够访问这个类的私有属性吗？</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin -- Object关键字</title>
      <link href="/posts/c4e3d35a/"/>
      <url>/posts/c4e3d35a/</url>
      
        <content type="html"><![CDATA[<p>语义：</p><ul><li>匿名内部类</li><li>单例模式</li><li>伴生对象</li></ul><p><em><strong>本质： 在定义一个类的同时还创建了对象</strong></em></p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>在Java中，我们一般这么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnClickListener</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">image.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>在Kotlin中</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.textView.setOnClickListener(<span class="keyword">object</span> : View.OnClickListener&#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>.</p><p>不过，在 Kotlin 中，匿名内部类还有一个特殊之处，就是我们在使用 object 定义匿名内部类的时候，其实还可以<strong>在继承一个抽象类的同时，来实现多个接口。</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">funA</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">funB</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">findC</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">object</span> : C(),A,B&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">funA</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">funB</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findC</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> AppManager &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的Java代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AppManager</span> &#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AppManager INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">AppManager</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="type">AppManager</span> <span class="variable">var0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppManager</span>();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们使用 object 关键字定义单例类的时候，Kotlin 编译器会将其<strong>转换成静态代码块的单例模式</strong>。因为static{}代码块当中的代码(在类初始化的时候完成加载)，由虚拟机保证它只会被执行一次，因此，它在保证了线程安全的前提下，同时也保证我们的 INSTANCE 只会被初始化一次。</p><p>缺点:</p><ul><li>不支持懒加载</li><li>不支持传参构造单例</li></ul><h3 id="object-伴生对象"><a href="#object-伴生对象" class="headerlink" title="object: 伴生对象"></a>object: 伴生对象</h3><p>我们都知道，Kotlin 当中没有 static 关键字，所以我们没有办法直接定义静态方法和静态变量。不过，Kotlin 还是为我们提供了伴生对象，来帮助实现静态方法和变量。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">object</span> InnerSingleton &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们可以将单例定义到一个类的内部。这样，单例就跟外部类形成了一种嵌套的关系，而我们要使用它的话，可以直接这样写：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Person.InnerSingleton.foo()</span><br></pre></td></tr></table></figure><p>以上的代码看起来，foo() 就像是静态方法一样。不过，为了一探究竟，我们可以看看 Person 类反编译成 Java 后是怎样的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InnerSingleton</span> &#123;</span><br><span class="line">      <span class="meta">@NotNull</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerSingleton INSTANCE;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">InnerSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="type">InnerSingleton</span> <span class="variable">var0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerSingleton</span>();</span><br><span class="line">         INSTANCE = var0;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，foo() 并不是静态方法，它实际上是通过调用单例 InnerSingleton 的实例上的方法实现的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Kotlin当中这样调用</span></span><br><span class="line">Person.InnerSingleton.foo()</span><br><span class="line"><span class="comment">//      等价</span></span><br><span class="line"><span class="comment">//       ↓  java 当中这样调用</span></span><br><span class="line">Person.InnerSingleton.INSTANCE.foo()</span><br></pre></td></tr></table></figure><p>这时候，你可能就会想：<strong>要如何才能实现类似 Java 静态方法的代码呢？</strong></p><p>其实很简单，我们可以使用“@JvmStatic”这个注解，如以下代码所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">object</span> InnerSingleton &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的Java代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InnerSingleton</span> &#123;</span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerSingleton INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">InnerSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="type">InnerSingleton</span> <span class="variable">var0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerSingleton</span>();</span><br><span class="line">            INSTANCE = var0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，foo() 这个方法就变成了 InnerSingleton 类当中的一个静态方法了。</p><p>这样一来，不管事Kotlin还是Java，调用方式都变成了</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Person.InnerSingleton.foo()</span><br></pre></td></tr></table></figure><p>看到这里，如果你足够细心，你一定会产生一个疑问：上面的静态内部类“InnerSingleton”看起来有点多余，我们平时在 Java 当中写的静态方法，不应该是只有一个层级吗？比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用的时候，只有一个层级</span></span><br><span class="line">Person.foo()</span><br></pre></td></tr></table></figure><p>答案当然是有的，我们只需要在前面例子当中的 object 关键字前面，加一个 <strong>companion 关键字</strong>即可。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="comment">//  改动在这里</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> InnerSingleton &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>companion object，在 Kotlin 当中就被称作伴生对象，它其实是我们嵌套单例的一种特殊情况。也就是，<strong>在伴生对象的内部，如果存在“@JvmStatic”修饰的方法或属性，它会被挪到伴生对象外部的类当中，变成静态成员。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Person.<span class="type">InnerSingleton</span> <span class="variable">InnerSingleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.InnerSingleton((DefaultConstructorMarker)<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注意这里</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">      InnerSingleton.foo();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InnerSingleton</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">InnerSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">InnerSingleton</span><span class="params">(DefaultConstructorMarker $constructor_marker)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  根据上面反编译后的代码，我们可以看出来，被挪到外部的静态方法 foo()，它最终还是调用了单例 InnerSingleton 的成员方法 foo()，所以它只是做了一层转接而已。</p><p>  到这里，也许你已经明白 object 单例、伴生对象中间的演变关系了：普通的 object 单例，演变出了嵌套的单例；嵌套的单例，演变出了伴生对象。</p><p>你也可以换个说法：<strong>嵌套单例，是 object 单例的一种特殊情况；伴生对象，是嵌套单例的一种特殊情况</strong>。</p><p>如果comanion中的方法，不加@JvmStatic修饰</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">InnerSingleton</span> <span class="variable">InnerSingleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerSingleton</span>((DefaultConstructorMarker)<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InnerSingleton</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">InnerSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// $FF: synthetic method</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">InnerSingleton</span><span class="params">(DefaultConstructorMarker $constructor_marker)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PersonKt</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//注意这里</span></span><br><span class="line">      Person.InnerSingleton.foo();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] var0)</span> &#123;</span><br><span class="line">      main();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Person.foo()</span><br></pre></td></tr></table></figure><p><strong>对于companion中用@JvmStatic修饰的方法而言，加不加@JvmStatic都不影响我们的调用，如果不加@JvmStatic修饰，编译器会自动实现Person.InnerSingleton.foo()，区别只在于是否将方法移到伴生对象外部的类当中，变成静态成员</strong></p><h4 id="伴生对象的实战应用"><a href="#伴生对象的实战应用" class="headerlink" title="伴生对象的实战应用"></a>伴生对象的实战应用</h4><h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>所谓的工厂模式，就是指当我们想要统一管理一个类的创建时，我们可以将这个类的构造函数声明成 private，然后用工厂模式来暴露一个统一的方法，以供外部使用。Kotlin 的伴生对象非常符合这样的使用场景：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  私有的构造函数，外部无法调用</span></span><br><span class="line"><span class="comment">//            ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(name: <span class="type">String</span>)</span></span>: User? &#123;</span><br><span class="line">            <span class="comment">// 统一检查，比如敏感词过滤</span></span><br><span class="line">            <span class="keyword">return</span> User(name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在这个例子当中，我们将 User 的构造函数声明成了 private 的，这样，外部的类就无法直接使用它的构造函数来创建实例了。与此同时，我们通过伴生对象，暴露出了一个 create() 方法。在这个 create() 方法当中，我们可以做一些统一的判断，比如敏感词过滤、判断用户的名称是否合法。</p><p>​另外，由于“伴生对象”本质上还是属于 User 的嵌套类，伴生对象仍然还算是在 User 类的内部，所以，我们是可以在 create() 方法内部调用 User 的构造函数的。</p><p>​这样，我们就通过“伴生对象”巧妙地实现了工厂模式。接下来，我们继续看看如何使用“伴生对象”来实现更加复杂的单例设计模式。</p><h5 id="另外4中单例模式的写法"><a href="#另外4中单例模式的写法" class="headerlink" title="另外4中单例模式的写法"></a>另外4中单例模式的写法</h5><p>​在前面，我们已经学习了 Kotlin 当中最简单的单例模式，也就是 object 关键字。同时，我们也提到了，这种方式虽然简洁，但它也存在两大问题：第一，无法懒加载；第二，不支持传参。</p><p>​那么，Kotlin 当中有没有既支持懒加载又支持传参的单例模式呢？</p><p>​答案当然是有的。接下来，我们就来了解下 Kotlin 里功能更加全面的 4 种单例模式，分别是懒加载委托单例模式、Double Check 单例模式、抽象类模板单例，以及接口单例模板</p><h6 id="第一种：懒加载委托"><a href="#第一种：懒加载委托" class="headerlink" title="第一种：懒加载委托"></a>第一种：懒加载委托</h6><p>​其实，针对懒加载的问题，我们在原有的代码基础上做一个非常小的改动就能优化，也就是借助 Kotlin 提供的“委托”语法。</p><p>​比如，针对前面的单例代码，我们在它内部的属性上使用 by lazy 将其包裹起来，这样我们的单例就能得到一部分的懒加载效果</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> UserManager &#123;</span><br><span class="line">    <span class="comment">// 对外暴露的 user</span></span><br><span class="line">    <span class="keyword">val</span> user <span class="keyword">by</span> lazy &#123; loadUser() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line">        <span class="comment">// 从网络或者数据库加载数据</span></span><br><span class="line">        <span class="keyword">return</span> User.create(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​可以看到，UserManager 内部的 user 变量变成了懒加载，只要 user 变量没有被使用过，它就不会触发 loadUser() 的逻辑。</p><p>​这其实是一种简洁与性能的折中方案。一个对象所占用的内存资源毕竟不大，绝大多数情况我们都可以接受。而从服务器去请求用户信息所消耗的资源更大，我们能够保证这个部分是懒加载的，就算是不错的结果了。</p><h6 id="第二种-伴生对象Double-Check"><a href="#第二种-伴生对象Double-Check" class="headerlink" title="第二种: 伴生对象Double Check"></a>第二种: 伴生对象Double Check</h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: UserManager? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(name: <span class="type">String</span>)</span></span>: UserManager =</span><br><span class="line">            <span class="comment">// 第一次判空</span></span><br><span class="line">            INSTANCE?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 第二次判空</span></span><br><span class="line">                INSTANCE?:UserManager(name).also &#123; INSTANCE = it &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">UserManager.getInstance(<span class="string">&quot;Tom&quot;</span>)</span><br></pre></td></tr></table></figure><p>​这种写法，其实是借鉴于 GitHub 上的Google 官方 Demo，它本质上就是 Java 的 Double Check。</p><p>​首先，我们定义了一个伴生对象，然后在它的内部，定义了一个 INSTANCE，它是 private 的，这样就保证了它无法直接被外部访问。同时它还被注解“@Volatile”修饰了，这可以保证 INSTANCE 的可见性，而 getInstance() 方法当中的 synchronized，保证了 INSTANCE 的原子性。因此，这种方案还是线程安全的。</p><p>​同时，我们也能注意到，初始化情况下，INSTANCE 是等于 null 的。这也就意味着，只有在 getInstance() 方法被使用的情况下，我们才会真正去加载用户数据。这样，我们就实现了整个 UserManager 的懒加载，而不是它内部的某个参数的懒加载。</p><p>​另外，由于我们可以在调用 getInstance(name) 方法的时候传入初始化参数，因此，这种方案也是支持传参的。</p><p>​不过，以上的实现方式仍然存在一个问题，在实现了 UserManager 以后，假设我们又有一个新的需求，要实现 PersonManager 的单例，这时候我们就需要重新写一次 Double Check 的逻辑。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: PersonManager? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(name: <span class="type">String</span>)</span></span>: PersonManager =</span><br><span class="line">            INSTANCE?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">                INSTANCE?:PersonManager(name).also &#123; INSTANCE = it &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​可以看到，不同的单例当中，我们必须反复写 Double Check 的逻辑，这是典型的坏代码。这种方式不仅很容易出错，同时也不符合编程规则（Don’t Repeat Yourself）。</p><h6 id="第三种：-类抽象模板"><a href="#第三种：-类抽象模板" class="headerlink" title="第三种： 类抽象模板"></a>第三种： 类抽象模板</h6><p>​我们来仔细分析下第二种写法的单例。其实很快就能发现，它主要由两个部分组成：第一部分是 INSTANCE 实例，第二部分是 getInstance() 函数。</p><p>​现在，我们要尝试对这种模式进行抽象。在面向对象的编程当中，我们主要有两种抽象手段，第一种是<strong>类抽象模板</strong>，第二种是<strong>接口抽象模板</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  ①                          ②                      </span></span><br><span class="line"><span class="comment">//  ↓                           ↓                       </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseSingleton</span>&lt;<span class="type">in P, out T</span>&gt; &#123;</span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> instance: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//                       ③</span></span><br><span class="line">    <span class="comment">//                       ↓</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">P</span>)</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(param: <span class="type">P</span>)</span></span>: T =</span><br><span class="line">        instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//            ④</span></span><br><span class="line">            <span class="comment">//            ↓</span></span><br><span class="line">            instance ?: creator(param).also &#123; instance = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在仔细分析每一处注释之前，我们先来整体看一下上面的代码：我们定义了一个抽象类 BaseSingleton，在这个抽象类当中，我们把单例当中通用的“INSTANCE 实例”和“getInstance() 函数”放了进去。也就是说，我们把单例类当中的核心逻辑放到了抽象类当中去了。</p><p>现在，我们再来看看上面的 4 处注释。</p><ul><li>注释①：abstract 关键字，代表了我们定义的 BaseSingleton 是一个抽象类。我们以后要实现单例类，就只需要继承这个 BaseSingleton 即可。</li><li>注释②：in P, out T 是 Kotlin 当中的泛型，P 和 T 分别代表了 getInstance() 的参数类型和返回值类型</li><li>注释③：creator(param: P): T 是 instance 构造器，它是一个抽象方法，需要我们在具体的单例子类当中实现此方法。</li><li>注释④：creator(param) 是对 instance 构造器的调用。</li></ul><p>这里，我们就以前面的 UserManager、PersonManager 为例，用抽象类模板的方式来实现单例，看看代码会发生什么样的变化。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="comment">//               ①                  ②</span></span><br><span class="line">    <span class="comment">//               ↓                   ↓</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : BaseSingleton&lt;String, PersonManager&gt;() &#123;</span><br><span class="line">    <span class="comment">//                  ③</span></span><br><span class="line">    <span class="comment">//                  ↓ </span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">String</span>)</span></span>: PersonManager = PersonManager(param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : BaseSingleton&lt;String, UserManager&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">String</span>)</span></span>: UserManager = UserManager(param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来分析上面的 3 处注释。</p><ul><li>注释①：companion object : BaseSingleton，由于伴生对象本质上还是嵌套类，也就是说，它仍然是一个类，那么它就具备类的特性“继承其他的类”。因此，我们让伴生对象继承 BaseSingleton 这个抽象类。</li><li>注释②：String, PersonManager，这是我们传入泛型的参数 P、T 对应的实际类型，分别代表了 creator() 的“参数类型”和“返回值类型”。</li><li>注释③：override fun creator，我们在子类当中实现了 creator() 这个抽象方法。</li></ul><p>​至此，我们就完成了单例的“抽象类模板”。通过这样的方式，我们不仅将重复的代码都统一封装到了抽象类“BaseSingleton”当中，还大大简化了单例的实现难度。</p><p>​接下来，让我们对比着看看单例的“接口模板”。</p><h6 id="第四种：类抽象模板"><a href="#第四种：类抽象模板" class="headerlink" title="第四种：类抽象模板"></a>第四种：类抽象模板</h6><p>​首先需要重点强调，<strong>这种方式是不被推荐的</strong>，这里提出这种写法是为了让你熟悉 Kotlin 接口的特性，并且明白 Kotlin 接口虽然能做到这件事，但它做得并不够好。</p><p>​如果你理解了上面的“抽象类模板”，那么，接口的这种方式你应该也很容易就能想到：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ISingleton</span>&lt;<span class="type">P, T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">var</span> instance: T?</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">P</span>)</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(p: <span class="type">P</span>)</span></span>: T =</span><br><span class="line">        instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            instance ?: creator(p).also &#123; instance = it &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​可以看到，接口模板的代码结构和抽象类的方式如出一辙。而我们之所以可以这么做，也是因为 Kotlin 接口的两个特性：<strong>接口属性、接口方法默认实现</strong>。Kotlin 当中的接口被增强了，让它与抽象类越来越接近，这个例子正好就可以说明这一点。抽象类能实现单例模板，我们的接口也可以。</p><p>​说实话，上面的接口单例模板看起来还是比较干净的，好像也挑不出什么大的毛病。但实际上，如果你看注释①的地方，你会发现：</p><ul><li><strong>instance 无法使用 private 修饰</strong>。这是接口特性规定的，而这并不符合单例的规范。正常情况下的单例模式，我们内部的 instance 必须是 private 的，这是为了防止它被外部直接修改。</li><li><strong>instance 无法使用 @Volatile 修饰</strong>。这也是受限于接口的特性，这会引发多线程同步的问题。</li></ul><p>除了 ISingleton 接口有这样的问题，我们在实现 ISingleton 接口的类当中，也会有类似的问题。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>: ISingleton&lt;String, Singleton&gt; &#123;</span><br><span class="line">        <span class="comment">//  ①      ②</span></span><br><span class="line">        <span class="comment">//  ↓       ↓</span></span><br><span class="line">        <span class="meta">@Volatile</span> <span class="keyword">override</span> <span class="keyword">var</span> instance: Singleton? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">String</span>)</span></span>: Singleton = Singleton(param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注释①：@Volatile，这个注解虽然可以在实现的时候添加，但实现方可能会忘记，这会导致隐患。</li><li>注释②：我们在实现 instance 的时候，仍然无法使用 private 来修饰。</li></ul><p>​此综合来看，单例“接口模板”并不是一种合格的实现方式。</p><p>​不过，在研究这个接口模板的过程中，我们又重温了 Kotlin 接口属性、接口方法默认实现这两个特性，并且对这两个特性进行一次应用。与此同时，我们也理解了接口模板存在的缺陷，以及不被推荐的原因。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​Kotlin 的匿名内部类和 Java 的类似，只不过它多了一个功能：匿名内部类可以在继承一个抽象类的同时还实现多个接口。</p><p>​另外，object 的单例和伴生对象，这两种语义从表面上看是没有任何联系的。但通过这节课的学习我们发现了，<strong>单例与伴生对象之间是存在某种演变关系的。“单例”演变出了“嵌套单例”，而“嵌套单例”演变出了“伴生对象”。</strong></p><p>​然后，我们也借助 Kotlin 伴生对象这个语法，研究了伴生对象的实战应用，比如可以实现工厂模式、懒加载 + 带参数的单例模式。</p><p>​这 4 种单例之间各有优劣，我们可以在工作中根据实际需求，来选择对应的实现方式：</p><ul><li>如果我们的单例占用内存很小，并且对内存不敏感，不需要传参，直接使用 object 定义的单例即可。</li><li>如果我们的单例占用内存很小，不需要传参，但它内部的属性会触发消耗资源的网络请求和数据库查询，我们可以使用 object 搭配 by lazy 懒加载。</li><li>如果我们的工程很简单，只有一两个单例场景，同时我们有懒加载需求，并且 getInstance() 需要传参，我们可以直接手写 Double Check。</li><li>如果我们的工程规模大，对内存敏感，单例场景比较多，那我们就很有必要使用抽象类模板 BaseSingleton 了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-在Activity中使用Menu</title>
      <link href="/posts/be1a9334/"/>
      <url>/posts/be1a9334/</url>
      
        <content type="html"><![CDATA[<h1 id="在Activity中使用Menu"><a href="#在Activity中使用Menu" class="headerlink" title="在Activity中使用Menu"></a>在Activity中使用Menu</h1><h2 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h2><p>​首先在 <code>res</code> 目录下新建一个<code>menu</code>文件夹，右击<code>res</code>目录–&gt;New–&gt;Android Resource Directory，输入文件夹名<code>menu</code>，在弹出的菜单中<code>Directory Name</code>输入<code>Menu</code>，<code>Resource type</code> 选择<code>Menu</code>，然后在此文件夹下新建一个 <code>main.xml</code>的菜单文件，右击menu–&gt;New–&gt;Menu Resource File。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/wbyjaDYt2hqxVpX.png" alt="img"></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/GXwoUZl26Skj1C3.png" alt="0813-2"></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/dhJNj2MYbVHKkwq.png" alt="0813-3"></p><p>最后添加 <code>Item</code>的 <code>id</code>和<code>title</code>即可.</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/add_item&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:title</span>=<span class="string">&quot;@string/add&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/remove_item&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:title</span>=<span class="string">&quot;@string/remove&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用:"></a>使用:</h2><p>​重写 <code>Activity</code>的 <code>onCreateOptionsMenu</code> 和 <code>onOptionsItemSelected</code> 方法.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> &#123;</span><br><span class="line">        getMenuInflater().inflate(R.menu.main,menu);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onOptionsItemSelected</span><span class="params">(<span class="meta">@NonNull</span> MenuItem item)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (item.getItemId())&#123;</span><br><span class="line">            <span class="keyword">case</span>  R.id.add_item:</span><br><span class="line">                showToast(<span class="string">&quot;You Click Add&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.remove_item:</span><br><span class="line">                showToast(<span class="string">&quot;You Click Remove&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 11 分区存储</title>
      <link href="/posts/f305e41/"/>
      <url>/posts/f305e41/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>从微信打开KML文件，选择自家开发的App打开，发现能够读取读取文件路径，但是在操作的时候显示错误</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java.io.FileNotFoundException: /storage/emulated/0/Android/data/com.tencent.mm/MicroMsg/Download/xxx.kml: open failed: EACCES (Permission denied)</span><br></pre></td></tr></table></figure><p>其中AS工程已经正确配置存储权限，并且application已经配置<code>android:requestLegacyExternalStorage=&quot;true&quot;</code></p><p>因项目在Android10上能够正确运行，但是在Android 11及以上有异常，猜想是因为Android 11做了一些限制。</p><p>因此采用另外一种方法：先把真实路径从获取到的Uri对象中解析出来，然后把文件拷贝一份到App目录下面，再对这个文件进行解析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  从Uri获取真实路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFPUriToPath</span><span class="params">(Context context, Uri uri)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;PackageInfo&gt; packs = context.getPackageManager().getInstalledPackages(PackageManager.GET_PROVIDERS);</span><br><span class="line">            <span class="keyword">if</span> (packs != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">fileProviderClassName</span> <span class="operator">=</span> FileProvider.class.getName();</span><br><span class="line">                <span class="keyword">for</span> (PackageInfo pack : packs) &#123;</span><br><span class="line">                    ProviderInfo[] providers = pack.providers;</span><br><span class="line">                    <span class="keyword">if</span> (providers != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (ProviderInfo provider : providers) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (uri.getAuthority().equals(provider.authority)) &#123;</span><br><span class="line"><span class="comment">//                                if (provider.name.equalsIgnoreCase(fileProviderClassName)) &#123;</span></span><br><span class="line">                                    Class&lt;FileProvider&gt; fileProviderClass = FileProvider.class;</span><br><span class="line">                                    <span class="keyword">try</span> &#123;</span><br><span class="line">                                        <span class="type">Method</span> <span class="variable">getPathStrategy</span> <span class="operator">=</span> fileProviderClass.getDeclaredMethod(<span class="string">&quot;getPathStrategy&quot;</span>, Context.class, String.class);</span><br><span class="line">                                        getPathStrategy.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                                        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> getPathStrategy.invoke(<span class="literal">null</span>, context, uri.getAuthority());</span><br><span class="line">                                        <span class="keyword">if</span> (invoke != <span class="literal">null</span>) &#123;</span><br><span class="line">                                            <span class="type">String</span> <span class="variable">PathStrategyStringClass</span> <span class="operator">=</span> FileProvider.class.getName() + <span class="string">&quot;$PathStrategy&quot;</span>;</span><br><span class="line">                                            Class&lt;?&gt; PathStrategy = Class.forName(PathStrategyStringClass);</span><br><span class="line">                                            <span class="type">Method</span> <span class="variable">getFileForUri</span> <span class="operator">=</span> PathStrategy.getDeclaredMethod(<span class="string">&quot;getFileForUri&quot;</span>, Uri.class);</span><br><span class="line">                                            getFileForUri.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                                            <span class="type">Object</span> <span class="variable">invoke1</span> <span class="operator">=</span> getFileForUri.invoke(invoke, uri);</span><br><span class="line">                                            <span class="keyword">if</span> (invoke1 <span class="keyword">instanceof</span> File) &#123;</span><br><span class="line">                                                <span class="keyword">return</span> ((File) invoke1).getAbsolutePath();</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                                        e.printStackTrace();</span><br><span class="line">                                    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                                        e.printStackTrace();</span><br><span class="line">                                    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                                        e.printStackTrace();</span><br><span class="line">                                    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                                        e.printStackTrace();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//                                &#125;</span></span><br><span class="line"><span class="comment">//                                break;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用流拷贝文件一份到自己APP目录下</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPathFromInputStreamUri</span><span class="params">(Context context, Uri uri, String fileName)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uri.getAuthority() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream = context.getContentResolver().openInputStream(uri);</span><br><span class="line">                <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> createTemporalFileFrom(context, inputStream, fileName);</span><br><span class="line">                filePath = file.getPath();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                        inputStream.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File <span class="title function_">createTemporalFileFrom</span><span class="params">(Context context, InputStream inputStream, String fileName)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> read;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span> * <span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//自己定义拷贝文件路径</span></span><br><span class="line">            targetFile = <span class="keyword">new</span> <span class="title class_">File</span>(context.getCacheDir(), fileName);</span><br><span class="line">            <span class="keyword">if</span> (targetFile.exists()) &#123;</span><br><span class="line">                targetFile.delete();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((read = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(buffer, <span class="number">0</span>, read);</span><br><span class="line">            &#125;</span><br><span class="line">            outputStream.flush();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> targetFile;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConstraintLayout-constraintDimensionRatio属性</title>
      <link href="/posts/59a3d1d6/"/>
      <url>/posts/59a3d1d6/</url>
      
        <content type="html"><![CDATA[<h3 id="h和w参数的解释"><a href="#h和w参数的解释" class="headerlink" title="h和w参数的解释"></a>h和w参数的解释</h3><blockquote><p>这里我们还需要解释一下app:layout_constraintDimensionRatio的值里面的h和w是什么意思。一般来说，加上h的意思就是，h之后的比例是以w为基础去设置h，即h &#x3D; w * ratio。反之，写上w的意思是，w &#x3D; h &#x2F; ratio （因为 ratio &#x3D; w &#x2F; h 代表宽高比）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava3+Retrofit简单使用</title>
      <link href="/posts/8de7aebd/"/>
      <url>/posts/8de7aebd/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>​从百度翻译定时轮询翻译API</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;io.reactivex.rxjava3:rxjava:3.1.2&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;io.reactivex.rxjava3:rxandroid:3.0.0&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;</span>// 衔接 Retrofit &amp; RxJava</span><br><span class="line">// retrofit适配器</span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:adapter-rxjava3:2.9.0&#x27;</span></span><br><span class="line">// Gson解析</span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:converter-gson:2.9.0&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="权限"><a href="#权限" class="headerlink" title="权限:"></a>权限:</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="https请求配置"><a href="#https请求配置" class="headerlink" title="https请求配置:"></a>https请求配置:</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:usesCleartextTraffic</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@lombok</span>.NoArgsConstructor</span><br><span class="line"><span class="meta">@lombok</span>.Data</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Translation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="keyword">private</span> String to;</span><br><span class="line">    <span class="keyword">private</span> List&lt;TransResultBean&gt; trans_result;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@lombok</span>.NoArgsConstructor</span><br><span class="line">    <span class="meta">@lombok</span>.Data</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TransResultBean</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String src;</span><br><span class="line">        <span class="keyword">private</span> String dst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        Log.e(<span class="string">&quot;RxJava&quot;</span>, trans_result.get(<span class="number">0</span>).dst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="描述网络请求接口"><a href="#描述网络请求接口" class="headerlink" title="描述网络请求接口"></a>描述网络请求接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GetRequest_Interface</span> &#123;</span><br><span class="line">    <span class="meta">@GET(&quot;trans/vip/translate?q=apple&amp;from=en&amp;to=zh&amp;appid=2015063000000001&amp;salt=1435660288&amp;sign=f89f9594663708c1605f3d736d01d2d4&quot;)</span></span><br><span class="line">    Observable&lt;Translation&gt; <span class="title function_">getCall</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> MainActivity.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">                .baseUrl(<span class="string">&quot;http://api.fanyi.baidu.com/api/&quot;</span>)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .addCallAdapterFactory(RxJava3CallAdapterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">GetRequest_Interface</span> <span class="variable">request</span> <span class="operator">=</span> retrofit.create(GetRequest_Interface.class);</span><br><span class="line"></span><br><span class="line">        Observable.interval(<span class="number">3</span>,<span class="number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                .doOnNext(aLong -&gt; &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">&quot;第 &quot;</span> + aLong + <span class="string">&quot; 次轮询&quot;</span> );</span><br><span class="line">                    Observable&lt;Translation&gt; observable = request.getCall();</span><br><span class="line">                    observable.subscribeOn(Schedulers.io())</span><br><span class="line">                            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                            .subscribe(<span class="keyword">new</span> <span class="title class_">Observer</span>&lt;Translation&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(<span class="meta">@NonNull</span> Disposable d)</span> &#123;</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(<span class="meta">@NonNull</span> Translation translation)</span> &#123;</span><br><span class="line">                                    translation.show();</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="meta">@NonNull</span> Throwable e)</span> &#123;</span><br><span class="line">                                    Log.e(TAG, <span class="string">&quot;onError: &quot;</span> );</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125;).subscribe(<span class="keyword">new</span> <span class="title class_">Observer</span>&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(<span class="meta">@NonNull</span> Disposable d)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(<span class="meta">@NonNull</span> Long aLong)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="meta">@NonNull</span> Throwable e)</span> &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;对Error事件作出响应&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;对Complete事件作出响应&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android优秀开源第三方库</title>
      <link href="/posts/b79c82/"/>
      <url>/posts/b79c82/</url>
      
        <content type="html"><![CDATA[<h2 id="Log类"><a href="#Log类" class="headerlink" title="Log类"></a>Log类</h2><p><code>Timber</code>    <a href="https://github.com/JakeWharton/timber">https://github.com/JakeWharton/timber</a></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.jakewharton.timber:timber:5.0.1&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio 和Lombok插件不兼容问题</title>
      <link href="/posts/6ed51752/"/>
      <url>/posts/6ed51752/</url>
      
        <content type="html"><![CDATA[<p>最近安装了高版本的 AS，然后在<code>Plugins</code>里已经搜索不到<code>lombok</code>这个插件了</p><p>在<a href="https://plugins.jetbrains.com/plugin/6317-lombok/versions">https://plugins.jetbrains.com/plugin/6317-lombok/versions</a>下载离线的安装包</p><p>然后报错</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Plugin <span class="string">&#x27;Lombok&#x27;</span> (version <span class="string">&#x27;0.34.1-2019.1&#x27;</span>) is not compatible with the current version of the IDE, because it requires build 191.* or older but the current build is AI-211.7628.21</span><br></pre></td></tr></table></figure><p>解决办法：</p><p> 将下载的插件解压，然后拷贝里面的jar包到Android Studio的安装目录 <code>D:\Program Files\Android\Android Studio\plugins</code>下面，重启AS即可</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dagger基本使用</title>
      <link href="/posts/1e3700a5/"/>
      <url>/posts/1e3700a5/</url>
      
        <content type="html"><![CDATA[<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">annotationProcessor <span class="string">&#x27;com.google.dagger:dagger-compiler:2.41&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="一、快速实现"><a href="#一、快速实现" class="headerlink" title="一、快速实现"></a>一、快速实现</h3><h4 id="1、构造方法使用Inject注"><a href="#1、构造方法使用Inject注" class="headerlink" title="1、构造方法使用Inject注"></a>1、构造方法使用Inject注</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">  <span class="comment">//使用Inject注解在构造方法上，就是告知dagger可以通过构造方法来创建获取到User的实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;Lee&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、创建ApplicationComponent"><a href="#2、创建ApplicationComponent" class="headerlink" title="2、创建ApplicationComponent"></a>2、创建ApplicationComponent</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationComponent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(MainActivity mainActivity)</span>; <span class="comment">//选择需要在哪里注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、在MainActivity中执行依赖注入动作（-）"><a href="#3、在MainActivity中执行依赖注入动作（-）" class="headerlink" title="3、在MainActivity中执行依赖注入动作（*）"></a>3、在MainActivity中执行依赖注入动作（*）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line">    User user;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">      <span class="comment">//DaggerApplicationComponent是ApplicationComponent的实现类</span></span><br><span class="line">        DaggerApplicationComponent.create().inject(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、使用Module提供对象实例"><a href="#二、使用Module提供对象实例" class="headerlink" title="二、使用Module提供对象实例"></a>二、使用Module提供对象实例</h3><p>场景： 使用 <code>Retrofit</code> 处理网络请求</p><h4 id="1、创建-NetworkModule对象"><a href="#1、创建-NetworkModule对象" class="headerlink" title="1、创建 NetworkModule对象"></a>1、创建 NetworkModule对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetWorkModule</span> &#123;</span><br><span class="line">    <span class="comment">//第二种方式告知dagger，可以通过该方法来获取需要注入的对象</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> Retrofit <span class="title function_">provideRetrofit</span><span class="params">(OkHttpClient okHttpClient)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">                .client(okHttpClient)</span><br><span class="line">                .baseUrl(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> ApiService <span class="title function_">provideApiService</span><span class="params">(Retrofit retrofit)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  retrofit.create(ApiService.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> OkHttpClient <span class="title function_">provideOKHttpClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、Component关联Module"><a href="#2、Component关联Module" class="headerlink" title="2、Component关联Module"></a>2、Component关联Module</h4><p>在<code>AppliationComponent</code>的注解上添加module</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(modules = &#123;NetWorkModule.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(MainActivity mainActivity)</span>; <span class="comment">// * </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、在MainActivity中执行依赖注入动作"><a href="#3、在MainActivity中执行依赖注入动作" class="headerlink" title="3、在MainActivity中执行依赖注入动作"></a>3、在MainActivity中执行依赖注入动作</h4><p>跟上面的例子类似</p><h3 id="三、使用作用域实现单例"><a href="#三、使用作用域实现单例" class="headerlink" title="三、使用作用域实现单例"></a>三、使用作用域实现单例</h3><p><em><strong>使用作用域注解，可以将<code>某个对象的生命周期限定为其组件的生命周期</code>。这样也就意味着，在作用域范围内，使用到的是同一实例</strong></em></p><p><em><strong>@Singleton是dagger提供的一种默认的作用域注解，其意义表示一个单例对象。也就是实例的生命周期和程序运行的生命周期保护一致</strong></em></p><p>在<code>@Provides</code>注解的基础上，添加<code>@Singleton</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="keyword">public</span> Retrofit <span class="title function_">provideRetrofit</span><span class="params">(OkHttpClient okHttpClient)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">            .client(okHttpClient)</span><br><span class="line">            .baseUrl(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时需要在 <code>Applicationomponent</code>上添加<code>@Singleton</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component(modules = &#123;NetWorkModule.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果在同一个Activity多次使用 @Inject 的对象，可以发现是属于同一个实例</strong></p><p><strong>但是在不同的Activity中使用注入相同的对象,发现属于不同的实例</strong></p><p>解决办法,在Application中构造相同的 <code>ApplicationComponent</code>对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AppComponent <span class="title function_">getAppComponent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> appComponent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AppComponent</span> <span class="variable">appComponent</span> <span class="operator">=</span> DaggerAppComponent.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不同的Activity中使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component(modules = &#123;NetWorkModule.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(MainActivity mainActivity)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(SecondActivity secondActivity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    ApiService apiService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_second);</span><br><span class="line">        <span class="comment">//从Application中获取实例</span></span><br><span class="line">        MyApplication.appComponent.inject(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;apiService = &quot;</span> + apiService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode使用技巧(ImageLiteral、ColorLiteral)</title>
      <link href="/posts/d846019/"/>
      <url>/posts/d846019/</url>
      
        <content type="html"><![CDATA[<p>选择图片:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span> <span class="type">Literal</span></span><br></pre></td></tr></table></figure><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/QsxqOnIgCJSF8PD.png" alt="img"></p><p>颜色:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Color</span> <span class="type">Literal</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Xcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Postman截取Chrome网络请求</title>
      <link href="/posts/a8ca6419/"/>
      <url>/posts/a8ca6419/</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装Chrome插件"><a href="#1-安装Chrome插件" class="headerlink" title="1.安装Chrome插件"></a>1.安装Chrome插件</h1><h2 id="安装-Postman-Interceptor-插件"><a href="#安装-Postman-Interceptor-插件" class="headerlink" title="安装 Postman Interceptor 插件"></a>安装 <code>Postman Interceptor</code> 插件</h2><p><a href="https://chrome.google.com/webstore/detail/postman-interceptor/aicmkgpgakddgnaphhhpliifpcfhicfo?hl=zh"> https://chrome.google.com/webstore/detail/postman-interceptor/aicmkgpgakddgnaphhhpliifpcfhicfo?hl=zh</a></p><h1 id="2-安装-Interceptor-Bridge"><a href="#2-安装-Interceptor-Bridge" class="headerlink" title="2.安装 Interceptor Bridge "></a>2.安装 <code>Interceptor Bridge </code></h1><p>按照 <a href="https://learning.postman.com/docs/sending-requests/capturing-request-data/interceptor/">https://learning.postman.com/docs/sending-requests/capturing-request-data/interceptor/</a> 设置安装</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/cWJyhdQfqb5OguM.png" alt="Interceptor Bridge"></p> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Mac OS下需要先安装Node.js环境，没有的话，会自动下载node.js的安装包</span><br></pre></td></tr></table></figure><h1 id="打开Requests-和Cookies"><a href="#打开Requests-和Cookies" class="headerlink" title="打开Requests 和Cookies"></a>打开Requests 和Cookies</h1><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/tQOI71PwoaZUBX3.png" alt="Request Cookie" style="zoom:67%;" /><p>在<code>Requests</code> 里面选择 <code>Source</code> 为<code>Interceptor</code>，打开<code>Capture Requests</code>，然后选择请求保存的位置</p><p>​<img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/LNJrVUkGgKDtfBb.png" alt="20210625-3" style="zoom:67%;" /></p><p>在<code>Cookies</code>里面，打开<code>Capture Cookie</code>，然后在<code>Domains</code>里面可以过滤信息</p><h1 id="重复请求测试"><a href="#重复请求测试" class="headerlink" title="重复请求测试"></a>重复请求测试</h1><p> 在Postman左侧找到已经抓取到的请求，然后添加到<code>Save Request</code>，将请求添加到<code>Collections</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/ls9TXEVeZWCibnt.png" alt="20210625-4"></p><p>点击<code> Run collection</code></p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/LmIy6GFE5UlOSz4.png" alt="20210625-5" style="zoom:67%;" /><p><code>Iterations</code> 表示执行的次数</p><p><code>Delay</code> 表示延时</p><p><code>Save Responses</code> 可以查看相应结果</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Charles破解方法</title>
      <link href="/posts/6149b0e8/"/>
      <url>/posts/6149b0e8/</url>
      
        <content type="html"><![CDATA[<h2 id="下载Charles"><a href="#下载Charles" class="headerlink" title="下载Charles"></a>下载Charles</h2><p>Charles下载地址 <a href="https://www.charlesproxy.com/download">https://www.charlesproxy.com/download/</a></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/TfzBhwvj3uJERD8.png" alt="Charles下载地址"></p><h2 id="下载破解文件"><a href="#下载破解文件" class="headerlink" title="下载破解文件"></a>下载破解文件</h2><p>在线破解地址: <a href="https://www.zzzmode.com/mytools/charles/">https://www.zzzmode.com/mytools/charles/</a></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/aOX8CkvlnPxhoef.png" alt="下载破解文件"></p><p>在<code>RegisterName</code>输入你想注册的名字。</p><h2 id="替换charles-jar"><a href="#替换charles-jar" class="headerlink" title="替换charles.jar"></a>替换<code>charles.jar</code></h2><p>方法： 用刚才下载的<code>charles.jar</code>替换本地<code>charles.jar</code>文件。</p><blockquote><p>macOS: <code>/Applications/Charles.app/Contents/Java/charles.jar</code></p><p>Windows: <code>&lt;安装盘&gt;:\Program Files\Charles\lib\charles.jar</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
          <category> Charles </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Charles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm 2020.3破解</title>
      <link href="/posts/f145095/"/>
      <url>/posts/f145095/</url>
      
        <content type="html"><![CDATA[<p><font size= 5><code>文章如果过期，详情参考：https://blog.idejihuo.com/topics/jetbrains/pycharm</code></font></p><h2 id="破解补丁下载"><a href="#破解补丁下载" class="headerlink" title="破解补丁下载"></a>破解补丁下载</h2><p>链接: <a href="https://pan.baidu.com/s/1IKM8thIqRfU3L2U815RpFw"> https://pan.baidu.com/s/1IKM8thIqRfU3L2U815RpFw</a>  提取码: <code>9r8u</code></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="1-打开PyCharm，新建一个空工程"><a href="#1-打开PyCharm，新建一个空工程" class="headerlink" title="1.打开PyCharm，新建一个空工程"></a>1.打开PyCharm，新建一个空工程</h3><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/heDzXpRFGW7vx1M.png"></p><h3 id="2-把下载的-zip-包拖动到右侧编辑内容，然后重启IDE"><a href="#2-把下载的-zip-包拖动到右侧编辑内容，然后重启IDE" class="headerlink" title="2.把下载的 zip 包拖动到右侧编辑内容，然后重启IDE"></a>2.把下载的 <code>zip</code> 包拖动到右侧编辑内容，然后重启IDE</h3><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/4cbfApSQhMYLP1J.png" alt="20210806-4"></p><h3 id="3-在工具栏-Help-–-Eval-Reset"><a href="#3-在工具栏-Help-–-Eval-Reset" class="headerlink" title="3.在工具栏 Help –&gt; Eval Reset"></a>3.在工具栏 <code>Help</code> –&gt; <code>Eval Reset</code></h3><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/DgnqSYokQ912BaI.png"></p><h3 id="4-重置时间"><a href="#4-重置时间" class="headerlink" title="4.重置时间"></a>4.重置时间</h3><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/BhuQzX1M9TcKDw2.png" alt="20210806-3"></p><p>然后可以在注册信息里看到，剩余的时间是30天</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/58PQqTg1hGHJrSB.png" alt="20210806-5"></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">过期了之后，按照前面的方法重新激活</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
          <category> JetBrains </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Arcgis-Search for an address</title>
      <link href="/posts/e568ea1/"/>
      <url>/posts/e568ea1/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://developers.arcgis.com/labs/ios/search-for-an-address/">https://developers.arcgis.com/labs/ios/search-for-an-address/</a></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> geocoder:<span class="type">AGSLocatorTask</span> <span class="operator">=</span> <span class="type">AGSLocatorTask</span>(url: <span class="type">URL</span>(string: <span class="string">&quot;https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer&quot;</span>)<span class="operator">!</span>)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">searchBarSearchButtonClicked</span>(<span class="keyword">_</span> <span class="params">searchBar</span>: <span class="type">UISearchBar</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> searchText <span class="operator">=</span> searchBar.text, <span class="operator">!</span>searchText.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Nothing to search&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        geocoder.geocode(withSearchText: searchText) &#123; (results, error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> error <span class="operator">==</span> <span class="literal">nil</span> <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Error Geocoding `<span class="subst">\(searchText)</span>`: <span class="subst">\(error<span class="operator">!</span>.localizedDescription)</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span>  firstResult <span class="operator">=</span> results<span class="operator">?</span>.first, <span class="keyword">let</span> extent <span class="operator">=</span> firstResult.extent <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> alert <span class="operator">=</span> <span class="type">UIAlertController</span>(title: <span class="string">&quot;Nothing Found&quot;</span>, message: <span class="string">&quot;No results  found for <span class="subst">\(searchText)</span>&quot;</span>, preferredStyle: .alert)</span><br><span class="line">                alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">&quot;OK&quot;</span>, style: .default, handler: &#123; (<span class="keyword">_</span>) <span class="keyword">in</span></span><br><span class="line">                    alert.dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">                &#125;))</span><br><span class="line">                <span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将获取到的geometry加载到地图上</span></span><br><span class="line">            <span class="keyword">let</span> point:<span class="type">AGSPoint</span> <span class="operator">=</span> firstResult.displayLocation<span class="operator">!</span></span><br><span class="line">            <span class="keyword">let</span> simpleMarkSymbol <span class="operator">=</span> <span class="type">AGSSimpleMarkerSymbol</span>(style: .circle, color: .red, size: <span class="number">10</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> resultGraphics <span class="operator">=</span> <span class="type">AGSGraphic</span>(geometry: point, symbol:simpleMarkSymbol , attributes: <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">self</span>.mGraphicsOverlay.graphics.add(resultGraphics)</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.mapView.setViewpointGeometry(extent, completion: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
          <category> Nativie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arcgis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arcgis相关知识</title>
      <link href="/posts/e7a57cad/"/>
      <url>/posts/e7a57cad/</url>
      
        <content type="html"><![CDATA[<p>​AGS相关知识:</p><ul><li><p>添加一个 <code>GraphicsOverlay</code></p><ul><li><p>点</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> graphicsOverlay <span class="operator">=</span> <span class="type">AGSGraphicsOverlay</span>()</span><br><span class="line">        mapView.graphicsOverlays.add(graphicsOverlay)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> ref:<span class="type">AGSSpatialReference</span> <span class="operator">=</span> .wgs84()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> pointGraphic: <span class="type">AGSGraphic</span> <span class="operator">=</span> &#123;</span><br><span class="line">            <span class="comment">//Create a point geometry</span></span><br><span class="line">            <span class="keyword">let</span> point <span class="operator">=</span> <span class="type">AGSPoint</span>(x: <span class="number">111.677914</span>, y: <span class="number">40.838096</span>, spatialReference: ref)</span><br><span class="line">            <span class="comment">//Create point symbol with outline </span></span><br><span class="line">          <span class="comment">// style: 中心点的样式</span></span><br><span class="line">            <span class="keyword">let</span> symbol <span class="operator">=</span> <span class="type">AGSSimpleMarkerSymbol</span>(style: .diamond, color: .orange, size: <span class="number">10.0</span>)</span><br><span class="line">            <span class="comment">//设置边线的样式</span></span><br><span class="line">            symbol.outline <span class="operator">=</span> <span class="type">AGSSimpleLineSymbol</span>(style: .solid, color: .blue, width: <span class="number">2.0</span>)</span><br><span class="line">          <span class="comment">//let textSymbol = AGSTextSymbol(text: &quot;This is textSymbol&quot;, color: .red, size: 10.0, horizontalAlignment: .left, verticalAlignment: .middle)</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//Create point graphic with geometry &amp; symbol</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">AGSGraphic</span>(geometry: point, symbol: symbol, attributes: <span class="literal">nil</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">        </span><br><span class="line">        graphicsOverlay.graphics.add(pointGraphic)</span><br></pre></td></tr></table></figure><ul><li><p>线</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lineGraphic:<span class="type">AGSGraphic</span> <span class="operator">=</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> polyline <span class="operator">=</span> <span class="type">AGSPolyline</span>(</span><br><span class="line">                points:[</span><br><span class="line">                    <span class="type">AGSPoint</span>(x: <span class="number">111.681234</span>, y: <span class="number">40.839142</span>, spatialReference: ref),</span><br><span class="line">                    <span class="type">AGSPoint</span>(x: <span class="number">111.691345</span>, y: <span class="number">40.847132</span>, spatialReference:ref)</span><br><span class="line">                ]</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> polylineSymbol <span class="operator">=</span> <span class="type">AGSSimpleLineSymbol</span>(style:.solid, color: .orange, width: <span class="number">4.0</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="type">AGSGraphic</span>(geometry: polyline, symbol: polylineSymbol, attributes: <span class="literal">nil</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">        </span><br><span class="line">        graphicsOverlay.graphics.add(lineGraphic)</span><br></pre></td></tr></table></figure></li><li><p>面</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> polygonGraphic: <span class="type">AGSGraphic</span> <span class="operator">=</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> polygon <span class="operator">=</span> <span class="type">AGSPolygon</span>(points: [</span><br><span class="line">                <span class="type">AGSPoint</span>(x: <span class="number">111.683211</span>, y: <span class="number">40.839132</span>, spatialReference: ref),</span><br><span class="line">                <span class="type">AGSPoint</span>(x: <span class="number">111.703211</span>, y: <span class="number">40.840142</span>, spatialReference: ref),</span><br><span class="line">                <span class="type">AGSPoint</span>(x: <span class="number">111.710211</span>, y: <span class="number">40.831023</span>, spatialReference: ref)</span><br><span class="line">            ])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> polygonSymbol <span class="operator">=</span> <span class="type">AGSSimpleFillSymbol</span>(style: .solid, color: .red,</span><br><span class="line">                                                    outline: <span class="type">AGSSimpleLineSymbol</span>(</span><br><span class="line">                                                        style: .solid, color: .blue, width: <span class="number">3.0</span></span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="type">AGSGraphic</span>(geometry: polygon, symbol: polygonSymbol, attributes: <span class="literal">nil</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">        </span><br><span class="line">        graphicsOverlay.graphics.add(polygonGraphic)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
          <category> Nativie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arcgis for iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arcgis offline map(Swift)</title>
      <link href="/posts/704a878a/"/>
      <url>/posts/704a878a/</url>
      
        <content type="html"><![CDATA[<p>加载离线地图:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> mobileMapPackage <span class="operator">=</span> <span class="type">AGSMobileMapPackage</span>(name: <span class="string">&quot;offline-maps-package&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">setupMap</span>() &#123;</span><br><span class="line">        mobileMapPackage.load &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>](error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Error loading the mobile map package: <span class="subst">\(error.localizedDescription)</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> map <span class="operator">=</span> <span class="keyword">self</span>.mobileMapPackage.maps.first&#123;</span><br><span class="line">                <span class="keyword">self</span>.mapView.map <span class="operator">=</span> map</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
          <category> Nativie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arcgis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arcgis for Android 100.10.0(一)：开发环境配置</title>
      <link href="/posts/97fdcddb/"/>
      <url>/posts/97fdcddb/</url>
      
        <content type="html"><![CDATA[<h3 id="一-在Project的build-gradle文件中中进行配置"><a href="#一-在Project的build-gradle文件中中进行配置" class="headerlink" title="(一)  在Project的build.gradle文件中中进行配置:"></a>(一)  在<code>Project</code>的<code>build.gradle</code>文件中中进行配置:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the following ArcGIS repository</span></span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">&#x27;https://esri.bintray.com/arcgis&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-在Module的build-gradle中添加依赖"><a href="#二-在Module的build-gradle中添加依赖" class="headerlink" title="(二) 在Module的build.gradle中添加依赖:"></a>(二) 在<code>Module</code>的<code>build.gradle</code>中添加依赖:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add ArcGIS Runtime SDK for Android dependency</span></span><br><span class="line">implementation <span class="string">&#x27;com.esri.arcgisruntime:arcgis-android:100.10.0&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="三-在Module的builde-gradle的android中添加配置"><a href="#三-在Module的builde-gradle的android中添加配置" class="headerlink" title="(三) 在Module的builde.gradle的android中添加配置:"></a>(三) 在<code>Module</code>的<code>builde.gradle</code>的<code>android</code>中添加配置:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">30</span></span><br><span class="line">    buildToolsVersion <span class="string">&quot;30.0.2&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//Add Arcgis compile sdk</span></span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="四-在AndroidManifest-xml中添加"><a href="#四-在AndroidManifest-xml中添加" class="headerlink" title="(四) 在AndroidManifest.xml中添加:"></a>(四) 在<code>AndroidManifest.xm</code>l中添加:</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-feature</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:glEsVersion</span>=<span class="string">&quot;0x00020000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
          <category> Nativie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arcgis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arcgis Runtime API for Android 100.13 (一)环境配置</title>
      <link href="/posts/e6f64ca3/"/>
      <url>/posts/e6f64ca3/</url>
      
        <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>1.低版本的Gradle,在  <code>build.gradle</code> 的<code>repositories</code> 里配置</p><p>高版本的Gradle,在<code>settings.gradle</code>里的<code>dependencyResolutionManagement</code>里配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">       google()</span><br><span class="line">       mavenCentral()</span><br><span class="line">       maven &#123;</span><br><span class="line">           url &#x27;https://esri.jfrog.io/artifactory/arcgis&#x27;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>2.在<code>Module</code>的<code>build.gradle</code>里配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">implementation &#x27;com.esri.arcgisruntime:arcgis-android:100.13.1&#x27;</span><br></pre></td></tr></table></figure><p>3.在<code>Module</code> <code>build.gradle</code>里配置Java8</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  compileOptions &#123;</span><br><span class="line">    sourceCompatibility 1.8</span><br><span class="line">    targetCompatibility 1.8</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.在<code>Module</code> <code>build.gradle</code>中添加</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  packagingOptions &#123;</span><br><span class="line">        exclude &#x27;META-INF/DEPENDENCIES&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
          <category> Nativie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arcgis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arcgis Runtime API for Android 100.13 (二)基本地图</title>
      <link href="/posts/73e0c502/"/>
      <url>/posts/73e0c502/</url>
      
        <content type="html"><![CDATA[<p>上篇介绍了环境配置，现在来展示一个基本二维地图</p><p>1、在<code>AndroidManifest.xml</code>中添加网络权限和OpenGL 2.0支持</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:glEsVersion</span>=<span class="string">&quot;0x00020000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>2、布局文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.esri.arcgisruntime.mapping.view.MapView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/mapView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> ActivityMainBinding binding;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        binding = ActivityMainBinding.inflate(getLayoutInflater());</span><br><span class="line">        setContentView(binding.getRoot());</span><br><span class="line">        setApiKeyForApp();</span><br><span class="line">        setRequestConfiguration();</span><br><span class="line">        setupMap();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setApiKeyForApp</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//设置Apikey和License</span></span><br><span class="line">        ArcGISRuntimeEnvironment.setLicense(<span class="string">&quot;runtimelite,1000,rud9978704000,none,TRB3LNBHPFMB4P7EJ046&quot;</span>);</span><br><span class="line">        ArcGISRuntimeEnvironment.setApiKey(<span class="string">&quot;AAPK7bc88675e61a49f9bcb8ceb647c694f7wGb7zTAkJBYB8MWcOd3ale30A0sTU9dl8kr9uMEggfRfA3X9cNBrGXDIu3PwkIcp&quot;</span>);</span><br><span class="line">        <span class="comment">//去除水印</span></span><br><span class="line">        binding.mapView.setAttributionTextVisible(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setRequestConfiguration</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//设置RequestConfiguration</span></span><br><span class="line">        <span class="type">RequestConfiguration</span> <span class="variable">requestConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestConfiguration</span>();</span><br><span class="line">        requestConfiguration.getHeaders().put(<span class="string">&quot;referer&quot;</span>, <span class="string">&quot;http://www.arcgis.com&quot;</span>);</span><br><span class="line">        RequestConfiguration.setGlobalRequestConfiguration(requestConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setupMap</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ArcGISMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArcGISMap</span>(Basemap.Type.OPEN_STREET_MAP,<span class="number">27.822421448238604</span>,<span class="number">111.98435756939104</span>,<span class="number">13</span>);</span><br><span class="line">        binding.mapView.setMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause();</span><br><span class="line">        binding.mapView.pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        binding.mapView.resume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        binding.mapView.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下:</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://gitee.com/sliverfoxwb/image/raw/master/img/A3F0DA82-0D3B-4ad7-83C8-73CA7433698C.png" alt="1"></p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
          <category> Nativie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arcgis for Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cesium加载天地图</title>
      <link href="/posts/a0094c0f/"/>
      <url>/posts/a0094c0f/</url>
      
        <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>天地图<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引用cesium的js和css，天地图的扩展js --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cesiumjs.org/releases/1.74/Build/Cesium/Cesium.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://api.tianditu.gov.cn/cdn/plugins/cesium/cesiumTdt.js&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cesiumjs.org/releases/1.74/Build/Cesium/Widgets/widgets.css&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-id">#tiandituContainer</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">100%</span>; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>; <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;tiandituContainer&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> cesiumAsset=<span class="string">&#x27;cesiumAsset&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> tiandituTk=<span class="string">&#x27;tiandituTk&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 服务负载子域</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> subdomains=[<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>];</span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">Cesium</span>.<span class="property">Ion</span>.<span class="property">defaultAccessToken</span> = cesiumAsset;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> viewer = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">Viewer</span>(<span class="string">&#x27;tiandituContainer&#x27;</span>,&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">animation</span>:<span class="literal">false</span>,       <span class="comment">//动画</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">homeButton</span>:<span class="literal">true</span>,       <span class="comment">//home键</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">geocoder</span>:<span class="literal">true</span>,         <span class="comment">//地址编码</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">baseLayerPicker</span>:<span class="literal">false</span>, <span class="comment">//图层选择控件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">timeline</span>:<span class="literal">false</span>,        <span class="comment">//时间轴</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">fullscreenButton</span>:<span class="literal">true</span>, <span class="comment">//全屏显示</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">infoBox</span>:<span class="literal">true</span>,         <span class="comment">//点击要素之后浮窗</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">sceneModePicker</span>:<span class="literal">true</span>,  <span class="comment">//投影方式  三维/二维</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">navigationInstructionsInitiallyVisible</span>:<span class="literal">false</span>, <span class="comment">//导航指令</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">navigationHelpButton</span>:<span class="literal">false</span>,     <span class="comment">//帮助信息</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">selectionIndicator</span>:<span class="literal">false</span>, <span class="comment">// 选择</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">imageryProvider</span>: <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">WebMapTileServiceImageryProvider</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//影像底图</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">url</span>: <span class="string">&quot;http://t&#123;s&#125;.tianditu.com/img_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=img&amp;tileMatrixSet=w&amp;TileMatrix=&#123;TileMatrix&#125;&amp;TileRow=&#123;TileRow&#125;&amp;TileCol=&#123;TileCol&#125;&amp;style=default&amp;format=tiles&amp;tk=&quot;</span>+tiandituTk,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">subdomains</span>: subdomains,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">layer</span>: <span class="string">&quot;tdtImgLayer&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">style</span>: <span class="string">&quot;default&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">format</span>: <span class="string">&quot;image/jpeg&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">tileMatrixSetID</span>: <span class="string">&quot;GoogleMapsCompatible&quot;</span>,<span class="comment">//使用谷歌的瓦片切片方式</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">show</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript">  viewer.<span class="property">_cesiumWidget</span>.<span class="property">_creditContainer</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;  <span class="comment">// 隐藏cesium ion</span></span></span><br><span class="line"><span class="language-javascript">  viewer.<span class="property">imageryLayers</span>.<span class="title function_">addImageryProvider</span>(<span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">WebMapTileServiceImageryProvider</span>(&#123;   </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//影像注记</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">url</span>: <span class="string">&quot;http://t&#123;s&#125;.tianditu.com/cia_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=cia&amp;tileMatrixSet=w&amp;TileMatrix=&#123;TileMatrix&#125;&amp;TileRow=&#123;TileRow&#125;&amp;TileCol=&#123;TileCol&#125;&amp;style=default.jpg&amp;tk=&quot;</span>+tiandituTk,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">subdomains</span>: subdomains,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">layer</span>: <span class="string">&quot;tdtCiaLayer&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">style</span>: <span class="string">&quot;default&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">format</span>: <span class="string">&quot;image/jpeg&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">tileMatrixSetID</span>: <span class="string">&quot;GoogleMapsCompatible&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">show</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">  &#125;));</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 将三维球定位到中国</span></span></span><br><span class="line"><span class="language-javascript">    viewer.<span class="property">camera</span>.<span class="title function_">flyTo</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//17850000</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">destination</span>: <span class="title class_">Cesium</span>.<span class="property">Cartesian3</span>.<span class="title function_">fromDegrees</span>(<span class="number">112.92</span>, <span class="number">28.20</span>, <span class="number">5000</span>),</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">orientation</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            heading :  <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toRadians</span>(<span class="number">348.4202942851978</span>),</span></span><br><span class="line"><span class="language-javascript">            pitch : <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toRadians</span>(-<span class="number">89.74026687972041</span>),</span></span><br><span class="line"><span class="language-javascript">            roll : <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toRadians</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">complete</span>:<span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 定位完成之后的回调函数</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将<a href="https://cesium.com/ion/tokens?page=1"><code> cesiumAsset</code></a> 和 <code>tiandituTk</code> 换成自己的申请的key即可</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cesium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cesium编程-绘制图形</title>
      <link href="/posts/d45ce2e9/"/>
      <url>/posts/d45ce2e9/</url>
      
        <content type="html"><![CDATA[<h2 id="通过Entity绘制图形"><a href="#通过Entity绘制图形" class="headerlink" title="通过Entity绘制图形"></a>通过Entity绘制图形</h2><p>添加一个立方体</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> viewer = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">Viewer</span>(<span class="string">&quot;cesiumContainer&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> redBox = viewer.<span class="property">entities</span>.<span class="title function_">add</span>(&#123;</span><br><span class="line">              <span class="attr">name</span>:<span class="string">&#x27; box with  outline&#x27;</span>,</span><br><span class="line">              <span class="attr">position</span>: <span class="title class_">Cesium</span>.<span class="property">Cartesian3</span>.<span class="title function_">fromDegrees</span>(<span class="number">112.92</span>,<span class="number">28.20</span>,<span class="number">3000.0</span>),</span><br><span class="line">              box : &#123;</span><br><span class="line">                dimensions : <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">Cartesian3</span>(<span class="number">400.0</span>, <span class="number">300.0</span>, <span class="number">500.0</span>),</span><br><span class="line">                material : <span class="title class_">Cesium</span>.<span class="property">Color</span>.<span class="property">RED</span>.<span class="title function_">withAlpha</span>(<span class="number">0.5</span>),</span><br><span class="line">                outline : <span class="literal">true</span>,</span><br><span class="line">                outlineColor : <span class="title class_">Cesium</span>.<span class="property">Color</span>.<span class="property">BLACK</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">viewer.<span class="title function_">zoomTo</span>(viewer.<span class="property">entities</span>)</span><br></pre></td></tr></table></figure><h2 id="通过CZML添加"><a href="#通过CZML添加" class="headerlink" title="通过CZML添加"></a>通过CZML添加</h2>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cesium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetpack架构组件</title>
      <link href="/posts/e656a1a7/"/>
      <url>/posts/e656a1a7/</url>
      
        <content type="html"><![CDATA[<h1 id="Jetpack架构组件"><a href="#Jetpack架构组件" class="headerlink" title="Jetpack架构组件"></a>Jetpack架构组件</h1><p>官方应用架构</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/img/1130-1.png" alt="架构" style="zoom:50%;" /><h2 id="DataStore"><a href="#DataStore" class="headerlink" title="DataStore"></a>DataStore</h2><h3 id="1-类型"><a href="#1-类型" class="headerlink" title="1.类型"></a>1.类型</h3><p>​DataStore 提供两种不同的实现：Preferences DataStore 和 Proto DataStore。</p><ul><li><strong>Preferences DataStore</strong> 使用键存储和访问数据。此实现不需要预定义的架构，也不确保类型安全。</li><li><strong>Proto DataStore</strong> 将数据作为自定义数据类型的实例进行存储。此实现要求您使用<a href="https://developers.google.com/protocol-buffers">协议缓冲区</a>来定义架构，但可以确保类型安全。</li></ul><h3 id="2-Gradle配置"><a href="#2-Gradle配置" class="headerlink" title="2.Gradle配置"></a>2.Gradle配置</h3><p><strong>DataStore Typed</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Typed DataStore (Typed API surface, such as Proto)</span></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        implementation(<span class="string">&quot;androidx.datastore:datastore:1.0.0&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// optional - RxJava2 support</span></span><br><span class="line">        implementation(<span class="string">&quot;androidx.datastore:datastore-rxjava2:1.0.0&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// optional - RxJava3 support</span></span><br><span class="line">        implementation(<span class="string">&quot;androidx.datastore:datastore-rxjava3:1.0.0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Alternatively - use the following artifact without an Android dependency.</span></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        implementation(<span class="string">&quot;androidx.datastore:datastore-core:1.0.0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><strong>DataStore Preferences</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Preferences DataStore (SharedPreferences like APIs)</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;androidx.datastore:datastore-preferences:1.0.0&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava2 support</span></span><br><span class="line">    implementation(<span class="string">&quot;androidx.datastore:datastore-preferences-rxjava2:1.0.0&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava3 support</span></span><br><span class="line">    implementation(<span class="string">&quot;androidx.datastore:datastore-preferences-rxjava3:1.0.0&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alternatively - use the following artifact without an Android dependency.</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;androidx.datastore:datastore-preferences-core:1.0.0&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果您将 <code>datastore-preferences-core</code> 工件与 Proguard 搭配使用，就必须手动将 Proguard 规则添加到 <code>proguard-rules.pro</code> 文件中，以免您的字段遭到删除。您可以点击<a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:datastore/datastore-preferences/proguard-rules.pro">此处</a>查找必要的规则。</p><h2 id="视图绑定-viewBinding"><a href="#视图绑定-viewBinding" class="headerlink" title="视图绑定(viewBinding)"></a>视图绑定(viewBinding)</h2><h3 id="设置说明"><a href="#设置说明" class="headerlink" title="设置说明"></a>设置说明</h3><p>视图绑定功能可按模块启用。要在某个模块中启用视图绑定，请将 <code>viewBinding</code> 元素添加到其 <code>build.gradle</code> 文件中，如下例所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">        ...</span><br><span class="line">        viewBinding &#123;</span><br><span class="line">            enabled = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果您希望在生成绑定类时忽略某个布局文件，请将 <code>tools:viewBindingIgnore=&quot;true&quot;</code> 属性添加到相应布局文件的根视图中：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">...</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:viewBindingIgnore</span>=<span class="string">&quot;true&quot;</span> &gt;</span></span><br><span class="line">        ...</span><br><span class="line"> <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：Fragment 的存在时间比其视图长。请务必在 Fragment 的 <a href="https://developer.android.com/reference/kotlin/androidx/fragment/app/Fragment#ondestroyview"><code>onDestroyView()</code></a> 方法中清除对绑定类实例的所有引用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ResultProfileBinding binding;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> View <span class="title function_">onCreateView</span> <span class="params">(LayoutInflater inflater,</span></span><br><span class="line"><span class="params">                             ViewGroup container,</span></span><br><span class="line"><span class="params">                             Bundle savedInstanceState)</span> &#123;</span><br><span class="line">       binding = ResultProfileBinding.inflate(inflater, container, <span class="literal">false</span>);</span><br><span class="line">       <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> binding.getRoot();</span><br><span class="line">       <span class="keyword">return</span> view;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroyView</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>.onDestroyView();</span><br><span class="line">       binding = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="与-findViewById-的区别"><a href="#与-findViewById-的区别" class="headerlink" title="与 findViewById 的区别"></a>与 findViewById 的区别</h3><p>与使用 <code>findViewById</code> 相比，视图绑定具有一些很显著的优点：</p><ul><li><strong>Null 安全</strong>：由于视图绑定会创建对视图的直接引用，因此不存在因视图 ID 无效而引发 Null 指针异常的风险。此外，如果视图仅出现在布局的某些配置中，则绑定类中包含其引用的字段会使用 <code>@Nullable</code> 标记。</li><li><strong>类型安全</strong>：每个绑定类中的字段均具有与它们在 XML 文件中引用的视图相匹配的类型。这意味着不存在发生类转换异常的风险。</li></ul><p>这些差异意味着布局和代码之间的不兼容将会导致构建在编译时（而非运行时）失败。</p><h3 id="与数据绑定的对比"><a href="#与数据绑定的对比" class="headerlink" title="与数据绑定的对比"></a>与数据绑定的对比</h3><p>视图绑定和<a href="https://developer.android.com/topic/libraries/data-binding">数据绑定</a>均会生成可用于直接引用视图的绑定类。但是，视图绑定旨在处理更简单的用例，与数据绑定相比，具有以下优势：</p><ul><li><strong>更快的编译速度</strong>：视图绑定不需要处理注释，因此编译时间更短。</li><li><strong>易于使用</strong>：视图绑定不需要特别标记的 XML 布局文件，因此在应用中采用速度更快。在模块中启用视图绑定后，它会自动应用于该模块的所有布局。</li></ul><p>反过来，与数据绑定相比，视图绑定也具有以下限制：</p><ul><li>视图绑定不支持<a href="https://developer.android.com/topic/libraries/data-binding/expressions">布局变量或布局表达式</a>，因此不能用于直接在 XML 布局文件中声明动态界面内容。</li><li>视图绑定不支持<a href="https://developer.android.com/topic/libraries/data-binding/two-way">双向数据绑定</a>。</li></ul><p>考虑到这些因素，在某些情况下，最好在项目中同时使用视图绑定和数据绑定。您可以在需要高级功能的布局中使用数据绑定，而在不需要高级功能的布局中使用视图绑定。</p><h2 id="数据绑定库-dataBinding"><a href="#数据绑定库-dataBinding" class="headerlink" title="数据绑定库(dataBinding)"></a>数据绑定库(dataBinding)</h2><h3 id="设置说明-1"><a href="#设置说明-1" class="headerlink" title="设置说明"></a>设置说明</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">        ...</span><br><span class="line">        dataBinding &#123;</span><br><span class="line">            enabled = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data binding with ViewModel and LiveData</title>
      <link href="/posts/25183f3/"/>
      <url>/posts/25183f3/</url>
      
        <content type="html"><![CDATA[<h2 id="官方Demo"><a href="#官方Demo" class="headerlink" title="官方Demo"></a>官方Demo</h2><p><a href="https://developer.android.com/codelabs/kotlin-android-training-live-data-data-binding#0">https://developer.android.com/codelabs/kotlin-android-training-live-data-data-binding#0</a></p><p>本文基于 ViewModel + LiveData 改造</p><h2 id="Gradle配置"><a href="#Gradle配置" class="headerlink" title="Gradle配置"></a>Gradle配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        dataBinding true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Add-ViewModel-data-binding"><a href="#Add-ViewModel-data-binding" class="headerlink" title="Add ViewModel data binding"></a>Add ViewModel data binding</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">           <span class="attr">name</span>=<span class="string">&quot;scoreViewModel&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">type</span>=<span class="string">&quot;com.example.android.guesstheword.screens.score.ScoreViewModel&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">   &lt;androidx.constraintlayout.widget.ConstraintLayout</span><br></pre></td></tr></table></figure><p>Button点击事件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/play_again_button&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; scoreViewModel.onPlayAgain()&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>Fragment中用<code>DataBindingUtil</code>初始化<code>binding</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        <span class="comment">// Inflate view and obtain an instance of the binding class.</span></span><br><span class="line">        <span class="keyword">val</span> binding: ScoreFragmentBinding = DataBindingUtil.inflate(</span><br><span class="line">                inflater,</span><br><span class="line">                R.layout.score_fragment,</span><br><span class="line">                container,</span><br><span class="line">                <span class="literal">false</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Fragment中初始化<code>binding.scoreViewModel</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModelFactory = ScoreViewModelFactory(ScoreFragmentArgs.fromBundle(arguments!!).score)</span><br><span class="line">viewModel = ViewModelProvider(<span class="keyword">this</span>, viewModelFactory).<span class="keyword">get</span>(ScoreViewModel::<span class="keyword">class</span>.java)</span><br><span class="line"><span class="comment">//initial </span></span><br><span class="line">binding.scoreViewModel = viewModel</span><br></pre></td></tr></table></figure><h2 id="Add-LiveData-to-data-binding"><a href="#Add-LiveData-to-data-binding" class="headerlink" title="Add LiveData to data binding"></a>Add LiveData to data binding</h2><h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/word_text&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;@&#123;gameViewModel.word&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Fragment修改"><a href="#Fragment修改" class="headerlink" title="Fragment修改"></a>Fragment修改</h3><p>set the fragment view as the lifecycle owner of the <code>binding</code> variable</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.gameViewModel = ...</span><br><span class="line"><span class="comment">// Specify the fragment view as the lifecycle owner of the binding.</span></span><br><span class="line"><span class="comment">// This is used so that the binding can observe LiveData updates</span></span><br><span class="line">binding.lifecycleOwner = viewLifecycleOwner</span><br></pre></td></tr></table></figure><h3 id="Add-string-formatting-with-data-binding"><a href="#Add-string-formatting-with-data-binding" class="headerlink" title="Add string formatting with data binding"></a>Add string formatting with data binding</h3><h3 id="strings-xml"><a href="#strings-xml" class="headerlink" title="strings.xml"></a>strings.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;quote_format&quot;</span>&gt;</span>\&quot;%s\&quot;<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;score_format&quot;</span>&gt;</span>Current Score: %d<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="layout-xml"><a href="#layout-xml" class="headerlink" title="layout.xml"></a>layout.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/word_text&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;@&#123;@string/quote_format(gameViewModel.word)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/score_text&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;@&#123;@string/score_format(gameViewModel.score)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LiveData transformations</title>
      <link href="/posts/62149ceb/"/>
      <url>/posts/62149ceb/</url>
      
        <content type="html"><![CDATA[<p> <a href="https://developer.android.com/reference/androidx/lifecycle/Transformations.html"><code>Transformations</code></a> 有两个: </p><ul><li>[<code>Transformations.map</code>](<a href="https://developer.android.com/reference/androidx/lifecycle/Transformations.html#map">https://developer.android.com/reference/androidx/lifecycle/Transformations.html#map</a>(androidx.lifecycle.LiveData, androidx.arch.core.util.Function))</li><li>[<code>Transformations.switchMap</code>](<a href="https://developer.android.com/reference/androidx/lifecycle/Transformations.html#switchMap">https://developer.android.com/reference/androidx/lifecycle/Transformations.html#switchMap</a>(androidx.lifecycle.LiveData, androidx.arch.core.util.Function&gt;))</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LiveData和LiveData观察者</title>
      <link href="/posts/b74e9fe6/"/>
      <url>/posts/b74e9fe6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Add-LiveData-to-ViewModel"><a href="#1-Add-LiveData-to-ViewModel" class="headerlink" title="1.Add LiveData to ViewModel"></a>1.Add LiveData to ViewModel</h2><p>​Add LiveData to ViewModel and encapsulate the LiveData</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The current word</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _word = MutableLiveData&lt;String&gt;()</span><br><span class="line"><span class="keyword">val</span> word: LiveData&lt;String&gt;</span><br><span class="line">    <span class="keyword">get</span>() = _word</span><br><span class="line"></span><br><span class="line"><span class="comment">// The current score</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _score = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> score: LiveData&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line">    <span class="keyword">get</span>() = _score</span><br></pre></td></tr></table></figure><h2 id="2-Attach-observers-to-the-LiveData-objects"><a href="#2-Attach-observers-to-the-LiveData-objects" class="headerlink" title="2.Attach observers to the LiveData objects"></a>2.Attach observers to the LiveData objects</h2><p>在<code>Activity</code>中使用:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.score.observe(<span class="keyword">this</span>, Observer &#123; newScore -&gt;</span><br><span class="line">           Log.e(TAG, <span class="string">&quot;<span class="variable">$newScore</span>&quot;</span> )</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><p>在<code>Fragment</code>中使用:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.score.observe(viewLifecycleOwner, Observer &#123; newScore -&gt;</span><br><span class="line">            binding.scoreText.text = newScore.toString()</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Why use viewLifecycleOwner?</span><br><span class="line">Fragment views get destroyed when a user navigates away from a fragment, even though the fragment itself is not destroyed. This essentially creates two lifecycles, the lifecycle of the fragment, and the lifecycle of the fragment&#x27;s view. Referring to the fragment&#x27;s lifecycle instead of the fragment view&#x27;s lifecycle can cause subtle bugs when updating the fragment&#x27;s view. Therefore, when setting up observers that affect the fragment&#x27;s view you should:</span><br><span class="line"></span><br><span class="line">1. Set up the observers in onCreateView()</span><br><span class="line"></span><br><span class="line">2. Pass in viewLifecycleOwner to observers</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetpack——DataBinding使用-RecyclerView</title>
      <link href="/posts/5f8a375b/"/>
      <url>/posts/5f8a375b/</url>
      
        <content type="html"><![CDATA[<h3 id="RecyclerView的绑定"><a href="#RecyclerView的绑定" class="headerlink" title="RecyclerView的绑定"></a>RecyclerView的绑定</h3><p>效果图：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/QsvVqx3pRDY1iuW.png" alt="RecyclerView"></p><p>列表适配器:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisplayAdapter</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.Adapter&lt;DisplayAdapter.DisplayViewHolder&gt; &#123;</span><br><span class="line">    List&lt;User&gt; users;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DisplayAdapter</span><span class="params">(List&lt;User&gt; users)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.users = users;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DisplayViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup parent, <span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">      <span class="comment">//创建ViewHolder时,传入对应的 XXXBinding</span></span><br><span class="line">         <span class="type">ItemDisplayBinding</span> <span class="variable">binding</span> <span class="operator">=</span> DataBindingUtil.inflate(LayoutInflater.from(parent.getContext()),</span><br><span class="line">                R.layout.item_display,</span><br><span class="line">                parent,</span><br><span class="line">                <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DisplayViewHolder</span>(binding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(<span class="meta">@NonNull</span> DisplayViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> users.get(position);</span><br><span class="line">        holder.itemDisplayBinding.setUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> users.size();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DisplayViewHolder</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ViewHolder&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ItemDisplayBinding itemDisplayBinding;</span><br><span class="line">        <span class="comment">//构造方法传入binding</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DisplayViewHolder</span><span class="params">(ItemDisplayBinding binding)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(binding.getRoot());</span><br><span class="line">            <span class="built_in">this</span>.itemDisplayBinding = binding;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;user&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.carl.demo.databinding.User&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--app:itemImage 自定义的bindingAdapter--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;80dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;80dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:itemImage</span>=<span class="string">&quot;@&#123;user.image&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:srcCompat</span>=<span class="string">&quot;@tools:sample/backgrounds/scenic&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:contentDescription</span>=<span class="string">&quot;@string/app_name&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/userName&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;32dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;user.userName&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;24sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/desc&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;32dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;user.desc&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;18sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@+id/imageView&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ImageView的视图绑定:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisplayBindingAdapter</span> &#123;</span><br><span class="line"><span class="comment">//这里注意要用static，不然运行时会报错</span></span><br><span class="line">    <span class="meta">@BindingAdapter(&quot;itemImage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setImageView</span><span class="params">(ImageView imageView,String image)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(image))&#123;</span><br><span class="line">            Glide.with(imageView).load(image).into(imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>视图绑定方法要用static修饰</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-05-27-ViewModel+LiveData实现Fragment间通信</title>
      <link href="/posts/d904b99f/"/>
      <url>/posts/d904b99f/</url>
      
        <content type="html"><![CDATA[<p><em><strong>模拟场景： 在Activity定义两个相同的Fragment，等分布局，Fragment里面只包含一个SeekBar控件，通过共享ViewModel来实现Fragment间的通讯</strong></em></p><h3 id="1-定义ViewModel和LiveData"><a href="#1-定义ViewModel和LiveData" class="headerlink" title="1. 定义ViewModel和LiveData"></a>1. 定义ViewModel和LiveData</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedViewModel</span>: <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> progress: MutableLiveData&lt;<span class="built_in">Int</span>&gt; = MutableLiveData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-布局文件"><a href="#2-布局文件" class="headerlink" title="2. 布局文件"></a>2. 布局文件</h3><p>activity_main.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragmentContainerView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.carl.demo.viewmodeldemo.TopFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragmentContainerView3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.carl.demo.viewmodeldemo.CenterFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>fragment_top.xml(fragment_bottom.xml相同)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.TopFragment&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">SeekBar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/seekBar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-Fragment文件"><a href="#3-Fragment文件" class="headerlink" title="3.Fragment文件"></a>3.Fragment文件</h3><p>如果使用的是Kotlin，那么在依赖中声明：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;androidx.activity:activity-ktx:1.6.0-alpha04&#x27;</span>  <span class="comment">//在Activity中使用 by viewModels()</span></span><br><span class="line">implementation <span class="string">&#x27;androidx.fragment:fragment-ktx:1.5.0-rc01&#x27;</span>   <span class="comment">//在Fragment中使用 by activityViewModels()</span></span><br></pre></td></tr></table></figure><p>声明 sharedViewModel</p><p>Kotlin:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sharedViewModel: SharedViewModel <span class="keyword">by</span> activityViewModels() </span><br></pre></td></tr></table></figure><p>Java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SharedViewModel sharedViewModel;</span><br><span class="line">sharedViewModel = <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(<span class="built_in">this</span>.requireActivity()).get(SharedViewModel.class);</span><br></pre></td></tr></table></figure><p>监听和改变liveData</p><p>Kotlin:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> liveData = sharedViewModel.progress</span><br><span class="line">liveData.observe(viewLifecycleOwner)&#123; progress -&gt;</span><br><span class="line">    binding.seekBar.progress = progress</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">binding.seekBar.setOnSeekBarChangeListener(<span class="keyword">object</span> : SeekBar.OnSeekBarChangeListener&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onProgressChanged</span><span class="params">(seekBar: <span class="type">SeekBar</span>?, progress: <span class="type">Int</span>, fromUser: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">liveData.value = progress</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartTrackingTouch</span><span class="params">(seekBar: <span class="type">SeekBar</span>?)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStopTrackingTouch</span><span class="params">(seekBar: <span class="type">SeekBar</span>?)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> MutableLiveData&lt;Integer&gt; progressLiveData = sharedViewModel.getProgress();</span><br><span class="line"></span><br><span class="line">progressLiveData.observe(getViewLifecycleOwner(), integer -&gt; binding.seekBar.setProgress(integer));</span><br><span class="line"></span><br><span class="line">binding.seekBar.setOnSeekBarChangeListener(<span class="keyword">new</span> <span class="title class_">SeekBar</span>.OnSeekBarChangeListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onProgressChanged</span><span class="params">(SeekBar seekBar, <span class="type">int</span> progress, <span class="type">boolean</span> fromUser)</span> &#123;</span><br><span class="line">progressLiveData.setValue(progress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartTrackingTouch</span><span class="params">(SeekBar seekBar)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStopTrackingTouch</span><span class="params">(SeekBar seekBar)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最终效果： 拖动任意seekbar，另外一个seekbar也会随之变化</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Gradle 7.1+新版本依赖变化</title>
      <link href="/posts/d18f53bc/"/>
      <url>/posts/d18f53bc/</url>
      
        <content type="html"><![CDATA[<h3 id="1-功能位置迁移"><a href="#1-功能位置迁移" class="headerlink" title="1.功能位置迁移"></a>1.功能位置迁移</h3><p>旧版 <code>Project build.gradle</code>的 <code>buildscript</code>和 <code>allprojects</code>的移动至<code>setting.gradle</code>并改名为<code>pluginManagement</code>和<code>dependencyResolutionManagement</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">pluginManagement &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    repositoriesMode.<span class="keyword">set</span>(RepositoriesMode.FAIL_ON_PROJECT_REPOS)</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">rootProject.name = <span class="string">&quot;Hilt&quot;</span></span><br><span class="line">include <span class="string">&#x27;:app&#x27;</span></span><br></pre></td></tr></table></figure><p><em><strong>如果修改rootProject.name的内容，会在当前工程下新建该内容的文件夹，把原来的文件夹内容移动到新文件夹中</strong></em></p><h3 id="2-dependencies变化"><a href="#2-dependencies变化" class="headerlink" title="2. dependencies变化"></a>2. dependencies变化</h3><p>​<code>Project/build.gradle</code>文件中之前的dependencies文件</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    classpath <span class="string">&quot;com.android.tools.build:gradle:7.0.3&quot;</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">    <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变为：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span> version <span class="string">&#x27;7.1.3&#x27;</span> apply <span class="literal">false</span></span><br><span class="line">    id <span class="string">&#x27;com.android.library&#x27;</span> version <span class="string">&#x27;7.1.3&#x27;</span> apply <span class="literal">false</span></span><br><span class="line">    id(<span class="string">&quot;org.jetbrains.kotlin.android&quot;</span>) version <span class="string">&quot;1.5.30&quot;</span> apply <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引入Hilt依赖的变化"><a href="#引入Hilt依赖的变化" class="headerlink" title="引入Hilt依赖的变化"></a>引入<code>Hilt</code>依赖的变化</h2><p>在<code>Module/build.gradle</code>中：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;dagger.hilt.android.plugin&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖中添加:</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;androidx.appcompat:appcompat:1.4.1&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//Hilt支持</span></span><br><span class="line">    implementation <span class="string">&quot;com.google.dagger:hilt-android:2.28-alpha&quot;</span></span><br><span class="line">    kapt <span class="string">&quot;com.google.dagger:hilt-android-compiler:2.28-alpha&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最重要的一步</strong></p><p>在<code>setting.gradle</code>中添加<code>resolutionStrategy</code></p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pluginManagement &#123;</span><br><span class="line">    resolutionStrategy&#123;</span><br><span class="line">        eachPlugin &#123;</span><br><span class="line">            <span class="keyword">if</span>( requested.id.id == <span class="string">&#x27;dagger.hilt.android.plugin&#x27;</span>) &#123;</span><br><span class="line">                useModule(<span class="string">&quot;com.google.dagger:hilt-android-gradle-plugin:2.28-alpha&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Done!</p>]]></content>
      
      
      <categories>
          
          <category> gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS Touch ID使用</title>
      <link href="/posts/6ff1617e/"/>
      <url>/posts/6ff1617e/</url>
      
        <content type="html"><![CDATA[<ul><li>Swift:</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> LocalAuthentication</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> context <span class="operator">=</span> <span class="type">LAContext</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">loginBtnClick</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="keyword">Any</span>) &#123;</span><br><span class="line">        context <span class="operator">=</span> <span class="type">LAContext</span>()</span><br><span class="line">        context.localizedCancelTitle <span class="operator">=</span> <span class="string">&quot;Cancel&quot;</span>;</span><br><span class="line">        <span class="comment">//        context.localizedFallbackTitle = &quot;&quot;;</span></span><br><span class="line">        <span class="keyword">var</span> error:<span class="type">NSError</span>?</span><br><span class="line">        <span class="keyword">if</span> context.canEvaluatePolicy(.deviceOwnerAuthentication, error: <span class="operator">&amp;</span>error)&#123;</span><br><span class="line">            <span class="keyword">let</span> reason <span class="operator">=</span> <span class="string">&quot;Run App&quot;</span>      </span><br><span class="line">            context.evaluatePolicy(.deviceOwnerAuthentication, localizedReason: reason) &#123; (success, error) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> success&#123;</span><br><span class="line">                    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                        <span class="comment">/// do Something</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">print</span>(error<span class="operator">?</span>.localizedDescription <span class="operator">??</span> <span class="string">&quot;Failed to authenticate&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">print</span>(error<span class="operator">?</span>.localizedDescription <span class="operator">??</span> <span class="string">&quot;Can&#x27;t evaluate policy&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>OC</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;LocalAuthentication/LocalAuthentication.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span>(nonatomic,strong) <span class="type">LAContext</span> <span class="operator">*</span>context;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">IBAction</span>)buttonClick:(id)sender &#123;</span><br><span class="line">    <span class="type">NSError</span> <span class="operator">*</span>error;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.context canEvaluatePolicy:<span class="type">LAPolicyDeviceOwnerAuthentication</span> error:<span class="operator">&amp;</span>error]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.context evaluatePolicy:<span class="type">LAPolicyDeviceOwnerAuthentication</span> localizedReason:@<span class="string">&quot;Cancel&quot;</span> reply:<span class="operator">^</span>(<span class="type">BOOL</span> success, <span class="type">NSError</span> <span class="operator">*</span> _Nullable error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                dispatch_sync(dispatch_get_main_queue(), <span class="operator">^</span>&#123;</span><br><span class="line">                   <span class="comment">/// do Something</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>, error.localizedDescription);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>, error.localizedDescription);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS单例宏定义</title>
      <link href="/posts/bd2b5919/"/>
      <url>/posts/bd2b5919/</url>
      
        <content type="html"><![CDATA[<ul><li>定义:</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// @interface</span><br><span class="line">#define singleton_interface(className) \</span><br><span class="line">+ (className *)shared##className;</span><br><span class="line"></span><br><span class="line">// @implementation</span><br><span class="line">#define singleton_implementation(className) \</span><br><span class="line">static className *_instance; \</span><br><span class="line">+ (id)allocWithZone:(NSZone *)zone \</span><br><span class="line">&#123; \</span><br><span class="line">    static dispatch_once_t onceToken; \</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123; \</span><br><span class="line">        _instance = [super allocWithZone:zone]; \</span><br><span class="line">    &#125;); \</span><br><span class="line">    return _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">+ (className *)shared##className \</span><br><span class="line">&#123; \</span><br><span class="line">    static dispatch_once_t onceToken; \</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123; \</span><br><span class="line">        _instance = [[self alloc] init]; \</span><br><span class="line">    &#125;); \</span><br><span class="line">    return _instance; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>使用:</p><ul><li><p>.h</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface GeoApplication : NSObject</span><br><span class="line">singleton_interface(GeoApplication)</span><br></pre></td></tr></table></figure></li><li><p>.m</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@implementation GeoApplication</span><br><span class="line">singleton_implementation(GeoApplication)</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GeoApplication *geoApplication = [GeoApplication sharedGeoApplication];</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin函数</title>
      <link href="/posts/68bf7d20/"/>
      <url>/posts/68bf7d20/</url>
      
        <content type="html"><![CDATA[<h3 id="函数类型作为返回类型"><a href="#函数类型作为返回类型" class="headerlink" title="函数类型作为返回类型"></a>函数类型作为返回类型</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  println(show(<span class="string">&quot;Demo&quot;</span>))</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">val</span> lambdaFunction = showMethod(<span class="string">&quot;Jack&quot;</span>) <span class="comment">//注意lambdaFunction 这里的类型为(String,Int) -&gt; String</span></span><br><span class="line">    println(lambdaFunction(<span class="string">&quot;Carl&quot;</span>,<span class="number">20</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">(name:<span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;name is <span class="variable">$name</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回类型为函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showMethod</span><span class="params">(name: <span class="type">String</span>)</span></span>: (String,<span class="built_in">Int</span>) -&gt; String &#123;</span><br><span class="line">    println(<span class="string">&quot;name is <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; name: String, age: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        <span class="string">&quot;名字是:<span class="variable">$name</span>,年纪是<span class="variable">$age</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比普通函数，区别就是返回类型</p><h3 id="Nothing类型"><a href="#Nothing类型" class="headerlink" title="Nothing类型"></a>Nothing类型</h3><ul><li>TODO函数的任务就是跑出异常，就是永远别指望运行成功，返回Nothing类型</li></ul><p>函数实现</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">TODO</span><span class="params">(reason: <span class="type">String</span>)</span></span>: <span class="built_in">Nothing</span> = <span class="keyword">throw</span> NotImplementedError(<span class="string">&quot;An operation is not implemented: <span class="variable">$reason</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="反引号中的函数名"><a href="#反引号中的函数名" class="headerlink" title="反引号中的函数名"></a>反引号中的函数名</h3><ul><li>Kotlin可以使用空格和特殊字符对函数命名，不过函数名要用一对反引号括起来。</li><li>为了支持Kotlin和Java互操作，而Kotlin和Java各自有着不同的保留关键字，不能作为函数名，使用反引号括住函数名就能<code>避免任何冲突</code></li></ul><h4 id="便于测试"><a href="#便于测试" class="headerlink" title="便于测试"></a>便于测试</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> `~~fef0h!!特殊函数~~`<span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;特殊函数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    `~~fef0h!!特殊函数~~`()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在编写测试用例的时候可以用</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFunc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static void <span class="keyword">is</span>()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;is invoked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    MyFunc.`<span class="keyword">is</span>`()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面主要是为了Java和Kotlin调用的时候的相互支持</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><ul><li>定义时不取名字的函数，我们称之为匿名函数，<code>匿名函数通常整体传递给其他函数，或者从其他函数返回</code></li><li>匿名函数对Kotlin来说很重要，有了它，我们能够根据需要定制特殊规则，轻松定制标准库里的内置函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin内置函数apply、let、run、with、also等区别</title>
      <link href="/posts/8c331668/"/>
      <url>/posts/8c331668/</url>
      
        <content type="html"><![CDATA[<h3 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h3><p>apply函数可看作一个<code>配置函数</code>，可以传入一个接收者，然后调用一系列函数来配置它以便使用，如果提供lambda给apply函数执行，它会返回配置好的接受者</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> file1 = File(<span class="string">&quot;/User/geowin/hello.txt&quot;</span>)</span><br><span class="line">file1.apply &#123; <span class="comment">// this: File</span></span><br><span class="line">   setWritable(<span class="literal">true</span>)</span><br><span class="line">   setReadable(<span class="literal">true</span>)</span><br><span class="line">   setExecutable(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，调用一个个函数类配置接受者时，变量名就省略了，这是因为，在lambda表达式中，apply能让每个配置函数都作用于接受者，这种行为有时又叫做<code>相关作用域</code>,因为lambda表达式里的所有函数调用都是针对接收者的，或者说，它们是针对接受者的<code>隐式调用</code>.</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>let函数能使某个变量作用于lambda表达式里，让it关键字能引用它。let与apply比较，let会把接受者传给lambda，而apply什么都不传，匿名函数执行完，<code>apply会返回当前接受者，而let会返回lambda的最后一行</code>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = listOf(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>).first().let &#123;</span><br><span class="line">        it * it</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">    println(greeting(<span class="literal">null</span>)) <span class="comment">// name is null</span></span><br><span class="line">    println(greeting(<span class="string">&quot;Jack&quot;</span>)) <span class="comment">// Welcome,Jack.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">greeting</span><span class="params">(name: <span class="type">String</span>?)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span>  name?.let &#123; <span class="string">&quot;Welcome,<span class="variable">$name</span>.&quot;</span> &#125; ?: <span class="string">&quot;name is null&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>光看作用域行为，run和apply差不多，但与apply不同，run函数不返回接收者，run<code>返回的lambda结果</code>，也就是true或者false。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> file = File(<span class="string">&quot;/Users/geowin/Downloads/hello.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> run: <span class="built_in">Boolean</span> = file.run &#123; <span class="comment">//this: File</span></span><br><span class="line">        readText().contains(<span class="string">&quot;hell1o&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(run)</span><br></pre></td></tr></table></figure><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>​with函数是run的变体，他们的功能行为是一样的，但with调用方式不同，调用with时需要<code>值参作为第一个参数传入</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> run = <span class="string">&quot;A new Version&quot;</span>.run &#123;</span><br><span class="line">        length &gt; <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(run)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> with = with(<span class="string">&quot;old&quot;</span>) &#123;</span><br><span class="line">        length &gt; <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(with)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="also"><a href="#also" class="headerlink" title="also"></a>also</h3><p> also函数和let函数功能相似，和let一样，also也是把接受者作为值参传给lambda，但有一点不同：also返回接受者对象，而let返回lambda结果。因为这个差异，also尤其适和<code>针对同一原始对象</code>，利用副作用做事，既然also返回的是接受者对象，你就可以<code>基于原始接受者对象执行额外的链式调用</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fileContents:List&lt;String&gt;</span><br><span class="line"><span class="keyword">val</span> also:File = File(<span class="string">&quot;D://hello.txt&quot;</span>)</span><br><span class="line">    .also &#123;<span class="comment">//it: File</span></span><br><span class="line">        println(it.name)</span><br><span class="line">    &#125;.also &#123;<span class="comment">//it: File</span></span><br><span class="line">        fileContents = it.readLines()</span><br><span class="line">    &#125;</span><br><span class="line">println(fileContents)</span><br></pre></td></tr></table></figure><h3 id="takeIf"><a href="#takeIf" class="headerlink" title="takeIf"></a>takeIf</h3><p>和其他标注函数有点不一样，takeIf函数需要判断lambda中提供的条件表达式，给出true或false结果，如果判断是true，从takeIf函数返回接受者对象，如果是false，则返回null。<code>如果需要判断某个条件是否满足，再决定是否可以赋值变量或者执行某项任务</code>,takeIf就非常有用，概念上讲，takeIf函数类似于if语句，但它的优势是可以直接在对象实例上调用，避免了临时变量赋值的麻烦</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> readText:String? = File(<span class="string">&quot;D://hello.txt&quot;</span>)</span><br><span class="line">    .takeIf &#123; it.exists() &amp;&amp; it.canRead() &#125;</span><br><span class="line">    ?.readText()</span><br><span class="line">println(readText)</span><br></pre></td></tr></table></figure><h3 id="takeUnless"><a href="#takeUnless" class="headerlink" title="takeUnless"></a>takeUnless</h3><p>takeIf辅助函数takeUnless，只有判断你给定的条件<code>结果是false时</code>,takeUnless才会返回返回原始接受者对象。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> text = File(<span class="string">&quot;D://hello.txt&quot;</span>)</span><br><span class="line">        .takeUnless &#123; it.isHidden &#125;</span><br><span class="line">        ?.readText()</span><br><span class="line">    println(text)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Foundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Starting SwiftUI -- 创建表单</title>
      <link href="/posts/92592bf0/"/>
      <url>/posts/92592bf0/</url>
      
        <content type="html"><![CDATA[<p>创建表单</p><p>默认文本视图包装在<code>Form</code>里面，就可以创建基本表单。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Form</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 1&quot;</span>)</span><br><span class="line">      <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tips: 表单最多添加10行，超过10行是不允许的，这是SwiftUI的限制</span><br></pre></td></tr></table></figure><p>如果表单包含11行及以上内容，需要将内容包裹在<code>Group</code>中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Form</span>&#123;</span><br><span class="line">            <span class="type">Group</span>&#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 1&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 2&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 3&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 1&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 2&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 3&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 1&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 2&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 3&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 1&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">Group</span>&#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 4&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 5&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 6&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>Group</code>实际上不会改变用户界面的外观，它们只是让我们绕过SwiftUI在父视图中只包含10个子视图的限制</p><p>如果希望拆分表单成块，应该用<code>Section</code>视图</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Form</span>&#123;</span><br><span class="line">                <span class="type">Section</span>&#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 1&quot;</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 2&quot;</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 3&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Section</span>&#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 4&quot;</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 5&quot;</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 6&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/LoTERzD7VXFsUt4.png" alt="0310-01"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Starting SwiftUI -- Modifying Program State</title>
      <link href="/posts/9a9dd6a7/"/>
      <url>/posts/9a9dd6a7/</url>
      
        <content type="html"><![CDATA[<p>在SwiftUI开发人员中有一种说法是，我们的“视图是他们状态的函数(views are a function of their state)”，但这虽然只是少数几句话，但一开始对您来说可能毫无意义。</p><p>如果您正在玩格斗游戏，那么您可能会丧生，夺取一些积分，收集一些财宝，甚至可能会捡起一些强大的武器。在编程中，我们称这些为<em>状态</em>-描述游戏当前<em>状态</em>的有效设置集合。</p><p>当您退出游戏时，该状态将被保存，并且当您稍后返回游戏时，您可以重新加载游戏以回到原来的状态。但是，<em>在</em>您玩游戏时，这全都叫做<em>state</em>：所有整数，字符串，布尔值等等，都存储在RAM中以描述您现在正在做什么。</p><p>当我们说SwiftUI的视图是其状态的函数时，我们的意思是用户界面的外观（人们可以看到的东西以及可以与之交互的东西）由程序的状态决定。例如，他们只有在文本字段中输入自己的姓名后才能点击“继续”。</p><p>这本身听起来似乎很明显，但这实际上与之前使用的替代方案有很大不同：您的用户界面由一系列事件决定。因此，用户现在看到的是因为他们已经使用您的应用程序已有一段时间，利用了各种功能，可能已经登录或刷新了数据，等等。</p><p>“事件顺序”方法意味着很难存储应用程序的状态，因为获取完美状态的唯一方法是回放用户执行的事件的确切顺序。这就是为什么如此多的应用程序甚至根本不尝试保存状态的原因-您的新闻应用程序将不会返回到您正在阅读的上一篇文章，Twitter不会记住您是否正在键入内容。回复某人，Photoshop会忘记您堆积的任何撤消状态。</p><p>让我们通过一个按钮将其付诸实践，该按钮可以在SwiftUI中使用标题字符串和一个动作闭合创建，并在按下按钮时运行该闭合：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tapCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Tap Count: <span class="subst">\(tapCount)</span>&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.tapCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码看起来足够合理：创建一个显示“点击计数”的按钮，再加上点击该按钮的次数，然后在<code>tapCount</code>每次点击该按钮时加1 。</p><p>但是，它不会建立。那不是有效的Swift代码。您看到的<code>ContentView</code>是一个结构，可以将其创建为常量。如果回想起当您了解结构时，这意味着它是<em>不可变的</em>–我们不能随意更改其值。</p><p>例如，在创建要更改属性的结构方法时，我们需要添加<code>mutating</code>关键字：<code>mutating func doSomeWork()</code>。但是，Swift不允许我们对计算的属性进行突变，这意味着我们不能编写<code>mutating var body: some View</code>-只是不允许这样做。</p><p>似乎我们陷入了僵局：我们希望能够在程序运行时更改值，但是Swift不允许我们这样做，因为我们的视图是结构。</p><p>幸运的是，Swift为我们提供了一个特殊的解决方案，称为<em>属性包装器</em>：可以在属性之前放置一个特殊的属性，以有效地赋予它们超能力。在存储简单的程序状态（如点击按钮的次数）的情况下，我们可以使用来自SwiftUI的名为的属性包装器<code>@State</code>，如下所示</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> tapCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Tap Count: <span class="subst">\(tapCount)</span>&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.tapCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很小的变化足以使我们的程序正常工作，因此您现在可以构建它并进行尝试。</p><p><code>@State</code>允许我们解决结构的局限性：我们知道由于结构是固定的，我们无法更改其属性，但<code>@State</code>允许该值由SwiftUI单独存储在<em>可以</em>修改的位置。</p><p>是的，感觉有点像作弊，您可能想知道为什么我们不使用类，而是<em>可以</em>自由修改它们。但是请相信我，这是值得的：随着您的进步，您将了解到SwiftUI经常破坏并重新创建您的结构，因此将它们保持为较小且简单的结构对于性能至关重要。</p><p><strong>提示：</strong>有几种方法可以在SwiftUI中存储程序状态，您将学习所有这些方法。<code>@State</code>专为存储在一个视图中的简单属性而设计。因此，Apple建议我们<code>private</code>向这些属性添加访问控制，如下所示：<code>@State private var tapCount = 0</code>。</p><p>译: <a href="https://www.hackingwithswift.com/books/ios-swiftui/modifying-program-state">Modifying Program State</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Starting SwiftUI -- NavigationBar</title>
      <link href="/posts/1786137e/"/>
      <url>/posts/1786137e/</url>
      
        <content type="html"><![CDATA[<p>默认情况下，iOS允许我们在屏幕上的任何地方放置内容，包括在系统时钟和主指示器下。这看起来不太好，这就是为什么默认情况下，SwiftUI会确保组件放置在系统UI或设备圆角无法覆盖的区域中，这一区域称为安全区域。</p><p>在iPhone 11上，安全区域的范围从略低于刘海到略高于主指示器（底部白条）。您可以在这样的用户界面中看到它的运行：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Form</span>&#123;</span><br><span class="line">            <span class="type">Section</span>&#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello Swift&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表单是可以上下滚动的，向上滑动的时候，状态栏可能会覆盖表单，影响阅读。</p><p>常见的解决办法是，在顶部增加一个导航栏<code>NavagationView</code>。导航栏有标题和按钮，在SwiftUI中，它们还让我们能够在用户执行操作时显示新视图。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span>&#123;</span><br><span class="line">            <span class="type">Form</span>&#123;</span><br><span class="line">                <span class="type">Section</span>&#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 1&quot;</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 2&quot;</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 3&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们尝试添加一个修饰符来添加导航栏标题:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NavigationView</span>&#123;</span><br><span class="line">            <span class="type">Form</span>&#123;</span><br><span class="line">                <span class="type">Section</span>&#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 1&quot;</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 2&quot;</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI 3&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;SwiftUI&quot;</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>也可以在右侧的视图检查器中操作：</p><p>将光标放在<code>Form</code>表单处，在视图检查器中的 <code>Add Modifier</code>中搜索<code>Navagation Title</code> 输入<code>SwiftUI</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/wXiAFEnBZKTYk6h.png" alt="0310-02"></p><p>当我们将<code>.navigationBarTitle()</code>修饰符附加到表单时，Swift实际上会创建一个新表单，该表单具有导航栏标题和您提供的所有现有内容。</p><p>将标题添加到导航栏时，您会注意到该标题使用了大字体。您可以使用稍微不同的<code>navigationBarTitle（）</code>调用获得一个小字体：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.navigationBarTitle(<span class="string">&quot;SwiftUI&quot;</span>,displayMode: .inline)</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.navigationTitle(<span class="string">&quot;SwiftUI&quot;</span>)</span><br><span class="line">.navigationBarTitleDisplayMode(.inline)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jekyll 运行错误</title>
      <link href="/posts/c9b7198f/"/>
      <url>/posts/c9b7198f/</url>
      
        <content type="html"><![CDATA[<p><code>Jekyll</code> 运行时发生错误:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/Library/Ruby/Gems/2.6.0/gems/bundler-2.1.4/lib/bundler/runtime.rb:312:in `check_for_activated_spec!&#x27;:</span><br><span class="line">You have already activated i18n 1.8.3, but your Gemfile requires i18n 0.9.5.</span><br><span class="line">Prepending `bundle exec` to your command may solve this. (Gem::LoadError)</span><br></pre></td></tr></table></figure><p>​解决办法:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bundle update</span><br></pre></td></tr></table></figure><p> 修改 <code>Gemfile.lock</code> 将 <code>i18n</code> 配置升级为<code>1.8.3</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bundle exec jekyll serve</span><br></pre></td></tr></table></figure><p>再次运行项目</p>]]></content>
      
      
      <categories>
          
          <category> Jekyll </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jekyll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课(目录)</title>
      <link href="/posts/be9f17d6/"/>
      <url>/posts/be9f17d6/</url>
      
        <content type="html"><![CDATA[<h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><h4 id="Kotlin编程第一课–-基础篇-01-Kotlin基础语法：正式开启学习之旅"><a href="#Kotlin编程第一课–-基础篇-01-Kotlin基础语法：正式开启学习之旅" class="headerlink" title="Kotlin编程第一课–(基础篇)01  Kotlin基础语法：正式开启学习之旅"></a><a href="https://devsu.top/posts/3dc00e96/">Kotlin编程第一课–(基础篇)01  Kotlin基础语法：正式开启学习之旅</a></h4><h4 id="Kotlin编程第一课–-基础篇-02-面向对象：理解Kotlin设计者的良苦用心"><a href="#Kotlin编程第一课–-基础篇-02-面向对象：理解Kotlin设计者的良苦用心" class="headerlink" title="Kotlin编程第一课–(基础篇)02  面向对象：理解Kotlin设计者的良苦用心"></a><a href="https://devsu.top/posts/25decd61">Kotlin编程第一课–(基础篇)02  面向对象：理解Kotlin设计者的良苦用心</a></h4><h4 id="Kotlin编程第一课–-基础篇-03-Kotlin原理：编译器在幕后干了哪些“好事”？"><a href="#Kotlin编程第一课–-基础篇-03-Kotlin原理：编译器在幕后干了哪些“好事”？" class="headerlink" title="Kotlin编程第一课–(基础篇)03  Kotlin原理：编译器在幕后干了哪些“好事”？"></a><a href="https://devsu.top/posts/e0b30b8/">Kotlin编程第一课–(基础篇)03  Kotlin原理：编译器在幕后干了哪些“好事”？</a></h4><h4 id="Kotlin编程第一课–-基础篇-04-实战：构建一个Kotlin版本的四则运算计算器"><a href="#Kotlin编程第一课–-基础篇-04-实战：构建一个Kotlin版本的四则运算计算器" class="headerlink" title="Kotlin编程第一课–(基础篇)04 | 实战：构建一个Kotlin版本的四则运算计算器"></a><a href="https://devsu.top/posts/9850cd08/">Kotlin编程第一课–(基础篇)04 | 实战：构建一个Kotlin版本的四则运算计算器</a></h4><h4 id="Kotlin编程第一课–-基础篇-05-object关键字：你到底有多少种用法？"><a href="#Kotlin编程第一课–-基础篇-05-object关键字：你到底有多少种用法？" class="headerlink" title="Kotlin编程第一课–(基础篇)05  object关键字：你到底有多少种用法？"></a><a href="https://devsu.top/posts/38dca859/">Kotlin编程第一课–(基础篇)05  object关键字：你到底有多少种用法？</a></h4><h4 id="Kotlin编程第一课–-基础篇-06-扩展：你的能力边界到底在哪里？"><a href="#Kotlin编程第一课–-基础篇-06-扩展：你的能力边界到底在哪里？" class="headerlink" title="Kotlin编程第一课–(基础篇)06  扩展：你的能力边界到底在哪里？"></a><a href="https://devsu.top/posts/85d82fa8/">Kotlin编程第一课–(基础篇)06  扩展：你的能力边界到底在哪里？</a></h4><h4 id="Kotlin编程第一课–-基础篇-07-高阶函数：为什么说函数是Kotlin的“一等公民”？"><a href="#Kotlin编程第一课–-基础篇-07-高阶函数：为什么说函数是Kotlin的“一等公民”？" class="headerlink" title="Kotlin编程第一课–(基础篇)07  高阶函数：为什么说函数是Kotlin的“一等公民”？"></a><a href="https://devsu.top/posts/15c1fa4b/">Kotlin编程第一课–(基础篇)07  高阶函数：为什么说函数是Kotlin的“一等公民”？</a></h4><h4 id="Kotlin编程第一课–-基础篇-08-实战：用Kotlin写一个英语词频统计程序"><a href="#Kotlin编程第一课–-基础篇-08-实战：用Kotlin写一个英语词频统计程序" class="headerlink" title="Kotlin编程第一课–(基础篇)08  实战：用Kotlin写一个英语词频统计程序"></a><a href="https://devsu.top/posts/90cef85a/">Kotlin编程第一课–(基础篇)08  实战：用Kotlin写一个英语词频统计程序</a></h4><h4 id="Kotlin编程第一课–-基础篇-加餐一-初识Kotlin函数式编程"><a href="#Kotlin编程第一课–-基础篇-加餐一-初识Kotlin函数式编程" class="headerlink" title="Kotlin编程第一课–(基础篇)加餐一  初识Kotlin函数式编程"></a><a href="https://devsu.top/posts/e851a3a2/">Kotlin编程第一课–(基础篇)加餐一  初识Kotlin函数式编程</a></h4><h4 id="Kotlin编程第一课–-基础篇-09-委托：你为何总是被低估？"><a href="#Kotlin编程第一课–-基础篇-09-委托：你为何总是被低估？" class="headerlink" title="Kotlin编程第一课–(基础篇)09  委托：你为何总是被低估？"></a><a href="https://devsu.top/posts/5db0fd8d/">Kotlin编程第一课–(基础篇)09  委托：你为何总是被低估？</a></h4><h4 id="Kotlin编程第一课–-基础篇-10-泛型：逆变or协变，傻傻分不清？"><a href="#Kotlin编程第一课–-基础篇-10-泛型：逆变or协变，傻傻分不清？" class="headerlink" title="Kotlin编程第一课–(基础篇)10  泛型：逆变or协变，傻傻分不清？"></a><a href="https://devsu.top/posts/91ec5a6c/">Kotlin编程第一课–(基础篇)10  泛型：逆变or协变，傻傻分不清？</a></h4><h4 id="Kotlin编程第一课–-基础篇-11-注解与反射：进阶必备技能"><a href="#Kotlin编程第一课–-基础篇-11-注解与反射：进阶必备技能" class="headerlink" title="Kotlin编程第一课–(基础篇)11  注解与反射：进阶必备技能"></a><a href="https://devsu.top/posts/f3ad1558/">Kotlin编程第一课–(基础篇)11  注解与反射：进阶必备技能</a></h4><h4 id="Kotlin编程第一课–-基础篇-12-实战：用Kotlin实现一个网络请求框架KtHttp"><a href="#Kotlin编程第一课–-基础篇-12-实战：用Kotlin实现一个网络请求框架KtHttp" class="headerlink" title="Kotlin编程第一课–(基础篇)12  实战：用Kotlin实现一个网络请求框架KtHttp"></a><a href="https://devsu.top/posts/e45ff726/">Kotlin编程第一课–(基础篇)12  实战：用Kotlin实现一个网络请求框架KtHttp</a></h4><h4 id="Kotlin编程第一课–-基础篇-加餐二-什么是“表达式思维”？"><a href="#Kotlin编程第一课–-基础篇-加餐二-什么是“表达式思维”？" class="headerlink" title="Kotlin编程第一课–(基础篇)加餐二  什么是“表达式思维”？"></a><a href="https://devsu.top/posts/11b33035/">Kotlin编程第一课–(基础篇)加餐二  什么是“表达式思维”？</a></h4><h4 id="Kotlin编程第一课–-基础篇-加餐三-什么是“不变性思维”？"><a href="#Kotlin编程第一课–-基础篇-加餐三-什么是“不变性思维”？" class="headerlink" title="Kotlin编程第一课–(基础篇)加餐三  什么是“不变性思维”？"></a><a href="https://devsu.top/posts/210fbe34/">Kotlin编程第一课–(基础篇)加餐三  什么是“不变性思维”？</a></h4><h4 id="Kotlin编程第一课–-基础篇-加餐四-什么是“空安全思维”？"><a href="#Kotlin编程第一课–-基础篇-加餐四-什么是“空安全思维”？" class="headerlink" title="Kotlin编程第一课–(基础篇)加餐四  什么是“空安全思维”？"></a><a href="https://devsu.top/posts/f0ec5bb9/">Kotlin编程第一课–(基础篇)加餐四  什么是“空安全思维”？</a></h4><h3 id="特别放送篇"><a href="#特别放送篇" class="headerlink" title="特别放送篇"></a>特别放送篇</h3><h4 id="Kotlin编程第一课–-特别放送-刷题计划（一）-当Kotlin遇上LeetCode"><a href="#Kotlin编程第一课–-特别放送-刷题计划（一）-当Kotlin遇上LeetCode" class="headerlink" title="Kotlin编程第一课–(特别放送)刷题计划（一） 当Kotlin遇上LeetCode"></a><a href="https://devsu.top/posts/a7227a95/">Kotlin编程第一课–(特别放送)刷题计划（一） 当Kotlin遇上LeetCode</a></h4><h4 id="Kotlin编程第一课–-特别放送-刷题计划（二）-一题三解，搞定版本号判断"><a href="#Kotlin编程第一课–-特别放送-刷题计划（二）-一题三解，搞定版本号判断" class="headerlink" title="Kotlin编程第一课–(特别放送)刷题计划（二） 一题三解，搞定版本号判断"></a><a href="https://devsu.top/posts/b0ff92f3/">Kotlin编程第一课–(特别放送)刷题计划（二） 一题三解，搞定版本号判断</a></h4><h4 id="Kotlin编程第一课–-春节特别放松-春节刷题计划（三）-一题双解，-方程"><a href="#Kotlin编程第一课–-春节特别放松-春节刷题计划（三）-一题双解，-方程" class="headerlink" title="Kotlin编程第一课–(春节特别放松)春节刷题计划（三） 一题双解， 方程"></a><a href="https://devsu.top/posts/4b068051/">Kotlin编程第一课–(春节特别放松)春节刷题计划（三） 一题双解， 方程</a></h4><h4 id="Kotlin编程第一课–-特别放送-刷题计划（四）-一题三解，搞定分式加减法"><a href="#Kotlin编程第一课–-特别放送-刷题计划（四）-一题三解，搞定分式加减法" class="headerlink" title="Kotlin编程第一课–(特别放送)刷题计划（四） 一题三解，搞定分式加减法"></a><a href="https://devsu.top/posts/9ab13196/">Kotlin编程第一课–(特别放送)刷题计划（四） 一题三解，搞定分式加减法</a></h4><h3 id="协程篇"><a href="#协程篇" class="headerlink" title="协程篇"></a>协程篇</h3><h4 id="Kotlin编程第一课–-协程篇-13-什么是“协程思维模型”？"><a href="#Kotlin编程第一课–-协程篇-13-什么是“协程思维模型”？" class="headerlink" title="Kotlin编程第一课–(协程篇)13 什么是“协程思维模型”？"></a><a href="https://devsu.top/posts/e6b226ff/">Kotlin编程第一课–(协程篇)13 什么是“协程思维模型”？</a></h4><h4 id="Kotlin编程第一课–-协程篇-14-如何启动协程？"><a href="#Kotlin编程第一课–-协程篇-14-如何启动协程？" class="headerlink" title="Kotlin编程第一课–(协程篇)14  如何启动协程？"></a><a href="https://devsu.top/posts/608fa63f/">Kotlin编程第一课–(协程篇)14  如何启动协程？</a></h4><h4 id="Kotlin编程第一课–-协程篇-15-挂起函数：Kotlin协程的核心"><a href="#Kotlin编程第一课–-协程篇-15-挂起函数：Kotlin协程的核心" class="headerlink" title="Kotlin编程第一课–(协程篇)15  挂起函数：Kotlin协程的核心"></a><a href="https://devsu.top/posts/96509131/">Kotlin编程第一课–(协程篇)15  挂起函数：Kotlin协程的核心</a></h4><h4 id="Kotlin编程第一课–-协程篇-16-Job：协程也有生命周期吗？"><a href="#Kotlin编程第一课–-协程篇-16-Job：协程也有生命周期吗？" class="headerlink" title="Kotlin编程第一课–(协程篇)16  Job：协程也有生命周期吗？"></a><a href="https://devsu.top/posts/5b46e6ea/">Kotlin编程第一课–(协程篇)16  Job：协程也有生命周期吗？</a></h4><h4 id="Kotlin编程第一课–-协程篇-17-Context：万物皆为Context？"><a href="#Kotlin编程第一课–-协程篇-17-Context：万物皆为Context？" class="headerlink" title="Kotlin编程第一课–(协程篇)17  Context：万物皆为Context？"></a><a href="https://devsu.top/posts/12ca5097/">Kotlin编程第一课–(协程篇)17  Context：万物皆为Context？</a></h4><h4 id="Kotlin编程第一课–-协程篇-18-实战：让KtHttp支持挂起函数"><a href="#Kotlin编程第一课–-协程篇-18-实战：让KtHttp支持挂起函数" class="headerlink" title="Kotlin编程第一课–(协程篇)18  实战：让KtHttp支持挂起函数"></a><a href="https://devsu.top/posts/95448d7b/">Kotlin编程第一课–(协程篇)18  实战：让KtHttp支持挂起函数</a></h4><h4 id="Kotlin编程第一课–-协程篇-期中考试-用Kotlin实现图片处理程序"><a href="#Kotlin编程第一课–-协程篇-期中考试-用Kotlin实现图片处理程序" class="headerlink" title="Kotlin编程第一课–(协程篇)期中考试  用Kotlin实现图片处理程序"></a><a href="https://devsu.top/posts/849ea54c/">Kotlin编程第一课–(协程篇)期中考试  用Kotlin实现图片处理程序</a></h4><h4 id="Kotlin编程第一课–-协程篇-题目解答-期中考试版本参考实现"><a href="#Kotlin编程第一课–-协程篇-题目解答-期中考试版本参考实现" class="headerlink" title="Kotlin编程第一课–(协程篇)题目解答  期中考试版本参考实现"></a><a href="https://devsu.top/posts/aa27c6dc/">Kotlin编程第一课–(协程篇)题目解答  期中考试版本参考实现</a></h4><h4 id="kotlin编程第一课–-协程篇-19-channel：为什么说channel是热的"><a href="#kotlin编程第一课–-协程篇-19-channel：为什么说channel是热的" class="headerlink" title="kotlin编程第一课–(协程篇)19  channel：为什么说channel是热的?"></a><a href="https://devsu.top/posts/8f28ab97/">kotlin编程第一课–(协程篇)19  channel：为什么说channel是热的?</a></h4><h4 id="Kotlin编程第一课–-协程篇-20-Flow：为什么说Flow是“冷”的？"><a href="#Kotlin编程第一课–-协程篇-20-Flow：为什么说Flow是“冷”的？" class="headerlink" title="Kotlin编程第一课–(协程篇)20  Flow：为什么说Flow是“冷”的？"></a><a href="https://devsu.top/posts/e7c23ba1/">Kotlin编程第一课–(协程篇)20  Flow：为什么说Flow是“冷”的？</a></h4><h4 id="Kotlin编程第一课–-协程篇-21-select：到底是在选择什么？"><a href="#Kotlin编程第一课–-协程篇-21-select：到底是在选择什么？" class="headerlink" title="Kotlin编程第一课–(协程篇)21  select：到底是在选择什么？"></a><a href="https://devsu.top/posts/4b3d9f4d/">Kotlin编程第一课–(协程篇)21  select：到底是在选择什么？</a></h4><h4 id="Kotlin编程第一课–-协程篇-22-并发：协程不需要处理同步吗？"><a href="#Kotlin编程第一课–-协程篇-22-并发：协程不需要处理同步吗？" class="headerlink" title="Kotlin编程第一课–(协程篇)22  并发：协程不需要处理同步吗？"></a><a href="https://devsu.top/posts/778b5847/">Kotlin编程第一课–(协程篇)22  并发：协程不需要处理同步吗？</a></h4><h4 id="Kotlin编程第一课–-协程篇-23-异常：try-catch-坑！"><a href="#Kotlin编程第一课–-协程篇-23-异常：try-catch-坑！" class="headerlink" title="Kotlin编程第一课–(协程篇)23  异常：try-catch 坑！"></a><a href="https://devsu.top/posts/a3460e51/">Kotlin编程第一课–(协程篇)23  异常：try-catch 坑！</a></h4><h4 id="Kotlin编程第一课–-协程篇-24-实战：让KtHttp支持Flow"><a href="#Kotlin编程第一课–-协程篇-24-实战：让KtHttp支持Flow" class="headerlink" title="Kotlin编程第一课–(协程篇)24  实战：让KtHttp支持Flow"></a><a href="https://devsu.top/posts/6532289/">Kotlin编程第一课–(协程篇)24  实战：让KtHttp支持Flow</a></h4><h3 id="答疑篇"><a href="#答疑篇" class="headerlink" title="答疑篇"></a>答疑篇</h3><h4 id="Kotlin编程第一课–-答疑篇-答疑（一）-Java和Kotlin到底谁好谁坏？"><a href="#Kotlin编程第一课–-答疑篇-答疑（一）-Java和Kotlin到底谁好谁坏？" class="headerlink" title="Kotlin编程第一课–(答疑篇)答疑（一）| Java和Kotlin到底谁好谁坏？"></a><a href="https://devsu.top/posts/85d82fa8/">Kotlin编程第一课–(答疑篇)答疑（一）| Java和Kotlin到底谁好谁坏？</a></h4><h3 id="源码篇"><a href="#源码篇" class="headerlink" title="源码篇"></a>源码篇</h3><h4 id="Kotlin编程第一课–-源码篇-25-集合操作符：你也会“看完就忘”吗？"><a href="#Kotlin编程第一课–-源码篇-25-集合操作符：你也会“看完就忘”吗？" class="headerlink" title="Kotlin编程第一课–(源码篇)25  集合操作符：你也会“看完就忘”吗？"></a><a href="https://devsu.top/posts/e47f1d17/">Kotlin编程第一课–(源码篇)25  集合操作符：你也会“看完就忘”吗？</a></h4><h4 id="Kotlin编程第一课–-源码篇-26-协程源码的地图：如何读源码才不会迷失？"><a href="#Kotlin编程第一课–-源码篇-26-协程源码的地图：如何读源码才不会迷失？" class="headerlink" title="Kotlin编程第一课–(源码篇)26  协程源码的地图：如何读源码才不会迷失？"></a><a href="https://devsu.top/posts/80bc5780/">Kotlin编程第一课–(源码篇)26  协程源码的地图：如何读源码才不会迷失？</a></h4><h4 id="Kotlin编程第一课–-源码篇-27-图解挂起函数：原来你就是个状态机？"><a href="#Kotlin编程第一课–-源码篇-27-图解挂起函数：原来你就是个状态机？" class="headerlink" title="Kotlin编程第一课–(源码篇)27  图解挂起函数：原来你就是个状态机？"></a><a href="https://devsu.top/posts/875d6a31/">Kotlin编程第一课–(源码篇)27  图解挂起函数：原来你就是个状态机？</a></h4><h4 id="Kotlin编程第一课–-源码篇-28-launch的背后到底发生了什么？"><a href="#Kotlin编程第一课–-源码篇-28-launch的背后到底发生了什么？" class="headerlink" title="Kotlin编程第一课–(源码篇)28  launch的背后到底发生了什么？"></a><a href="https://devsu.top/posts/e184d855/">Kotlin编程第一课–(源码篇)28  launch的背后到底发生了什么？</a></h4><h4 id="Kotlin编程第一课–-源码篇-加餐五-深入理解协程基础元素"><a href="#Kotlin编程第一课–-源码篇-加餐五-深入理解协程基础元素" class="headerlink" title="Kotlin编程第一课–(源码篇)加餐五  深入理解协程基础元素"></a><a href="https://devsu.top/posts/4c362f78/">Kotlin编程第一课–(源码篇)加餐五  深入理解协程基础元素</a></h4><h4 id="Kotlin编程第一课–-源码篇-29-Dispatchers是如何工作的？"><a href="#Kotlin编程第一课–-源码篇-29-Dispatchers是如何工作的？" class="headerlink" title="Kotlin编程第一课–(源码篇)29  Dispatchers是如何工作的？"></a><a href="https://devsu.top/posts/c0627888/">Kotlin编程第一课–(源码篇)29  Dispatchers是如何工作的？</a></h4><h4 id="Kotlin编程第一课–-源码篇-30-CoroutineScope是如何管理协程的？"><a href="#Kotlin编程第一课–-源码篇-30-CoroutineScope是如何管理协程的？" class="headerlink" title="Kotlin编程第一课–(源码篇)30  CoroutineScope是如何管理协程的？"></a><a href="https://devsu.top/posts/4f3df7f8/">Kotlin编程第一课–(源码篇)30  CoroutineScope是如何管理协程的？</a></h4><h4 id="Kotlin编程第一课–-源码篇-31-图解Channel：如何理解它的CSP通信模型？"><a href="#Kotlin编程第一课–-源码篇-31-图解Channel：如何理解它的CSP通信模型？" class="headerlink" title="Kotlin编程第一课–(源码篇)31  图解Channel：如何理解它的CSP通信模型？"></a><a href="https://devsu.top/posts/6017bcef/">Kotlin编程第一课–(源码篇)31  图解Channel：如何理解它的CSP通信模型？</a></h4><h4 id="Kotlin编程第一课–-源码篇-32-图解Flow：原来你是只纸老虎？"><a href="#Kotlin编程第一课–-源码篇-32-图解Flow：原来你是只纸老虎？" class="headerlink" title="Kotlin编程第一课–(源码篇)32  图解Flow：原来你是只纸老虎？"></a><a href="https://devsu.top/posts/11989076/">Kotlin编程第一课–(源码篇)32  图解Flow：原来你是只纸老虎？</a></h4><h3 id="Android项目篇"><a href="#Android项目篇" class="headerlink" title="Android项目篇"></a>Android项目篇</h3><h4 id="Kotlin编程第一课–-Android项目篇-33-Java-Android开发者还会有未来吗？"><a href="#Kotlin编程第一课–-Android项目篇-33-Java-Android开发者还会有未来吗？" class="headerlink" title="Kotlin编程第一课–(Android项目篇)33 Java Android开发者还会有未来吗？"></a><a href="https://devsu.top/posts/11a43e5b/">Kotlin编程第一课–(Android项目篇)33 Java Android开发者还会有未来吗？</a></h4><h4 id="Kotlin编程第一课–-Android项目篇-34-Kotlin与Jetpack简直是天生一对！"><a href="#Kotlin编程第一课–-Android项目篇-34-Kotlin与Jetpack简直是天生一对！" class="headerlink" title="Kotlin编程第一课–(Android项目篇)34  Kotlin与Jetpack简直是天生一对！"></a><a href="https://devsu.top/posts/b63f0842/">Kotlin编程第一课–(Android项目篇)34  Kotlin与Jetpack简直是天生一对！</a></h4><h4 id="Kotlin编程第一课–-Android项目篇-35-用Kotlin写一个GitHub-Trending-App"><a href="#Kotlin编程第一课–-Android项目篇-35-用Kotlin写一个GitHub-Trending-App" class="headerlink" title="Kotlin编程第一课–(Android项目篇)35  用Kotlin写一个GitHub Trending App"></a><a href="https://devsu.top/posts/58999c28/">Kotlin编程第一课–(Android项目篇)35  用Kotlin写一个GitHub Trending App</a></h4>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(Android项目篇)35  用Kotlin写一个GitHub Trending App</title>
      <link href="/posts/58999c28/"/>
      <url>/posts/58999c28/</url>
      
        <content type="html"><![CDATA[<p>这节课，我们一起来用 Kotlin 和 Jetpack 写一个简单的 Android 应用。为了便于理解，这个应用的功能会尽量简单，即使你对 Android 不是特别熟悉，跟着课程的引导，你也能轻松完成。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在之前的课程中，我们的实战项目都是基于 JVM 的，并没有涉及过 Android 相关的配置。因此，如果你的电脑没有 Android 开发的环境的话，那么可能需要做一些额外的配置。当然，在你已有 Java 环境的前提下，想要配置 Android 开发环境并不麻烦，你可以去搜索一些相关的Android 开发环境配置的教程。</p><p>那么，要进行 Android 开发，我们可以使用 IntelliJ，也可以使用 Android Studio，后者针对 Android 开发做了很多定制化，也是免费的，这里我也建议你去下载 Android Studio。</p><p>当配置好所有的环境以后，我们就可以像创建 Kotlin 工程一样，来创建一个新的 Android 工程了。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/f9/00/f9f6b73c7a09bac3ae5b3e15ff997000.gif?wh=900x650" alt="img"></p><p>然后，当你创建好工程以后，就可以尝试运行代码了，这时候你大概率会看到一个 Hello World 的初始界面。</p><p>接下来，我们就正式进入开发吧。</p><h2 id="MVVM-架构"><a href="#MVVM-架构" class="headerlink" title="MVVM 架构"></a>MVVM 架构</h2><p>Android 应用的架构，在过去的这些年里一直都在变化。最开始的 Android 其实没有什么明确的架构，大家习惯于把所有代码都往 Activity 里放，直到后来才开始有了 MVC、MVP 以及 MVVM。</p><p>那么，站在现在这个时间节点上，当前 Android 中比较主流、比较受 Google 推崇的，是 MVVM 架构。这节课，我们就以 <strong>MVVM 架构</strong>为基础，并且也尝试<strong>结合 Clean 架构</strong>来进行一些实践。</p><p>关于 MVVM 架构，它其实就是代表了 Model — View — ViewModel，如果将其对应到 Android 当中来的话，它们之间大概会是这样的关系：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/41/04/416e9447d2cfbe726154c25b6317f404.png?wh=771x232" alt="img"></p><p>MVVM 其实是一种广泛存在的架构模式，在 Android 当中也有类似的实现。ViewModel 会连接 View 和 Model，View 和 Model 之间是隔离开的。而 View 和 ViewModel 之间，也往往会存在数据绑定，这里的数据绑定可以是一个组件（如 Android 的 DataBinding），也可以是由代码来完成绑定。</p><p>而相比 MVVM 架构，Clean 架构则是一种更加抽象的思维模式了。它将整个架构大致分为三层，由外到内分别是：表现层、领域层、数据层。它们之间的依赖关系也是由外到内的。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/ae/0a/ae182ae3b475ff0289ce3653db6ec70a.png?wh=1656x1216" alt="img" style="zoom: 50%;" /><p>不过 <strong>Clean 架构只是一种思想</strong>，当我们尝试在 Android 中落地应用的时候，其实并不一定会完全按照这里的架构图来设计，目前比较常见的架构是下面这样的：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/5a/b2/5aa98ff8962f90dd47b479fee303dcb2.png?wh=928x687" alt="img" style="zoom: 67%;" /><p>可以看到，上面这个架构，融入了 MVVM 与 Clean 两个架构的特点，让我们从下往上看：</p><ul><li><strong>实体层</strong>，这里其实就是我们平时定义的一些 Bean 的实体类，用 Kotlin 的数据类即可。</li><li><strong>数据层</strong>，这里一般会有两个概念，分别是 DataSource 与 Repository，前者代表数据源，后者代表数据仓库。数据源一般会区分本地数据源和远程数据源，而数据仓库则会统筹它们两者。</li><li><strong>领域层</strong>，这里一般会是一些相对具体一些的业务逻辑。</li><li><strong>表现层</strong>，这里则是接近 UI 展示的上层逻辑了。</li></ul><p>好，架构分析完了，接下来我们看看代码该怎么写，我们还是按照架构的分层，从下往上来实现。</p><h3 id="实体层"><a href="#实体层" class="headerlink" title="实体层"></a>实体层</h3><p>首先，我们要定义一个密封类，来统一不同情况下的数据形式。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">ResultX</span>&lt;<span class="type">out R: Any</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Success</span>&lt;<span class="type">out T: Any</span>&gt;(<span class="keyword">val</span> <span class="keyword">data</span>: T) : ResultX&lt;T&gt;()</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> exception: Exception) : ResultX&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line">    <span class="keyword">object</span> Loading : ResultX&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">is</span> Success&lt;*&gt; -&gt; <span class="string">&quot;Success[data=<span class="variable">$data</span>]&quot;</span></span><br><span class="line">            <span class="keyword">is</span> Error -&gt; <span class="string">&quot;Error[exception=<span class="variable">$exception</span>]&quot;</span></span><br><span class="line">            Loading -&gt; <span class="string">&quot;Loading&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们利用密封类和泛型，将数据的成功、失败、加载中都统一了起来。类似这样的做法，我们在课程的第 2 讲里也已经提到过了。</p><p>然后，由于我们是要实现一个 GitHub Trending 的应用，所以这里我们只需要找一个开源的 API，通过分析它的 JSON 结构，然后定义出具体的 Data Class 就行了。这一步，我们其实在第 12 讲当中就已经完成了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">RepoList</span>(</span><br><span class="line">    <span class="keyword">var</span> count: <span class="built_in">Int</span>?,</span><br><span class="line">    <span class="keyword">var</span> items: List&lt;Repo&gt;?,</span><br><span class="line">    <span class="keyword">var</span> msg: String?</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Repo</span>(</span><br><span class="line">    <span class="keyword">var</span> added_stars: String?,</span><br><span class="line">    <span class="keyword">var</span> avatars: List&lt;String&gt;?,</span><br><span class="line">    <span class="keyword">var</span> desc: String?,</span><br><span class="line">    <span class="keyword">var</span> forks: String?,</span><br><span class="line">    <span class="keyword">var</span> lang: String?,</span><br><span class="line">    <span class="keyword">var</span> repo: String?,</span><br><span class="line">    <span class="keyword">var</span> repo_link: String?,</span><br><span class="line">    <span class="keyword">var</span> stars: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>不过，在之前的课程当中，我提到过以这种方式定义的数据类，其实还存在 2 个问题。</p><ul><li>问题 1：不符合“不变性思维”，成员属性全部都是 var 定义的。</li><li>问题 2：不符合“空安全思维”，所有的类型都是可为空的。</li></ul><p>那么针对这两个问题，我们像下面这样做，其实很容易就能搞定：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">RepoList</span>(</span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">val</span> items: List&lt;Repo&gt; = listOf(),</span><br><span class="line">    <span class="keyword">val</span> msg: String = <span class="string">&quot;数据为空&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Repo</span>(</span><br><span class="line">    <span class="keyword">val</span> added_stars: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">val</span> avatars: List&lt;String&gt; = listOf(),</span><br><span class="line">    <span class="keyword">val</span> desc: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">val</span> forks: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">val</span> lang: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">val</span> repo: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">val</span> repo_link: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">val</span> stars: String = <span class="string">&quot;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在这段代码中，我们是把 var 都替换成了 val，把所有的可空类型都改成了不可空类型，同时也为属性都提供了默认值。</p><p>当然，仅仅只是改变底层的实体类的定义还远远不够，具体遇到的问题，我们会在后面分析。下面我们接着来看数据层。</p><h3 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h3><p>在数据层当中，最关键的就是 RepoDataSource 和 Repository。那么首先，我们就要定义它们对应的接口。你可以参考这里的实现：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RepoDataSource</span> &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRepos</span><span class="params">()</span></span>: ResultX&lt;RepoList&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRepository</span> &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRepoList</span><span class="params">()</span></span>: ResultX&lt;RepoList&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，就是它们对应的实现类了，我们先来看看数据源怎么处理。</p><p>由于我们需要请求网络，所以这里我们自然就会想到 OkHttp 和 Retrofit 了。虽然我们也可以使用自己写的 KtHttp，但它毕竟只是用于学习和研究目的而编写的，并不适合真的拿来用。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> RetrofitClient &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;OkHttp&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> BASE_URL = <span class="string">&quot;https://baseUrl.com/&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TIME_OUT = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> moshi: Moshi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        Moshi.Builder()</span><br><span class="line">            .add(KotlinJsonAdapterFactory())</span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> service <span class="keyword">by</span> lazy &#123; getService(RepoService::<span class="keyword">class</span>.java, BASE_URL) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> client: OkHttpClient <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = OkHttpClient.Builder()</span><br><span class="line">        builder.connectTimeout(TIME_OUT.toLong(), TimeUnit.SECONDS)</span><br><span class="line">        builder.build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;S&gt;</span> <span class="title">getService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        serviceClass: <span class="type">Class</span>&lt;<span class="type">S</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        baseUrl: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        client: <span class="type">OkHttpClient</span> = this.client</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: S &#123;</span><br><span class="line">        <span class="keyword">return</span> Retrofit.Builder()</span><br><span class="line">            .client(client)</span><br><span class="line">            .addConverterFactory(MoshiConverterFactory.create(moshi))</span><br><span class="line">            .baseUrl(baseUrl)</span><br><span class="line">            .build().create(serviceClass)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RepoService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;repo&quot;</span>)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(<span class="meta">@Query(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span> = <span class="string">&quot;Kotlin&quot;</span>, <span class="meta">@Query(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span> = <span class="string">&quot;weekly&quot;</span>)</span></span>: RepoList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，当我们自己手写了 KtHttp 的源码以后，Retrofit 用起来就会非常顺手。这里我们是定义了一个单例 RetrofitClient 用来请求 API，还有 RepoService 来代表具体的请求参数规则。</p><p>那么有了 Retrofit 以后，我们要处理数据源也就很容易了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> RemoteRepoDataSource : RepoDataSource &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;RemoteRepoDataSource&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRepos</span><span class="params">()</span></span>: ResultX&lt;RepoList&gt; =</span><br><span class="line">        withContext(Dispatchers.IO) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Success(RetrofitClient.service.repos())</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                Log.e(TAG, e.message, e)</span><br><span class="line">                Error(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们定义了一个 RemoteRepoDataSource，它实现了 RepoDataSource 这个数据源的接口。而它具体的实现方法，是使用 withContext{} 将 API 请求分发到了 IO 线程池，然后根据实际的运行结果，将数据封装成对应的 ResultX 的子类型。</p><p>接着就是数据仓库了，它一般是用于统筹缓存数据、远程数据的，这里为了不引入过多的复杂度，我们简单来实现：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainRepository</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> dataSource: RepoDataSource = RemoteRepoDataSource,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> localDataSource: RepoDataSource? = <span class="literal">null</span></span><br><span class="line">) : IRepository &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRepoList</span><span class="params">()</span></span>: ResultX&lt;RepoList&gt; &#123;</span><br><span class="line">        <span class="comment">// 暂不处理缓存逻辑</span></span><br><span class="line">        <span class="keyword">return</span> dataSource.getRepos()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到，它其实就是数据源的一层封装而已。</p><p>好，至此，我们的数据层就已经完成了。</p><h3 id="领域层"><a href="#领域层" class="headerlink" title="领域层"></a>领域层</h3><p>所谓领域层，其实就像是业务逻辑的一个小单元，这里的小单元，我们可以将其称为 UseCase。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetRepoListUseCase</span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: IRepository = MainRepository()) &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span>: ResultX&lt;RepoList&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.getRepoList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前的案例中，我们只有一个业务场景，也就是获取 GitHub 仓库的列表，所以这个 UseCase 的逻辑也很简单。不过你要知道，在实际的工作场景中，UseCase 是可以承载复杂的业务逻辑的。</p><p>接下来，我们往上看一下表现层。</p><h3 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h3><p>到了表现层这里，我们其实就已经非常接近 UI 了，具体来说，这里主要涉及到 ViewModel 还有 Activity、Fragment。我们先来看看 ViewModel。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>(</span><br><span class="line">    <span class="keyword">val</span> getRepoListUseCase: GetRepoListUseCase = GetRepoListUseCase()</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">val</span> repos: LiveData&lt;RepoList&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _repos</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _repos = MutableLiveData&lt;RepoList&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadRepos</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            <span class="keyword">val</span> result = getRepoListUseCase()</span><br><span class="line">            <span class="keyword">when</span> (result) &#123;</span><br><span class="line">                <span class="keyword">is</span> ResultX.Success -&gt; &#123;</span><br><span class="line">                    _repos.value = result.<span class="keyword">data</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">is</span> ResultX.Error -&gt; &#123;</span><br><span class="line">                    _repos.value = RepoList()</span><br><span class="line">                &#125;</span><br><span class="line">                ResultX.Loading -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 展示Loading</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在 ViewModel 当中定义了一组 LiveData，并且针对它的读写做了限制，这一点，我们在讲不变性思维的时候提到过。</p><p>在 loadRepos() 这个方法中，我们用到了 viewModelScope.launch {} 来启动协程。经过上节课的学习，我们知道以这种方式启动的协程是不会发生泄漏的，其中的协程任务会随着 Activity 的销毁而取消。</p><p>OK，最后，就是 Activity 当中的逻辑了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: MainViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> adapter: RepoAdapter</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> layoutManager = LinearLayoutManager(<span class="keyword">this</span>, LinearLayoutManager.VERTICAL, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        viewModel.loadRepos()</span><br><span class="line">        observeData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">observeData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        viewModel.repos.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">            display(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">display</span><span class="params">(repoList: <span class="type">RepoList</span>)</span></span> &#123;</span><br><span class="line">        adapter = RepoAdapter(repoList)</span><br><span class="line">        binding.recycler.layoutManager = layoutManager</span><br><span class="line">        binding.recycler.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 Activity 的逻辑也很简单，其中有几个注释，我们一起来看看：</p><ul><li>注释 1，这里我们使用了委托的语法，将 ViewModel 的创建交给了”by viewModels()”。它其实是 Activity 的一个扩展函数，是由 KTX 实现的。</li><li>注释 2，ActivityMainBinding，这里我们使用了 Jetpack 当中的 ViewBinding，这样我们就不用写烦人的 findViewById() 了。</li><li>注释 3，viewModel.repos.observe{}，这里我们完成了 ViewModel 当中 LiveData 的数据监听，当我们的网络请求有结果以后，它就会立刻被回调。</li></ul><p>另外，以上代码中还涉及到了一些 RecyclerView 相关的适配器逻辑，也非常简单：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RepoAdapter</span>(<span class="keyword">private</span> <span class="keyword">val</span> repoList: RepoList): RecyclerView.Adapter&lt;RepoHolder&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: RepoHolder &#123;</span><br><span class="line">        <span class="keyword">return</span> RepoHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_repo, parent, <span class="literal">false</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">RepoHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        holder.text.text = repoList.items.getOrNull(position)?.repo</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = repoList.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RepoHolder</span>(itemView: View): RecyclerView.ViewHolder(itemView) &#123;</span><br><span class="line">    <span class="keyword">val</span> text : TextView = itemView.findViewById(R.id.text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是，为了让 RecyclerView 正确展示数据，我们需要实现一些方法，以上这些都是一些模板代码。</p><p>最后，在运行代码之前，我们还需要给 App 增加一个网络权限。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这个时候，如果你在模拟器或者真机上运行的话，就会看到类似这样的一个效果：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/9d/0b/9d1b8168691b7b59a0dbf30cecbbbd0b.gif?wh=271x576" alt="img"></p><p>那么，到这里，我们的代码是不是就写完了呢？其实并没有。</p><h2 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h2><p>因为，我们还有一个问题没有解决：<strong>如果服务端返回的 JSON 字段是 null 的话，我们的程序仍然会出错</strong>。具体来说，我们可以用这个单元测试来模拟。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//                  强行返回null</span></span><br><span class="line">    <span class="comment">//                      ↓</span></span><br><span class="line">    <span class="keyword">val</span> json = <span class="string">&quot;&quot;&quot;&#123;&quot;repo&quot;: null, &quot;repo_link&quot;: &quot;https://github.com/JetBrains/kotlin&quot;, &quot;desc&quot;: &quot;The Kotlin Programming Language.&quot;, &quot;lang&quot;: &quot;Kotlin&quot;, &quot;stars&quot;: &quot;40,907&quot;, &quot;forks&quot;: &quot;5,067&quot;, &quot;added_stars&quot;: &quot;98 stars this week&quot;, &quot;avatars&quot;: [&quot;https://avatars.githubusercontent.com/u/292714?s=40&amp;v=4&quot;, &quot;https://avatars.githubusercontent.com/u/1127631?s=40&amp;v=4&quot;, &quot;https://avatars.githubusercontent.com/u/908958?s=40&amp;v=4&quot;, &quot;https://avatars.githubusercontent.com/u/3007027?s=40&amp;v=4&quot;, &quot;https://avatars.githubusercontent.com/u/888318?s=40&amp;v=4&quot;]&#125;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">val</span> repo = RetrofitClient.moshi.adapter(Repo::<span class="keyword">class</span>.java).fromJson(json)</span><br><span class="line">    println(repo?.repo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">报错：</span></span><br><span class="line"><span class="comment">Non-null value &#x27;repo&#x27; was null at $.repo at com.squareup.moshi.internal.Util</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/30/36/30b3bbf89b59c957801b1f75454a3236.gif?wh=1200x850" alt="img" style="zoom:50%;" /><p>其实，当我们利用空安全思维，将 Repo 中所有的成员都定义成“非空类型”以后，当 API 不返回某个字段的时候，程序是可以自动填充默认值的。但是，当 API 强行在接口当中返回 null 的时候，我们的程序还是会崩溃。为了解决这个问题，</p><p>我们需要为 JSON 解析框架Moshi，配置一个额外的规则：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> NullStringAdapter &#123;</span><br><span class="line">    <span class="meta">@FromJson</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromJson</span><span class="params">(reader: <span class="type">JsonReader</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">if</span> (reader.peek() != JsonReader.Token.NULL) &#123;</span><br><span class="line">            <span class="keyword">return</span> reader.nextString()</span><br><span class="line">        &#125;</span><br><span class="line">        reader.nextNull&lt;<span class="built_in">Unit</span>&gt;()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ToJson</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toJson</span><span class="params">(writer: <span class="type">JsonWriter</span>, value: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        writer.value(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Adapter，其实就是在服务端返回 null 的时候，我们做一层兼容，将其替换成默认值。它的用法也很简单：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> RetrofitClient &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> moshi: Moshi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        Moshi.Builder()</span><br><span class="line">            .add(NullStringAdapter) <span class="comment">// 变化在这里</span></span><br><span class="line">            .add(KotlinJsonAdapterFactory())</span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当我们把这个 Adapter 配置到 Moshi 当中以后，单元测试就可以正常通过了。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/19/88/197d46d4fe35edf1babbd0a9b15ff388.gif?wh=1198x822" alt="img" style="zoom:50%;" /><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好，这节课的内容到这里就差不多结束了。让我们来做一个简单的总结。</p><ul><li>MVVM，是一种常见的架构模式，在 Android 当中，一般会借助 ViewModel、LiveData 之类的组件来实现。在实战当中，我们还可以将其跟 Clean 架构的思想相结合，将整体应用的架构分为四层：实体层、数据层、领域层、表现层。</li><li>实体层，在大部分架构设计当中，实体层会和数据层进行融合，不过在这节课当中，我们将其单独抽了出来，放在了整个架构的最底层，通过密封类、数据类来实现的。</li><li>数据层，这里有两个概念，分别是“数据源”和“数据仓库”。数据源一般会分为缓存数据与远程数据，数据仓库则负责统筹多种数据源。</li><li>领域层，这里会涉及到业务逻辑的最小单元，我们一般将其称为 UseCase。</li><li>表现层，这里会涉及到数据与 UI 交互的逻辑。ViewModel 当中会封装 UseCase，并且持有数据和 View 进行交互。</li><li>最后，我们还根据实际情况，对 JSON 解析库 Moshi，做了额外配置，让它可以对服务端返回 null 的时候，仍然保持兼容，不会出现空指针异常。</li></ul><p>那么，如果你本身对 Android、MVVM、Clean 架构都不是很熟悉，也许在学习这节课的过程中会有点不太适应。这时候，你可以去 GitHub 下载本课程对应的 Demo，来实际运行和调试，以加深印象，链接在这里。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>这节课，我们融合 MVVM 和 Clean 完成了一种混合架构，请问这种架构有什么样的优点和缺点呢？</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(Android项目篇)34  Kotlin与Jetpack简直是天生一对！</title>
      <link href="/posts/b63f0842/"/>
      <url>/posts/b63f0842/</url>
      
        <content type="html"><![CDATA[<p>今天，我们来聊聊 Android 的 Jetpack。</p><p>在我看来，Kotlin 和 Jetpack，它们两个简直就是天生一对。作为 Android 开发者，如果只用 Kotlin 不用 Jetpack，我们其实很难在 Android 平台充分发挥 Kotlin 的语言优势。而如果我们只用 Jetpack 而不用 Kotlin，那么，我们将只能用到 Jetpack 的小部分功能。毕竟，Jetpack 当中有很多 API 和库，是专门为 Kotlin 提供的。</p><p>经过前面课程内容的学习，相信现在你已经对 Kotlin 十分熟悉了，那么，接下来就让我们来看看 Jetpack 吧！这节课里，我会为你介绍 Jetpack 核心库的基本概念、简单用法，以及它跟 Kotlin 之间的关系，从而也为我们下节课的实战项目打下基础。</p><h2 id="Jetpack-简介"><a href="#Jetpack-简介" class="headerlink" title="Jetpack 简介"></a>Jetpack 简介</h2><p>Jetpack，它有“喷气式背包”的意思。对于我们开发者来说，它其实就是 Google 官方为我们提供的一套开发套件，专门用来帮助 Android 开发者提升开发效率、提升应用稳定性的。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/ba/c2/ba1e45560e1e6510591d75ee6ee862c2.jpg?wh=600x600" alt="img"></p><p>Android Jetpack，最初的宣传图标，就是“穿着喷气式背包的 Android 机器人”。大概意思就是：有了 Jetpack，Android 就能“起飞了”。这当然只是一种夸张的比喻，不过，从我实际的开发体验来说，Jetpack 确实可以给 Android 开发者带来极大的好处，尤其是当 Jetpack 与 Kotlin 结合到一起的情况下。</p><p>我们先来了解下 KTX。</p><h2 id="KTX"><a href="#KTX" class="headerlink" title="KTX"></a>KTX</h2><p>KTX 是 Jetpack 当中最特殊的一类库，它是由 Kotlin 编写的，同时也仅为 Kotlin 开发者服务，使用 Java 语言的 Android 开发者是用不了的。KTX，它的作用其实是对当前 Android 生态当中的 API 进行额外补充。它依托 Kotlin 的扩展能力，为 Android 原有 API 增加新的：扩展函数、扩展属性、高阶函数、命名参数、参数默认值、协程支持。</p><p>如果我们想要使用 KTX 的核心功能，我们需要单独进行依赖：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&quot;androidx.core:core-ktx:1.7.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们来看一个关于 SharedPreference 的简单例子，如果我们使用 Java，我们大概率是需要写一堆模板代码的，类似这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line">SharedPreferences sharedPreferences= getSharedPreferences(<span class="string">&quot;data&quot;</span>,Context.MODE_PRIVATE);</span><br><span class="line">SharedPreferences.Editor editor = sharedPreferences.edit();</span><br><span class="line">editor.putString(SP_KEY_RESPONSE, response);</span><br><span class="line"></span><br><span class="line">editor.commit();</span><br><span class="line">editor.apply();</span><br></pre></td></tr></table></figure><p>不过，如果我们有了 KTX，那么代码就会变得极其简单：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line">preference.edit &#123; putBoolean(<span class="string">&quot;key&quot;</span>, value) &#125;</span><br></pre></td></tr></table></figure><p>上面的这个 edit() 方法，其实是一个高阶函数，它是由 KTX 提供的，如果你去看它的源代码，会发现，它其实就是一个扩展出来的高阶函数：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> SharedPreferences.<span class="title">edit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        commit: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        action: <span class="type">SharedPreferences</span>.<span class="type">Editor</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> editor = edit()</span><br><span class="line">    action(editor)</span><br><span class="line">    <span class="keyword">if</span> (commit) &#123;</span><br><span class="line">        editor.commit()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        editor.apply()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，KTX 其实就是将一些常见的模板代码封装了起来，然后以扩展函数的形式提供给开发者。虽然它自身的原理很简单，但是却可以大大提升开发者的效率。</p><p>KTX 除了能够扩展 Android SDK 的 API 以外，它还可以扩展 Jetpack 当中其他的库，比如说 LiveData、Room 等等。接下来，我们就来看看 Jetpack 当中比较核心的库：Lifecycle。</p><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>Lifecycle，其实就是 Android 的生命周期组件。在整个 Jetpack 组件当中的地位非常特殊，是必学的组件。举个例子，其他的组件比如 WorkManager，如果我们实际工作中用不上，那么我们不去学它是不会有什么问题的。Lifecycle 不一样，只要我们是做 Android 开发的，我们就绕不开 Lifecycle。Activity 里面有 Lifecycle；Fragment 里面也有；LiveData 里面也有；</p><p>ViewModel 底层也用到了 Lifecycle；使用协程也离不开 Lifecycle。</p><p>那么，Lifecycle 到底是什么呢？我们平时提到生命周期，往往都是说的 Activity、Fragment，而它们两者之间却有一个很大的问题，<strong>生命周期函数不一致</strong>。</p><p>Activity 的生命周期我们肯定心里有数，不过 Fragment 生命周期函数比 Activity 多了几个：onCreateView、onViewCreated、onViewStateRestore、onDestoryView。最重要的是，Fragment 生命周期、回调函数、Fragment 内部 View 的生命周期，它们三者之间还有很复杂的对应关系。换句话说，Fragment 的生命周期函数要比 Activity 复杂一些。</p><p>加之，Activity 和 Fragment 结合的情况下，它们的生命周期行为在不同版本的 Android 系统上行为可能还会不一致。这在某些边界条件下，还会引发一些难以排查的 bug，进一步增加我们 Android 程序员的维护成本。</p><p>在计算机世界里，大部分问题都可以通过增加一个抽象层来解决。Android 团队的做法就是推出了 Lifecycle 这个架构组件，用它来统一 Activity、Fragment 的生命周期行为。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/f0/a1/f03yy1b87813c58f5591aab720e432a1.jpg?wh=2000x904" alt="img"></p><p>有了 LifeCycle 以后，我们开发者就可以面向 Lifecycle 编程。比如说，我们希望实现一个通用的地理位置监听的 Manager，就可以这样来做：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不关心调用方是Activity还是Fragment</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LocationManager</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> callback: (Location) -&gt; <span class="built_in">Unit</span></span><br><span class="line">): DefaultLifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        stop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 使用高德之类的 SDK 请求地理位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 停止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LifecycleExampleActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_life_cycle_example)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> locationManager = LocationManager(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 展示地理位置信息</span></span><br><span class="line">        &#125;</span><br><span class="line">        lifecycle.addObserver(locationManager)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的 LocationManager 只需要实现 DefaultLifecycleObserver 这个接口即可，外部是在 Activity 还是在 Fragment 当中使用，根本不必关心。</p><h2 id="Lifecycle-与协程"><a href="#Lifecycle-与协程" class="headerlink" title="Lifecycle 与协程"></a>Lifecycle 与协程</h2><p>通过前面课程的学习，我们知道，协程其实也是有生命周期的。也就是说，Android 和 Kotlin 协程都是有生命周期的。这就意味着，当我们在 Android 当中使用协程的时候，就要格外小心。</p><p>作为 Android 开发者，你一定知道内存泄漏的概念：当内存变量的生命周期大于 Android 生命周期的时候，我们就认为内存发生泄漏了。类似的，当协程的生命周期大于 Android 生命周期的时候，<strong>协程也就发生泄漏了</strong>。</p><p>这一点，Android 官方早就帮我们考虑到了。Lifecycle 还可以跟我们前面提到的 KTX 结合到一起，进一步为 Kotlin 协程提供支持。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/ba/5c/ba1d19579cd0e6e6a8e4e004732c705c.png?wh=884x456" alt="img"></p><p>在 Activity、Fragment 当中，KTX 还提供了对应的 lifecycleScope，它本质上就是一个：与生命周期绑定的协程作用域。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> LifecycleOwner.lifecycleScope: LifecycleCoroutineScope</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">get</span>() = lifecycle.coroutineScope</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LifecycleCoroutineScope</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>() : CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">val</span> lifecycle: Lifecycle</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">launchWhenCreated</span><span class="params">(block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span>)</span></span>: Job = launch &#123;</span><br><span class="line">        lifecycle.whenCreated(block)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">launchWhenStarted</span><span class="params">(block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span>)</span></span>: Job = launch &#123;</span><br><span class="line">        lifecycle.whenStarted(block)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">launchWhenResumed</span><span class="params">(block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span>)</span></span>: Job = launch &#123;</span><br><span class="line">        lifecycle.whenResumed(block)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Android 当中，Activity 和 Fragment 都会实现 LifecycleOwner 这个接口，代表它们都是拥有生命周期的组件。注释 1 处，这里使用了 Kotlin 的扩展属性，为 LifecycleOwner 扩展了 lifecycleScope。它的类型是 LifecycleCoroutineScope，而它其实就是 CoroutineScope 的实现类。</p><p>lifecycleScope 这个属性的具体实现，其实是通过注释 2 处的自定义 getter() 实现的，也就是：Lifecycle.coroutineScope。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> Lifecycle.coroutineScope: LifecycleCoroutineScope</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">val</span> existing = mInternalScopeRef.<span class="keyword">get</span>() <span class="keyword">as</span> LifecycleCoroutineScopeImpl?</span><br><span class="line">            <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> existing</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">val</span> newScope = LifecycleCoroutineScopeImpl(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                SupervisorJob() + Dispatchers.Main.immediate</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">if</span> (mInternalScopeRef.compareAndSet(<span class="literal">null</span>, newScope)) &#123;</span><br><span class="line">                newScope.register()</span><br><span class="line">                <span class="keyword">return</span> newScope</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，Lifecycle.coroutineScope 仍然是一个扩展属性。它的逻辑其实也很简单，主要是分为了三个步骤：</p><ul><li>第一步，检查是否存在缓存的 CoroutineScope，如果存在，那就直接返回即可。</li><li>第二步，如果不存在缓存，那就创建一个新的协程作用域。在创建的作用域的时候，用到了两个我们熟悉的概念：SupervisorJob、Dispatchers.Main，它们都是协程上下文的元素，<strong>前者是用来隔离协程异常传播的，后者是指定协程执行线程的</strong>。</li><li>第三步，更新缓存，并且调用 register() 绑定 scope 与 Lifecycle 的关系，最后返回</li></ul><p>接下来，我们打破砂锅问到底，看看 register() 的具体逻辑是什么：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LifecycleCoroutineScopeImpl</span>(</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> lifecycle: Lifecycle,</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">) : LifecycleCoroutineScope(), LifecycleEventObserver &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lifecycle.currentState == Lifecycle.State.DESTROYED) &#123;</span><br><span class="line">            coroutineContext.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">()</span></span> &#123;</span><br><span class="line">        launch(Dispatchers.Main.immediate) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lifecycle.currentState &gt;= Lifecycle.State.INITIALIZED) &#123;</span><br><span class="line">                lifecycle.addObserver(<span class="keyword">this</span><span class="symbol">@LifecycleCoroutineScopeImpl</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                coroutineContext.cancel()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lifecycle.currentState &lt;= Lifecycle.State.DESTROYED) &#123;</span><br><span class="line">            lifecycle.removeObserver(<span class="keyword">this</span>)</span><br><span class="line">            coroutineContext.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LifecycleEventObserver</span> <span class="title">extends</span> <span class="title">LifecycleObserver</span> &#123;</span><br><span class="line">    void onStateChanged(<span class="meta">@NonNull</span> LifecycleOwner source, <span class="meta">@NonNull</span> Lifecycle.Event event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码一共有三个注释，我们一个个来看：</p><ul><li>注释 1，register()，可以看到，它的逻辑其实很简单，主要就是调用了 addObserver()，将自身作为观察者传了进去。之所以可以这么做，还是因为注释 2 处的 LifecycleEventObserver。</li><li>注释 2，LifecycleEventObserver，它其实就是一个 SAM 接口，每当 LifeCycleOwner 的生命周期发生变化的时候，这个 onStateChanged() 方法就会被调用。而这个方法的具体实现则在注释 3 处。</li><li>注释 3，这里的逻辑也很简单，当 LifeCycleOwner 对应的 Activity、Fragment 被销毁以后，就会调用 removeObserver(this) 移除观察者，最后，就是最关键的 coroutineContext.cancel()，取消整个作用域里所有的协程任务。</li></ul><p>这样一来，就能保证 LifeCycle 与协程的生命周期完全一致了，也就不会出现协程泄漏的问题了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课，我们主要了解了 Android 当中的 Jetpack，它是 Android 官方提供给开发者的一个开发套件，可以帮助我们开发者提升开发效率。Jetpack 当中其实有几十个库，在这节课里，我们是着重讲解了其中的 KTX 与 LifeCycle。</p><ul><li><p><strong>KTX</strong>，主要是依托 Kotlin 的扩展能力，为 Android 原有 API 增加新的：扩展函数、扩展属性、高阶函数、命名参数、参数默认值、协程支持。</p></li><li><p><strong>Lifecycle</strong>，其实就是 Android 的生命周期组件。它统一封装了 Activity、Fragment 等 Android 生命周期的组件。让我们开发者可以只关注 LifeCycle 的生命周期，而不用在意其他细节。</p></li><li><p><strong>KTX 还为 LifeCycle 增加了协程支持，也就是 lifecycleScope</strong>。在它的底层，这个协程作用域和宿主的生命周期进行了绑定。当宿主被销毁以后，它可以确保 lifecycleScope 当中的协程任务，也跟着被取消。</p></li></ul><p>所以，对于 Android 开发者来说，Kotlin 和 Jetpack 是一个“你中有我，我中有你”的关系，我们把它们称为“天生一对”一点儿也不为过。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>在 Android 中使用协程的时候，除了 lifecycleScope 以外，我们还经常会使用 ViewModel 的 viewModelScope。你能结合前面协程篇、源码篇的知识点，分析出 viewModelScope 的实现原理吗？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _persons: MutableLiveData&lt;List&lt;Person&gt;&gt; = MutableLiveData()</span><br><span class="line">    <span class="keyword">val</span> persons: LiveData&lt;List&lt;Person&gt;&gt; = _persons</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadPersons</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">            _persons.value = listOf(Person(<span class="string">&quot;Tom&quot;</span>), Person(<span class="string">&quot;Jack&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> ViewModel.viewModelScope: CoroutineScope</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">val</span> scope: CoroutineScope? = <span class="keyword">this</span>.getTag(JOB_KEY)</span><br><span class="line">        <span class="keyword">if</span> (scope != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> scope</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setTagIfAbsent(</span><br><span class="line">            JOB_KEY,</span><br><span class="line">            <span class="comment">// 实现类</span></span><br><span class="line">            CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了Closeable的CoroutineScope</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">CloseableCoroutineScope</span>(context: CoroutineContext) : Closeable, CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext = context</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 取消</span></span><br><span class="line">        coroutineContext.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; mBagOfTags = new HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> volatile boolean mCleared = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(<span class="string">&quot;WeakerAccess&quot;</span>)</span></span><br><span class="line">    <span class="keyword">protected</span> void onCleared() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">final</span> void clear() &#123;</span><br><span class="line">        mCleared = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mBagOfTags != <span class="literal">null</span>) &#123;</span><br><span class="line">            synchronized (mBagOfTags) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Object value : mBagOfTags.values()) &#123;</span><br><span class="line">                    <span class="comment">// 调用scope的close()</span></span><br><span class="line">                    closeWithRuntimeException(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onCleared();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scope暂存起来</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(<span class="string">&quot;unchecked&quot;</span>)</span></span><br><span class="line">    &lt;T&gt; T setTagIfAbsent(String key, T newValue) &#123;</span><br><span class="line">        T previous;</span><br><span class="line">        synchronized (mBagOfTags) &#123;</span><br><span class="line">            previous = (T) mBagOfTags.<span class="keyword">get</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (previous == <span class="literal">null</span>) &#123;</span><br><span class="line">                mBagOfTags.put(key, newValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T result = previous == <span class="literal">null</span> ? newValue : previous;</span><br><span class="line">        <span class="keyword">if</span> (mCleared) &#123;</span><br><span class="line"></span><br><span class="line">            closeWithRuntimeException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static void closeWithRuntimeException(Object obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj instanceof Closeable) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((Closeable) obj).close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(Android项目篇)33 Java Android开发者还会有未来吗？</title>
      <link href="/posts/11a43e5b/"/>
      <url>/posts/11a43e5b/</url>
      
        <content type="html"><![CDATA[<p><audio src="https://github.com/winstone-su/imageHosting/blob/main/course/kotlin/kotlin-programming-first-lesson/33%20%7C%20Java%20Android%E5%BC%80%E5%8F%91%E8%80%85%E8%BF%98%E4%BC%9A%E6%9C%89%E6%9C%AA%E6%9D%A5%E5%90%97%EF%BC%9F.m4a?raw=true"></audio></p><p>在过去的几十讲里，我们把 Kotlin 的基础语法和核心难点协程，都全面学习了一遍，从原理到实战，从协程的核心挂起函数、launch 等，到探究它们的源码定义，可以说我们已经基本掌握了 Kotlin 的核心知识点与特性，你也应该可以在工作中使用 Kotlin 来解决实际问题了。如果你发现自己对这些知识的掌握还有不少漏洞，也别着急，可以再回头复习一下相应部分的内容，或者在留言区提问，我会给你解答。</p><p>那么，从这节课起，我会带你来看看 Kotlin 在实践场景中，应用得最普遍、最广泛的领域，<strong>Android</strong>。我们一起来学习下如何结合所学的 Kotlin 知识，来高效开发 Android 应用。</p><p>今天这节课，我们先来聊聊 Kotlin 和 Android 的关系，让你对 Android 的现状与未来的发展方向有一个清晰的认识。</p><p>虽然 Kotlin 是面向多个平台的（如 JVM、Native、JS 等），不过我们在讨论 Kotlin 的同时，难免也会讨论下 Android。甚至，很多开发者都是因为 Android 才开始接触 Kotlin 的。</p><p>说起 Kotlin 与 Android，就不得不提它俩对应的公司 JetBrains 和 Google。早在 2013 年之前，这两家公司就有过合作。最开始的时候，Android 开发者的开发工具还是 Eclipse，Google 是在 JetBrains 的 IntelliJ 的基础上，进行改造以后，才有了后来的 Android Studio。</p><p>而 Eclipse 与 Android Studio 之间的开发体验，可以说是天壤之别。这一点，在 Kotlin 与 Java 的对比上其实也是类似的。Android 开发者不学 Kotlin 坚持使用 Java，就好比是不使用 Android Studio 坚持使用 Eclipse 一样。</p><p>那么，对于 Android 开发者来说，Kotlin 对比 Java 的优势，可以说是全方位的，具体我们可以从下面几个维度来看。</p><h2 id="语言的优势"><a href="#语言的优势" class="headerlink" title="语言的优势"></a>语言的优势</h2><p>在前面的课程当中，我曾经说过，Kotlin 与 Java 并没有绝对的好坏，但不可否认的是：<strong>在 Android 平台上，Kotlin 对比 Java 是有绝对优势的</strong>。</p><p>经过前面课程的学习，我想你对 Kotlin 的语法特性已经有了充分的认识，不论是它简洁的语法，还是灵活的扩展特性，还是它的空安全特性，或者是强大的协程框架，都可以为我们 Android 开发者带来更好的体验。</p><p>另外，由于 Kotlin 同时也是基于 JVM 的，它与 Java 的 100% 互操作性，也让我们开发者可以灵活地集成到现有的工程中去。</p><p>根据 Android 官方的一组统计数据，已经有超过 60% 的 Android 个人开发者在使用 Kotlin；而在排名前 1000 的 Android 应用中，也已经有超过 80% 的比例在使用 Kotlin 进行开发。可见，头部互联网公司的 Android 团队都在积极在做技术转型，Kotlin 也正在成为大厂 Android 研发的基本要求。</p><p>而随着 Kotlin 在 Android 当中普及率的提升，整个开发者社区产出的内容也渐渐以 Kotlin 为主，不论是 Android 官方的文档，还是其他技术社区的博客，其中的代码片段都在使用 Kotlin。我们以 Google 官方在 GitHub 开源的Sample为例，其中大部分的代码都已经变成了 Kotlin。试想一下，作为一个 Android 开发者，如果看不懂 Kotlin 代码，我们又该如何跟进最新的技术呢？</p><h2 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h2><p>作为 Android 开发者，我们总是难免会用到一些优秀的开源库，近几年，GitHub 上也涌现了许多纯 Kotlin 开发的开源库，比如说<a href="https://github.com/InsertKoinIO/koin">Kotlin 依赖注入框架 Koin</a>、<a href="https://github.com/coil-kt/coil">Kotlin 实现的图片加载框架 coil</a>，等等。其实，不仅是新的开源库会用 Kotlin，许多著名的 Java 开源库也在使用 Kotlin 重写，比如著名的<a href="https://github.com/square/okhttp">网络请求框架 OkHttp</a>、<a href="https://github.com/square/leakcanary">内存泄漏检测框架 LeakCanary</a>、<a href="https://github.com/square/picasso">图片加载框架 Picasso</a>等。大量开源库拥抱 Kotlin，这本身其实就说明了 Kotlin 自身的语言优势。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/db/ce/db2b8998684f9bc89f44de57a71116ce.png?wh=1920x1164" alt="img" style="zoom:50%;" /><p>所以，如果我们 Android 开发者看不懂 Kotlin 代码，这些用 Kotlin 编写的开源库，我们用起来肯定会有点儿心虚，因为看不懂它们的源代码。</p><p>当然，如果仅仅是 GitHub 上面的第三方开源库在选择 Kotlin，我们也还是可以选择不用它。但如果是 Android 官方的呢？实际上，连 Android 官方团队都开始使用 Kotlin 写<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/packages/SystemUI/src/com/android/systemui/media/">Android 系统的源代码（AOSP）</a>，还有 Jetpack 库（比如<a href="https://github.com/androidx/androidx/tree/androidx-main/paging/paging-common/src/main/kotlin/androidx/paging">Paging</a>、<a href="https://github.com/androidx/androidx/tree/androidx-main/lifecycle/lifecycle-viewmodel/src/main/java/androidx/lifecycle">ViewModel</a>）等等。可以说，Kotlin 在 Android 当中的地位已经远远超过了 Java，而且，随着时间的推移，两者的差距会越来越大。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/2f/7a/2f50c2584cce6c8ddyy1f36feed04e7a.png?wh=1920x1360" alt="img"></p><p><strong>Jetpack Compose</strong></p><p>在 2021 年 7 月，Android 官方团队正式发布了全新的 UI 编程框架 Jetpack Compose。它是由纯 Kotlin 实现的，想要使用它，我们就必须懂 Kotlin。</p><p>对于传统的 Android 开发来说，开发者必须先用 XML 编写 UI 布局，类似这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/text&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">        app:layout_constraintBottom_toBottomOf=<span class="string">&quot;parent&quot;</span></span><br><span class="line">        app:layout_constraintLeft_toLeftOf=<span class="string">&quot;parent&quot;</span></span><br><span class="line">        app:layout_constraintRight_toRightOf=<span class="string">&quot;parent&quot;</span></span><br><span class="line">        app:layout_constraintTop_toTopOf=<span class="string">&quot;parent&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><p>这个 XML，其实就是一个最简单的 UI 布局，父布局 ConstraintLayout 里面有一个 TextView。在 XML 当中，我们使用一个个的 UI 控件节点，来描述控件间的嵌套关系，最终组成一个 UI 的树。接着，开发者就需要在 Java 或 Kotlin 当中编写对应的业务逻辑。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> textView = findViewById&lt;TextView&gt;(R.id.text)</span><br><span class="line">        textView.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码模式其实有一个特别明显的缺陷，那就是<strong>代码之间的依赖跨越了两个不同的语言模块</strong>：XML 模块、Kotlin 模块。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/33/58/33bfe3be69b354e713976efa5a82cc58.jpg?wh=2000x853" alt="img"></p><p>对于这样跨越模块的依赖，两者之间的耦合是非常严重的，维护起来非常费力，XML 发生改变了，Kotlin 当中也要发生对应的改变。虽然 Android 官方也曾推出过 DataBinding 之类的工具，帮助我们在 XML 当中编写简单的数据绑定逻辑，但这种方式并不能从根本上解决问题，因为 <strong>DataBinding 只能减少两个模块之间的耦合，并不能消灭。</strong></p><p>而 Jetpack Compose，就为 Android 开发提供了另一种可能性：UI 和逻辑都用 Kotlin 编写。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 不需要 xml</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            Text(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们直接使用 Text() 的方法创建了一个 TextView，然后传入了 setContent{}这个高阶函数当中。这样，我们整个 Android 的代码就写完了，根本不需要编写 XML，也不需要 findViewById、DataBinding 之类的操作了。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/fb/7d/fb265dcabc32b1e9f8a064980a22c27d.jpg?wh=2000x859" alt="img"></p><p>很明显，Jetpack Compose 这样的代码模式，就属于内聚模式。由于我们可以使用 Kotlin 编写 UI 布局，所以，我们可以同时使用 Kotlin 完成 View 相关的逻辑，比如状态管理、布局测量、触摸反馈、动画，等等。要知道，在从前 XML 的时代，View 相关的这些逻辑都是割裂开的，耦合也非常严重。</p><p>总的来说，使用 Compose 可以大大简化我们 Android 的开发，也可以提升开发者的效率。在 Compose 当中，大量使用了 Kotlin 的高级特性，比如扩展、委托，甚至协程；同时它大量借鉴了函数式编程的思想，在 Compose 当中推崇“不变性”“无副作用”，为此，Compose 也为开发者提供了一系列的<a href="https://developer.android.com/jetpack/compose/side-effects">Effect Handlers</a>。</p><p>总之，如果你是一名热爱 Kotlin 的 Android 工程师，那么你一定会对 Jetpack Compose 一见钟情。</p><p>当然，这里我为了让课程简单易懂，特地举了最简单的例子，如果你对 Jetpack Compose 感兴趣，也可以去看看<a href="https://developer.android.com/courses/pathways/compose">Android 官方的 Compose 教程</a>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好，到这里，我们这节课的内容就差不多结束了。这节课我们主要从三个角度分析了 Kotlin 对 Android 开发的重要性。</p><ul><li><strong>语言的优势</strong>，Kotlin 因为其简洁的语法，以及灵活的语法特性，还有强大的协程框架，让它建立起了对比 Java 的语言优势，从而也让越来越多的开发者愿意使用它。业界的文档、博客也渐渐以 Kotlin 为主流。</li><li><strong>开源库</strong>，不仅第三方的开源库，就连 Android 官方团队也在使用 Kotlin 编写源代码。</li><li><strong>Jetpack Compose</strong>，它是 Android 团队推出的全新 UI 框架，可以大大简化 Android 开发，也可以提升开发效率。它是纯 Kotlin 开发的，我们开发者如果要使用它的话，也必须使用 Kotlin。</li></ul><p>好，现在，让我们来回答这节课的标题的问题：<strong>Java Android 开发者还会有未来吗？</strong>我认为单纯的 Android 应用开发者，如果不掌握好 Kotlin，一定是会渐渐被淘汰的。</p><p>当然，经过前面一系列课程的学习，我相信你已经对 Kotlin 的各个方面都有了透彻的认识。这节课的目的，我是想告诉你，如果你是 Android 开发者，请一定不要怀疑自己学习 Kotlin 这个决定到底正不正确；同时也不要犹豫，一定要在实际工作中用起来。</p><p>在接下来的两节课当中，我会用一些简单的案例，来向你展示 Kotlin 在 Android 开发当中的实际应用。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>作为 Android 开发者，你最喜欢 Kotlin 的哪个语言特性？为什么？</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(源码篇)32  图解Flow：原来你是只纸老虎？</title>
      <link href="/posts/11989076/"/>
      <url>/posts/11989076/</url>
      
        <content type="html"><![CDATA[<p><audio src= "https://github.com/winstone-su/imageHosting/blob/main/course/kotlin/kotlin-programming-first-lesson/32%20%7C%20%E5%9B%BE%E8%A7%A3Flow%EF%BC%9A%E5%8E%9F%E6%9D%A5%E4%BD%A0%E6%98%AF%E5%8F%AA%E7%BA%B8%E8%80%81%E8%99%8E%EF%BC%9F.m4a?raw=true"></audio></p><p>今天我们来研究 Flow 的源代码。</p><p>经过前面的学习，我们已经知道了，Channel 和 Flow 都是数据流，Channel 是“热”的，Flow 则是“冷”的。这里的冷，代表着 Flow 不仅是“冷淡”的，而且还是“懒惰”的。</p><p>除了“冷”这个特性以外，Flow 从 API 的角度分类，主要分为：构造器、中间操作符、终止操作符。今天这节课，我们将会从这几个角度来分析 Flow 的源码，来看看它的这几类 API 是如何实现的。</p><p>经过这节课的学习，你会发现：虽然 Flow 的功能看起来非常高大上，然而它的原理却非常的简单，是一只名副其实的“纸老虎”。</p><h2 id="Flow-为什么是冷的？"><a href="#Flow-为什么是冷的？" class="headerlink" title="Flow 为什么是冷的？"></a>Flow 为什么是冷的？</h2><p>在正式开始研究 Flow 源代码之前，我们首先需要确定研究的对象。这里，我写了一段 Demo 代码，接下来我们就以这个 Demo 为例，来分析 Flow 的整个执行流程：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        testFlow()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    flow &#123;</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">        emit(<span class="number">4</span>)</span><br><span class="line">        emit(<span class="number">5</span>)</span><br><span class="line">    &#125;.collect &#123;      <span class="comment">// 2</span></span><br><span class="line">            logX(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制台输出带协程信息的log</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">logX</span><span class="params">(any: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">    println(</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">================================</span></span><br><span class="line"><span class="string"><span class="variable">$any</span></span></span><br><span class="line"><span class="string">Thread:<span class="subst">$&#123;Thread.currentThread().name&#125;</span></span></span><br><span class="line"><span class="string">================================&quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这段代码很简单，我们创建了一个 CoroutineScope，接着使用它创建了一个新的协程，在协程当中，我们使用 flow{} 这个高阶函数创建了 Flow 对象，接着使用了 collect{} 这个终止操作符。</p><p>我们利用第 20 讲当中学过的内容，很容易就能想象出类似这样的一个思维模型。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/e3/4f/e3c3bd48f715e6d26yye3bd60096fd4f.jpg?wh=2000x940" alt="img"></p><p>那么下面，我们就先来看看注释 1 处，分析一下 Flow 是怎么创建出来的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">flow</span><span class="params">(block: <span class="type">suspend</span> <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span>)</span></span>: Flow&lt;T&gt; =</span><br><span class="line">     SafeFlow(block)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flow</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，flow{} 是一个高阶函数，它接收的参数类型是函数类型FlowCollector.() -&gt; Unit，这个类型代表了：它是 FlowCollector 的扩展或成员方法，没有参数，也没有返回值。flow() 的返回值类型是Flow，而它实际返回的类型是 SafeFlow，让我们来看看它的源码定义。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SafeFlow</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> block: <span class="keyword">suspend</span> FlowCollector&lt;T&gt;.() -&gt; <span class="built_in">Unit</span>) : AbstractFlow&lt;T&gt;() &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collectSafely</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        collector.block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFlow</span>&lt;<span class="type">T</span>&gt; : <span class="type">Flow</span>&lt;<span class="type">T</span>&gt;, <span class="type">CancellableFlow</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">interface</span> <span class="title class_">CancellableFlow</span>&lt;<span class="type">out T</span>&gt; : <span class="type">Flow</span>&lt;<span class="type">T</span>&gt;</span><br></pre></td></tr></table></figure><p>从上面的代码我们可以看到，SafeFlow 其实是 AbstractFlow 的子类，而 AbstractFlow 则实现了 Flow 这个接口，所以 SafeFlow 算是间接实现了 Flow 接口。而 AbstractFlow 是协程当中所有 Flow 的抽象类，所以，它当中应该会有许多 Flow 通用的逻辑。</p><p>那么接下来，我们就来看看 AbstractFlow 当中的逻辑：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFlow</span>&lt;<span class="type">T</span>&gt; : <span class="type">Flow</span>&lt;<span class="type">T</span>&gt;, <span class="type">CancellableFlow</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">val</span> safeCollector = SafeCollector(collector, coroutineContext)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line">            collectSafely(safeCollector)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            safeCollector.releaseIntercepted()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collectSafely</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请留意上面代码的注释 1，看到这个挂起函数 collect()，你是不是觉得很熟悉呢？它其实就是终止操作符 collect 对应的调用处。这个 collect() 的逻辑其实也很简单，我都用注释标记出来了，我们来看看：</p><ul><li>注释 2，collect() 的参数类型是 FlowCollector，这里只是将其重新封装了一遍，变成了 SafeColletor 对象。从它的名称，我们也大概可以猜出来，它肯定是会对 collect 当中的逻辑做一些安全检查的，SafeCollector 的源码我们留到后面分析，我们接着看注释 3。</li><li>注释 3，collectSafely()，这里其实就是调用了它的抽象方法，而它的具体实现就在代码段 3 里 SafeFlow 的 collectSafely() 方法，而它的逻辑也很简单，它直接调用了 collector.block()，这其实就相当于触发了 flow{} 当中的 Lambda 逻辑。换句话说，collector.block() 就相当于调用了代码段 1 当中的 5 次 emit() 方法。</li></ul><p>那么，代码分析到这里，我们其实就已经可以看出来 Flow 为什么是冷的了。我们都知道 Channel 之所以是热的，是因为它不管有没有接收方，发送方都会工作。而 FLow 之所以是冷的，是因为 Flow 的构造器，真的就只会构造一个 SafeFlow 对象，完全不会触发执行它内部的 Lambda 表达式的逻辑，<strong>只有当 collect() 被调用之后，flow{} 当中的 Lambda 逻辑才会真正被触发执行。</strong></p><p>好，现在我们已经知道 collect() 是如何触发 Flow 执行的了，接下来，我们来看看 Flow 是如何将上游的数据传递给下游的。</p><h2 id="FlowCollector：上游与下游之间的桥梁"><a href="#FlowCollector：上游与下游之间的桥梁" class="headerlink" title="FlowCollector：上游与下游之间的桥梁"></a>FlowCollector：上游与下游之间的桥梁</h2><p>经过之前的分析，我们知道 flow{} 这个高阶函数会创建一个 Flow 对象，它具体的类型是 SafeFlow，它其实间接实现了 Flow 接口，因此我们可以直接调用 collect() 这个终止操作符，从而拿到 flow{} 的 Lambda 当中 emit（发射）出来的数据。</p><p>上面整个流程分析下来，给我们的感觉是这样的：<strong>下游的 collect() 会触发上游的 Lambda 执行，上游的 Lambda 当中的 emit() 会把数据传递给下游。</strong></p><p>那么，Flow 到底是如何做到的呢？这其中的关键，还是 collect() 传入的参数类型：FlowCollector。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> FlowCollector<span class="type">&lt;in T&gt;</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flow</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在下游调用 collect{} 的时候，其实是在调用 Flow 接口的 collect 方法，而我们之所以可以写出花括号的形式，是因为 Lambda 简写，这一点我们在第 7 讲当中有提到过。那么，为了让它们的关系更加清晰地暴露出来，我们可以换一种写法，来实现代码段 1 当中的逻辑。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    flow &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">        emit(<span class="number">4</span>)</span><br><span class="line">        emit(<span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 变化在这里</span></span><br><span class="line">        .collect(<span class="keyword">object</span> : FlowCollector&lt;<span class="built_in">Int</span>&gt;&#123; </span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">                logX(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里代码段 6 和前面代码段 1 的逻辑其实是等价的，唯一的变化在于，这里我们使用了匿名内部类的方式，直接传入了 FlowCollector，在这个匿名内部类的 emit() 方法，其实就充当着 Flow 的下游接收其中的数据流。</p><p>所以，要分析“上游与下游是如何连接的”这个问题，我们只需要看注释 2 处的 emit() 是如何被调用的即可。</p><p>那么，经过前面代码段 4 的分析，我们从它注释 2 处的代码就可以知道，collect() 方法传入的 FlowCollector 参数，其实是被传入 SafeCollector 当中，被封装了起来。所以接下来，我们只要分析 SafeCollector 当中的逻辑就行。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">actual</span> <span class="keyword">class</span> <span class="title class_">SafeCollector</span>&lt;<span class="type">T</span>&gt; <span class="title">actual</span> <span class="keyword">constructor</span>(</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">internal</span> <span class="keyword">actual</span> <span class="keyword">val</span> collector: FlowCollector&lt;T&gt;,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">internal</span> <span class="keyword">actual</span> <span class="keyword">val</span> collectContext: CoroutineContext</span><br><span class="line">) : FlowCollector&lt;T&gt;, ContinuationImpl(NoOpContinuation, EmptyCoroutineContext), CoroutineStackFrame &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">actual</span> <span class="keyword">val</span> collectContextSize = collectContext.fold(<span class="number">0</span>) &#123; count, _ -&gt; count + <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastEmissionContext: CoroutineContext? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> completion: Continuation&lt;<span class="built_in">Unit</span>&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ContinuationImpl</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = completion?.context ?: EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn <span class="symbol">sc@</span>&#123; uCont -&gt;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 3</span></span><br><span class="line">                emit(uCont, value)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">                lastEmissionContext = DownstreamExceptionElement(e)</span><br><span class="line">                <span class="keyword">throw</span> e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(uCont: <span class="type">Continuation</span>&lt;<span class="type">Unit</span>&gt;, value: <span class="type">T</span>)</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">val</span> currentContext = uCont.context</span><br><span class="line">        currentContext.ensureActive()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">val</span> previousContext = lastEmissionContext</span><br><span class="line">        <span class="keyword">if</span> (previousContext !== currentContext) &#123;</span><br><span class="line">            checkContext(currentContext, previousContext, value)</span><br><span class="line">        &#125;</span><br><span class="line">        completion = uCont</span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">return</span> emitFun(collector <span class="keyword">as</span> FlowCollector&lt;Any?&gt;, value, <span class="keyword">this</span> <span class="keyword">as</span> Continuation&lt;<span class="built_in">Unit</span>&gt;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> emitFun =</span><br><span class="line">    FlowCollector&lt;Any?&gt;::emit <span class="keyword">as</span> Function3&lt;FlowCollector&lt;Any?&gt;, Any?, Continuation&lt;<span class="built_in">Unit</span>&gt;, Any?&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function3</span>&lt;<span class="type">in P1, in P2, in P3, out R</span>&gt; : <span class="type">Function</span>&lt;<span class="type">R</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(p1: <span class="type">P1</span>, p2: <span class="type">P2</span>, p3: <span class="type">P3</span>)</span></span>: R</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段 SafeCollector 的源码中，一共有 6 个地方需要我们注意，让我们来看看。</p><p>注释 1，collector，它是 SafeCollector 的参数，通过分析代码段 4 的注释 2 处，我们可以知道，它其实就对应着代码段 6 里，注释 1 处的匿名内部类 FlowCollector。之后我们需要特别留意这个 collector，看看它的 emit() 是在哪里被调用的，因为这就意味着代码段 6 当中的注释 2 被调用。我们可以将其看作**下游的 emit()**。</p><p>注释 2，emit()，通过之前代码段 4 的分析，我们知道，这个 emit() 方法，其实就是代码段 6 里调用的 emit()。也就是说，Flow 上游发送的数据，最终会传递到这个 emit() 方法当中来。我们可以将其看作**上游的 emit()**。</p><p>注释 3，emit(uCont, value)，这里的 suspendCoroutineUninterceptedOrReturn 这个高阶函数，是把挂起函数的 Continuation 暴露了出来，并且将其作为参数传递给了另一个 emit() 方法。你需要注意的是，这行代码被 try-catch 包裹了，而且把其中的异常捕获以后，会被重新包装成 DownstreamExceptionElement，意思就是“下游的异常”，这从侧面也能说明，这个方法即将执行下游的代码。</p><p>这里还有一个细节就是，DownstreamExceptionElement 会被存储在 lastEmissionContext 当中，它的作用是：在下游发送异常以后，可以让上游感知到。</p><p>注释 4，这里会对当前的协程上下文与之前的协程上下文做对比检查，如果它们两者不一致，就会在 checkContext() 当中做进一步的判断和提示。我们第 20 讲思考题的答案就藏在这里，为了不偏离主线，这个部分的逻辑我们暂时先放着，等我们分析完 Flow 的整体流程以后再来看。</p><p>注释 5，emitFun(collector as FlowCollector, value, this as Continuation)，这里其实就是在调用下游的 emit()，也就是代码段 6 当中的注释 2 对应的 emit() 方法。那么，这里的 emitFun() 是什么呢？我们可以在注释 6 处找到它的定义：FlowCollector::emit，这是函数引用的语法，代表了它就是 FlowCollector 的 emit() 方法，它的类型是Function3, Any?, Continuation, Any?&gt;。</p><p>乍一看，你也许会觉得这个类型有点难以理解，其实，这个知识点我们在第 8 讲当中就已经介绍过，我们平时写的函数类型() -&gt; Unit其实就对应了 Function0，也就是：没有参数的函数类型。所以，这里的 Function3 其实就代表了三个参数的函数类型。因此，注释 5 处，其实就代表了下游的 emit() 方法被调用了，对应的 value 也是这时候传进去的。</p><p>至此，上游传递数据给下游的整个流程，我们也分析完毕了，FlowCollector 其实就相当于上游与下游之间的桥梁，它起到了连接上游、下游的作用。</p><p>回过头去看前面分析过的代码，你会发现，Flow 的核心原理其实只牵涉到那么几十行代码，而它的核心接口也只有 Flow、FlowCollector 而已。为了方便你理解，这里我做了一个视频，描述 Flow 的整体调用流程。</p><p><video src= "https://github.com/winstone-su/imageHosting/blob/main/course/kotlin/kotlin-programming-first-lesson/32_3%20%7C%20%E5%9B%BE%E8%A7%A3Flow%EF%BC%9A%E5%8E%9F%E6%9D%A5%E4%BD%A0%E6%98%AF%E5%8F%AA%E7%BA%B8%E8%80%81%E8%99%8E%EF%BC%9F%20-%20%20-%202023-01-30%2000-39-07.mp4?raw=true"></video></p><p>所以，对比挂起函数的原理，不得不说，Flow 真的只是一只看起来吓人的“纸老虎”。</p><h2 id="思考与推演"><a href="#思考与推演" class="headerlink" title="思考与推演"></a>思考与推演</h2><p>接下来，我们基于前面的结论来进行一些思考，来尝试推演和理解一下 Flow 的其他功能细节，比如：中间操作符的原理、不允许使用 withContext{} 的原因。</p><h3 id="推演：中间操作符"><a href="#推演：中间操作符" class="headerlink" title="推演：中间操作符"></a>推演：中间操作符</h3><p>请你想象一个问题：在已知 Flow 上游、下游传递数据的原理以后，如果让你来设计 Flow 的中间操作符，你会怎么设计？</p><p>要回答这个问题，其实我们只需要回想一下 Flow 的思维模型，让我们来更新一下代码段 1 对应的思维模型，将 Flow 的源码执行流程也融入进去：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/98/ac/9828f4c4f874ddf4b7d1c45a5f5ab5ac.jpg?wh=2000x980" alt="img"></p><p>flow{} 这个高阶函数，代表了上游，它会创建一个 Flow 对象，提供给下游调用 Flow 的 collect 方法。在前面的代码段 2 当中，我们曾经分析过，flow{} 实际上返回的是 SafeFlow 对象，在这个 SafeFlow 当中，会有一个 SafeCollector 对象。而整个 Flow 的调用过程，其实就是三个步骤：</p><ul><li>第一步，上游的 flow{} 创建 SafeFlow 的对象，下游调用 Flow 的 collect() 方法，触发 flow{} 的 Lambda 对应的代码执行，也就是其中 emit() 被执行。</li><li>第二步，上游调用的 emit()，其实就是 SafeCollector 的 emit()，这时候，就相当于上游将数据传递给 SafeCollector。</li><li>第三步，SafeCollector 调用 emitFun()，这里的 emitFun() 其实就对应了下游的 emit() 方法（如果你忘了，可以回过头看看代码段 6 的注释 2）。</li></ul><p>通过以上分析，我们能发现，Flow 的源码执行流程，也非常符合我们之前构想出来的思维模型。那么，对于它的中间操作符，我们是不是只需要加一个“中转站”就可以了呢？答案是肯定的。</p><p>如果让你来设计 Flow 的中间操作符，我相信你大概率会设计出类似下面这样的结构：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/13/eb/13acf7e1dbffdc22226f59f432658deb.jpg?wh=2000x1125" alt="img"></p><p>可以看到，当 Flow 当中出现中间操作符的时候，上游和下游之间就会多出一个个的中转站。对于每一个“中转站”来说，它都会有上游和下游，它都会被下游触发执行，它也会触发自己的上游；同时，它会接收来自上游的数据，也会传递给自己的下游。</p><p>那么，接下来，让我们来分析一下 Flow 中间操作符的源代码，看看 Kotlin 官方的设计是否符合我们的猜想：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">filter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">crossinline</span> predicate: <span class="type">suspend</span> (<span class="type">T</span>) -&gt; <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Flow&lt;T&gt; = transform &#123; value -&gt;</span><br><span class="line">    <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">if</span> (predicate(value)) <span class="keyword">return</span><span class="symbol">@transform</span> emit(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">unsafeTransform</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">crossinline</span> transform: <span class="type">suspend</span> <span class="type">FlowCollector</span>&lt;<span class="type">R</span>&gt;.(<span class="type">value</span>: <span class="type">T</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Flow&lt;R&gt; = unsafeFlow &#123; </span><br><span class="line">    <span class="comment">// 6</span></span><br><span class="line">    collect &#123; value -&gt;</span><br><span class="line">        <span class="comment">// 7</span></span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@collect</span> transform(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">unsafeFlow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">crossinline</span> block: <span class="type">suspend</span> <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Flow&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">object</span> : Flow&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">            collector.block()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看起来有点复杂，让我们来一步步来分析：</p><ul><li>注释 1、2、3，请留意这几个方法的签名，它们的返回值类型都是 Flow，这意味着，Flow.filter{} 的返回值类型仍然是 Flow。我们站在整体的角度来分析的话，会发现：这只是一个 Flow 被封装的过程。我们都知道，flow{} 创建的是 SafeFlow 对象，当我们接着调用 filter{} 之后，根据注释 4 处的逻辑，我们发现它会变成一个普通的 Flow 匿名内部类对象。</li><li>注释 5，对于flow{}.filter{}.collect{}这样的代码，最终的 collect{} 调用的代码，其实就是注释 5 对应的 collect() 方法。我们看看它的方法体 collector.block()，这其实就代表了注释 6、7 会执行。</li><li>注释 6，collect{}，这里是在调用上游 Flow 的 collect{}，触发上游的 Lambda 执行了，也就是flow{}.filter{}.collect{}里的 flow{} 当中的 Lambda，然后注释 7 就会被执行。</li><li>注释 7，transform(value)，在前面代码段 7 的分析中，我们知道，这里 transform(value) 当中的 value，其实就是上游传递下来的数据，让我们来看看 transform{} 当中具体的逻辑，也就是注释 8。</li><li>注释 8，if (predicate(value))，这其实就是我们 filter 的条件，只有符合这个条件的情况下，我们才会继续向下游传递数据，而传递的方式，就是调用 emit()，这里的 emit() 其实就代表了下游会接收到数据了。</li></ul><p>可见，filter{} 的核心思想，完全符合我们前面思维模型推演的结果。接下来，我们来看看 map{}、onEach{} 之类的源码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(<span class="keyword">crossinline</span> transform: <span class="type">suspend</span> (<span class="type">value</span>: <span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: Flow&lt;R&gt; = transform &#123; value -&gt;</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@transform</span> emit(transform(value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">onEach</span><span class="params">(action: <span class="type">suspend</span> (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: Flow&lt;T&gt; = transform &#123; value -&gt;</span><br><span class="line">    action(value)</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@transform</span> emit(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们理解了 filter 以后，你会发现，map、和 onEach 之类的操作符就变得很简单了。前者就是在调用下游 emit() 的时候做了一次数据转换，而后者则是在每次向下游传递数据的时候，同时调用一下传入的 Lambda 表达式 action()。</p><h3 id="思考：上下文保护"><a href="#思考：上下文保护" class="headerlink" title="思考：上下文保护"></a>思考：上下文保护</h3><p>在第 20 讲当中，我留过一个思考题：</p><p><code>课程里我曾提到过，Flow 当中直接使用 withContext&#123;&#125; 是很容易出现问题的，下面代码是其中的一种。请问你能解释其中的缘由吗？Kotlin 官方为什么要这么设计？</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flow &#123;</span><br><span class="line">        withContext(Dispatchers.IO) &#123;</span><br><span class="line">            emit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .collect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Flow invariant is violated:</span></span><br><span class="line"><span class="comment">        Flow was collected in [BlockingCoroutine&#123;Active&#125;@6e58a46, BlockingEventLoop@2cbfb24],</span></span><br><span class="line"><span class="comment">        but emission happened in [DispatchedCoroutine&#123;Active&#125;@500da3c0, Dispatchers.IO].</span></span><br><span class="line"><span class="comment">        Please refer to &#x27;flow&#x27; documentation or use &#x27;flowOn&#x27; instead</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>其实，课程进行到这里，我们就已经可以很简单地回答这个问题了。</p><p>在第 24 讲当中，我们曾经给 Flow 的三种 API 进行过分类：Flow 构建器、Flow 中间操作符，它们两个是不需要协程作用域的，只有 Flow 终止操作符需要协程作用域。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/b9/b7/b98d651e66309f67f16843e5d00a80b7.jpg?wh=2000x1125" alt="img"></p><p>通过前面 Flow 的源码分析流程，我们其实就会发现，在默认情况下，Flow 下游的“协程上下文”最终会成为上游的执行环境，也会变成中间操作符的执行环境。也正是这个原因，才让 Flow 可以天然支持协程的“结构化并发”的特性，比如说结构化取消。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        flow &#123;</span><br><span class="line">            logX(<span class="string">&quot;上游&quot;</span>)</span><br><span class="line">            repeat(<span class="number">100</span>) &#123;</span><br><span class="line">                emit(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.filter &#123;</span><br><span class="line">            logX(<span class="string">&quot;中间&quot;</span>)</span><br><span class="line">            it &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">            .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">            .onCompletion &#123;</span><br><span class="line">                logX(it)</span><br><span class="line">            &#125;</span><br><span class="line">            .collect &#123;</span><br><span class="line">                logX(it)</span><br><span class="line">                delay(<span class="number">1000L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    scope.cancel()</span><br><span class="line">    logX(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">上游</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">中间</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">中间</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">中间</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">中间</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">中间</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">结束</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">kotlinx.coroutines.JobCancellationException: Job was cancelled; job=JobImpl&#123;Cancelling&#125;@407d87d0</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从上面的执行结果可以看到，虽然我们的上游要尝试 emit()100 个数据，但是由于外部的 scope 在 2000 毫秒后会取消，所以整个 Flow 都会响应取消。</p><p>那么反之，如果 Kotlin 官方允许开发者在 flow{} 当中，调用 withContext{} 改变协程上下文的话，<strong>Flow 上游与下游的协程上下文就会不一致，它们整体的结构也会被破坏，从而导致“结构化并发”的特性也被破坏。</strong></p><p>Flow 源码中对于上下文的检测，我们称之为上下文保护（Context Preservation），它对应的检测时机在代码段 7 的注释 4 处，具体的逻辑如下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(uCont: <span class="type">Continuation</span>&lt;<span class="type">Unit</span>&gt;, value: <span class="type">T</span>)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// This check is triggered once per flow on happy path.</span></span><br><span class="line">    <span class="keyword">val</span> previousContext = lastEmissionContext</span><br><span class="line">    <span class="keyword">if</span> (previousContext !== currentContext) &#123;</span><br><span class="line">        checkContext(currentContext, previousContext, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    currentContext: <span class="type">CoroutineContext</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    previousContext: <span class="type">CoroutineContext</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    value: <span class="type">T</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (previousContext <span class="keyword">is</span> DownstreamExceptionElement) &#123;</span><br><span class="line">        exceptionTransparencyViolated(previousContext, value)</span><br><span class="line">    &#125;</span><br><span class="line">    checkContext(currentContext)</span><br><span class="line">    lastEmissionContext = currentContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> SafeCollector<span class="type">&lt;*&gt;</span>.<span class="title">checkContext</span><span class="params">(currentContext: <span class="type">CoroutineContext</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = currentContext.fold(<span class="number">0</span>) <span class="symbol">fold@</span>&#123; count, element -&gt;</span><br><span class="line">        <span class="keyword">val</span> key = element.key</span><br><span class="line">        <span class="keyword">val</span> collectElement = collectContext[key]</span><br><span class="line">        <span class="keyword">if</span> (key !== Job) &#123;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@fold</span> <span class="keyword">if</span> (element !== collectElement) <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line">            <span class="keyword">else</span> count + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> collectJob = collectElement <span class="keyword">as</span> Job?</span><br><span class="line">        <span class="keyword">val</span> emissionParentJob = (element <span class="keyword">as</span> Job).transitiveCoroutineParent(collectJob)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (emissionParentJob !== collectJob) &#123;</span><br><span class="line">            error(</span><br><span class="line">                <span class="string">&quot;Flow invariant is violated:\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;\t\tEmission from another coroutine is detected.\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;\t\tChild of <span class="variable">$emissionParentJob</span>, expected child of <span class="variable">$collectJob</span>.\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;\t\tFlowCollector is not thread-safe and concurrent emissions are prohibited.\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;\t\tTo mitigate this restriction please use &#x27;channelFlow&#x27; builder instead of &#x27;flow&#x27;&quot;</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (collectJob == <span class="literal">null</span>) count <span class="keyword">else</span> count + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断上游、下游的Context</span></span><br><span class="line">    <span class="keyword">if</span> (result != collectContextSize) &#123;</span><br><span class="line">        error(</span><br><span class="line">            <span class="string">&quot;Flow invariant is violated:\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;\t\tFlow was collected in <span class="variable">$collectContext</span>,\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;\t\tbut emission happened in <span class="variable">$currentContext</span>.\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;\t\tPlease refer to &#x27;flow&#x27; documentation or use &#x27;flowOn&#x27; instead&quot;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，总的来说，Flow 不允许直接使用 withContext{} 的原因，是为了“结构化并发”，它并不是不允许切换线程，而是不允许随意破坏协程的上下文。Kotlin 提供的操作符 flowOn{}，官方已经帮我们处理好了上下文的问题，所以我们可以放心地切线程。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课，我们是通过分析 Flow 的源码，理解了它的几类 API 是如何实现的。我们知道，Flow 是冷数据流，可以分为上游 Flow 构造器、中间操作符、下游 FlowCollector。那么可以说，<strong>理解了 Flow、FlowCollector 这两个接口，其实就理解了 Flow 的原理。</strong></p><p>上游 Flow 构造器，它实际返回的对象是 SafeFlow，在 SafeFlow 当中有一个 SafeCollector，它会接收上游的数据，并且将数据传递给下游的 FlowCollector。</p><p>下游 FlowCollector，在下游调用 collect() 的时候，实际上是调用的 Flow 的 collect() 方法，这就会触发上游的 Lambda 被执行。在 collect() 调用的时候，它会创建一个 FlowCollector 的匿名内部类对象，专门用于接收来自上游的数据。</p><p>中间操作符，它在整个 Flow 的调用流程当中，既会充当上游，也会充当下游。它会被下游触发执行，它也会触发自己的上游；同时，它会接收来自上游的数据，也会传递给自己的下游。</p><p>上下文保护，由于 Flow 的上游与中间操作符并不需要协程作用域，因此，它们都是共用的 Flow 下游的协程上下文。也正是因为 Flow 的这种设计，让 Flow 天然支持结构化并发。为此，Kotlin 官方也限制了我们开发者不能随意在上游与中转站阶段，改变 Flow 的上下文。</p><p>其实，课程进行到这里，你会发现，Flow 的原理之所以看起来很简单，完全是因为它站在了“挂起函数”“高阶函数”这两个巨人的肩膀上！如果没有它们作为基础，Flow 的 API 设计一定会更加复杂。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>前面我提到过，“理解了 Flow、FlowCollector 这两个接口，就理解了 Flow 的原理。”那么，你能概括出 Flow、FlowCollector 这两个抽象的接口之间的内在联系吗？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flow</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> FlowCollector<span class="type">&lt;in T&gt;</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(源码篇)31  图解Channel：如何理解它的CSP通信模型？</title>
      <link href="/posts/6017bcef/"/>
      <url>/posts/6017bcef/</url>
      
        <content type="html"><![CDATA[<p>今天我们来分析 Channel 的源码。</p><p>Kotlin 的 Channel 是一个非常重要的组件，在它出现之前，协程之间很难进行通信，有了它以后，协程之间的通信就轻而易举了。在第 22 讲当中，我们甚至还借助 Channel 实现的 Actor 做到了并发安全。</p><p>那么总的来说，Channel 是热的，同时它还是一个<strong>线程安全的数据管道</strong>。而由于 Channel 具有线程安全的特性，因此，它最常见的用法，就是建立 CSP 通信模型（Communicating Sequential Processes）。</p><p>不过你可能会觉得，CSP 太抽象了不好理解，但其实，这个通信模型我们在第 22 讲里就接触过了。当时我们虽然是通过 Actor 来实现的，但却是把它当作 CSP 在用，它们两者的差异其实很小。</p><p>关于CSP 的理论，它的精确定义其实比较复杂，不过它的核心理念用一句话就可以概括：<strong>不要共享内存来通信；而是要用通信来共享内存</strong>（Don’t communicate by sharing memory; share memory by communicating）。</p><p>可是，我们为什么可以通过 Channel 实现 CSP 通信模型呢？这背后的技术细节，则需要我们通过源码来发掘了。</p><h2 id="Channel-背后的数据结构"><a href="#Channel-背后的数据结构" class="headerlink" title="Channel 背后的数据结构"></a>Channel 背后的数据结构</h2><p>为了研究 Channel 的源代码，我们仍然是以一个简单的 Demo 为例，来跟踪它的代码执行流程。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job() + mySingleDispatcher)</span><br><span class="line">    <span class="comment">// 1，创建管道</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        <span class="comment">// 2，在一个单独的协程当中发送管道消息</span></span><br><span class="line">        repeat(<span class="number">3</span>)  &#123;</span><br><span class="line">            channel.send(it)</span><br><span class="line">            println(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        <span class="comment">// 3，在一个单独的协程当中接收管道消息</span></span><br><span class="line">        repeat(<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> result = channel.receive()</span><br><span class="line">            println(<span class="string">&quot;Receive <span class="subst">$&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">    Thread.sleep(<span class="number">2000000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Receive 0</span></span><br><span class="line"><span class="comment">Send: 0</span></span><br><span class="line"><span class="comment">Send: 1</span></span><br><span class="line"><span class="comment">Receive 1</span></span><br><span class="line"><span class="comment">Receive 2</span></span><br><span class="line"><span class="comment">Send: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上代码主要分为三个部分，分别是：Channel 创建、发送数据、接收数据。</p><p>我们先来分析注释 1 处的 Channel 创建逻辑。我们都知道 Channel 其实是一个接口，它是通过组合 SendChannel、ReceiveChannel 得来的。而注释 1 处调用的 Channel()，其实是一个普通的顶层函数，<strong>只是它发挥的作用是构造函数，因此它的首字母是大写的</strong>，这跟我们上节课分析的 CoroutineScope、Job 也是类似的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span>&lt;<span class="type">E</span>&gt; : <span class="type">SendChannel</span>&lt;<span class="type">E</span>&gt;, <span class="type">ReceiveChannel</span>&lt;<span class="type">E</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> <span class="title">Channel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    capacity: <span class="type">Int</span> = RENDEZVOUS,</span></span></span><br><span class="line"><span class="params"><span class="function">    onBufferOverflow: <span class="type">BufferOverflow</span> = BufferOverflow.SUSPEND,</span></span></span><br><span class="line"><span class="params"><span class="function">    onUndeliveredElement: ((<span class="type">E</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Channel&lt;E&gt; =</span><br><span class="line">    <span class="keyword">when</span> (capacity) &#123;</span><br><span class="line">        RENDEZVOUS -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (onBufferOverflow == BufferOverflow.SUSPEND)</span><br><span class="line">                RendezvousChannel(onUndeliveredElement) </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ArrayChannel(<span class="number">1</span>, onBufferOverflow, onUndeliveredElement) </span><br><span class="line">        &#125;</span><br><span class="line">        CONFLATED -&gt; &#123;</span><br><span class="line">            ConflatedChannel(onUndeliveredElement)</span><br><span class="line">        &#125;</span><br><span class="line">        UNLIMITED -&gt; LinkedListChannel(onUndeliveredElement) </span><br><span class="line">        BUFFERED -&gt; ArrayChannel( </span><br><span class="line">            <span class="keyword">if</span> (onBufferOverflow == BufferOverflow.SUSPEND) CHANNEL_DEFAULT_CAPACITY <span class="keyword">else</span> <span class="number">1</span>,</span><br><span class="line">            onBufferOverflow, onUndeliveredElement</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (capacity == <span class="number">1</span> &amp;&amp; onBufferOverflow == BufferOverflow.DROP_OLDEST)</span><br><span class="line">                ConflatedChannel(onUndeliveredElement) </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ArrayChannel(capacity, onBufferOverflow, onUndeliveredElement)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后，从上面的代码里，我们可以看到，<strong>Channel() 方法的核心逻辑就是一个 when 表达式</strong>，它根据传入的参数，会创建不同类型的 Channel 实例，包括了：RendezvousChannel、ArrayChannel、ConflatedChannel、LinkedListChannel。而这些实现类都有一个共同的父类：<strong>AbstractChannel</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSendChannel</span>&lt;<span class="type">E</span>&gt;(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">protected</span> <span class="keyword">val</span> onUndeliveredElement: OnUndeliveredElement&lt;E&gt;?</span><br><span class="line">) : SendChannel&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> queue = LockFreeLinkedListHead()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractChannel</span>&lt;<span class="type">E</span>&gt;(</span><br><span class="line">    onUndeliveredElement: OnUndeliveredElement&lt;E&gt;?</span><br><span class="line">) : AbstractSendChannel&lt;E&gt;(onUndeliveredElement), Channel&lt;E&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，AbstractChannel 其实是 AbstractSendChannel 的内部类，同时它也是 AbstractSendChannel 的子类。而 Channel 当中的核心逻辑，都是依靠 AbstractSendChannel 当中的 <strong>LockFreeLinkedListHead</strong> 实现的。我们接着来看下它的源代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">LockFreeLinkedListHead</span> : <span class="type">LockFreeLinkedListNode</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = next === <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">LockFreeLinkedListNode</span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _next = atomic&lt;Any&gt;(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _prev = atomic(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _removedRef = atomic&lt;Removed?&gt;(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，LockFreeLinkedListHead 其实继承自 <strong>LockFreeLinkedListNode</strong>，而 LockFreeLinkedListNode 则是实现 Channel 核心功能的关键数据结构。整个数据结构的核心思想，来自于 2004 年的一篇论文：<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.4693&rep=rep1&type=pdf">《Lock-Free and Practical Doubly Linked List-Based Deques Using Single-Word Compare-and-Swap》</a>。如果你对其中的原理感兴趣，可以去看看这篇论文。这里，为了不偏离主题，我们只分析它的核心思想。</p><p>LockFreeLinkedListNode，我们可以将其区分开来看待，即 LockFree 和 LinkedList。</p><p>第一个部分：<strong>LockFree</strong>，它是通过<a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2">CAS</a>（Compare And Swap）的思想来实现的，比如 JDK 提供的 java.util.concurrent.atomic。这一点，我们从上面注释 1 的 atomic 也可以看出来。</p><p>第二个部分：<strong>LinkedList</strong>，这说明 LockFreeLinkedList 本质上还是一个<strong>链表</strong>。简单来说，它其实是一个循环双向链表，而 LockFreeLinkedListHead 其实是一个<strong>哨兵节点</strong>，如果你熟悉链表这个数据结构，也可以将其看作是链表当中的<a href="https://stackoverflow.com/questions/37324972/what-is-a-dummy-head">虚拟头结点</a>，这个节点本身不会用于存储任何数据，它的 next 指针会指向整个链表的<strong>头节点</strong>，而它的 prev 指针会指向整个链表的<strong>尾节点</strong>。</p><p>为了方便你理解，我画了一张图描述这个链表的结构：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/b0/ef/b040356bb5e6e6eab4b4fb4bcdbb74ef.jpg?wh=2000x713" alt="img"></p><p>请看图片左边的部分，<strong>当链表为空的时候</strong>，LockFreeLinkedListHead 的 next 指针和 prev 指针，都是指向自身的。这也就意味着，这个 Head 节点是不会存储数据，同时，也是不会被删除的。</p><p>然后再看图片右边的部分，<strong>当链表有 2 个元素的时候</strong>，这时 LockFreeLinkedListHead 节点的 next 指针才是第一个节点，而 Head 的 prev 指针则是指向尾结点。</p><p>实际上，寻常的循环双向链表是可以在首尾添加元素的，同时也支持“正向遍历、逆向遍历”的。但 Channel 内部的这个数据结构只能在末尾添加，而它遍历的顺序则是从队首开始的。这样的设计，就让它的行为在变成了先进先出<strong>单向队列</strong>的同时，还实现了队尾添加操作，只需要 O(1) 的时间复杂度。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/47/c4/479f6fcb5cf2a9eb2f56951546eefdc4.jpg?wh=2000x683" alt="img"></p><p>可以说，正是因为 LockFreeLinkedList 这个数据结构，我们才能使用 Channel 实现 CSP 通信模型。</p><p>好，在弄清楚 LockFreeLinkedList 这个数据结构以后，Channel 后续的源码分析就很简单了。让我们来分别分析一下 Channel 的 send()、receive() 的流程。</p><h2 id="发送和接收的流程"><a href="#发送和接收的流程" class="headerlink" title="发送和接收的流程"></a>发送和接收的流程</h2><p>我们回过头来看代码段 1 当中的逻辑，我们分别启动了两个协程，在这两个协程中，我们分别发送了三次数据，也接收了三次数据。程序首先会执行 send()，由于 Channel 在默认情况下容量是 0，所以，send() 首先会被挂起。让我们来看看这部分的逻辑：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(element: <span class="type">E</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (offerInternal(element) === OFFER_SUCCESS) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> sendSuspend(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">offerInternal</span><span class="params">(element: <span class="type">E</span>)</span></span>: Any &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">val</span> receive = takeFirstReceiveOrPeekClosed() ?: <span class="keyword">return</span> OFFER_FAILE</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendSuspend</span><span class="params">(element: <span class="type">E</span>)</span></span>: <span class="built_in">Unit</span> = suspendCancellableCoroutineReusable <span class="symbol">sc@</span> &#123; cont -&gt;</span><br><span class="line">    <span class="symbol">loop@</span> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFullImpl) &#123;</span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">val</span> send = <span class="keyword">if</span> (onUndeliveredElement == <span class="literal">null</span>)</span><br><span class="line">                SendElement(element, cont) <span class="keyword">else</span></span><br><span class="line">                SendElementWithUndeliveredHandler(element, cont, onUndeliveredElement)</span><br><span class="line">            <span class="keyword">val</span> enqueueResult = enqueueSend(send)</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                enqueueResult == <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 5</span></span><br><span class="line">                    cont.removeOnCancellation(send)</span><br><span class="line">                    <span class="keyword">return</span><span class="symbol">@sc</span></span><br><span class="line">                &#125;</span><br><span class="line">                enqueueResult <span class="keyword">is</span> Closed&lt;*&gt; -&gt; &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                enqueueResult === ENQUEUE_FAILED -&gt; &#123;&#125; </span><br><span class="line">                enqueueResult <span class="keyword">is</span> Receive&lt;*&gt; -&gt; &#123;&#125; </span><br><span class="line">                <span class="keyword">else</span> -&gt; error(<span class="string">&quot;enqueueSend returned <span class="variable">$enqueueResult</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的挂起函数 send() 分为两个部分：</p><ul><li>注释 1，尝试向 Channel 发送数据，如果这时候 Channel 已经有了消费者，那么 if 就会为 true，send() 方法就会 return。不过，按照代码段 1 的逻辑，首次调用 send() 的时候，Channel 还不存在消费者，因此在注释 3 处，尝试从 LockFreeLinkedList 取出消费者是不可能的。所以，程序会继续执行注释 2 处的逻辑。</li><li>注释 2，会调用挂起函数 sendSuspend()，它是由高阶函数 suspendCancellableCoroutineReusable{} 实现的。我们看它的名字就能知道，它跟 suspendCancellableCoroutine{} 是类似的（如果你有些忘了，可以回过头去看看加餐五）。另外，请留意下这个方法的注释 4，它会将发送的元素封装成 SendElement 对象，然后调用 enqueueSend() 方法，将其添加到 LockFreeLinkedList 这个队列的末尾。如果 enqueueSend() 执行成功了，就会执行注释 5，注册一个回调，用于将 SendElement 从队列中移除掉。</li></ul><p>如果你足够细心的话，你会发现这整个流程并没有涉及到 resume 的调用，因此，这也意味着 sendSuspend() 会一直被挂起，而这就意味着 send() 会一直被挂起！那么，问题来了，<strong>send() 会在什么时候被恢复</strong>？</p><p>答案当然是：<strong>receive() 被调用的时候！</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">receive</span><span class="params">()</span></span>: E &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> result = pollInternal()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    <span class="keyword">if</span> (result !== POLL_FAILED &amp;&amp; result !<span class="keyword">is</span> Closed&lt;*&gt;) <span class="keyword">return</span> result <span class="keyword">as</span> E</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> receiveSuspend(RECEIVE_THROWS_ON_CLOSE)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">pollInternal</span><span class="params">()</span></span>: Any? &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">val</span> send = takeFirstSendOrPeekClosed() ?: <span class="keyword">return</span> POLL_FAILED</span><br><span class="line">        <span class="keyword">val</span> token = send.tryResumeSend(<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span>) &#123;</span><br><span class="line">            assert &#123; token === RESUME_TOKEN &#125;</span><br><span class="line">            <span class="comment">//4</span></span><br><span class="line">            send.completeResumeSend()</span><br><span class="line">            <span class="keyword">return</span> send.pollResult</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        send.undeliveredElement()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CancellableContinuationImpl</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchResume</span><span class="params">(mode: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryResume()) <span class="keyword">return</span> </span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    dispatch(mode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> DispatchedTask<span class="type">&lt;T&gt;</span>.<span class="title">dispatch</span><span class="params">(mode: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">if</span> (!undispatched &amp;&amp; delegate <span class="keyword">is</span> DispatchedContinuation&lt;*&gt; &amp;&amp; mode.isCancellableMode == resumeMode.isCancellableMode) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> dispatcher = delegate.dispatcher</span><br><span class="line">        <span class="keyword">val</span> context = delegate.context</span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">            <span class="comment">// 6</span></span><br><span class="line">            dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resumeUnconfined()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，挂起函数 receive() 的逻辑，跟代码段 5 当中的 send() 是类似的。</p><ul><li>注释 1，尝试从 LockFree 队列当中找出是否有正在被挂起的<strong>发送方</strong>。具体的逻辑在注释 3 处，它会从队首开始遍历，寻找 Send 节点。</li><li>接着上面的代码段 1 的案例分析，此时我们一定是可以从队列中找到一个 Send 节点的，因此程序会继续执行注释 4 处的代码。</li><li>注释 4，completeResumeSend()，它最终会调用注释 5 处的 dispatch(mode)，而 dispatch(mode) 其实就是 DispatchedTask 的 dispatch()，是不是觉得很熟悉？这个 DispatchedTask 其实就是我们在第 29 讲当中分析过的 DispatchedTask，这里的 dispatch() 就是协程体当中的代码在线程执行的时机。最终，它会执行在 Java 的 Executor 之上。至此，我们之前被挂起的 send() 方法，其实就算是恢复了。</li></ul><p>另外，你可以再留意上面的注释 2，当 LockFree 队列当中没有正在挂起的发送方时，它会执行 receiveSuspend()，而 receiveSuspend() 也同样会被挂起：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">receiveSuspend</span><span class="params">(receiveMode: <span class="type">Int</span>)</span></span>: R = suspendCancellableCoroutineReusable <span class="symbol">sc@</span> &#123; cont -&gt;</span><br><span class="line">    <span class="keyword">val</span> receive = <span class="keyword">if</span> (onUndeliveredElement == <span class="literal">null</span>)</span><br><span class="line">        ReceiveElement(cont <span class="keyword">as</span> CancellableContinuation&lt;Any?&gt;, receiveMode) <span class="keyword">else</span></span><br><span class="line">        ReceiveElementWithUndeliveredHandler(cont <span class="keyword">as</span> CancellableContinuation&lt;Any?&gt;, receiveMode, onUndeliveredElement)</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (enqueueReceive(receive)) &#123;</span><br><span class="line">            removeReceiveOnCancel(cont, receive)</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@sc</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> result = pollInternal()</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">is</span> Closed&lt;*&gt;) &#123;</span><br><span class="line">            receive.resumeReceiveClosed(result)</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@sc</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result !== POLL_FAILED) &#123;</span><br><span class="line">            cont.resume(receive.resumeValue(result <span class="keyword">as</span> E), receive.resumeOnCancellationFun(result <span class="keyword">as</span> E))</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@sc</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，这里的逻辑其实跟之前的 sendSuspend() 是类似的。首先，它会封装一个 ReceiveElement 对象，并且将其添加到 LockFree 队列的末尾，如果添加成功的话，这个 receiveSuspend 就会继续挂起，这就意味着 receive() 也会被挂起。而 receive() 被恢复的时机，其实就对应了代码段 5 当中注释 1 的代码：offerInternal(element)。</p><p>至此，Channel 的发送和接收流程，我们就都已经分析完了。按照惯例，我们还是通过一个视频来回顾代码的整体执行流程：</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过这节课，我们知道，Channel 其实是一个线程安全的管道。它最常见的用法，就是实现 CSP 通信模型。它的核心理念是：<strong>不要共享内存来通信；而是要用通信来共享内存</strong>。而 Channel 之所以可以用来实现 CSP 通信模型，主要还是因为它底层用到的数据结构：LockFreeLinkedList。</p><p>LockFreeLinkedList 虽然是一个循环双向链表，但在 Channel 的源码中，它会被当做<strong>先进先出</strong>的单向队列，它只在队列末尾插入节点，而遍历则只正向遍历。</p><p>还有 Channel 的 send()，它会分为两种情况，一种是当前的 LockFree 队列当中已经有被挂起的<strong>接收方</strong>，这时候，send() 会恢复 Receive 节点的执行，并且将数据发送给对方。第二种情况是：当前队列当中没有被挂起的接收方，这时候 send() 就会被挂起，而被发送的数据会被封装成 SendElement 对象插入到队列的末尾，等待被下次的 receive() 恢复执行。</p><p>而 Channel 的 receive()，也是分为两种情况，一种是当前的 LockFree 队列当中已经存在被挂起的<strong>发送方</strong>，这时候 receive() 会恢复 Send 节点的执行，并且取出 Send 节点当中带过来的数据。第二种情况是：当前队列没有被挂起的发送方，这时候 receive() 就会被挂起，同时它也会被封装成一个 ReceiveElement 对象插入到队列的末尾，等待被下次的 send() 恢复执行。</p><p>其实，Kotlin 推崇 CSP 模型进行并发的原因还有很多，比如门槛低、可读性高、扩展性好，还有一点是会被很多人提到的：不容易发生死锁。</p><p>不过，这里需要特别注意的是，CSP 场景下的并发模型，并非不可能发生死锁，在一些特殊场景下，它也是可能发生死锁的，比如：通信死锁（Communication Deadlock）。因此，CSP 也并不是解决所有并发问题的万能解药，我们还是要具体问题具体分析。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>在课程的开头，我们分析了 Channel 一共有四种实现方式：RendezvousChannel、ArrayChannel、ConflatedChannel、LinkedListChannel，请问你能结合今天学习的知识，分析 LinkedListChannel 的原理吗？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">LinkedListChannel</span>&lt;<span class="type">E</span>&gt;(onUndeliveredElement: OnUndeliveredElement&lt;E&gt;?) : AbstractChannel&lt;E&gt;(onUndeliveredElement) &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">val</span> isBufferAlwaysEmpty: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">val</span> isBufferEmpty: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">val</span> isBufferAlwaysFull: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">val</span> isBufferFull: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">offerInternal</span><span class="params">(element: <span class="type">E</span>)</span></span>: Any &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> result = <span class="keyword">super</span>.offerInternal(element)</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                result === OFFER_SUCCESS -&gt; <span class="keyword">return</span> OFFER_SUCCESS</span><br><span class="line">                result === OFFER_FAILED -&gt; &#123; <span class="comment">// try to buffer</span></span><br><span class="line">                    <span class="keyword">when</span> (<span class="keyword">val</span> sendResult = sendBuffered(element)) &#123;</span><br><span class="line">                        <span class="literal">null</span> -&gt; <span class="keyword">return</span> OFFER_SUCCESS</span><br><span class="line">                        <span class="keyword">is</span> Closed&lt;*&gt; -&gt; <span class="keyword">return</span> sendResult</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// otherwise there was receiver in queue, retry super.offerInternal</span></span><br><span class="line">                &#125;</span><br><span class="line">                result <span class="keyword">is</span> Closed&lt;*&gt; -&gt; <span class="keyword">return</span> result</span><br><span class="line">                <span class="keyword">else</span> -&gt; error(<span class="string">&quot;Invalid offerInternal result <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">offerSelectInternal</span><span class="params">(element: <span class="type">E</span>, select: <span class="type">SelectInstance</span>&lt;*&gt;)</span></span>: Any &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> result = <span class="keyword">if</span> (hasReceiveOrClosed)</span><br><span class="line">                <span class="keyword">super</span>.offerSelectInternal(element, select) <span class="keyword">else</span></span><br><span class="line">                (select.performAtomicTrySelect(describeSendBuffered(element)) ?: OFFER_SUCCESS)</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                result === ALREADY_SELECTED -&gt; <span class="keyword">return</span> ALREADY_SELECTED</span><br><span class="line">                result === OFFER_SUCCESS -&gt; <span class="keyword">return</span> OFFER_SUCCESS</span><br><span class="line">                result === OFFER_FAILED -&gt; &#123;&#125; <span class="comment">// retry</span></span><br><span class="line">                result === RETRY_ATOMIC -&gt; &#123;&#125; <span class="comment">// retry</span></span><br><span class="line">                result <span class="keyword">is</span> Closed&lt;*&gt; -&gt; <span class="keyword">return</span> result</span><br><span class="line">                <span class="keyword">else</span> -&gt; error(<span class="string">&quot;Invalid result <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(源码篇)30  CoroutineScope是如何管理协程的？</title>
      <link href="/posts/4f3df7f8/"/>
      <url>/posts/4f3df7f8/</url>
      
        <content type="html"><![CDATA[<p>通过前面课程的学习，我们知道 CoroutineScope 是实现协程结构化并发的关键。使用 CoroutineScope，我们可以批量管理同一个作用域下面所有的协程。那么，今天这节课，我们就来研究一下 CoroutineScope 是如何管理协程的。</p><h2 id="CoroutineScope-VS-结构化并发"><a href="#CoroutineScope-VS-结构化并发" class="headerlink" title="CoroutineScope VS 结构化并发"></a>CoroutineScope VS 结构化并发</h2><p>在前面的课程中，我们学习过 CoroutineScope 的用法。由于 launch、async 被定义成了 CoroutineScope 的扩展函数，这就意味着：在调用 launch 之前，我们必须先获取 CoroutineScope。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> CoroutineScope.<span class="title">async</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Deferred&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testScope</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">    scope.launch&#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，很多初学者可能不知道，协程早期的 API 并不是这么设计的，最初的 launch、async 只是普通的顶层函数，我们不需要 scope 就可以直接创建协程，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testScope</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 早期协程API的写法</span></span><br><span class="line">    launch&#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，代码段 2 的写法要比代码段 1 的简单很多，那么 Kotlin 官方为什么要舍近求远，专门设计一个更加复杂的 API 呢？这一切，都是因为<strong>结构化并发</strong>。</p><p>让我们来看一段代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testScope</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">    scope.launch&#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">1000000L</span>)</span><br><span class="line">            logX(<span class="string">&quot;Inner&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        logX(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;World!&quot;</span>)  <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scope.launch&#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">1000000L</span>)</span><br><span class="line">            logX(<span class="string">&quot;Inner！！！&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        logX(<span class="string">&quot;Hello！！!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;World1!！！&quot;</span>)  <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">    scope.cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码很简单，我们使用 scope 创建了两个顶层的协程，接着，在协程的内部我们使用 launch 又创建了一个子协程。最后，我们在协程的外部等待了 500 毫秒，并且调用了 scope.cancel()。这样一来，我们前面创建的 4 个协程就全部都取消了。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/7b/80/7b40c302yy14d01d07787dc857a5cf80.jpg?wh=2000x1125" alt="img" style="zoom: 33%;" /><p>通过前面第 17 讲的学习，我们知道上面的代码其实可以用这样的关系图来表示。父协程是属于 Scope 的，子协程是属于父协程的，因此，只要调用了 scope.cancel()，这 4 个协程都会被取消。</p><p>想象一下，如果我们将上面的代码用协程最初的 API 改写的话，这一切就完全不一样了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用协程最初的API，只是伪代码</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testScopeJob</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> job = Job()</span><br><span class="line">    launch(job)&#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">1000000L</span>)</span><br><span class="line">            logX(<span class="string">&quot;Inner&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        logX(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;World!&quot;</span>)  <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch(job)&#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">1000000L</span>)</span><br><span class="line">            logX(<span class="string">&quot;Inner！！！&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        logX(<span class="string">&quot;Hello！！!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;World1!！！&quot;</span>)  <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">    job.cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，为了实现结构化并发，我们不得不创建一个 Job 对象，然后将其传入 launch 当中作为参数。</p><p>你能感受到其中的差别吗？如果使用原始的协程 API，结构化并发是需要开发者自觉往 launch 当中传 job 参数才能实现，它是<strong>可选</strong>的，开发者也可能疏忽大意，忘记传参数。而 launch 成为 CoroutineScope 的扩展函数以后，这一切就成为必须的了，我们开发者不可能忘记。</p><p>而且，通过对比代码段 3 和 4 以后，我们也可以发现：<strong>CoroutineScope 管理协程的能力，其实也是源自于 Job</strong>。</p><p>那么，CoroutineScope 与 Job 到底是如何实现结构化并发的呢？接下来，让我们从源码中寻找答案吧！</p><p><strong>父子关系在哪里建立的？</strong></p><p>在分析源码之前，我们先来写一个简单的 Demo。接下来，我们就以这个 Demo 为例，来研究一下 CoroutineScope 是如何通过 Job 来管理协程的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testScope</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">    scope.launch&#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">1000000L</span>)</span><br><span class="line">            logX(<span class="string">&quot;Inner&quot;</span>)  <span class="comment">// 不会执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        logX(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;World!&quot;</span>)  <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    scope.cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineScope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Job</span> : <span class="type">CoroutineContext.Element</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>以上代码的逻辑很简单，我们先来看看注释 1 对应的地方。我们都知道，CoroutineScope 是一个接口，那么我们为<strong>什么可以调用它的构造函数，来创建 CoroutineScope 对象呢？</strong>不应该使用 object 关键字创建匿名内部类吗？</p><p>其实，代码段 5 当中调用 CoroutineScope() 并不是构造函数，而是一个顶层函数：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶层函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">CoroutineScope</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineScope =</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    ContextScope(<span class="keyword">if</span> (context[Job] != <span class="literal">null</span>) context <span class="keyword">else</span> context + Job())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶层函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">Job</span><span class="params">(parent: <span class="type">Job</span>? = <span class="literal">null</span>)</span></span>: CompletableJob = JobImpl(parent)</span><br></pre></td></tr></table></figure><p>在第 1 讲当中，我曾提到过，Kotlin 当中的函数名称，在大部分情况下都是遵循“驼峰命名法”的，而在一些特殊情况下则不遵循这种命名法。上面的顶层函数 CoroutineScope()，其实就属于特殊的情况，因为它虽然是一个普通的顶层函数，但它发挥的作用却是“构造函数”。类似的用法，还有 Job() 这个顶层函数。</p><p>因此，在 Kotlin 当中，当顶层函数作为构造函数使用的时候，<strong>它的首字母是要大写的</strong>。</p><p>让我们回到代码段 6，看看其中注释 1 的地方。这行代码的意思是，当我们创建 CoroutineScope 的时候，如果传入的 Context 是包含 Job 的，那就直接用；如果是不包含 Job 的，就会创建一个新的 Job。这就意味着<strong>，每一个 CoroutineScope 对象，它的 Context 当中必定存在一个 Job 对象</strong>。而代码段 5 当中的 CoroutineScope(Job())，改成 CoroutineScope() 也是完全没问题的。</p><p>接下来，我们再来看看 launch 的源代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面两节课里，我们已经分析过注释 1 和注释 3 当中的逻辑了，这节课呢，我们来分析注释 2 处的逻辑。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">StandaloneCoroutine</span>(</span><br><span class="line">    parentContext: CoroutineContext,</span><br><span class="line">    active: <span class="built_in">Boolean</span></span><br><span class="line">) : AbstractCoroutine&lt;<span class="built_in">Unit</span>&gt;(parentContext, initParentJob = <span class="literal">true</span>, active = active) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleJobException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        handleCoroutineException(context, exception)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LazyStandaloneCoroutine</span>(</span><br><span class="line">    parentContext: CoroutineContext,</span><br><span class="line">    block: <span class="keyword">suspend</span> CoroutineScope.() -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : StandaloneCoroutine(parentContext, active = <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> continuation = block.createCoroutineUnintercepted(<span class="keyword">this</span>, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        continuation.startCoroutineCancellable(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，StandaloneCoroutine 是 AbstractCoroutine 的子类，而在第 28 讲当中，我们就已经遇到过 AbstractCoroutine，它其实就是代表了<strong>协程的抽象类</strong>。另外这里有一个 initParentJob 参数，它是 true，代表了协程创建了以后，需要初始化协程的父子关系。而 LazyStandaloneCoroutine 则是 StandaloneCoroutine 的子类，它的 active 参数是 false，代表了以懒加载的方式创建协程。</p><p>接下来，我们就看看它们的父类 AbstractCoroutine：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCoroutine</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    parentContext: CoroutineContext,</span><br><span class="line">    initParentJob: <span class="built_in">Boolean</span>,</span><br><span class="line">    active: <span class="built_in">Boolean</span></span><br><span class="line">) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initParentJob) initParentJob(parentContext[Job])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们就看看它们的父类 AbstractCoroutine：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCoroutine</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    parentContext: CoroutineContext,</span><br><span class="line">    initParentJob: <span class="built_in">Boolean</span>,</span><br><span class="line">    active: <span class="built_in">Boolean</span></span><br><span class="line">) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initParentJob) initParentJob(parentContext[Job])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>AbstractCoroutine 其实是 JobSupport 的子类</strong>，在它的 init{} 代码块当中，会根据 initParentJob 参数，判断是否需要初始化协程的父子关系。这个参数我们在代码段 8 当中已经分析过了，它一定是 true，所以这里的 initParentJob() 方法一定会执行，而它的参数 parentContext[Job]取出来的 Job，其实就是我们在 Scope 当中的 Job。</p><p>另外，这里的 initParentJob() 方法，是它的父类 JobSupport 当中的方法，我们来看看：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">JobSupport</span> <span class="keyword">constructor</span>(active: <span class="built_in">Boolean</span>) : Job, ChildJob, ParentJob, SelectClause0 &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt; <span class="keyword">get</span>() = Job</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">initParentJob</span><span class="params">(parent: <span class="type">Job</span>?)</span></span> &#123;</span><br><span class="line">        assert &#123; parentHandle == <span class="literal">null</span> &#125;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) &#123;</span><br><span class="line">            parentHandle = NonDisposableHandle</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        parent.start()</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;DEPRECATION&quot;</span>)</span></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">val</span> handle = parent.attachChild(<span class="keyword">this</span>)</span><br><span class="line">        parentHandle = handle</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isCompleted) &#123;</span><br><span class="line">            handle.dispose()</span><br><span class="line">            parentHandle = NonDisposableHandle </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Job源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Job</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> children: Sequence&lt;Job&gt;   </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">attachChild</span><span class="params">(child: <span class="type">ChildJob</span>)</span></span>: ChildHandle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>AbstractCoroutine 其实是 JobSupport 的子类</strong>，在它的 init{} 代码块当中，会根据 initParentJob 参数，判断是否需要初始化协程的父子关系。这个参数我们在代码段 8 当中已经分析过了，它一定是 true，所以这里的 initParentJob() 方法一定会执行，而它的参数 parentContext[Job]取出来的 Job，其实就是我们在 Scope 当中的 Job。</p><p>另外，这里的 initParentJob() 方法，是它的父类 JobSupport 当中的方法，我们来看看：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">JobSupport</span> <span class="keyword">constructor</span>(active: <span class="built_in">Boolean</span>) : Job, ChildJob, ParentJob, SelectClause0 &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt; <span class="keyword">get</span>() = Job</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">initParentJob</span><span class="params">(parent: <span class="type">Job</span>?)</span></span> &#123;</span><br><span class="line">        assert &#123; parentHandle == <span class="literal">null</span> &#125;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) &#123;</span><br><span class="line">            parentHandle = NonDisposableHandle</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        parent.start()</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;DEPRECATION&quot;</span>)</span></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">val</span> handle = parent.attachChild(<span class="keyword">this</span>)</span><br><span class="line">        parentHandle = handle</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isCompleted) &#123;</span><br><span class="line">            handle.dispose()</span><br><span class="line">            parentHandle = NonDisposableHandle </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Job源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Job</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> children: Sequence&lt;Job&gt;   </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">attachChild</span><span class="params">(child: <span class="type">ChildJob</span>)</span></span>: ChildHandle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码一共有三个地方需要注意，我们来分析一下：</p><ul><li>注释 1，判断传入的 parent 是否为空，如果 parent 为空，说明当前的协程不存在父 Job，这时候就谈不上创建协程父子关系了。不过，如果按照代码段 5 的逻辑来分析的话，此处的 parent 则是 scope 当中的 Job，因此，代码会继续执行到注释 2。</li><li>注释 2，这里是确保 parent 对应的 Job 启动了。</li><li>注释 3，parent.attachChild(this)，这个方法我们在第 16 讲当中提到过，它会将当前的 Job，添加为 parent 的子 Job。<strong>这里其实就是建立协程父子关系的关键代码。</strong></li></ul><p>所以，我们可以将协程的结构当作一颗 <strong>N 叉树</strong>。每一个协程，都对应着一个 Job 的对象，而每一个 Job 可以有一个父 Job，也可以有多个子 Job。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/30/9a/308decb3a0d5c89d2082673d00f33f9a.jpg?wh=2000x1013" alt="img" style="zoom: 33%;" /><p>这样，当我们知道协程的父子关系是如何建立的了以后，父协程如何取消子协程也就很容易理解了。</p><h2 id="协程是如何“结构化取消”的？"><a href="#协程是如何“结构化取消”的？" class="headerlink" title="协程是如何“结构化取消”的？"></a>协程是如何“结构化取消”的？</h2><p>其实，协程的结构化取消，本质上是<strong>事件的传递</strong>，它跟我们平时生活中的场景都是类似的：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/0b/da/0b95644933e584dcdf0e8a24696394da.jpg?wh=2000x986" alt="img" style="zoom:33%;" /><p>就比如，当我们在学校、公司内部，有消息或任务需要传递的时候，总是遵循这样的规则：处理好分内的事情，剩下的部分交给上级和下级。协程的结构化取消，也是通过这样的事件消息模型来实现的。</p><p>甚至，如果让我们来实现协程 API 的话，都能想象到它的代码该怎么写：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Job.<span class="title">cancelJob</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通知子Job</span></span><br><span class="line">    children.forEach &#123;</span><br><span class="line">        cancelJob()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知父Job</span></span><br><span class="line">    notifyParentCancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，以上只是简化后的伪代码，真实的协程代码一定比这个复杂很多，但只要你能理解这一点，我们后面的分析就很简单了。让我们接着代码段 5 当中的注释 2，继续分析 scope.cancel() 后续的流程。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">cancel</span><span class="params">(cause: <span class="type">CancellationException</span>? = <span class="literal">null</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> job = coroutineContext[Job] ?: error(<span class="string">&quot;Scope cannot be cancelled because it does not have a job: <span class="variable">$this</span>&quot;</span>)</span><br><span class="line">    job.cancel(cause)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，CoroutineScope 的 cancel() 方法，本质上是调用了它当中的 Job.cancel()。而这个方法的具体实现在 JobSupport 当中：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">(cause: <span class="type">CancellationException</span>?)</span></span> &#123;</span><br><span class="line">    cancelInternal(cause ?: defaultCancellationException())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancelInternal</span><span class="params">(cause: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">    cancelImpl(cause)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancelImpl</span><span class="params">(cause: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> finalState: Any? = COMPLETING_ALREADY</span><br><span class="line">    <span class="keyword">if</span> (onCancelComplete) &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        finalState = cancelMakeCompleting(cause)</span><br><span class="line">        <span class="keyword">if</span> (finalState === COMPLETING_WAITING_CHILDREN) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finalState === COMPLETING_ALREADY) &#123;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        finalState = makeCancelling(cause)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        finalState === COMPLETING_ALREADY -&gt; <span class="literal">true</span></span><br><span class="line">        finalState === COMPLETING_WAITING_CHILDREN -&gt; <span class="literal">true</span></span><br><span class="line">        finalState === TOO_LATE_TO_CANCEL -&gt; <span class="literal">false</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            afterCompletion(finalState)</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，job.cancel() 最终会调用 JobSupport 的 <strong>cancelImpl() 方法</strong>。其中有两个注释，代表了两个分支，它的判断依据是 onCancelComplete 这个 Boolean 类型的成员属性。这个其实就代表了当前的 Job，是否有协程体需要执行。</p><p>另外，由于 CoroutineScope 当中的 Job 是我们手动创建的，并不需要执行任何协程代码，所以，它会是 <strong>true</strong>。也就是说，这里会执行注释 1 对应的代码。</p><p>让我们继续分析 cancelMakeCompleting() 方法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancelMakeCompleting</span><span class="params">(cause: <span class="type">Any</span>?)</span></span>: Any? &#123;</span><br><span class="line">    loopOnState &#123; state -&gt;</span><br><span class="line">        <span class="comment">// 省略部分</span></span><br><span class="line">        <span class="keyword">val</span> finalState = tryMakeCompleting(state, proposedUpdate)</span><br><span class="line">        <span class="keyword">if</span> (finalState !== COMPLETING_RETRY) <span class="keyword">return</span> finalState</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">tryMakeCompleting</span><span class="params">(state: <span class="type">Any</span>?, proposedUpdate: <span class="type">Any</span>?)</span></span>: Any? &#123;</span><br><span class="line">    <span class="keyword">if</span> (state !<span class="keyword">is</span> Incomplete)</span><br><span class="line">        <span class="keyword">return</span> COMPLETING_ALREADY</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略部分</span></span><br><span class="line">        <span class="keyword">return</span> COMPLETING_RETRY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tryMakeCompletingSlowPath(state, proposedUpdate)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">tryMakeCompletingSlowPath</span><span class="params">(state: <span class="type">Incomplete</span>, proposedUpdate: <span class="type">Any</span>?)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// 省略部分</span></span><br><span class="line">    notifyRootCause?.let &#123; notifyCancelling(list, it) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> finalizeFinishingState(finishing, proposedUpdate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以看到 cancelMakeCompleting() 会调用 tryMakeCompleting() 方法，最终则会调用 tryMakeCompletingSlowPath() 当中的 notifyCancelling() 方法。所以<strong>，它才是最关键的代码</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">notifyCancelling</span><span class="params">(list: <span class="type">NodeList</span>, cause: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    onCancelling(cause)</span><br><span class="line">    <span class="comment">// 1，通知子Job</span></span><br><span class="line">    notifyHandlers&lt;JobCancellingNode&gt;(list, cause)</span><br><span class="line">    <span class="comment">// 2，通知父Job</span></span><br><span class="line">    cancelParent(cause)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面代码段 15 和我们前面写的代码段 11 当中的伪代码的逻辑是一致的。我们再分别来看看它们具体的逻辑：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T: JobNode&gt;</span> <span class="title">notifyHandlers</span><span class="params">(list: <span class="type">NodeList</span>, cause: <span class="type">Throwable</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> exception: Throwable? = <span class="literal">null</span></span><br><span class="line">    list.forEach&lt;T&gt; &#123; node -&gt;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            node.invoke(cause)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ex: Throwable) &#123;</span><br><span class="line">            exception?.apply &#123; addSuppressedThrowable(ex) &#125; ?: run &#123;</span><br><span class="line">                exception =  CompletionHandlerException(<span class="string">&quot;Exception in completion handler <span class="variable">$node</span> for <span class="variable">$this</span>&quot;</span>, ex)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    exception?.let &#123; handleOnCompletionException(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码段 16 当中的逻辑，就是遍历当前 Job 的子 Job，并将取消的 cause 传递过去，这里的 invoke() 最终会调用 ChildHandleNode 的 invoke() 方法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">ChildHandleNode</span>(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> childJob: ChildJob</span><br><span class="line">) : JobCancellingNode(), ChildHandle &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> parent: Job <span class="keyword">get</span>() = job</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(cause: <span class="type">Throwable</span>?)</span></span> = childJob.parentCancelled(job)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">childCancelled</span><span class="params">(cause: <span class="type">Throwable</span>)</span></span>: <span class="built_in">Boolean</span> = job.childCancelled(cause)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">parentCancelled</span><span class="params">(parentJob: <span class="type">ParentJob</span>)</span></span> &#123;</span><br><span class="line">    cancelImpl(parentJob)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，从以上代码中我们可以看到，ChildHandleNode 的 invoke() 方法会调用 parentCancelled() 方法，而它最终会调用 cancelImpl() 方法。其实，这个就是代码段 13 当中的 cancelImpl() 方法，也就是 Job 取消的入口函数。这实际上就相当于在做<strong>递归调用</strong>。</p><p>接下来，我们看看代码段 15 当中的注释 2，通知父 Job 的流程：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancelParent</span><span class="params">(cause: <span class="type">Throwable</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isScopedCoroutine) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isCancellation = cause <span class="keyword">is</span> CancellationException</span><br><span class="line">    <span class="keyword">val</span> parent = parentHandle</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent === <span class="literal">null</span> || parent === NonDisposableHandle) &#123;</span><br><span class="line">        <span class="keyword">return</span> isCancellation</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> parent.childCancelled(cause) || isCancellation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请留意上面代码段的注释 1，这个函数的返回值是有意义的，返回 true 代表父协程处理了异常，而返回 false，代表父协程没有处理异常。这种类似<strong>责任链的设计模式</strong>，在很多领域都有应用，比如 Android 的事件分发机制、OkHttp 的拦截器，等等。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">childCancelled</span><span class="params">(cause: <span class="type">Throwable</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cause <span class="keyword">is</span> CancellationException) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> cancelImpl(cause) &amp;&amp; handlesException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，当异常是 CancellationException 的时候，协程是会进行特殊处理的。一般来说，父协程会忽略子协程的取消异常，这一点我们在第 23 讲当中也提到过。而如果是其他的异常，那么父协程就会响应子协程的取消了。这个时候，我们的代码又会继续递归调用代码段 13 当中的 cancelImpl() 方法了。</p><p>至此，协程的“结构化取消”部分的逻辑，我们也分析完了。让我们通过视频来看看它们整体的执行流程。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天的内容到这里就结束了，我们来总结和回顾一下这节课里涉及到的知识点：</p><ul><li>每次创建 CoroutineScope 的时候，它的内部会确保 CoroutineContext 当中一定存在 Job 元素，而 CoroutineScope 就是通过这个 Job 对象来管理协程的。</li><li>在我们通过 launch、async 创建协程的时候，会同时创建 AbstractCoroutine 的子类，在它的 initParentJob() 方法当中，会建立协程的父子关系。每个协程都会对应一个 Job，而每个 Job 都会有一个父 Job，多个子 Job。最终它们会形成一个 N 叉树的结构。</li><li>由于协程是一个 N 叉树的结构，因此协程的取消事件以及异常传播，也会按照这个结构进行传递。每个 Job 取消的时候，都会通知自己的子 Job 和父 Job，最终以递归的形式传递给每一个协程。另外，协程在向上取消父 Job 的时候，还利用了责任链模式，确保取消事件可以一步步传播到最顶层的协程。这里还有一个细节就是，默认情况下，父协程都会忽略子协程的 CancellationException。</li></ul><p>到这里，我们其实就可以进一步总结出协程的<strong>结构化取消</strong>的规律了。</p><p>对于 CancellationException 引起的取消，它只会向下传播，取消子协程；对于其他的异常引起的取消，它既向上传播，也向下传播，最终会导致所有协程都被取消。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/04/35/04a978310f722996c38bd09a00fdae35.gif?wh=1080x608" alt="img" style="zoom: 67%;" /><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>在第 23 讲当中，我们学习过 SupervisorJob，它可以起到隔离异常传播的作用，下面是它的源代码，请问你能借助这节课学的知识点来分析下它的原理吗？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">SupervisorJob</span><span class="params">(parent: <span class="type">Job</span>? = <span class="literal">null</span>)</span></span> : CompletableJob = </span><br><span class="line">    SupervisorJobImpl(parent)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SupervisorJobImpl</span>(parent: Job?) : JobImpl(parent) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">childCancelled</span><span class="params">(cause: <span class="type">Throwable</span>)</span></span>: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(源码篇)29  Dispatchers是如何工作的？</title>
      <link href="/posts/c0627888/"/>
      <url>/posts/c0627888/</url>
      
        <content type="html"><![CDATA[<p>今天，我们来分析 Kotlin 协程当中的 Dispatchers。</p><p>上节课里，我们分析了 launch 的源代码，从中我们知道，Kotlin 的 launch 会调用 startCoroutineCancellable()，接着又会调用 createCoroutineUnintercepted()，最终会调用编译器帮我们生成 SuspendLambda 实现类当中的 create() 方法。这样，协程就创建出来了。不过，协程是创建出来了，可它是如何运行的呢？</p><p>另外我们也都知道，协程无法脱离线程运行，Kotlin 当中所有的协程，最终都是运行在线程之上的。那么，<strong>协程创建出来以后，它又是如何跟线程产生关联的</strong>？这节课，我们将进一步分析 launch 的启动流程，去发掘上节课我们忽略掉的代码分支。</p><p>我相信，经过这节课的学习，你会对协程与线程之间的关系有一个更加透彻的认识。</p><h2 id="Dispatchers"><a href="#Dispatchers" class="headerlink" title="Dispatchers"></a>Dispatchers</h2><p>在上节课里我们学习过，launch{}本质上是调用了 startCoroutineCancellable() 当中的 createCoroutineUnintercepted() 方法创建了协程。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): <span class="built_in">Unit</span> = runSafely(completion) &#123;</span><br><span class="line">    <span class="comment">//                                        注意这里</span></span><br><span class="line">    <span class="comment">//                                           ↓</span></span><br><span class="line">    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么下面，我们就接着上节课的流程，继续分析 createCoroutineUnintercepted(completion) 之后的 <strong>intercepted() 方法</strong>。</p><p>不过，在正式分析 intercepted() 之前，我们还需要弄清楚 Dispatchers、CoroutineDispatcher、ContinuationInterceptor、CoroutineContext 之间的关系。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">object</span> Dispatchers &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Default: CoroutineDispatcher = DefaultScheduler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Main: MainCoroutineDispatcher <span class="keyword">get</span>() = MainDispatcherLoader.dispatcher</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> IO: CoroutineDispatcher = DefaultIoScheduler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">shutdown</span><span class="params">()</span></span> &#123;    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoroutineDispatcher</span> :</span><br><span class="line">    <span class="type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> : <span class="type">CoroutineContext</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>在第 17 讲当中，我们曾经分析过它们之间的继承关系。Dispatchers 是一个单例对象，它当中的 Default、Main、Unconfined、IO，类型都是 CoroutineDispatcher，而它本身就是 CoroutineContext。所以，它们之间的关系就可以用下面这个图来描述。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/2c/d1/2cf4c3c45b6f6838e5fyy16a4fce02d1.jpg?wh=2000x1125" alt="img" style="zoom: 50%;" /><p>让我们结合这张图，来看看下面这段代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testLaunch()</span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testLaunch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">    scope.launch&#123;</span><br><span class="line">        logX(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制台输出带协程信息的log</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">logX</span><span class="params">(any: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">    println(</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">================================</span></span><br><span class="line"><span class="string"><span class="variable">$any</span></span></span><br><span class="line"><span class="string">Thread:<span class="subst">$&#123;Thread.currentThread().name&#125;</span></span></span><br><span class="line"><span class="string">================================&quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">World!</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们没有为 launch() 传入任何 CoroutineContext 参数，但通过执行结果，我们发现协程代码居然执行在 DefaultDispatcher，并没有运行在 main 线程之上。这是为什么呢？</p><p>我们可以回过头来分析下 launch 的源代码，去看看上节课中我们刻意忽略的地方。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，请留意 launch 的第一个参数，context，它的默认值是 EmptyCoroutineContext。在第 17 讲里，我曾提到过，CoroutineContext 就相当于 Map，而 EmptyCoroutineContext 则相当于一个空的 Map。所以，我们可以认为，这里的 EmptyCoroutineContext 传了也相当于没有传，它的目的只是为了让 context 参数不为空而已。<strong>这其实也体现出了 Kotlin 的空安全思维，Kotlin 官方用 EmptyCoroutineContext 替代了 null</strong>。</p><p>接着，请留意上面代码的注释 1，这行代码会调用 newCoroutineContext(context)，将传入的 context 参数重新包装一下，然后返回。让我们看看它具体的逻辑：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">newCoroutineContext</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> combined = coroutineContext.foldCopiesForChildCoroutine() + context</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">val</span> debug = <span class="keyword">if</span> (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) <span class="keyword">else</span> combined</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == <span class="literal">null</span>)</span><br><span class="line">        debug + Dispatchers.Default <span class="keyword">else</span> debug</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码一共有三个注释，我们来分析一下：</p><ul><li>注释 1，由于 newCoroutineContext() 是 CoroutineScope 的扩展函数，因此，我们可以直接访问 CoroutineScope 的 coroutineContext 对象，它其实就是 CoroutineScope 对应的上下文。foldCopiesForChildCoroutine() 的作用，其实就是将 CoroutineScope 当中的所有上下文元素都拷贝出来，然后跟传入的 context 参数进行合并。<strong>这行代码，可以让子协程继承父协程的上下文元素</strong>。</li><li>注释 2，它的作用是在调试模式下，为我们的协程对象增加唯一的 ID。我们在代码段 3 的输出结果中看到的“@coroutine#1”，其中的数字“1”就是在这个阶段生成的。</li><li>注释 3，如果合并过后的 combined 当中没有 CoroutineDispatcher，那么，就会默认使用 Dispatchers.Default。</li></ul><p>看到这里，你也许会有一个疑问，为什么协程默认的线程池是 Dispatchers.Default，而不是 Main 呢？答案其实也很简单，因为 Kotlin 协程是支持多平台的，<strong>Main 线程只在 UI 编程平台才有可用</strong>。因此，当我们的协程没有指定 Dispatcher 的时候，就只能使用 Dispatchers.Default 了。毕竟，协程是无法脱离线程执行的。</p><p>那么现在，代码段 3 当中的协程执行在 Dispatchers.Default 的原因也就找到了：由于我们定义的 scope 没有指定 Dispatcher，同时 launch 的参数也没有传入 Dispatcher，最终在 newCoroutineContext() 的时候，会被默认指定为 Default 线程池。</p><p>好，有了前面的基础以后，接下来，我们就可以开始 intercepted() 的逻辑了。</p><h2 id="CoroutineDispatcher-拦截器"><a href="#CoroutineDispatcher-拦截器" class="headerlink" title="CoroutineDispatcher 拦截器"></a>CoroutineDispatcher 拦截器</h2><p>让我们回到课程开头提到过的 startCoroutineCancellable() 方法的源代码，其中的 createCoroutineUnintercepted() 方法，我们在上节课已经分析过了，它的返回值类型就是Continuation。而 <strong>intercepted() 方法，其实就是 Continuation 的扩展函数</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): <span class="built_in">Unit</span> = runSafely(completion) &#123;</span><br><span class="line">    <span class="comment">//                                        注意这里</span></span><br><span class="line">    <span class="comment">//                                           ↓</span></span><br><span class="line">    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ContinuationImpl</span>(</span><br><span class="line">    completion: Continuation&lt;Any?&gt;?,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _context: CoroutineContext?</span><br><span class="line">) : BaseContinuationImpl(completion) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(completion: Continuation&lt;Any?&gt;?) : <span class="keyword">this</span>(completion, completion?.context)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> intercepted: Continuation&lt;Any?&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;Any?&gt; =</span><br><span class="line">        intercepted</span><br><span class="line">            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span>)</span><br><span class="line">                .also &#123; intercepted = it &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以看到，startCoroutineCancellable() 当中的 intercepted() 最终会调用 BaseContinuationImpl 的 intercepted() 方法。</p><p>这里，请你留意代码中我标记出的注释，intercepted() 方法首先会判断它的成员变量 <strong>intercepted 是否为空</strong>，如果为空，就会调用 context[ContinuationInterceptor]，获取上下文当中的 Dispatcher 对象。以代码段 3 当中的逻辑为例，这时候的 Dispatcher 肯定是 Default 线程池。</p><p>然后，如果我们继续跟进 interceptContinuation(this) 方法的话，会发现程序最终会调用 CoroutineDispatcher 的 interceptContinuation() 方法。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoroutineDispatcher</span> :</span><br><span class="line">    <span class="type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">        DispatchedContinuation(<span class="keyword">this</span>, continuation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样留意下这里的注释 1，interceptContinuation() 直接返回了一个 DispatchedContinuation 对象，并且将 this、continuation 作为参数传了进去。这里的 this，其实就是 Dispatchers.Default。</p><p>所以，如果我们把 startCoroutineCancellable() 改写一下，它实际上会变成下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): <span class="built_in">Unit</span> = runSafely(completion) &#123;</span><br><span class="line">    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line"><span class="comment">//  ↓</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): <span class="built_in">Unit</span> = runSafely(completion) &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> continuation = createCoroutineUnintercepted(completion)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">val</span> dispatchedContinuation = continuation.intercepted()</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    dispatchedContinuation.resumeCancellableWith(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，注释 1，2 我们都已经分析完了，现在只剩下注释 3 了。这里的 resumeCancellableWith()，其实就是真正将协程任务分发到线程上的逻辑。让我们继续跟进分析源代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">DispatchedContinuation</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> dispatcher: CoroutineDispatcher,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;</span><br><span class="line">) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; <span class="keyword">by</span> continuation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">noinline</span> onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="comment">// 省略，留到后面分析</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是，DispatchedContinuation 是实现了 Continuation 接口，同时，它使用了“类委托”的语法，将接口的具体实现委托给了它的成员属性 continuation。通过之前代码段 7 的分析，我们知道它的成员属性 <strong>dispatcher 对应的就是 Dispatcher.Default</strong>，而<strong>成员属性 continuation 对应的则是 launch 当中传入的 SuspendLambda 实现类。</strong></p><p>另外，DispatchedContinuation 还继承自 DispatchedTask，我们来看看 DispatchedTask 到底是什么。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DispatchedTask</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">public</span> <span class="keyword">var</span> resumeMode: <span class="built_in">Int</span></span><br><span class="line">) : SchedulerTask() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">actual</span> <span class="keyword">typealias</span> SchedulerTask = Task</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Task</span>(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">var</span> submissionTime: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">var</span> taskContext: TaskContext</span><br><span class="line">) : Runnable &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="number">0</span>, NonBlockingContext)</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">val</span> mode: <span class="built_in">Int</span> <span class="keyword">get</span>() = taskContext.taskMode <span class="comment">// TASK_XXX</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，DispatchedContinuation 继承自 DispatchedTask，而它则是 SchedulerTask 的子类，SchedulerTask 是 Task 的类型别名，而 Task 实现了 Runnable 接口。因此，<strong>DispatchedContinuation 不仅是一个 Continuation，同时还是一个 Runnable</strong>。</p><p>那么，既然它是 Runnable，也就意味着它可以被分发到 Java 的线程当中去执行了。所以接下来，我们就来看看 resumeCancellableWith() 当中具体的逻辑：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">DispatchedContinuation</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> dispatcher: CoroutineDispatcher,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;</span><br><span class="line">) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; <span class="keyword">by</span> continuation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">noinline</span> onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> state = result.toState(onCancellation)</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">            _state = state</span><br><span class="line">            resumeMode = MODE_CANCELLABLE</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line">            executeUnconfined(state, MODE_CANCELLABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!resumeCancelled(state)) &#123;</span><br><span class="line">                    resumeUndispatchedWith(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoroutineDispatcher</span> :</span><br><span class="line">    <span class="type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class="line">    <span class="comment">// 默认是true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">isDispatchNeeded</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> Unconfined : CoroutineDispatcher() &#123;</span><br><span class="line">    <span class="comment">// 只有Unconfined会重写成false</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isDispatchNeeded</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码里也有三个注释，我们来分析一下：</p><ul><li>注释 1，dispatcher.isDispatchNeeded()，通过查看 CoroutineDispatcher 的源代码，我们发现它的返回值始终都是 true。在它的子类当中，只有 Dispatchers.Unconfined 会将其重写成 false。这也就意味着，除了 Unconfined 以外，其他的 Dispatcher 都会返回 true。对于我们代码段 3 当中的代码而言，我们的 Dispatcher 是默认的 Default，所以，代码将会进入注释 2 对应的分支。</li><li>注释 2，dispatcher.dispatch(context, this)，这里其实就相当于将代码的执行流程分发到 Default 线程池。dispatch() 的第二个参数要求是 Runnable，这里我们传入的是 this，这是因为 DispatchedContinuation 本身就间接实现了 Runnable 接口。</li><li>注释 3，executeUnconfined{}，它其实就对应着 Dispather 是 Unconfined 的情况，这时候，协程的执行不会被分发到别的线程，而是直接在当前线程执行。</li></ul><p>接下来，让我们继续沿着注释 2 进行分析，这里的 dispatcher.dispatch() 其实就相当于调用了 Dispatchers.Default.dispatch()。让我们看看它的逻辑：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">object</span> Dispatchers &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Default: CoroutineDispatcher = DefaultScheduler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> DefaultScheduler : SchedulerCoroutineDispatcher(</span><br><span class="line">    CORE_POOL_SIZE, MAX_POOL_SIZE,</span><br><span class="line">    IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME</span><br><span class="line">) &#123;&#125;</span><br></pre></td></tr></table></figure><p>那么，从上面的代码中，我们可以看到，<strong>Dispatchers.Default 本质上是一个单例对象 DefaultScheduler</strong>，它是 SchedulerCoroutineDispatcher 的子类。</p><p>我们也来看看 SchedulerCoroutineDispatcher 的源代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SchedulerCoroutineDispatcher</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> corePoolSize: <span class="built_in">Int</span> = CORE_POOL_SIZE,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> maxPoolSize: <span class="built_in">Int</span> = MAX_POOL_SIZE,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> idleWorkerKeepAliveNs: <span class="built_in">Long</span> = IDLE_WORKER_KEEP_ALIVE_NS,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> schedulerName: String = <span class="string">&quot;CoroutineScheduler&quot;</span>,</span><br><span class="line">) : ExecutorCoroutineDispatcher() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> coroutineScheduler = createScheduler()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span>: <span class="built_in">Unit</span> = coroutineScheduler.dispatch(block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上代码，我们可以看到 Dispatchers.Default.dispatch() 最终会调用 SchedulerCoroutineDispatcher 的 dispatch() 方法，而它实际上调用的是 coroutineScheduler.dispatch()。</p><p>这里，我们同样再来看看 CoroutineScheduler 的源代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">CoroutineScheduler</span>(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> corePoolSize: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> maxPoolSize: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> idleWorkerKeepAliveNs: <span class="built_in">Long</span> = IDLE_WORKER_KEEP_ALIVE_NS,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> schedulerName: String = DEFAULT_SCHEDULER_NAME</span><br><span class="line">) : Executor, Closeable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">(command: <span class="type">Runnable</span>)</span></span> = dispatch(command)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: <span class="type">Runnable</span>, taskContext: <span class="type">TaskContext</span> = NonBlockingContext, tailDispatch: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span> &#123;</span><br><span class="line">        trackTask() </span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">val</span> task = createTask(block, taskContext)</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">val</span> currentWorker = currentWorker()</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">val</span> notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)</span><br><span class="line">        <span class="keyword">if</span> (notAdded != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!addToGlobalQueue(notAdded)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> RejectedExecutionException(<span class="string">&quot;<span class="variable">$schedulerName</span> was terminated&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> skipUnpark = tailDispatch &amp;&amp; currentWorker != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (task.mode == TASK_NON_BLOCKING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (skipUnpark) <span class="keyword">return</span></span><br><span class="line">            signalCpuWork()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            signalBlockingWork(skipUnpark = skipUnpark)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">currentWorker</span><span class="params">()</span></span>: Worker? = (Thread.currentThread() <span class="keyword">as</span>? Worker)?.takeIf &#123; it.scheduler == <span class="keyword">this</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类 Worker</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">private</span> <span class="keyword">constructor</span>() : Thread() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你发现了吗？CoroutineScheduler 其实是 Java 并发包下的 Executor 的子类，它的 execute() 方法也被转发到了 dispatch()。</p><p>上面的代码里也有三个注释，我们分别来看看：</p><ul><li>注释 1，将传入的 Runnable 类型的 block（也就是 DispatchedContinuation），包装成 Task。</li><li>注释 2，currentWorker()，拿到当前执行的线程。这里的 Worker 其实是一个内部类，它本质上仍然是 Java 的 Thread。</li><li>注释 3，currentWorker.submitToLocalQueue()，将当前的 Task 添加到 Worker 线程的本地队列，等待执行。</li></ul><p>那么接下来，我们就来分析下 Worker 是如何执行 Task 的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">private</span> <span class="keyword">constructor</span>() : Thread() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> = runWorker()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    <span class="keyword">var</span> mayHaveLocalTasks = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">runWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> rescanned = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">while</span> (!isTerminated &amp;&amp; state != WorkerState.TERMINATED) &#123;</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">val</span> task = findTask(mayHaveLocalTasks)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">                rescanned = <span class="literal">false</span></span><br><span class="line">                minDelayUntilStealableTaskNs = <span class="number">0L</span></span><br><span class="line">                <span class="comment">// 2</span></span><br><span class="line">                executeTask(task)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mayHaveLocalTasks = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minDelayUntilStealableTaskNs != <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rescanned) &#123;</span><br><span class="line">                    rescanned = <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    rescanned = <span class="literal">false</span></span><br><span class="line">                    tryReleaseCpu(WorkerState.PARKING)</span><br><span class="line">                    interrupted()</span><br><span class="line">                    LockSupport.parkNanos(minDelayUntilStealableTaskNs)</span><br><span class="line">                    minDelayUntilStealableTaskNs = <span class="number">0L</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tryPark()</span><br><span class="line">        &#125;</span><br><span class="line">        tryReleaseCpu(WorkerState.TERMINATED)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，Worker 会重写 Thread 的 run() 方法，然后把执行流程交给 runWorker()，以上代码里有两个关键的地方，我也用注释标记了。</p><ul><li>注释 1，在 while 循环当中，会一直尝试从 Worker 的本地队列取 Task 出来，如果存在需要执行的 Task，就会进入下一步。</li><li>注释 2，executeTask(task)，其实就是执行对应的 Task。</li></ul><p>而接下来的逻辑，就是<strong>最关键的部分</strong>了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">private</span> <span class="keyword">constructor</span>() : Thread() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeTask</span><span class="params">(task: <span class="type">Task</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> taskMode = task.mode</span><br><span class="line">        idleReset(taskMode)</span><br><span class="line">        beforeTask(taskMode)</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        runSafely(task)</span><br><span class="line">        afterTask(taskMode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runSafely</span><span class="params">(task: <span class="type">Task</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        task.run()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        <span class="keyword">val</span> thread = Thread.currentThread()</span><br><span class="line">        thread.uncaughtExceptionHandler.uncaughtException(thread, e)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unTrackTask()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Task</span>(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">var</span> submissionTime: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">var</span> taskContext: TaskContext</span><br><span class="line">) : Runnable &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="number">0</span>, NonBlockingContext)</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">val</span> mode: <span class="built_in">Int</span> <span class="keyword">get</span>() = taskContext.taskMode <span class="comment">// TASK_XXX</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Worker 的 executeTask() 方法当中，会调用 runSafely() 方法，而在这个方法当中，最终会调用 task.run()。前面我们就提到过 <strong>Task 本质上就是 Runnable，而 Runnable.run() 其实就代表了我们的协程任务真正执行了！</strong></p><p>那么，task.run() 具体执行的代码是什么呢？其实它是执行的 **DispatchedTask.run()**。这里的 DispatchedTask 实际上是 DispatchedContinuation 的父类。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">DispatchedContinuation</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> dispatcher: CoroutineDispatcher,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;</span><br><span class="line">) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; <span class="keyword">by</span> continuation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> taskContext = <span class="keyword">this</span>.taskContext</span><br><span class="line">        <span class="keyword">var</span> fatalException: Throwable? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> delegate = delegate <span class="keyword">as</span> DispatchedContinuation&lt;T&gt;</span><br><span class="line">            <span class="keyword">val</span> continuation = delegate.continuation</span><br><span class="line">            withContinuationContext(continuation, delegate.countOrElement) &#123;</span><br><span class="line">                <span class="keyword">val</span> context = continuation.context</span><br><span class="line">                <span class="keyword">val</span> state = takeState() </span><br><span class="line">                <span class="keyword">val</span> exception = getExceptionalResult(state)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> job = <span class="keyword">if</span> (exception == <span class="literal">null</span> &amp;&amp; resumeMode.isCancellableMode) context[Job] <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">                <span class="keyword">if</span> (job != <span class="literal">null</span> &amp;&amp; !job.isActive) &#123;</span><br><span class="line">                    <span class="comment">// 1</span></span><br><span class="line">                    <span class="keyword">val</span> cause = job.getCancellationException()</span><br><span class="line">                    cancelCompletedResult(state, cause)</span><br><span class="line">                    continuation.resumeWithStackTrace(cause)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 2</span></span><br><span class="line">                        continuation.resumeWithException(exception)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 3</span></span><br><span class="line">                        continuation.resume(getSuccessfulResult(state))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line"></span><br><span class="line">            fatalException = e</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> result = runCatching &#123; taskContext.afterTask() &#125;</span><br><span class="line">            handleFatalException(fatalException, result.exceptionOrNull())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码有三个关键的注释，我们一起来分析：</p><ul><li>注释 1，在协程代码执行之前，它首先会判断当前协程是否已经取消。如果已经取消的话，就会调用 continuation.resumeWithStackTrace(cause) 将具体的原因传出去。</li><li>注释 2，判断协程是否发生了异常，如果已经发生了异常，则需要调用 continuation.resumeWithException(exception) 将异常传递出去。</li><li>注释 3，如果一切正常，则会调用 continuation.resume(getSuccessfulResult(state))，这时候，协程才会正式启动，并且执行 launch 当中传入的 Lambda 表达式。</li></ul><p>最后，按照惯例，我还是制作了一个视频，来向你展示整个 Dispather 的代码执行流程。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课，我们围绕着 launch，着重分析了它的 Dispatchers 执行流程。Dispatchers 是协程框架中与线程交互的关键，这里面主要涉及以下几个步骤：</p><ul><li>第一步，createCoroutineUnintercepted(completion) 创建了协程的 Continuation 实例，紧接着就会调用它的 intercepted() 方法，将其封装成 DispatchedContinuation 对象。</li><li>第二步，DispatchedContinuation 会持有 CoroutineDispatcher、以及前面创建的 Continuation 对象。课程中的 CoroutineDispatcher 实际上就是 Default 线程池。</li><li>第三步，执行 DispatchedContinuation 的 resumeCancellableWith() 方法，这时候，就会执行 dispatcher.dispatch()，这就会将协程的 Continuation 封装成 Task 添加到 Worker 的本地任务队列，等待执行。这里的 Worker 本质上就是 Java 的 Thread。<strong>在这一步，协程就已经完成了线程的切换</strong>。</li><li>第四步，Worker 的 run() 方法会调用 runWork()，它会从本地的任务队列当中取出 Task，并且调用 task.run()。而它实际上调用的是 DispatchedContinuation 的 run() 方法，在这里，会调用 continuation.resume()，它将执行原本 launch 当中生成的 SuspendLambda 子类。这时候，<strong>launch 协程体当中的代码，就在线程上执行了。</strong></li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>经过这节课的学习以后，请问你是否对协程的本质有了更深入的认识？请讲讲你的心得体会吧！</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(源码篇)加餐五  深入理解协程基础元素</title>
      <link href="/posts/4c362f78/"/>
      <url>/posts/4c362f78/</url>
      
        <content type="html"><![CDATA[<p>在上一讲当中，我们深入研究了 Kotlin 挂起函数的原理，实际更多的是在了解协程的“基础层”。而接下来，我们将会开始研究协程启动的原理，探索协程的“中间层”。</p><p>在第 26 讲里，我曾提到过，Kotlin 的协程框架其实就是协程基础元素组合出来的框架。如果我们想要弄懂 Kotlin 协程，首先就要将它的“基础层”理解透彻。</p><p>所以今天，我还是决定来一次加餐，带你系统深入地认识一下 Kotlin 协程当中的基础元素。等你对协程的基础层有了深入认识以后，下节课研究协程启动原理就会轻松一些了。</p><h2 id="协程基础元素"><a href="#协程基础元素" class="headerlink" title="协程基础元素"></a>协程基础元素</h2><p>通过第 26 讲我们现在已经知道，Kotlin 协程的基础元素大致有这些：Continuation、SafeContinuation、CoroutineContext、CombinedContext、CancellationException、intrinsics。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/c6/ae/c65bbb36321c7683ea6d17155d2ee2ae.jpg?wh=2000x1125" alt="img" style="zoom: 50%;" /><p>其中的 CoroutineContext、CancellationException 我都已经介绍过了，另外的 CombinedContext，其实就是 CoroutineContext 的一个实现类，而 SafeContinuation 则是 Continuation 的实现类。</p><p>所以，在整个协程基础元素当中，我们最需要关心的，其实就是 <strong>Continuation 和 intrinsics</strong>。</p><p><em><strong>Continuation 到底该怎么用？</strong></em></p><p>实际上，在第 18 讲里，我们就已经学过 Continuation 的其中一种用法了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T =</span><br><span class="line">    suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class="line">        <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">// 注意这里</span></span><br><span class="line">                continuation.resume(<span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">// 注意这里</span></span><br><span class="line">                continuation.resumeWithException(throwable)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        continuation.invokeOnCancellation &#123;</span><br><span class="line">            println(<span class="string">&quot;Call cancelled!&quot;</span>)</span><br><span class="line">            call.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当我们想要实现挂起函数的时候，可以使用 suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，在它们的 Lambda 当中，我们可以使用它暴露出来的 continuation 对象，把程序的执行结果或异常传到外部去。</p><p><strong>这种方式，往往是用于实现挂起函数内部逻辑的。</strong></p><p>比如说，我们可以用 suspendCoroutine{}写一个更加简单的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = getLengthSuspend(<span class="string">&quot;Kotlin&quot;</span>)</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLengthSuspend</span><span class="params">(text: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> = suspendCoroutine &#123; continuation-&gt;</span><br><span class="line">    thread &#123;</span><br><span class="line">        <span class="comment">// 模拟耗时</span></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">        continuation.resume(text.length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">等待1秒</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上代码里，我们是使用 suspendCoroutine{}实现了挂起函数，然后在它的内部，我们使用 continuation.resume() 的方式，传出了挂起函数的返回值。</p><p>可能你会觉得奇怪，为什么以 continuation.resume() 这样异步的方式传出结果以后，挂起函数就能接收到结果呢？其实，当我们把 main() 函数当中的调用逻辑改一下，这一切就会清晰明了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变化在这里</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">val</span> func = ::getLengthSuspend <span class="keyword">as</span> (String, Continuation&lt;<span class="built_in">Int</span>&gt;) -&gt; Any?</span><br><span class="line"></span><br><span class="line">    func(<span class="string">&quot;Kotlin&quot;</span>, <span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt;&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">            <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(result.getOrNull())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止程序提前结束</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLengthSuspend</span><span class="params">(text: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> = suspendCoroutine &#123; continuation-&gt;</span><br><span class="line">    thread &#123;</span><br><span class="line">        <span class="comment">// 模拟耗时</span></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">        continuation.resume(text.length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">等待1秒</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，在这段代码里，我们借助上节课的知识，把 getLengthSuspend() 这个函数强转成了带有 Continuation 的函数类型，然后通过匿名内部类的方式，创建了一个 Continuation 对象传了进去。最终，程序的执行结果和代码段 2 是一致的。</p><p>你还记得我在第 15 讲提到过的观点吗？</p><p><code>挂起函数的本质，就是 Callback!</code></p><p>那么现在，就让我们把 Continuation 改为 Callback，看看代码会变成什么样子。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变化在这里</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    func(<span class="string">&quot;Kotlin&quot;</span>, <span class="keyword">object</span>: Callback&lt;<span class="built_in">Int</span>&gt;&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(result: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            println(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止程序提前结束</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">func</span><span class="params">(text: <span class="type">String</span>, callback: <span class="type">Callback</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    thread &#123;</span><br><span class="line">        <span class="comment">// 模拟耗时</span></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">        callback.resume(text.length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">等待1秒</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可见，当我们把 Continuation 改成 Callback 以后，整个代码就变成了我们曾经最熟悉的异步回调代码了。调用方，可以使用匿名内部类创建 Callback 用于接收异步结果；异步函数内部，使用 callback.resume() 将结果传出去。</p><p>综上所述，Kotlin 协程当中的 Continuation，作用其实就相当于 Callback，它既可以用于<strong>实现挂起函数</strong>，往挂起函数的外部传递结果；也可以用于<strong>调用挂起函数</strong>，我们可以创建 Continuation 的匿名内部类，来接收挂起函数传递出来的结果。</p><p>所以在这里，我们也就可以轻松回答上节课的思考题了：</p><p><code>我们都知道挂起函数是 Kotlin 协程里才有的概念，请问，Java 代码中可以调用 Kotlin 的挂起函数吗？比如，下面这个函数，我们可以在 Java 当中调用吗？</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要在Java中调用的Kotlin挂起函数</span></span><br><span class="line"><span class="keyword">object</span> SuspendFromJavaExample &#123;</span><br><span class="line">    <span class="comment">// 在Java当中如何调用这个方法？</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">(id: <span class="type">Long</span>)</span></span>:String &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案当然是肯定的，Java 当中调用挂起函数的方式，其实跟前面的代码段 3 是一样的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    SuspendFromJavaExample.INSTANCE.getUserInfo(<span class="number">100L</span>, new Continuation&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> CoroutineContext getContext() &#123;</span><br><span class="line">            <span class="keyword">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void resumeWith(<span class="meta">@NotNull</span> Object o) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(o+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止程序提前结束</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Kotlin</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们只是把代码段 3 的思想应用到了 Java 代码中而已，唯一需要注意的，就是：在 Java 当中访问 Kotlin 的 object 单例，是需要加上 INSTANCE 后缀的。这一点，我们在第 5 讲当中就已经了解过。</p><p>看到这里，可以发现，我们在实现挂起函数逻辑的时候，总是离不开 **suspendCoroutine{}、suspendCancellableCoroutine{}**。其实，这两个高阶函数也是 Kotlin 协程的基础元素，让我们来进一步认识这两个高阶函数。</p><p><code>suspendCoroutineUninterceptedOrReturn</code></p><p>实际上，suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数的实现原理是类似的，所以这里我们就主要解释下 suspendCoroutine{}。</p><p>如果你去看 suspendCoroutine{}的源代码，会发现它其实也在<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/Continuation.kt">Continuation.kt</a>这个文件当中。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">suspendCoroutine</span><span class="params">(<span class="keyword">crossinline</span> block: (<span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; c: Continuation&lt;T&gt; -&gt;</span><br><span class="line">        <span class="keyword">val</span> safe = SafeContinuation(c.intercepted())</span><br><span class="line">        block(safe)</span><br><span class="line">        safe.getOrThrow()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们第一眼就能看到一个名字特别长的高阶函数 suspendCoroutineUninterceptedOrReturn{}。它其实就是实现 suspendCoroutine{}的关键。除了它之外，其他部分的代码都很好理解：</p><ul><li>SafeContinuation(c.intercepted()) 这行代码的作用，就是把原本的 Continuation 包裹一遍。</li><li>block(safe) 这行代码，其实就是在调用 Lambda 当中的逻辑。</li><li>safe.getOrThrow()，就是在取出 block(safe) 的运行结果，我们在上节课也提到过，Continuation 当中是可以存储 result 的。这个 Result 可能是正确的结果，也可能是异常。</li></ul><p>下面我们重点来看看 suspendCoroutineUninterceptedOrReturn{}这个高阶函数的作用。如果你去看它的源代码，那你看到的大概率会是这样的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">suspendCoroutineUninterceptedOrReturn</span><span class="params">(<span class="keyword">crossinline</span> block: (<span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Any</span>?)</span></span>: T &#123;</span><br><span class="line">    contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125;</span><br><span class="line">    <span class="keyword">throw</span> NotImplementedError(<span class="string">&quot;Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分人看到这样的代码可能都会觉得奇怪：<strong>为什么这个高阶函数的源代码会是抛出异常呢</strong>？</p><p>在前面的加餐二“表达式思维”里，我其实有做过说明，如果你还有印象的话，应该就能理解这样的代码也是符合函数返回值的规范的。不过，如果它总是抛异常的话，我们用 suspendCoroutine{}写代码的时候，为什么不会产生崩溃呢？这个异常信息里的提示内容又是什么意思？</p><p><code>“Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic.”</code></p><p>实际上，理解这句话的关键在于“intrinsic”这个单词，它有“固有”“本质”的意思，不过在上面这句话的语境下，这里的 intrinsic 其实是指编译器领域的一个术语，我们可以把它理解为“内建”。因此，上面我们看到的异常提示信息的意思就是：suspendCoroutineUninterceptedOrReturn 是一个编译器内建函数，<strong>它是由 Kotlin 编译器来实现的。</strong></p><p>为了不偏离这节课的主题，这里我们就不去深究 Kotlin 编译器当中的逻辑了，感兴趣的话你可以自行研究这个<a href="https://github.com/JetBrains/kotlin/blob/1.6.0/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/coroutineCodegenUtil.kt">链接</a>。接下来，我们可以换一个角度，写一些 Demo 代码，通过运行调试来看看这个内建函数的功能和作用。</p><p>让我们先来看看 suspendCoroutineUninterceptedOrReturn 这个高阶函数的参数，它会接收一个 Lambda，类型是(Continuation) -&gt; Any?，经过上节课的学习，你是否觉得这个类型有些眼熟呢？这里的“Any?”类型，其实就能代表当前这个挂起函数是否真正挂起。</p><p>因此，我们可以写出下面这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = testNoSuspendCoroutine()</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testNoSuspendCoroutine</span><span class="params">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;String&gt; &#123;</span><br><span class="line">        continuation -&gt;</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@suspendCoroutineUninterceptedOrReturn</span> <span class="string">&quot;Hello!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们直接使用 suspendCoroutineUninterceptedOrReturn 实现了挂起函数，并且，在它的 Lambda 当中，我们并没有调用 continuation.resume()，而是直接返回了结果“Hello!”。根据程序的运行结果，我们可以看到，在挂起函数的外部确实也可以接收到这个结果。</p><p>那么这时候，如果我们把上面的代码反编译一下，会看到类似这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> Object testNoSuspendCoroutine(Continuation $completion) &#123;</span><br><span class="line">  int var2 = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;Hello!&quot;</span> == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;</span><br><span class="line">     DebugProbesKt.probeCoroutineSuspended($completion);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，从反编译的结果来看，testNoSuspendCoroutine() 这个函数其实就是一个<strong>伪挂起函数，</strong>它的内部并不会真正挂起。这样，当我们从外部调用这个函数的时候，这个函数会立即返回结果“Hello!”。</p><p>而这时候，我们可以再写一个真正的挂起函数：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = testSuspendCoroutine()</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSuspendCoroutine</span><span class="params">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;String&gt; &#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    thread &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">        continuation.resume(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@suspendCoroutineUninterceptedOrReturn</span> kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">等待1秒</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这一次，我们并没有使用 return 返回结果，而是使用了 continuation.resume()。通过程序运行结果，我们可以看到挂起函数的外部也能接收到这个结果。然后我们也再来反编译一下，看看它对应的 Java 代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title function_">testSuspendCoroutine</span><span class="params">(Continuation $completion)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    ThreadsKt.thread$<span class="keyword">default</span>(<span class="literal">false</span>, <span class="literal">false</span>, (ClassLoader)<span class="literal">null</span>, (String)<span class="literal">null</span>, <span class="number">0</span>, (Function0)(<span class="keyword">new</span> <span class="title class_">CoroutineBasicElementsKt$testSuspendCoroutine$2$1</span>($completion)), <span class="number">31</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">var10000</span> <span class="operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">    <span class="keyword">if</span> (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;</span><br><span class="line">     DebugProbesKt.probeCoroutineSuspended($completion);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> var10000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CoroutineBasicElementsKt$testSuspendCoroutine$2$1</span> <span class="keyword">extends</span> <span class="title class_">Lambda</span> <span class="keyword">implements</span> <span class="title class_">Function0</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> Continuation $it;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.invoke();</span><br><span class="line">      <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">      <span class="type">Continuation</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="built_in">this</span>.$it;</span><br><span class="line">      <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">      <span class="type">Companion</span> <span class="variable">var3</span> <span class="operator">=</span> Result.Companion;</span><br><span class="line">      var1.resumeWith(Result.constructor-impl(var2));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   CoroutineBasicElementsKt$testSuspendCoroutine$<span class="number">2</span>$<span class="number">1</span>(Continuation var1) &#123;</span><br><span class="line">      <span class="built_in">super</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="built_in">this</span>.$it = var1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中一共有 4 个注释，我们一个个看：</p><ul><li>注释 1、4，创建了一个新的线程，执行了 thread{}当中的代码。</li><li>注释 2，将 var10000 赋值为 COROUTINE_SUSPENDED 这个挂起标志位。</li><li>注释 3，返回挂起标志位，代表 testSuspendCoroutine() 这个函数会真正挂起。</li></ul><p>所以，这两个例子其实也从侧面证明了我们在上节课当中的结论：</p><p><code>由于 suspend 修饰的函数，既可能返回 CoroutineSingletons.COROUTINE_SUSPENDED，也可能返回实际结果，甚至可能返回 null，为了适配所有的可能性，CPS 转换后的函数返回值类型就只能是 Any? 了。</code></p><p>那么现在，我们也就可以总结出 <strong>suspendCoroutineUninterceptedOrReturn{}这个高阶函数的作用了</strong>：它可以将挂起函数当中的 Continuation 以参数的形式暴露出来，在它的 Lambda 当中，我们可以直接返回结果，这时候它就是一个“伪挂起函数”；或者，我们也可以返回 COROUTINE_SUSPENDED 这个挂起标志位，然后使用 continuation.resume() 传递结果。</p><p>相应的，suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，只是对它的一种封装而已。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课，我们学习了 Kotlin 协程当中与挂起函数密切相关的两个基础元素，Continuation、suspendCoroutine{}。</p><p>Continuation 是整个协程当中最重要的基础元素，我们可以将其看做是一个 Callback。它主要有两个使用场景，一种是在实现挂起函数的时候，用于传递挂起函数的执行结果；另一种是在调用挂起函数的时候，以匿名内部类的方式，用于接收挂起函数的执行结果。借助这种思路，我们也完全可以在 Java 当中调用挂起函数。</p><p>当我们想要实现挂起函数的时候，我们往往需要使用 suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数。它们两个都是对 suspendCoroutineUninterceptedOrReturn{}的封装，这个高阶函数的作用其实就是暴露挂起函数的 Continuation 对象。在它的 Lambda 当中，我们既可以直接返回执行结果，也可以返回 COROUTINE_SUSPENDED 这个挂起标志位，然后使用 continuation.resume() 传递结果。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>你觉得，suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，它对比 suspendCoroutineUninterceptedOrReturn{}的优势在哪里？Kotlin 官方为什么要进行这样的封装呢？</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(源码篇)28  launch的背后到底发生了什么？</title>
      <link href="/posts/e184d855/"/>
      <url>/posts/e184d855/</url>
      
        <content type="html"><![CDATA[<p>在前面的课程里，我们一直在研究如何使用 Kotlin 协程，比如，如何启动协程，如何使用挂起函数，如何使用 Channel、Flow 等 API。但到目前为止，我们只知道该怎么用协程，对它内部的运行机制并没有深究。</p><p>现在我们都知道，launch、async 可以创建、启动新的协程，但我们只能通过调试参数，通过 log 看到协程。比如我们可以回过头来看下第 13 讲当中的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码中一共启动了两个协程</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(Thread.currentThread().name)</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        println(Thread.currentThread().name)</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">main @coroutine#1</span></span><br><span class="line"><span class="comment">main @coroutine#2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>现在回过头来看，这段代码无疑是非常简单的，runBlocking{} 启动了第一个协程，launch{} 启动了第二个协程。可是，有一个问题，我们一直都没有找到答案：<strong>协程到底是如何创建的？它对应的源代码，到底在哪个类？具体在哪一行？</strong></p><p>我们常说 Java 线程的源代码是 Thread.java，这样说虽然不一定准确，但我们起码能看到几个暴露出来的方法。那么，在 Kotlin 协程当中，有没有类似 Coroutine.kt 的类呢？对于这些问题，我们唯有去阅读 Kotlin 协程的源码、去分析 launch 的启动流程，才能找到答案。</p><p>这节课，我就将从第 26 讲当中提到的 createCoroutine{}、startCoroutine{} 这两个函数开始说起，在认识了这两个协程基础元素以后，我们就会进入协程的“中间层”，开始分析 launch 的源代码。我相信，学完这节课以后，你一定会对 Kotlin 协程有一个更加透彻的认识。</p><h2 id="协程启动的基础-API"><a href="#协程启动的基础-API" class="headerlink" title="协程启动的基础 API"></a>协程启动的基础 API</h2><p>在第 26 讲里，我给你留了一个思考题，在Continuation.kt这个文件当中，还有两个重要的扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; =</span><br><span class="line">    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">) &#123;</span><br><span class="line">    createCoroutineUnintercepted(completion).intercepted().resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，createCoroutine{}、startCoroutine{}这两个函数，就是 Kotlin 协程当中最基础的两个创建协程的 API。</p><p>我们在第 14 讲里曾经提到过，启动协程有三种常见的方式：launch、runBlocking、async。它们其实属于协程中间层提供的 API，而它们的底层都在某种程度上调用了“基础层”的协程 API。</p><p>那么，这是不是就意味着：<strong>我们使用协程的基础层 API，也可以创建协程呢</strong>？</p><p>答案当然是肯定的。我们可以来分析一下代码段 2 当中的函数签名。</p><p>createCoroutine{}、startCoroutine{}，它们都是扩展函数，其扩展接收者类型是一个函数类型：suspend () -&gt; T，代表了“无参数，返回值为 T 的挂起函数或者 Lambda”。而对于函数本身，它们两个都接收一个 Continuation 类型的参数，其中一个函数，还会返回一个 Continuation 类型的返回值。</p><p>也许你对于“给函数类型增加扩展”这样的行为会感到不太适应。不过，在 Kotlin 当中，<strong>函数就是一等公民</strong>，普通的类型可以有扩展，那么，函数类型自然也可以有扩展。因此，我们完全可以写出像下面这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testStartCoroutine()</span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> block = <span class="keyword">suspend</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    <span class="string">&quot;Result&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testStartCoroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> continuation = <span class="keyword">object</span> : Continuation&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">            <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Result is: <span class="subst">$&#123;result.getOrNull()&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    block.startCoroutine(continuation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">World!</span></span><br><span class="line"><span class="comment">Result is: Result</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们定义了一个 Lambda 表达式 block，它的类型就是 suspend () -&gt; T。这样一来，我们就可以用 block.startCoroutine() 来启动协程了。这里，我们还创建了一个匿名内部类对象 continuation，作为 startCoroutine() 的参数。</p><p>在加餐里，我们提到过 Continuation 主要有两种用法，一种是在实现挂起函数的时候，用于<strong>传递挂起函数的执行结果</strong>；另一种是在调用挂起函数的时候，以匿名内部类的方式，用于<strong>接收挂起函数的执行结果</strong>。而代码段 3 中 Continuation 的作用，则明显属于后者。</p><p>从代码段 3 的执行结果中，我们可以看出来，startCoroutine() 的作用其实就是创建一个新的协程，并且执行 block 当中的逻辑，等协程执行完毕以后，将结果返回给 Continuation 对象。而这个逻辑，我们使用 <strong>createCoroutine()</strong> 这个方法其实也可以实现。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">代码段<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testCreateCoroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> continuation = <span class="keyword">object</span> : Continuation&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">            <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Result is: <span class="subst">$&#123;result.getOrNull()&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> coroutine = block.createCoroutine(continuation)</span><br><span class="line"></span><br><span class="line">    coroutine.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">World!</span></span><br><span class="line"><span class="comment">Result is: Result</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>根据以上代码，我们可以看到，createCoroutine() 的作用其实就是创建一个协程，并暂时先不启动它。等我们想要启动它的时候，直接调用 resume() 即可。如果我们再进一步分析代码段 2 当中的源代码，会发现 createCoroutine()、startCoroutine() 的源代码差别也并不大，只是前者没有调用 resume()，而后者调用了 resume()。</p><p>换句话说，startCoroutine() 之所以可以创建并同时启动协程的原因就在于，它在源码中直接调用了 resume(Unit)，所以，我们在代码段 3 当中就不需要自己调用 resume() 方法了。</p><p>那么下面，我们就以 startCoroutine() 为例，来研究下它的实现原理。我们把代码段 3 反编译成 Java，看看它会变成什么样子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LaunchUnderTheHoodKt</span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">        testStartCoroutine();</span><br><span class="line">        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> Function1&lt;Continuation&lt;? <span class="keyword">super</span> String&gt;, Object&gt; block = new LaunchUnderTheHoodKt$block$<span class="number">1</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> Function1&lt;Continuation&lt;? <span class="keyword">super</span> String&gt;, Object&gt; getBlock() &#123;</span><br><span class="line">        <span class="keyword">return</span> block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LaunchUnderTheHoodKt</span>$<span class="title">block</span>$1 <span class="title">extends</span> <span class="title">SuspendLambda</span> <span class="title">implements</span> <span class="title">Function1</span>&lt;<span class="type">Continuation&lt;? super String</span>&gt;, <span class="type">Object&gt;</span> &#123;</span><br><span class="line">        int label;</span><br><span class="line"></span><br><span class="line">        LaunchUnderTheHoodKt$block$<span class="number">1</span>(Continuation $completion) &#123;</span><br><span class="line">          <span class="keyword">super</span>(<span class="number">1</span>, $completion);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object $result) &#123;</span><br><span class="line">          Object <span class="keyword">object</span> = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">          switch (<span class="keyword">this</span>.label) &#123;</span><br><span class="line">            case <span class="number">0</span>:</span><br><span class="line">              ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);</span><br><span class="line">              System.<span class="keyword">out</span></span><br><span class="line">                .println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">              <span class="keyword">this</span>.label = <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> (DelayKt.delay(<span class="number">1000L</span>, (Continuation)<span class="keyword">this</span>) == <span class="keyword">object</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">object</span>; </span><br><span class="line">              DelayKt.delay(<span class="number">1000L</span>, (Continuation)<span class="keyword">this</span>);</span><br><span class="line">              System.<span class="keyword">out</span></span><br><span class="line">                .println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span>;</span><br><span class="line">            case <span class="number">1</span>:</span><br><span class="line">              ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);</span><br><span class="line">              System.<span class="keyword">out</span>.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span>;</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Continuation&lt;<span class="built_in">Unit</span>&gt; create(<span class="meta">@NotNull</span> Continuation&lt;? <span class="keyword">super</span> LaunchUnderTheHoodKt$block$<span class="number">1</span>&gt; $completion) &#123;</span><br><span class="line">          <span class="keyword">return</span> (Continuation&lt;<span class="built_in">Unit</span>&gt;)new LaunchUnderTheHoodKt$block$<span class="number">1</span>($completion);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Object invoke(<span class="meta">@Nullable</span> Continuation&lt;?&gt; p1) &#123;</span><br><span class="line">          <span class="keyword">return</span> ((LaunchUnderTheHoodKt$block$<span class="number">1</span>)create(p1)).invokeSuspend(<span class="built_in">Unit</span>.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> void testStartCoroutine() &#123;</span><br><span class="line">        LaunchUnderTheHoodKt$testStartCoroutine$continuation$<span class="number">1</span> continuation = new LaunchUnderTheHoodKt$testStartCoroutine$continuation$<span class="number">1</span>();</span><br><span class="line">        ContinuationKt.startCoroutine(block, continuation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LaunchUnderTheHoodKt</span>$<span class="title">testStartCoroutine</span>$<span class="title">continuation</span>$1 <span class="title">implements</span> <span class="title">Continuation</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="keyword">public</span> CoroutineContext getContext() &#123;</span><br><span class="line">          <span class="keyword">return</span> (CoroutineContext)EmptyCoroutineContext.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> void resumeWith(<span class="meta">@NotNull</span> Object result) &#123;</span><br><span class="line">          System.<span class="keyword">out</span>.println(Intrinsics.stringPlus(<span class="string">&quot;Result is: &quot;</span>, Result.isFailure-impl(result) ? <span class="literal">null</span> : result));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SuspendLambda</span>(</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> arity: <span class="built_in">Int</span>,</span><br><span class="line">    completion: Continuation&lt;Any?&gt;?</span><br><span class="line">) : ContinuationImpl(completion), FunctionBase&lt;Any?&gt;, SuspendFunction &#123;&#125;</span><br></pre></td></tr></table></figure><p>上面的反编译代码中，一共有 6 个注释，我们一个个来看：</p><ul><li>注释 1，是我们的 main() 函数。由于它本身只是一个普通的函数，因此反编译之后，逻辑并没有什么变化。</li><li>注释 2、3，它们是 Kotlin 为 block 变量生成的静态变量以及方法。</li><li>注释 4，LaunchUnderTheHoodKt$block$1，其实就是 block 具体的实现类。这个类继承自 SuspendLambda，而 SuspendLambda 是 ContinuationImpl 的子类，因此它也间接实现了 Continuation 接口。其中的 invokeSuspend()，也就是我们在上节课分析过的<strong>协程状态机逻辑</strong>。除此之外，它还有一个 create() 方法，我们在后面会来分析它。</li><li>注释 5，它对应了 testStartCoroutine() 这个方法，原本的 block.startCoroutine(continuation) 变成了“ContinuationKt.startCoroutine(block, continuation)”，这其实就体现出了扩展函数的原理。</li><li>注释 6，其实就是 continuation 变量对应的匿名内部类。</li></ul><p>那么接下来，我们就可以对照着反编译代码，来分析整个代码的执行流程了。</p><p>首先，main() 函数会调用 testStartCoroutine() 函数，接着，就会调用 startCoroutine() 方法。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">//        注意这里</span></span><br><span class="line"><span class="comment">//           ↓</span></span><br><span class="line">createCoroutineUnintercepted(completion).intercepted().resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码段 6 里，我们可以看到，在 startCoroutine() 当中，首先会调用 createCoroutineUnintercepted() 方法。如果我们直接去看它的源代码，会发现它只存在一个声明，并没有具体实现：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    注意这里</span></span><br><span class="line"><span class="comment">//       ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">expect</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt;</span><br></pre></td></tr></table></figure><p>上面代码中的 expect，我们可以把它理解为一种<strong>声明</strong>，由于 Kotlin 是面向多个平台的，具体的实现，就需要在特定的平台实现。所以在这里，我们就需要打开 Kotlin 的源代码，找到 JVM 平台对应的实现：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    1，注意这里</span></span><br><span class="line"><span class="comment">//       ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line">    <span class="comment">//             2，注意这里</span></span><br><span class="line">    <span class="comment">//               ↓</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        create(probeCompletion)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请留意这里的注释 1，这个 actual，代表了 createCoroutineUnintercepted() 在 JVM 平台的实现。</p><p>另外，我们可以看到，createCoroutineUnintercepted() 仍然还是一个扩展函数，注释 2 处的 this，其实就代表了前面代码段 3 当中的 block 变量。我们结合代码段 5 反编译出来的 LaunchUnderTheHoodKt$block$1，可以知道 block 其实就是 SuspendLambda 的子类，而 SuspendLambda 则是 ContinuationImpl 的子类。</p><p>因此，注释 2 处的 (this is BaseContinuationImpl) 条件一定是为 <strong>true</strong> 的。这时候，它就会调用 create(probeCompletion)。</p><p>然后，如果你去查看 create() 的源代码，会看到这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(completion: <span class="type">Continuation</span>&lt;*&gt;)</span></span>: Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> UnsupportedOperationException(<span class="string">&quot;create(Continuation) has not been overridden&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在默认情况下，这个 create() 方法是会抛出异常的，它的提示信息是：create() 方法没有被重写！潜台词就是，create() 方法应该被重写！如果不被重写，就会抛出异常。</p><p>那么，<strong>create() 方法是在哪里被重写的呢？</strong>答案其实就在代码段 5 的“LaunchUnderTheHoodKt$block$1”这个 block 的实现类当中。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line">static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LaunchUnderTheHoodKt</span>$<span class="title">block</span>$1 <span class="title">extends</span> <span class="title">SuspendLambda</span> <span class="title">implements</span> <span class="title">Function1</span>&lt;<span class="type">Continuation&lt;? super String</span>&gt;, <span class="type">Object&gt;</span> &#123;</span><br><span class="line">    int label;</span><br><span class="line"></span><br><span class="line">    LaunchUnderTheHoodKt$block$<span class="number">1</span>(Continuation $completion) &#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="number">1</span>, $completion);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object $result) &#123;</span><br><span class="line">      Object <span class="keyword">object</span> = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">      switch (<span class="keyword">this</span>.label) &#123;</span><br><span class="line">        case <span class="number">0</span>:</span><br><span class="line">          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);</span><br><span class="line">          System.<span class="keyword">out</span></span><br><span class="line">            .println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">          <span class="keyword">this</span>.label = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (DelayKt.delay(<span class="number">1000L</span>, (Continuation)<span class="keyword">this</span>) == <span class="keyword">object</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">object</span>; </span><br><span class="line">          DelayKt.delay(<span class="number">1000L</span>, (Continuation)<span class="keyword">this</span>);</span><br><span class="line">          System.<span class="keyword">out</span></span><br><span class="line">            .println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span>;</span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);</span><br><span class="line">          System.<span class="keyword">out</span>.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span>;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1，注意这里</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Continuation&lt;<span class="built_in">Unit</span>&gt; create(<span class="meta">@NotNull</span> Continuation&lt;? <span class="keyword">super</span> LaunchUnderTheHoodKt$block$<span class="number">1</span>&gt; $completion) &#123;</span><br><span class="line">      <span class="keyword">return</span> (Continuation&lt;<span class="built_in">Unit</span>&gt;)new LaunchUnderTheHoodKt$block$<span class="number">1</span>($completion);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invoke(<span class="meta">@Nullable</span> Continuation&lt;?&gt; p1) &#123;</span><br><span class="line">      <span class="keyword">return</span> ((LaunchUnderTheHoodKt$block$<span class="number">1</span>)create(p1)).invokeSuspend(<span class="built_in">Unit</span>.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，你可以留意下代码里的注释 1，这个其实就是重写之后的 create() 方法。换句话说，代码段 8 当中的 create(probeCompletion)，最终会调用代码段 10 的 create() 方法，它最终会返回“LaunchUnderTheHoodKt$block$1”这个 block 实现类，对应的 Continuation 对象。</p><p><code>这行代码，其实就对应着协程被创建的时刻。</code></p><p>好，到这里，协程创建的逻辑就分析完了，我们再回到 startCoroutine() 的源码，看看它后续的逻辑。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">//                                           注意这里</span></span><br><span class="line"><span class="comment">//                                             ↓</span></span><br><span class="line">createCoroutineUnintercepted(completion).intercepted().resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，intercepted() 这个方法的源代码，我们也需要去 Kotlin 的源代码当中找到对应的 JVM 实现。</p><figure class="highlight k"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line">public actual fun &lt;T&gt; Continuation&lt;T&gt;.intercepted(): Continuation&lt;T&gt; =</span><br><span class="line">    (this as? ContinuationImpl)?.intercepted() ?: this</span><br></pre></td></tr></table></figure><p>它的逻辑很简单，只是将 Continuation 强转成了 ContinuationImpl，调用了它的 intercepted()。这里有个细节，由于 this 的类型是“LaunchUnderTheHoodKt$block$1”，它是 ContinuationImpl 的子类，所以这个类型转换一定可以成功。</p><p>接下来，我们看看 ContinuationImpl 的源代码。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ContinuationImpl</span>(</span><br><span class="line">    completion: Continuation&lt;Any?&gt;?,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _context: CoroutineContext?</span><br><span class="line">) : BaseContinuationImpl(completion) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> intercepted: Continuation&lt;Any?&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;Any?&gt; =</span><br><span class="line">        intercepted</span><br><span class="line">            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span>)</span><br><span class="line">                .also &#123; intercepted = it &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实就是通过 ContinuationInterceptor，对 Continuation 进行拦截，从而将程序的执行逻辑派发到特定的线程之上，这部分的逻辑我们在下一讲会再展开。</p><p>让我们回到 startCoroutine() 的源码，看看它的最后一步 **resume(Unit)**。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">//                                                   注意这里</span></span><br><span class="line"><span class="comment">//                                                      ↓</span></span><br><span class="line">createCoroutineUnintercepted(completion).intercepted().resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 resume(Unit)，作用其实就相当于启动了协程。</p><p>好，现在我们已经弄清楚了 startCoroutine() 这个协程的基础 API 是如何启动协程的了。接下来，我们来看看中间层的 launch{} 函数是如何启动协程的。</p><h2 id="launch-是如何启动协程的？"><a href="#launch-是如何启动协程的？" class="headerlink" title="launch 是如何启动协程的？"></a>launch 是如何启动协程的？</h2><p>在研究 launch 的源代码之前，我们先来写一个简单的 Demo：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testLaunch()</span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testLaunch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">World!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>然后，我们还是通过反编译，来看看它对应的 Java 代码长什么样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LaunchUnderTheHoodKt</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">    testLaunch();</span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> static <span class="keyword">final</span> void testLaunch() &#123;</span><br><span class="line">    CoroutineScope scope = CoroutineScopeKt.CoroutineScope((CoroutineContext)JobKt.Job$default(<span class="literal">null</span>, <span class="number">1</span>, <span class="literal">null</span>));</span><br><span class="line">    BuildersKt.launch$default(scope, <span class="literal">null</span>, <span class="literal">null</span>, new LaunchUnderTheHoodKt$testLaunch$<span class="number">1</span>(<span class="literal">null</span>), <span class="number">3</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LaunchUnderTheHoodKt</span>$<span class="title">testLaunch</span>$1 <span class="title">extends</span> <span class="title">SuspendLambda</span> <span class="title">implements</span> <span class="title">Function2</span>&lt;<span class="type">CoroutineScope, Continuation&lt;? super Unit</span>&gt;, <span class="type">Object&gt;</span> &#123;</span><br><span class="line">    int label;</span><br><span class="line"></span><br><span class="line">    LaunchUnderTheHoodKt$testLaunch$<span class="number">1</span>(Continuation $completion) &#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="number">2</span>, $completion);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object $result) &#123;</span><br><span class="line">      Object <span class="keyword">object</span> = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">      switch (<span class="keyword">this</span>.label) &#123;</span><br><span class="line">        case <span class="number">0</span>:</span><br><span class="line">          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);</span><br><span class="line">          System.<span class="keyword">out</span></span><br><span class="line">            .println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">          <span class="keyword">this</span>.label = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (DelayKt.delay(<span class="number">1000L</span>, (Continuation)<span class="keyword">this</span>) == <span class="keyword">object</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">object</span>; </span><br><span class="line">          DelayKt.delay(<span class="number">1000L</span>, (Continuation)<span class="keyword">this</span>);</span><br><span class="line">          System.<span class="keyword">out</span></span><br><span class="line">            .println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);</span><br><span class="line">          System.<span class="keyword">out</span>.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Continuation&lt;<span class="built_in">Unit</span>&gt; create(<span class="meta">@Nullable</span> Object value, <span class="meta">@NotNull</span> Continuation&lt;? <span class="keyword">super</span> LaunchUnderTheHoodKt$testLaunch$<span class="number">1</span>&gt; $completion) &#123;</span><br><span class="line">      <span class="keyword">return</span> (Continuation&lt;<span class="built_in">Unit</span>&gt;)new LaunchUnderTheHoodKt$testLaunch$<span class="number">1</span>($completion);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invoke(<span class="meta">@NotNull</span> CoroutineScope p1, <span class="meta">@Nullable</span> Continuation&lt;?&gt; p2) &#123;</span><br><span class="line">      <span class="keyword">return</span> ((LaunchUnderTheHoodKt$testLaunch$<span class="number">1</span>)create(p1, p2)).invokeSuspend(<span class="built_in">Unit</span>.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了前面的经验，上面的代码对我们来说就很简单了。唯一需要注意的是“LaunchUnderTheHoodKt$testLaunch$1”这个类，它其实对应的就是我们 launch 当中的 Lambda。</p><p>为了让它们之间的对应关系更加明显，我们可以换一种写法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testLaunch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">    <span class="keyword">val</span> block: <span class="keyword">suspend</span> CoroutineScope.() -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    scope.launch(block = block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中的 block，其实就对应着“LaunchUnderTheHoodKt$testLaunch$1”这个类。这里的 block，<strong>本质上仍然是一个 Continuation</strong>。</p><p>好，接下来，我们来看看 launch{} 的源代码。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码一共有三个注释，我们也来分析一下：</p><ul><li>注释 1，launch 会根据传入的 CoroutineContext 创建出新的 Context。</li><li>注释 2，launch 会根据传入的启动模式来创建对应的协程对象。这里有两种，一种是标准的，一种是懒加载的。</li><li>注释 3，尝试启动协程。</li></ul><p>我们跟进 coroutine.start() 这个方法，会进入 AbstractCoroutine 这个抽象类：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCoroutine</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    parentContext: CoroutineContext,</span><br><span class="line">    initParentJob: <span class="built_in">Boolean</span>,</span><br><span class="line">    active: <span class="built_in">Boolean</span></span><br><span class="line">) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">start</span><span class="params">(start: <span class="type">CoroutineStart</span>, receiver: <span class="type">R</span>, block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        start(block, receiver, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们其实就能看到，Java 当中有 Thread.java 对应线程的逻辑，而 Kotlin 协程当中，也有 AbstractCoroutine.kt 这个类对应协程的抽象逻辑。AbstractCoroutine 有一个 start() 方法，专门用于启动协程。</p><p>我们继续跟进 start(block, receiver, this)，就会进入 CoroutineStart.invoke()。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">CoroutineStart</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">invoke</span><span class="params">(block: <span class="type">suspend</span> () -&gt; <span class="type">T</span>, completion: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">        <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            DEFAULT -&gt; block.startCoroutineCancellable(completion)</span><br><span class="line">            ATOMIC -&gt; block.startCoroutine(completion)</span><br><span class="line">            UNDISPATCHED -&gt; block.startCoroutineUndispatched(completion)</span><br><span class="line">            LAZY -&gt; <span class="built_in">Unit</span> <span class="comment">// will start lazily</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 invoke() 方法当中，它会根据 launch 传入的启动模式，以不同的方式启动协程。当我们的启动模式是 ATOMIC 的时候，就会调用 block.startCoroutine(completion)。<strong>而这个，其实就是我们在课程最开始研究过的 startCoroutine() 这个协程基础 API</strong>。</p><p>而另外两个方法，startCoroutineUndispatched(completion) 和 startCoroutineCancellable(completion)，我们从名字上也能判断出，它们只是在 startCoroutine() 的基础上增加了一些额外的功能而已。前者代表启动协程以后就不会被分发，后者代表启动以后可以响应取消。</p><p>然后，对于代码段 15 的 launch 逻辑而言，由于我们没有传入特定的启动模式，因此，这里会<strong>执行默认的模式</strong>，也就是调用“startCoroutineCancellable(completion)”这个方法。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): <span class="built_in">Unit</span> = runSafely(completion) &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        create(probeCompletion)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，通过查看 startCoroutineCancellable() 的源代码，我们能发现，它最终还是会调用我们之前分析过的 **createCoroutineUnintercepted()**，而在它的内部，仍然会像我们之前分析过的，去调用 **create(probeCompletion)**，然后最终会调用代码段 16 当中“LaunchUnderTheHoodKt$testLaunch$1”的 <strong>create()</strong> 方法。</p><p>至此，launch 启动协程的整个过程，我们就已经分析完了。其实，launch 这个 API，只是对协程的基础元素 startCoroutine() 等方法进行了一些封装而已。</p><p>看完这么多的代码和文字，相信你可能已经有一些感觉了，不过可能对整个流程还是有些模糊。这里我做了一个视频，描述了 launch 的执行流程。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>createCoroutine{}、startCoroutine{}，它们是 Kotlin 提供的两个底层 API，前者是用来创建协程的，后者是用来创建并同时启动协程的。</p><p>通过反编译，我们发现，startCoroutine{} 最终会调用 createCoroutineUnintercepted() 这个函数，而它在 JVM 平台的实现，就是调用 Lambda 对应的实现类“LaunchUnderTheHoodKt$block$1”当中的 create() 方法。</p><p>另外，Kotlin 协程框架在<strong>中间层</strong>实现了 launch、async 之类的协程构建器（Builder），你要知道，它们只是对协程底层 API 进行了更好的封装而已。它们除了拥有启动协程的基础能力，还支持传入 CoroutineContext、CoroutineStart 等参数，前者可以帮我们实现结构化并发，后者可以支持更灵活的启动模式。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>在代码段 3 当中，我们使用的是 suspend {} 启动的协程，它的类型是 suspend () -&gt; String。那么，我们是否可以使用挂起函数启动协程呢？就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">func</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testStartCoroutineForSuspend</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> block = ::func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> continuation = <span class="keyword">object</span> : Continuation&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">            <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Result is: <span class="subst">$&#123;result.getOrNull()&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    block.startCoroutine(continuation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用这种方式启动协程，它的整体执行流程和代码段 3 会有什么不一样吗？欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(源码篇)27  图解挂起函数：原来你就是个状态机？</title>
      <link href="/posts/875d6a31/"/>
      <url>/posts/875d6a31/</url>
      
        <content type="html"><![CDATA[<p>今天我们来研究 Kotlin 挂起函数的实现原理。</p><p>挂起函数，是整个 Kotlin 协程的核心，它的重要性不言而喻。几乎所有协程里的知识点，都离不开挂起函数。而且也正是因为挂起函数的原因，我们才可以使用协程简化异步任务。</p><p>今天这节课，我会从这个 CPS 转换开始说起，带你进一步挖掘它背后的细节。在这个过程中，我们还会接触到 Kotlin 库当中的协程基础元素：Continuation、CoroutineContext 与挂起函数的底层联系。最后，我会带你灵活运用下这些知识点，以此进一步完善我们的 KtHttp，让它可以直接支持挂起函数。</p><p>好，接下来，我们就正式开始吧！</p><h2 id="CPS-转换背后的细节"><a href="#CPS-转换背后的细节" class="headerlink" title="CPS 转换背后的细节"></a>CPS 转换背后的细节</h2><p>在第 15 讲当中，我们已经初步介绍过挂起函数的用法了：挂起函数，只是比普通的函数多了 suspend 关键字。有了这个 suspend 关键字以后，Kotlin 编译器就会特殊对待这个函数，将其转换成一个带有 Callback 的函数，这里的 Callback 就是 Continuation 接口。</p><p>而这个过程，我们称之为 CPS 转换：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/37/92/3732f7a3473e82c5a5d109a18d87f992.gif?wh=720x405" alt="img" style="zoom: 67%;" /><p>以上的 CPS 转换过程中，函数的类型发生了变化：suspend ()-&gt;String 变成了 (Continuation)-&gt; Any?。这意味着，如果你在 Java 里访问一个 Kotlin 挂起函数 getUserInfo()，会看到 getUserInfo() 的类型是 (Continuation)-&gt; Object，也就是：接收 Continuation 为参数，返回值是 Object。</p><p>而在这里，函数签名的变化可以分为两个部分：<strong>函数参数</strong>的变化和函数返回值的变化。CPS 参数变化</p><h3 id="CPS-参数变化"><a href="#CPS-参数变化" class="headerlink" title="CPS 参数变化"></a>CPS 参数变化</h3><p>我们先来看函数参数的变化，suspend() 变成 (Continuation) 的情况，这里我们以第 15 讲当中的代码为例：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testCoroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    <span class="keyword">val</span> friendList = getFriendList(user)</span><br><span class="line">    <span class="keyword">val</span> feedList = getFeedList(user, friendList)</span><br><span class="line">    log(feedList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起函数</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;BoyCoder&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起函数</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getFriendList</span><span class="params">(user: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Tom, Jack&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起函数</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getFeedList</span><span class="params">(user: <span class="type">String</span>, list: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;FeedList..&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，testCoroutine() 是一个挂起函数，它的内部依次调用了三个挂起函数。而如果我们从 Java 的角度来看待 testCoroutine() 的话，代码中所有的参数都会发生变化。如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                 变化在这里</span></span><br><span class="line"><span class="comment">//                     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testCoroutine</span><span class="params">(continuation: <span class="type">Continuation</span>)</span></span>: Any? &#123;</span><br><span class="line"><span class="comment">//                          变化在这里</span></span><br><span class="line"><span class="comment">//                              ↓</span></span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo(continuation)</span><br><span class="line"><span class="comment">//                                        变化在这里</span></span><br><span class="line"><span class="comment">//                                            ↓</span></span><br><span class="line">    <span class="keyword">val</span> friendList = getFriendList(user, continuation)</span><br><span class="line"><span class="comment">//                                          变化在这里</span></span><br><span class="line"><span class="comment">//                                              ↓</span></span><br><span class="line">    <span class="keyword">val</span> feedList = getFeedList(friendList, continuation)</span><br><span class="line">    log(feedList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，在这里的 testCoroutine() 当中，每一次函数调用的时候，continuation 都会作为最后一个参数传到挂起函数里。不过这一步是 Kotlin 编译器帮我们做的，我们开发者是无感知的。还记得第 15 讲我留下的思考题吗：<strong>为什么挂起函数可以调用挂起函数，普通函数则不能？</strong></p><p>其实，这个问题的答案，我们从代码段 2 就可以看出来。请想象一下，如果 testCoroutine() 只是一个普通函数，那它就不会有 continuation 这个参数了，这样 getUserInfo()、getFriendList()、getFeedList() 这几个挂起函数自然也就无法被调用了。</p><h3 id="CPS-返回值变化"><a href="#CPS-返回值变化" class="headerlink" title="CPS 返回值变化"></a>CPS 返回值变化</h3><p>好，接下来我们看看 getUserInfo() 的返回值类型的变化：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                                  变化在这里</span></span><br><span class="line"><span class="comment">//                                     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">(cont: <span class="type">Continuation</span>)</span></span>: Any? &#123;&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码里，可以看到 getUserInfo() 的返回值类型从 String 变成“Any?”。你肯定会好奇，函数原本的 String 返回值难道丢失了吗？如果原本的返回值类型丢失了，那么程序执行难道不会出问题吗？</p><p>其实并不是这样。Kotlin 官方之所以要弄这一套 CPS 转换规则，它必然是“<strong>等价转换</strong>”。也就是说，String 这个原本的返回值类型肯定不会消失，而是会换一种形式存在。只是 String 存在的形式，经过 <strong>Kotlin反编译成 Java 之后会丢失</strong>。如果你直接在 Java 当中调用 getUserInfo() 的话，就会发现 String 这个返回值类型成为了 Continuation 的泛型类型。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/36/06/36eebc96c2dd6acf0c178068db0f4a06.png?wh=1582x426" alt="img" style="zoom:50%;" /><p>所以，对于 getUserInfo() 这个方法，经过 CPS 转换后，它完整的函数签名应该是这样的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                                变化在这里</span></span><br><span class="line"><span class="comment">//                                    ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">(cont: <span class="type">Continuation</span>&lt;<span class="type">String</span>&gt;)</span></span>: Any? &#123;&#125;</span><br></pre></td></tr></table></figure><p>这时候，我们就可以更新第 15 讲当中的那个 CPS 动图了：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/78/yy/784ce5776def5255e6d300cd5890a6yy.gif?wh=1080x608" alt="img" style="zoom:50%;" /><p>好，现在我们知道了，挂起函数原本的返回值类型 String 只是挪了个地方，所以，Kotlin 编译器的 CPS 转换仍然是等价的转换。也就是：suspend () -&gt; String 转换成 (Continuation) -&gt; Any?。不过，<strong>这里的“Any?”又是干什么的呢</strong>？</p><p>其实，挂起函数经过 CPS 转换后，它的返回值有一个重要作用：<strong>标志该挂起函数有没有被挂起</strong>。这听起来有点绕：挂起函数，就是可以被挂起的函数，它还能不被挂起吗？</p><p>是的，挂起函数也能不被挂起。</p><p>让我们来理清几个概念。只要有 suspend 修饰的函数，它就是挂起函数，比如我们前面的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;BoyCoder&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 getUserInfo() 执行到 withContext{} 的时候，就会返回 CoroutineSingletons.COROUTINE_SUSPENDED 表示函数被挂起了。</p><p>现在问题来了，请问下面这个函数是挂起函数吗？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// suspend 修饰</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">noSuspendFriendList</span><span class="params">(user: <span class="type">String</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="comment">// 函数体跟普通函数一样</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Tom, Jack&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个其实是 <strong>noSuspendFriendList() 方法</strong>，它的方法体跟普通函数一样。它跟一般的挂起函数有个区别：在执行的时候，它并不会被挂起，因为它就是个普通函数。当你写出以下这样的代码后，IDE 也会提示你，suspend 是多余的：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/35/d3/35de8c0f0bbabbce0ca8dee2840d33d3.png?wh=624x119" alt="img"  /><p>也就是，当我们调用 noSuspendFriendList() 这个挂起函数的时候，它不会真正挂起，而是会直接返回 String 类型：”no suspend”。针对这样的挂起函数，你可以把它看作是<strong>伪挂起函数</strong>。</p><p>所以到这里，挂起函数经过 CPS 转换后，返回值变成“Any?”的原因也就清晰了：</p><p>由于 suspend 修饰的函数，既可能返回 CoroutineSingletons.COROUTINE_SUSPENDED，也可能返回实际结果 “no suspend”，甚至可能返回 null，为了适配所有的可能性，CPS 转换后的函数返回值类型就只能是 Any? 了。</p><p>可见我在第 15 讲当中给出的这个 CPS 动图，仅仅只是粗略模拟了协程的 CPS 流程，其中还有很多细节没有体现出来。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/03/22/03d156ec6a31d650c6634f486dc06222.gif?wh=720x405" alt="img"></p><p>那么，为了让你对挂起函数的底层实现原理有一个更加清晰的认识，接下来，我们来看看挂起函数反编译之后会变成什么样。</p><h2 id="挂起函数的反编译"><a href="#挂起函数的反编译" class="headerlink" title="挂起函数的反编译"></a>挂起函数的反编译</h2><p>我们知道，通过查看 Kotlin 反编译后的字节码，可以帮助我们理解 Kotlin 的底层原理。不过，和往常不一样的是，这次我不会直接贴反编译后的代码，因为它的逻辑比较复杂。</p><p>所以，为了方便你理解，接下来我贴出的代码是我用 Kotlin 翻译后<strong>大致等价</strong>的代码，改善了可读性，抹掉了不必要的细节。当你理解其中的思想后，再去看反编译后的 Java 代码，会更轻松一些。</p><p>好，我们进入正题，这是我们即将研究的对象，testCoroutine() 反编译前的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testCoroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    log(user)</span><br><span class="line">    <span class="keyword">val</span> friendList = getFriendList(user)</span><br><span class="line">    log(friendList)</span><br><span class="line">    <span class="keyword">val</span> feedList = getFeedList(friendList)</span><br><span class="line">    log(feedList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来分析 testCoroutine() 的函数体，它相当复杂，涉及到三个挂起函数的调用。</p><p>首先，在 testCoroutine() 函数里，会多出一个 ContinuationImpl 的子类，它是整个协程挂起函数的核心。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testCoroutine</span><span class="params">(completion: <span class="type">Continuation</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// TestContinuation本质上是匿名内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TestContinuation</span>(completion: Continuation&lt;Any?&gt;?) : ContinuationImpl(completion) &#123;</span><br><span class="line">        <span class="comment">// 表示协程状态机当前的状态</span></span><br><span class="line">        <span class="keyword">var</span> label: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 协程返回结果</span></span><br><span class="line">        <span class="keyword">var</span> result: Any? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于保存之前协程的计算结果</span></span><br><span class="line">        <span class="keyword">var</span> mUser: Any? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> mFriendList: Any? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// invokeSuspend 是协程的关键</span></span><br><span class="line">        <span class="comment">// 它最终会调用 testCoroutine(this) 开启协程状态机</span></span><br><span class="line">        <span class="comment">// 状态机相关代码就是后面的 when 语句</span></span><br><span class="line">        <span class="comment">// 协程的本质，可以说就是 CPS + 状态机</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeSuspend</span><span class="params">(_result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any? &#123;</span><br><span class="line">            result = _result</span><br><span class="line">            label = label or <span class="built_in">Int</span>.Companion.MIN_VALUE</span><br><span class="line">            <span class="keyword">return</span> testCoroutine(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的这个 TestContinuation 类，是 Kotlin 编译器帮我们创建的匿名内部类，这里为了方便才用的 TestContinuation 这个名称。在这个类当中定义了几个成员变量：</p><ul><li>label 是用来代表协程状态机当中状态的；</li><li>result 是用来存储当前挂起函数执行结果的；</li><li>mUser、mFriendList 则是用来存储历史挂起函数执行结果的；</li><li>invokeSuspend 这个函数，是整个状态机的入口，它会将执行流程转交给 testCoroutine() 进行再次调用。</li></ul><p>接下来是要判断 testCoroutine 是不是初次运行，如果是初次运行，我们就要创建一个 TestContinuation 的实例对象。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                    ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testCoroutine</span><span class="params">(completion: <span class="type">Continuation</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any? &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">val</span> continuation = <span class="keyword">if</span> (completion <span class="keyword">is</span> TestContinuation) &#123;</span><br><span class="line">        completion</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//                作为参数</span></span><br><span class="line">        <span class="comment">//                   ↓</span></span><br><span class="line">        TestContinuation(completion)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是：</p><ul><li>invokeSuspend 最终会调用 testCoroutine，然后走到这个判断语句；</li><li>如果是初次运行，会创建一个 TestContinuation 对象，completion 作为参数；</li><li>这相当于用一个<strong>新的</strong> Continuation 包装了<strong>旧的</strong> Continuation；</li><li>如果不是初次运行，直接将 completion 赋值给 continuation；</li><li>这说明 continuation 在整个运行期间，只会产生一个实例，这能极大地节省内存开销（对比 CallBack）。</li></ul><p>接下来是几个变量的定义：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个变量，对应原函数的三个变量</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> user: String</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> friendList: String</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> feedList: String</span><br><span class="line"></span><br><span class="line"><span class="comment">// result 接收协程的运行结果</span></span><br><span class="line"><span class="keyword">var</span> result = continuation.result</span><br><span class="line"></span><br><span class="line"><span class="comment">// suspendReturn 接收挂起函数的返回值</span></span><br><span class="line"><span class="keyword">var</span> suspendReturn: Any? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CoroutineSingletons 是个枚举类</span></span><br><span class="line"><span class="comment">// COROUTINE_SUSPENDED 代表当前函数被挂起了</span></span><br><span class="line"><span class="keyword">val</span> sFlag = CoroutineSingletons.COROUTINE_SUSPENDED</span><br></pre></td></tr></table></figure><p>上面的代码，分别代表了函数当中的临时变量、挂起函数执行结果，以及是否挂起的标志位。接着，我们来看看协程状态机的核心逻辑：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">when</span> (continuation.label) &#123;</span><br><span class="line">    <span class="number">0</span> -&gt; &#123;</span><br><span class="line">        <span class="comment">// 检测异常</span></span><br><span class="line">        throwOnFailure(result)</span><br><span class="line"></span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        <span class="comment">// 将 label 置为 1，准备进入下一次状态</span></span><br><span class="line">        continuation.label = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 getUserInfo</span></span><br><span class="line">        suspendReturn = getUserInfo(continuation)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否挂起</span></span><br><span class="line">        <span class="keyword">if</span> (suspendReturn == sFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> suspendReturn</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = suspendReturn</span><br><span class="line">            <span class="comment">//go to next state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span> -&gt; &#123;</span><br><span class="line">        throwOnFailure(result)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 user 值</span></span><br><span class="line">        user = result <span class="keyword">as</span> String</span><br><span class="line">        log(user)</span><br><span class="line">        <span class="comment">// 将协程结果存到 continuation 里</span></span><br><span class="line">        continuation.mUser = user</span><br><span class="line">        <span class="comment">// 准备进入下一个状态</span></span><br><span class="line">        continuation.label = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 getFriendList</span></span><br><span class="line">        suspendReturn = getFriendList(user, continuation)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否挂起</span></span><br><span class="line">        <span class="keyword">if</span> (suspendReturn == sFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> suspendReturn</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = suspendReturn</span><br><span class="line">            <span class="comment">//go to next state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> -&gt; &#123;</span><br><span class="line">        throwOnFailure(result)</span><br><span class="line"></span><br><span class="line">        user = continuation.mUser <span class="keyword">as</span> String</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 friendList 的值</span></span><br><span class="line">        friendList = result <span class="keyword">as</span> String</span><br><span class="line">        log(friendList)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将协程结果存到 continuation 里</span></span><br><span class="line">        continuation.mUser = user</span><br><span class="line">        continuation.mFriendList = friendList</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备进入下一个状态</span></span><br><span class="line">        continuation.label = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 getFeedList</span></span><br><span class="line">        suspendReturn = getFeedList(user, friendList, continuation)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否挂起</span></span><br><span class="line">        <span class="keyword">if</span> (suspendReturn == sFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> suspendReturn</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = suspendReturn</span><br><span class="line">            <span class="comment">//go to next state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span> -&gt; &#123;</span><br><span class="line">        throwOnFailure(result)</span><br><span class="line"></span><br><span class="line">        user = continuation.mUser <span class="keyword">as</span> String</span><br><span class="line">        friendList = continuation.mFriendList <span class="keyword">as</span> String</span><br><span class="line">        feedList = continuation.result <span class="keyword">as</span> String</span><br><span class="line">        log(feedList)</span><br><span class="line">        loop = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 testCoroutine() 这个方法体当中，一共调用了三个挂起函数，这三个挂起函数把整个方法体分割成了 4 个部分，这四个部分就是上面 when 表达式当中的 4 种情况。</p><ul><li>when 表达式实现了协程状态机；</li><li>continuation.label 是状态流转的关键，continuation.label 改变一次，就代表了挂起函数被调用了一次；</li><li>每次挂起函数执行完后，都会检查是否发生异常；</li><li>testCoroutine 里的原本的代码，被<strong>拆分</strong>到状态机里各个状态中，<strong>分开执行</strong>；</li><li>getUserInfo(continuation)、getFriendList(user, continuation)、getFeedList(friendList, continuation) 三个函数调用的是同一个 continuation 实例；</li><li>如果一个函数被挂起了，它的返回值会是 CoroutineSingletons.COROUTINE_SUSPENDED；</li><li>在挂起函数执行的过程中，状态机会把之前的结果以成员变量的方式保存在 continuation 中。</li></ul><p>上面这一大串文字和代码看着是不是有点晕？你可以再结合着来看看这个视频演示。</p><p>那到这里是不是就结束了呢？并不，因为这个动画仅演示了每个协程正常挂起的情况。如果协程并没有真正挂起呢？协程状态机会怎么运行？</p><h2 id="协程未挂起的情况"><a href="#协程未挂起的情况" class="headerlink" title="协程未挂起的情况"></a>协程未挂起的情况</h2><p>要验证也很简单，我们将其中一个挂起函数改成伪挂起函数即可。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// “伪”挂起函数</span></span><br><span class="line"><span class="comment">// 虽然它有 suspend 修饰，但执行的时候并不会真正挂起，因为它函数体里没有其他挂起函数</span></span><br><span class="line"><span class="comment">//  ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">noSuspendFriendList</span><span class="params">(user: <span class="type">String</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Tom, Jack&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testNoSuspend</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    log(user)                  </span><br><span class="line">    <span class="comment">//                  变化在这里</span></span><br><span class="line">    <span class="comment">//                      ↓</span></span><br><span class="line">    <span class="keyword">val</span> friendList = noSuspendFriendList(user)</span><br><span class="line">    log(friendList)</span><br><span class="line">    <span class="keyword">val</span> feedList = getFeedList(friendList)</span><br><span class="line">    log(feedList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>testNoSuspend() 这样的一个函数体，它反编译后的代码逻辑是怎么样的？</p><p>答案其实很简单，<strong>它的结构跟前面的 testCoroutine() 是一致的，只是函数名字变了而已，Kotlin 编译器 CPS 转换的逻辑只认 suspend 关键字</strong>。就算挂起函数内部并没有挂起的逻辑，Kotlin 编译器也照样会进行 CPS 转换。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">when</span> (continuation.label) &#123;</span><br><span class="line">    <span class="number">0</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//               变化在这里</span></span><br><span class="line">        <span class="comment">//                   ↓</span></span><br><span class="line">        suspendReturn = noSuspendFriendList(user, continuation)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否挂起</span></span><br><span class="line">        <span class="keyword">if</span> (suspendReturn == sFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> suspendReturn</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = suspendReturn</span><br><span class="line">            <span class="comment">//go to next state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那 testNoSuspend() 的协程状态机是怎么运行的呢？</p><p>其实我们也很容易能想到，continuation.label &#x3D; 0, 2, 3 的情况都是不变的，唯独在 label &#x3D; 1 的时候，suspendReturn &#x3D;&#x3D; sFlag 这里会有区别。</p><p>具体区别我们还是通过动画来看吧：</p><p>&#x2F;&#x2F;TODO 视频</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//TODO 视频</span><br></pre></td></tr></table></figure><p>通过动画我们很清楚地看到了，对于“伪挂起函数”，suspendReturn &#x3D;&#x3D; sFlag 是会走 else 分支的，在 else 分支里，协程状态机会直接进入下一个状态。</p><p>现在只剩最后一个问题了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (suspendReturn == sFlag) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 具体代码是如何实现的？</span></span><br><span class="line">    <span class="comment">//       ↓</span></span><br><span class="line">    <span class="comment">//go to next state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案其实也很简单：如果你去看协程状态机的字节码反编译后的 Java，会看到很多 <strong>label</strong>。协程状态机底层字节码，是通过 label 来实现这个 go to next state 的。由于 Kotlin 没有类似 goto 的语法，下面我用伪代码来表示 go to next state 的逻辑。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="comment">// Kotlin 没有这样的语法</span></span><br><span class="line"><span class="comment">// ↓      ↓</span></span><br><span class="line">label: whenStart</span><br><span class="line"><span class="keyword">when</span> (continuation.label) &#123;</span><br><span class="line">    <span class="number">0</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        suspendReturn = noSuspendFriendList(user, continuation)</span><br><span class="line">        <span class="keyword">if</span> (suspendReturn == sFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> suspendReturn</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = suspendReturn</span><br><span class="line">            <span class="comment">// 让程序跳转到 label 标记的地方</span></span><br><span class="line">            <span class="comment">// 从而再执行一次 when 表达式</span></span><br><span class="line">            goto: whenStart</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：以上只是伪代码，它只是跟协程状态机字节码逻辑上“<strong>大致等价</strong>”。真实的字节码反编译出来的 Java 代码，它的可读性要差很多，也更难理解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看不懂也没关系，有个印象即可</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title function_">testCoroutine</span><span class="params">(<span class="meta">@NotNull</span> Continuation $completion)</span> &#123;</span><br><span class="line">    Object $continuation;</span><br><span class="line">    label37: &#123;</span><br><span class="line">        <span class="keyword">if</span> ($completion <span class="keyword">instanceof</span> &lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;) &#123;</span><br><span class="line">            $continuation = (&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$completion;</span><br><span class="line">            <span class="keyword">if</span> ((((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).label &amp; Integer.MIN_VALUE) != <span class="number">0</span>) &#123;</span><br><span class="line">                ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).label -= Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">break</span> label37;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $continuation = <span class="keyword">new</span> <span class="title class_">ContinuationImpl</span>($completion) &#123;</span><br><span class="line">            <span class="comment">// $FF: synthetic field</span></span><br><span class="line">            Object result;</span><br><span class="line">            <span class="type">int</span> label;</span><br><span class="line">            Object L$<span class="number">0</span>;</span><br><span class="line">            Object L$<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object $result)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.result = $result;</span><br><span class="line">                <span class="built_in">this</span>.label |= Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">return</span> TestSuspendKt.testCoroutine(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object var10000;</span><br><span class="line">    label31: &#123;</span><br><span class="line">        String user;</span><br><span class="line">        String friendList;</span><br><span class="line">        Object var6;</span><br><span class="line">        label30: &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">$result</span> <span class="operator">=</span> ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).result;</span><br><span class="line">            var6 = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">            <span class="keyword">switch</span>(((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).label) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    ResultKt.throwOnFailure($result);</span><br><span class="line">                    log(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">                    ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).label = <span class="number">1</span>;</span><br><span class="line">                    var10000 = getUserInfo((Continuation)$continuation);</span><br><span class="line">                    <span class="keyword">if</span> (var10000 == var6) &#123;</span><br><span class="line">                        <span class="keyword">return</span> var6;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    ResultKt.throwOnFailure($result);</span><br><span class="line">                    var10000 = $result;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    user = (String)((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).L$<span class="number">0</span>;</span><br><span class="line">                    ResultKt.throwOnFailure($result);</span><br><span class="line">                    var10000 = $result;</span><br><span class="line">                    <span class="keyword">break</span> label30;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    friendList = (String)((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).L$<span class="number">1</span>;</span><br><span class="line">                    user = (String)((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).L$<span class="number">0</span>;</span><br><span class="line">                    ResultKt.throwOnFailure($result);</span><br><span class="line">                    var10000 = $result;</span><br><span class="line">                    <span class="keyword">break</span> label31;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            user = (String)var10000;</span><br><span class="line">            log(user);</span><br><span class="line">            ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).L$<span class="number">0</span> = user;</span><br><span class="line">            ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).label = <span class="number">2</span>;</span><br><span class="line">            var10000 = getFriendList(user, (Continuation)$continuation);</span><br><span class="line">            <span class="keyword">if</span> (var10000 == var6) &#123;</span><br><span class="line">                <span class="keyword">return</span> var6;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        friendList = (String)var10000;</span><br><span class="line">        log(friendList);</span><br><span class="line">        ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).L$<span class="number">0</span> = user;</span><br><span class="line">        ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).L$<span class="number">1</span> = friendList;</span><br><span class="line">        ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).label = <span class="number">3</span>;</span><br><span class="line">        var10000 = getFeedList(friendList, (Continuation)$continuation);</span><br><span class="line">        <span class="keyword">if</span> (var10000 == var6) &#123;</span><br><span class="line">            <span class="keyword">return</span> var6;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">feedList</span> <span class="operator">=</span> (String)var10000;</span><br><span class="line">    log(feedList);</span><br><span class="line">    <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，对于上面反编译出来的 Java 代码，即使你看不懂也没关系，你只需要理解我们前面讲解的逻辑即可。<strong>本质上来说</strong>，Kotlin 协程就是通过 label 代码段嵌套，配合 switch 巧妙构造出一个状态机结构，这种逻辑比较复杂，相对难懂一些。毕竟 Java 的 label 在实际开发中用的很少。</p><p><code>注意：Kotlin 挂起函数反编译出来的 Java 代码，会因为实际开发环境的不同出现细微差异。随着 Kotlin 编译器的发展，将来可能会对这部分逻辑进一步优化，但它的核心状态机思想是不会轻易改变的。</code></p><p>好，到现在，我们就已经彻底弄懂挂起函数的实现原理了。接下来，我们就结合刚刚学习的内容，来进一步思考实战一下。</p><h2 id="思考与实战"><a href="#思考与实战" class="headerlink" title="思考与实战"></a>思考与实战</h2><p>在上节课我曾提到过，Kotlin 协程的源代码其实分为三层，其中基础层当中的“基础概念”尤为重要。那么，Kotlin 官方为我们提供了哪些与挂起函数相关的基础元素呢？</p><p>我们首先想到的，肯定就是Continuation.kt，在这里面，确实也可以找到一些跟挂起函数相关的基础元素。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Suppress(<span class="string">&quot;WRONG_MODIFIER_TARGET&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">throw</span> NotImplementedError(<span class="string">&quot;Implemented as intrinsic&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们最熟悉的就是 Continuation 这个接口了，除此之外，还有一个顶层的变量值得我们注意：suspend inline val coroutineContext。要知道，我们从来都是用 suspend 修饰函数的，从未见过 suspend 修饰变量的情况。</p><p>如果我们依葫芦画瓢，创建一个类似的顶层变量的话，编译器甚至会报错：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="keyword">val</span> test: CoroutineContext</span><br><span class="line">    <span class="keyword">get</span>() = TODO()</span><br></pre></td></tr></table></figure><p>由此可见，suspend 的这种用法只是一种特殊用法。结合“public suspend inline val”这几个关键字来看，我们其实可以大致推测出它的作用：它是一个只有在挂起函数作用域下，才能访问的顶层的不可变的变量。这里的 inline，意味着它的具体实现会被直接复制到代码的调用处。</p><h2 id="17-讲思考题解答"><a href="#17-讲思考题解答" class="headerlink" title="17 讲思考题解答"></a>17 讲思考题解答</h2><p>为了验证我们前面的猜测，我们可以回过头来看看第 17 讲的思考题：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段19</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.coroutines.coroutineContext</span><br><span class="line"></span><br><span class="line"><span class="comment">//                        挂起函数能可以访问协程上下文吗？</span></span><br><span class="line"><span class="comment">//                                 ↓                              </span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testContext</span><span class="params">()</span></span> = coroutineContext</span><br></pre></td></tr></table></figure><p>如果你将上面的代码反编译成 Java 的话，它就会变成这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> Object testContext(Continuation $completion) &#123;</span><br><span class="line">  <span class="keyword">return</span> $completion.getContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，代码段 17 当中的“suspend inline val coroutineContext”，本质上就是 Kotlin 官方提供的一种方便开发者在挂起函数当中，获取协程上下文的手段。它的具体实现，其实是 Kotlin 编译器来完成的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段19</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.coroutines.coroutineContext</span><br><span class="line"></span><br><span class="line"><span class="comment">//                  Continuation当中的coroutineContext</span></span><br><span class="line"><span class="comment">//                                 ↓                              </span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testContext</span><span class="params">()</span></span> = coroutineContext</span><br></pre></td></tr></table></figure><p>到这里，你就会发现一个有趣的现象：<strong>我们在挂起函数当中无法直接访问 Continuation 对象，但可以访问到 Continuation 当中的 coroutineContext</strong>。要知道，正常情况下，我们想要访问 Continuation.coroutineContext，首先是要拿到 Continuation 对象的。</p><p>是，Kotlin 官方通过“suspend inline val coroutineContext”这个顶层变量，让我们开发者能直接拿到 coroutineContext，却对 Continuation 毫无感知。</p><p>所以到这里，我们其实也就可以回答第 17 节课思考题的问题了。</p><p><code>课程里，我提到了“挂起函数”与 CoroutineContext 也有着紧密的联系，请问，你能找到具体的证据吗？</code></p><p>解答：挂起函数与 CoroutineContext 确实有着紧密的联系。每个挂起函数当中都会有 Continuation，而每个 Continuation 当中都会有 coroutineContext。并且，我们在挂起函数当中，就可以直接访问当前的 coroutineContext。</p><h2 id="KtHttp-支持挂起函数"><a href="#KtHttp-支持挂起函数" class="headerlink" title="KtHttp 支持挂起函数"></a>KtHttp 支持挂起函数</h2><p>在第 18 讲当中，我们并没有让 KtHttp 直接支持挂起函数，当时我们的做法是给 KtCall 扩展了一个 await() 方法，从而实现挂起函数调用的。</p><p>那么，经过这节课的学习，我们就可以来尝试让 KtHttp 直接支持挂起函数了，也就是我们可以这样来写代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiServiceV7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="comment">// 1，挂起函数</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">reposSuspend</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: RepoList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isSuspend(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 2，支持挂起函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3，判断是不是挂起函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isSuspend</span><span class="params">(method: <span class="type">Method</span>)</span></span> = method.kotlinFunction?.isSuspend ?: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4，真正执行网络请求的方法</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">realCall</span><span class="params">(call: <span class="type">Call</span>, gson: <span class="type">Gson</span>, type: <span class="type">Type</span>)</span></span>: T = suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class="line">    call.enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">            continuation.resumeWithException(e)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">okhttp3</span>.<span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> t = gson.fromJson&lt;T&gt;(response.body?.string(), type)</span><br><span class="line">                continuation.resume(t)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                continuation.resumeWithException(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    continuation.invokeOnCancellation &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码一共有 4 个注释，我们一个个看：</p><ul><li>注释 1，这其实就是我们希望达到的效果，可以在 ApiServiceV 接口当中直接定义挂起函数。</li><li>注释 2，在 KtHttp 6.0 版本的基础上，我们在 invoke() 的 when 表达式里增加了一个分支：isSuspend()。</li><li>注释 3，isSuspend() 的实现有一个细节，这里我们使用了“method.kotlinFunction”，将 Java 的 method 转换成了 kotlinFunction，这样一来，它就变成了一个 Kotlin 反射的对象了。因此，我们就可以查询到一些 Kotlin 相关的信息，比如说，它是不是一个挂起函数。</li><li>注释 4，为了直接在挂起函数里执行网络请求，我们将 KtCall 当中的部分代码逻辑挪了进来。这个 realCall() 方法，它被定义成了一个挂起函数。</li></ul><p>基于以上的分析，我们其实只需要借助反射，完成注释 2 处的代码逻辑，然后调用 realCall() 这个挂起函数就行了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isSuspend(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1，反射获取类型信息</span></span><br><span class="line">            <span class="comment">// 2，调用realCall()</span></span><br><span class="line">        &#125;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，接下来我们要做的事情大致可以分为两个部分。</p><p>第一个部分，获取类型信息，准备请求网络，这个部分其实很简单。但在第二个部分“支持挂起函数”这里会遇到问题：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isSuspend(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 支持挂起函数</span></span><br><span class="line">            <span class="keyword">val</span> genericReturnType = method.kotlinFunction?.returnType?.javaType ?: <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">            <span class="keyword">val</span> call = okHttpClient!!.newCall(request)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 报错！！</span></span><br><span class="line">            realCall&lt;T&gt;()</span><br><span class="line">        &#125;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码报错的原因也很容易理解，realCall() 是一个挂起函数，它无法在普通函数里被调用！所以这里我们就面临了一个问题：<strong>如何在普通 Kotlin 函数当中调用挂起函数？</strong></p><p>那么，我们首先可以想到的解决办法，就是强制类型转换：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isSuspend(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 支持挂起函数</span></span><br><span class="line">            <span class="keyword">val</span> genericReturnType = method.kotlinFunction?.returnType?.javaType ?: <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">            <span class="keyword">val</span> call = okHttpClient!!.newCall(request)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> continuation = args.last() <span class="keyword">as</span>? Continuation&lt;T&gt;</span><br><span class="line">            <span class="comment">// 1，将挂起函数类型转换成，带Continuation的类型，报错</span></span><br><span class="line">            <span class="keyword">val</span> func = ::realCall <span class="keyword">as</span> (Call, Gson, Type, Continuation&lt;T&gt;?) -&gt; Any?</span><br><span class="line">            func.invoke(call, gson, genericReturnType, continuation)</span><br><span class="line">        &#125;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请留意代码中的注释 1，我们尝试使用“函数引用”的方式，将 realCall() 转换成了带有 Continuation 的函数类型，这样我们就可以通过传入 Continuation，来调用 realCall() 这个挂起函数了。</p><p>不过，事与愿违，我们的方法并不能奏效，因为这行代码会报错，原因是 realCall() 带有泛型，而 Kotlin 暂时不支持“函数引用带泛型”的语法。</p><p>所以在这里，为了让这个 Demo 能运行起来，我们可以定义一个临时方法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isSuspend(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 支持挂起函数</span></span><br><span class="line">            <span class="keyword">val</span> genericReturnType = method.kotlinFunction?.returnType?.javaType ?: <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">            <span class="keyword">val</span> call = okHttpClient!!.newCall(request)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> continuation = args.last() <span class="keyword">as</span>? Continuation&lt;T&gt;</span><br><span class="line">            <span class="comment">// 1，使用临时方法消除泛型</span></span><br><span class="line">            <span class="keyword">val</span> func = ::temp <span class="keyword">as</span> (Call, Gson, Type, Continuation&lt;T&gt;?) -&gt; Any?</span><br><span class="line">            func.invoke(call, gson, genericReturnType, continuation)</span><br><span class="line">        &#125;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">temp</span><span class="params">(call: <span class="type">Call</span>, gson: <span class="type">Gson</span>, type: <span class="type">Type</span>)</span></span> = realCall&lt;RepoList&gt;(call, gson, type)</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用了一个临时方法消除了泛型 T，写死了返回值类型 RepoList。这样的代码，在 Demo 当中是可以运行的，这从侧面也能印证我们上面代码中的类型转换是成功的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: RepoList = KtHttpV7.create(ApiServiceV7::<span class="keyword">class</span>.java).reposSuspend(</span><br><span class="line">        lang = <span class="string">&quot;Kotlin&quot;</span>,</span><br><span class="line">        since = <span class="string">&quot;weekly&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">正常</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>不过，这种做法明显<strong>不具备普适性</strong>，为了让 KtHttp 支持所有类型的 API 请求，我们必须要想其他的办法。具体来说，我们可以这样做：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isSuspend(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 支持挂起函数</span></span><br><span class="line">            <span class="keyword">val</span> genericReturnType = method.kotlinFunction?.returnType?.javaType ?: <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">            <span class="keyword">val</span> call = okHttpClient!!.newCall(request)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> continuation = args.last() <span class="keyword">as</span>? Continuation&lt;T&gt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> func = KtHttpV7::<span class="keyword">class</span>.getGenericFunction(<span class="string">&quot;realCall&quot;</span>)</span><br><span class="line">            <span class="comment">// 反射调用realCall()</span></span><br><span class="line">            func.call(<span class="keyword">this</span>, call, gson, genericReturnType, continuation)</span><br><span class="line">        &#125;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2，获取方法的反射对象</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> KClass<span class="type">&lt;*&gt;</span>.<span class="title">getGenericFunction</span><span class="params">(name: <span class="type">String</span>)</span></span>: KFunction&lt;*&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> members.single &#123; it.name == name &#125; <span class="keyword">as</span> KFunction&lt;*&gt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实，这种思路跟前面的思路是类似的，我们仍然是对 realCall() 的类型进行了转换，只不过是通过<strong>反射</strong>来实现的而已。所以最重要的，我们还是要弄清楚 Kotlin 挂起函数 CPS 转换的细节。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课，我们通过研究挂起函数的反编译代码，<strong>发现了 Kotlin 的挂起函数，本质上就是一个状态机</strong>。其中主要涉及到下面几个知识点，我们需要重点掌握好。</p><ul><li>Kotlin 挂起函数的 CPS 转换，它的函数签名变化主要分为两个部分，第一部分是<strong>参数的变化</strong>，挂起函数经过 Kotlin 编译器转换以后，它会多出一个 Continuation 类型的参数。第二部分是<strong>返回值类型的变化</strong>，挂起函数原本的返回值类型，会被挪到 Continuation 当中作为泛型参数，比如 Continuation，而转换过后的函数返回值类型会变成“Any?”类型。</li><li>当挂起函数经过反编译以后<strong>，它会变成由 switch 和 label 组成的状态机结构</strong>。</li><li>为了便于研究，课程里提供了大致等价的协程状态机代码：其中，when 表达式实现了协程状态机，而 continuation.label 则代表了当前状态机的具体状态，continuation.label 改变一次，就代表了挂起函数被调用了一次；</li><li>在一个挂起函数被调用的时候，它的返回值可能是具体的结果，也可能会是 CoroutineSingletons.COROUTINE_SUSPENDED，这时候就代表了这个函数被挂起了。</li></ul><p>另外在这节课里，我们还进行了一次反思和实战，通过研究协程基础层当中的“suspend inline val coroutineContext”这个顶层变量，我们发现了挂起函数与协程上下文之间的紧密联系。并且，我们还灵活运用了这节课学到的知识，进一步改进了 KtHttp，让它可以直接支持挂起函数。</p><p>你在自己的工作场景当中，其实也可以通过这样思考与实战的方式，来进一步强化所学和所得，甚至可以把输入转化成输出，把知识真正沉淀成你自己的东西。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>我们都知道挂起函数是 Kotlin 协程里才有的概念，请问，Java 代码中可以调用 Kotlin 的挂起函数吗？比如，下面这个函数，我们可以在 Java 当中调用吗？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> SuspendFromJavaExample &#123;</span><br><span class="line">    <span class="comment">// 在Java当中如何调用这个方法？</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">(id: <span class="type">Long</span>)</span></span>:String &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(源码篇)26  协程源码的地图：如何读源码才不会迷失？</title>
      <link href="/posts/80bc5780/"/>
      <url>/posts/80bc5780/</url>
      
        <content type="html"><![CDATA[<p>在前面学习协程的时候，我们说过协程是 Kotlin 里最重要、最难学的特性。之所以说协程重要，是因为它有千般万般的好：挂起函数、结构化并发、非阻塞、冷数据流，等等。不过协程也真的太抽象、太难学了。即使我们学完了前面的协程篇，知道了协程的用法，但也仍然远远不够，这种“知其然，不知其所以然”的感觉，总会让我们心里不踏实。</p><p>所以，我们必须搞懂 Kotlin 协程的源代码。</p><p>可问题是，协程的源码也非常复杂。如果你尝试研究过协程的源代码，那你对此一定深有体会。在 Kotlin 协程 1.6.0 版本中，仅仅是协程跟 JVM 相关的源代码，就有 27789 行。如果算上 JavaScript 平台、Native 平台，以及单元测试相关的代码，Kotlin 协程库当中的源代码有接近 10 万行。面对这么多的源代码，我们根本不可能一行一行去分析。</p><p>因此，我们在研究 Kotlin 协程的源代码的时候，要有一定的技巧。这里给你分享我的两个小技巧：</p><ul><li><strong>理解 Kotlin 协程的源码结构</strong>。Kotlin 协程的源代码分布在多个模块之中，每个模块都会包含特定的协程概念。相应的，它的各个概念也有特定的层级结构，只有弄清楚各个概念之间的关系，并且建立一个类似“地图”的知识结构，我们在研究源码的时候，才不会那么容易迷失。</li><li><strong>明确研究源码的目标</strong>。正如我前面提到的，我们不可能一次性看完协程所有的源代码，所以我们在读源码的过程中，一定要有明确的目标。比如是想要了解挂起函数的原理，还是想学习协程的启动流程。</li></ul><p>所以在接下来的课程中，我们会主要攻克 Kotlin 协程源代码中，常见知识点的实现原理，比如挂起函数、launch、Flow 等，理解其中的代码逻辑，并掌握这些功能特性所涉及的关键技术和设计思想。</p><p>今天这节课，我们先来构建一个协程源码的知识地图，掌握了这张地图之后，我们再去学习协程的实现原理时，就可以在脑海中快速查找和定位相关模块对应的源代码，也不会迷失方向了。</p><p>不过，在正式开始学习之前，我还是要提前给你打一剂预防针。课程进行到这个阶段，学习难度也进一步提升了。<strong>不管是什么技术，研究它的底层原理永远不是一件容易的事情</strong>。因此，为了提高学习的效率，你一定要跟随课程的内容，去 IDE 里查看对应的源代码，一定要去实际运行、调试课程中给出的代码 Demo。</p><p>好，我们正式开始吧！</p><h2 id="协程源码的结构"><a href="#协程源码的结构" class="headerlink" title="协程源码的结构"></a>协程源码的结构</h2><p>在第 13 讲当中我们提到过，Kotlin 协程是一个独立的框架。如果想要使用 Kotlin 协程，我们需要单独进行依赖。</p><p>那么，要研究 Kotlin 协程，是不是只需研究这个协程框架的GitHub 仓库的代码就够了呢？其实不然。因为 Kotlin 的协程源码分为了三个层级，自底向上分别是：</p><ul><li><strong>基础层</strong>：Kotlin 库当中定义的协程基础元素；</li><li><strong>中间层</strong>：协程框架通用逻辑 kotlinx.coroutines-common；</li><li><strong>平台层</strong>：这个是指协程在特定平台的实现，比如说 JVM、JS、Native。</li></ul><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/1a/41/1aebcdcd079b531d39cc4c59ff799341.jpg?wh=2000x1125" alt="img" style="zoom:33%;" /><p>所以，我们需要分别从这三个层级来了解协程源码的目录结构、作用类别，以及对应的功能模块的源代码。也就是说，为了研究 Kotlin 协程的原理，我们不仅要读协程框架的源码，同时还要读 Kotlin 标准库的源码。接下来，我们一个个来看。</p><h3 id="基础层：协程基础元素"><a href="#基础层：协程基础元素" class="headerlink" title="基础层：协程基础元素"></a>基础层：协程基础元素</h3><p>Kotlin 协程的基础元素，其实是定义在 Kotlin 标准库当中的。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/d3/04/d3b94d0d28e467beyycb77a29af18f04.png?wh=769x629" alt="img" style="zoom: 80%;" /><p>比如，像是协程当中的一些基础概念，Continuation、SafeContinuation、CoroutineContext、CombinedContext、CancellationException、intrinsics 等等，这些概念都是定义在 Kotlin 标准库当中的。</p><p>那么，Kotlin 官方为什么要这么做呢？这其实是一种<strong>解耦</strong>的思想。Kotlin 标准库当中的基础元素，就像是构造协程框架的“<strong>砖块</strong>”一样。简单的几个基础概念，将它们组合到一起，就可以实现功能强大的协程框架。</p><p>实际上，现在的 kotlinx.coroutines 协程框架，就是基于以上几种协程基础元素构造出来的。如果哪天 GitHub 上突然冒出一款新的 Kotlin 协程框架，你也不要觉得意外，因为构造协程的砖块就在那里，每个人都可以借助这些基础元素来构建自己的协程框架。</p><p>不过就目前来说，还是 Kotlin 官方封装的协程框架功能最强大，所以开发者也都会选择 kotlinx.coroutines。另外我们都知道，Kotlin 是支持跨平台的，所以协程其实也存在跨平台的实现。在 Kotlin 官方的协程框架当中，大致分了两层：common 中间层和平台层。</p><h3 id="中间层：kotlinx-coroutines-common"><a href="#中间层：kotlinx-coroutines-common" class="headerlink" title="中间层：kotlinx.coroutines-common"></a>中间层：kotlinx.coroutines-common</h3><p>kotlinx.coroutines 源代码当中的 common 子模块，里面包含了 Kotlin 协程框架的通用逻辑。我们前面学过的大部分知识点，都来自于这个模块，比如 launch、async、CoroutineScope、CoroutineDispatcher、Job、Deferred、Channel、Select、Flow 等。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/77/40/774cf52229bdd6c60a57fa04a4001040.png?wh=947x1252" alt="img" style="zoom:80%;" /><p>虽然说，我们开发者使用那些底层的协程基础元素，也能够写代码，但它们终归是不如 Flow 之类的 API 好用的。而 kotlinx.coroutines-common 这个模块，就是 Kotlin 官方提供的一个协程的中间层。借助这些封装过后的高级协程概念，我们就可以直接去解决工作中的实际问题了。</p><p>在这个 common 中间层里，<strong>只有纯粹的协程框架逻辑，不会包含任何特定的平台特性</strong>。而我们知道，Kotlin 其实是支持 3 种平台的：JVM、JavaScript、Native。所以针对平台的支持逻辑，都在下面的平台层当中。</p><h3 id="平台层"><a href="#平台层" class="headerlink" title="平台层"></a>平台层</h3><p>在 core 模块之下，有几个与 common 平级的子模块，即 JVM、JavaScript、Native。这里面，才是 Kotlin 协程与某个平台产生关联的地方。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/f6/7e/f63577b1723d647661875362cb54e97e.png?wh=925x529" alt="img" style="zoom:80%;" /><p>我们都知道，Kotlin 的协程，最终都是运行在线程之上的。所以，当 Kotlin 在不同平台上运行的时候，最终还需要映射到对应的线程模型之上。这里我们就以 JVM 和 JavaScript 为例：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/cd/78/cdc90a8ecf17aca946600c637ce13478.png?wh=946x1101" alt="img" style="zoom:80%;" /><p>可以看到，同样的协程概念，在 JVM、JavaScript 两个平台上会有不同的实现：</p><ul><li>同样是线程，在 JVM 是线程池，而 JavaScript 则是 JS 线程；</li><li>同样是事件循环，两者也会有不同的实现方式；</li><li>同样是异步任务，JVM 是 Future，JavaScript 则是 Promise。</li></ul><p>可见，虽然协程的“平台层”是建立在 common 层之上的，但它同时又为协程在特定平台上提供了对应的支持。</p><p>好，到这里，我们就已经弄清楚 Kotlin 协程的源码结构了。这个源码的结构，也就相当于协程知识点的<strong>地图</strong>。有了这个地图以后，我们在后面遇到问题的时候，才知道去哪里找答案。比如说，当我们想知道 Kotlin 的协程是如何运行在线程之上的，那么我们肯定要到平台层，去找 JVM 的具体实现。</p><h2 id="如何研究协程源码？"><a href="#如何研究协程源码？" class="headerlink" title="如何研究协程源码？"></a>如何研究协程源码？</h2><p>读 Kotlin 协程的源代码，就像是一场原始森林里的探险一样。我们不仅要有一张清晰的地图，同时还要有明<strong>确的目标</strong>。</p><p>所以在接下来的源码篇当中，我们每一节课的学习目标都会非常明确，比如我们会来着重探究挂起函数的原理、协程启动原理、Dispatchers 原理、CoroutineScope 原理、Channel 原理，还有 Flow 的原理。这些都是 Kotlin 协程当中最基础、最重要的知识点，掌握了它们的原理以后，我们在工作中使用协程时也会更有底气。就算遇到了问题，我们也可以通过读源码找到解决方案。</p><p>不过，即使有了探索的目标也还不够，在正式开始之前，我们还需要做一些额外的准备工作。</p><p>首先，<strong>我们要掌握好协程的调试技巧</strong>。在之后的课程当中，我们会编写一些简单的 Demo，然后通过运行调试这些 Demo，一步步去跟踪、分析协程的源代码。因此，如果你还没看过第 14 讲的内容，一定要回过头去看一下其中关于协程调试的内容。</p><p>其次，我们要彻底弄懂协程的基础元素。前面我提到过，Kotlin 标准库当中的协程基础元素就像是构建协程框架的砖块一样。如果我们对协程的基础元素一知半解的话，在后面分析协程框架的过程中，就会寸步难行。</p><p>所以接下来，面对协程源码的三层结构：基础层、中间层、平台层，我们必须<strong>自底向上</strong>，一步步进行分析。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/c6/ae/c65bbb36321c7683ea6d17155d2ee2ae.jpg?wh=2000x1125" alt="img" style="zoom: 67%;" /><p><em><strong>Kotlin 源码编译细节</strong></em></p><p>另外，我们在平时用 Kotlin 协程的时候，一般只会使用依赖的方式：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">implementation <span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib&quot;</span></span><br><span class="line">implementation <span class="string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.0&#x27;</span></span><br></pre></td></tr></table></figure><p>不过使用这种方式，我们会经常遇到某些类看不到源代码实现的情况。比如，kotlin.coroutines.intrinsics 这个包下的源代码：</p><p>首先，当遇到依赖包当中无法查看的类时，你可以去 GitHub 下载 <a href="https://github.com/JetBrains/kotlin">Kotlin</a> 和 <a href="https://github.com/Kotlin/kotlinx.coroutines">Coroutines</a> 的源代码，然后按照上面画的“协程源码地图”去找对应的源代码实现。</p><p>然后，在 IDE 当中导入这两个工程的时候，可能也会遇到各种各样的问题。这时候，你需要参考这两个链接里的内容：<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/CONTRIBUTING.md">Coroutine Contributing Guidelines</a>、<a href="https://github.com/JetBrains/kotlin#build-environment-requirements">Kotlin Build environment requirements</a>，来配置好 Kotlin 和 Coroutines 的编译环境。</p><p>完成了这两个工程的导入工作以后，你就可以看到 Kotlin 和协程所有的源代码了。这里不仅有它们的核心代码，还会有跨平台实现、编译器实现，以及对应的单元测试代码。这样后面你在读 Kotlin 源码的时候，才会有更大的自由度。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课的内容到这里就差不多结束了。接下来，我们来做一个简单的总结。</p><p>研究 Kotlin 协程的源代码，我们要注意两个要点：<strong>理解 Kotlin 协程的源码结构、明确研究源码的目标</strong>。如果我们把读源码当做是一次原始森林的探险，那么前者就相当于我们手中的<strong>探险地图</strong>，后者就相当于地图上的<strong>探索目标和行进路线</strong>。</p><p>有了这两个保障以后，我们才不会轻易迷失在浩瀚的协程源码中。</p><p>那么，对于协程的源码结构来说，主要可以分为三层。</p><ul><li><strong>基础层</strong>：Kotlin 库当中定义的协程基础元素。如果说协程框架是一栋大楼，那么这些基础元素，就相当于一个个的砖块。</li><li><strong>中间层</strong>：协程框架通用逻辑 kotlinx.coroutines-common。协程框架里的 Job、Deferred、Channel、Flow，它们都是通过协程基础元素组合出来的高级概念。这些概念跟平台无关，不管协程运行在 JVM、JavaScript，还是 Native 上，这些概念都是不会变的。而这些概念的实现，全部都在协程的 common 中间层。</li><li><strong>平台层</strong>：最后就是协程在特定平台的实现，比如说 JVM、JavaScript、Native。当协程要在某个平台运行的时候，它总是免不了要跟这个平台打交道。比如 JVM，协程并不能脱离线程运行，因此协程最终还是会运行在 JVM 的线程池当中。</li></ul><p>这节课的作用跟前面第 13 讲的作用其实是差不多的。毕竟在探险之前，我们总要做一些准备工作。另外最后我也想再强调一点，就是我之所以先带你梳理协程源码的结构，也是因为如果我一上来就给你贴一大堆源代码，开始跟你分析代码的执行流程，一定会很难接受和消化吸收。</p><p>所以，也请你不要轻视这节课的作用，一定要做好充足的准备，再出发。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>在 Kotlin 协程的基础元素当中，最重要的其实就是 Continuation 这个接口。不过，在<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/Continuation.kt">Continuation.kt</a>这个文件当中，还有两个重要的扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; =</span><br><span class="line">    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">) &#123;</span><br><span class="line">    createCoroutineUnintercepted(completion).intercepted().resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问你能猜到它们的作用是什么吗？这个问题的答案，我会在第 28 讲给出。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(源码篇)25  集合操作符：你也会“看完就忘”吗？</title>
      <link href="/posts/e47f1d17/"/>
      <url>/posts/e47f1d17/</url>
      
        <content type="html"><![CDATA[<p>从这节课开始，我们就正式进入源码篇的学习了。当我们学习一门知识的时候，总</p><p>是离不开 What、Why 和 How。在前面的基础篇、协程篇当中，我们已经弄清楚了 <strong>Kotlin 是什么</strong>，以及<strong>为什么要用 Kotlin</strong>。那么在这个模块里，我们主要是来解决 How 的问题，以此从根源上搞清楚 Kotlin 的底层实现原理。今天这节课，我们先来搞定集合操作符的用法与原理。</p><p>对于大部分 Java、C 开发者来说，可能都会对 Kotlin 的集合操作符感到头疼，因为它们实在太多、太乱了。即使通过 Kotlin 官方文档把那些操作符一个个过了一遍，但过一段时间在代码中遇到它们，又会觉得陌生。<strong>一看就会，看完就忘</strong>！</p><p>其实，Kotlin 的集合 API，本质上是一种<strong>数据处理的模式</strong>。</p><p>什么是数据处理模式？可以想象一下：对于 1<del>10 的数字来说，我们找出其中的偶数，那么这就是一种过滤的行为。我们计算出 1</del>10 的总和，那么这就是一种求和的行为。所以从数据操作的角度来看，Kotlin 的操作符就可以分为几个大类：过滤、转换、分组、分割、求和。</p><p>那么接下来，我会根据一个统计学生成绩的案例，来带你分析 Kotlin 的集合 API 的使用场景，对于复杂的 API，我还会深入源码分析它们是如何实现的。这样你也就知道，集合操作符的底层实现原理，也能懂得如何在工作中灵活运用它们来解决实际问题。</p><p>好，让我们开始吧！</p><h2 id="场景模拟：统计学生成绩"><a href="#场景模拟：统计学生成绩" class="headerlink" title="场景模拟：统计学生成绩"></a>场景模拟：统计学生成绩</h2><p>为了研究 Kotlin 集合 API 的使用场景，我们先来模拟一个实际的生活场景：统计学生成绩。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Student</span>(</span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">val</span> score: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> class1 = listOf(</span><br><span class="line">    Student(<span class="string">&quot;小明&quot;</span>, <span class="number">83</span>),</span><br><span class="line">    Student(<span class="string">&quot;小红&quot;</span>, <span class="number">92</span>),</span><br><span class="line">    Student(<span class="string">&quot;小李&quot;</span>, <span class="number">50</span>),</span><br><span class="line">    Student(<span class="string">&quot;小白&quot;</span>, <span class="number">67</span>),</span><br><span class="line">    Student(<span class="string">&quot;小琳&quot;</span>, <span class="number">72</span>),</span><br><span class="line">    Student(<span class="string">&quot;小刚&quot;</span>, <span class="number">97</span>),</span><br><span class="line">    Student(<span class="string">&quot;小强&quot;</span>, <span class="number">57</span>),</span><br><span class="line">    Student(<span class="string">&quot;小林&quot;</span>, <span class="number">86</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> class2 = listOf(</span><br><span class="line">    Student(<span class="string">&quot;大明&quot;</span>, <span class="number">80</span>),</span><br><span class="line">    Student(<span class="string">&quot;大红&quot;</span>, <span class="number">97</span>),</span><br><span class="line">    Student(<span class="string">&quot;大李&quot;</span>, <span class="number">53</span>),</span><br><span class="line">    Student(<span class="string">&quot;大白&quot;</span>, <span class="number">64</span>),</span><br><span class="line">    Student(<span class="string">&quot;大琳&quot;</span>, <span class="number">76</span>),</span><br><span class="line">    Student(<span class="string">&quot;大刚&quot;</span>, <span class="number">92</span>),</span><br><span class="line">    Student(<span class="string">&quot;大强&quot;</span>, <span class="number">58</span>),</span><br><span class="line">    Student(<span class="string">&quot;大林&quot;</span>, <span class="number">88</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里我们定义了一个数据类 Student，然后有一个集合，当中对应的就是学生的名字和成绩。</p><p>接下来，我们就以这个场景来研究 Kotlin 的集合 API。</p><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>比如说，我们希望过滤 1 班里不及格的学生，我们就可以用 <strong>filter{}</strong> 这个操作符，这里的 filter 其实就是过滤的意思。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">filterNotPass</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = class1.filter &#123; it.score &lt; <span class="number">60</span> &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Student(name=小李, score=50), Student(name=小强, score=57)]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上代码段的逻辑很简单，读起来就像英语文本一样，这里我们重点来看看 filter{} 的源代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">filter</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 创建了新的ArrayList&lt;T&gt;()集合</span></span><br><span class="line">    <span class="keyword">return</span> filterTo(ArrayList&lt;T&gt;(), predicate)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, C : MutableCollection&lt;in T&gt;</span>&gt; Iterable<span class="type">&lt;T&gt;</span>.<span class="title">filterTo</span><span class="params">(destination: <span class="type">C</span>, predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: C &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">if</span> (predicate(element)) destination.add(element)</span><br><span class="line">    <span class="keyword">return</span> destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 filter{} 其实是一个高阶函数，它只有唯一的参数“predicate: (T) -&gt; Boolean”，这就是它的<strong>过滤条件及过滤标准</strong>，只有符合这个过滤条件的数据才会被保留下来。</p><p>而且，对于 List.filter{} 来说，它的内部还会创建一个新的 ArrayList()，然后将符合过滤条件的元素添加进去，再返回这个新的集合。</p><p>而除了 filter{} 以外，Kotlin 还提供了 filterIndexed{}，它的作用其实和 filter{} 一样，只是会额外带上集合元素的 index，即它的参数类型是“predicate: (index: Int, T) -&gt; Boolean”。</p><p>还有一个是 filterIsInstance()，这是我们在第 12 讲当中使用过的 API，它的作用是过滤集合当中特定类型的元素。如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 12讲当中的代码</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">create</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">        T::<span class="keyword">class</span>.java.classLoader,</span><br><span class="line">        arrayOf(T::<span class="keyword">class</span>.java)</span><br><span class="line">    ) &#123; proxy, method, args -&gt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@newProxyInstance</span> method.annotations</span><br><span class="line">            <span class="comment">// 注意这里</span></span><br><span class="line">            .filterIsInstance&lt;GET&gt;()</span><br><span class="line">            .takeIf &#123; it.size == <span class="number">1</span> &#125;</span><br><span class="line">            ?.let &#123; invoke(<span class="string">&quot;<span class="variable">$baseUrl</span><span class="subst">$&#123;it[<span class="number">0</span>].value&#125;</span>&quot;</span>, method, args) &#125;</span><br><span class="line">    &#125; <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//     inline    + reified = 类型实化</span></span><br><span class="line"><span class="comment">//       ↓            ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> R&gt;</span> Iterable<span class="type">&lt;*&gt;</span>.<span class="title">filterIsInstance</span><span class="params">()</span></span>: List&lt;<span class="meta">@kotlin</span>.<span class="keyword">internal</span>.NoInfer R&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> filterIsInstanceTo(ArrayList&lt;R&gt;())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//     inline    + reified = 类型实化</span></span><br><span class="line"><span class="comment">//       ↓            ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> R, C : MutableCollection&lt;in R&gt;</span>&gt; Iterable<span class="type">&lt;*&gt;</span>.<span class="title">filterIsInstanceTo</span><span class="params">(destination: <span class="type">C</span>)</span></span>: C &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">if</span> (element <span class="keyword">is</span> R) destination.add(element)</span><br><span class="line">    <span class="keyword">return</span> destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，filterIsInstance 的源代码逻辑也非常简单，其中最关键的，就是它借助了 inline、reified 这两个关键字，实现了<strong>类型实化</strong>。这个知识点我们在 12 讲当中也介绍过，它的作用就是让 Kotlin 的“伪泛型”变成“真泛型”。</p><p>好，Kotlin 集合 API 当中的过滤操作我们也就分析完了。接下来我们看看<strong>转换</strong>API。</p><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>现在，我们还是基于学生成绩统计的场景。不过，这次的需求是要把学生的名字隐藏掉一部分，原本的“小明”“小红”，要统一变成“小某某”。</p><p>那么对于这样的需求，我们用 <strong>map{}</strong> 就可以实现了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">mapName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = class1.map &#123; it.copy(name = <span class="string">&quot;小某某&quot;</span>) &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Student(name=小某某, score=83), </span></span><br><span class="line"><span class="comment">Student(name=小某某, score=92), </span></span><br><span class="line"><span class="comment">Student(name=小某某, score=50),</span></span><br><span class="line"><span class="comment">Student(name=小某某, score=67), </span></span><br><span class="line"><span class="comment">Student(name=小某某, score=72),</span></span><br><span class="line"><span class="comment">Student(name=小某某, score=97), </span></span><br><span class="line"><span class="comment">Student(name=小某某, score=57),</span></span><br><span class="line"><span class="comment">Student(name=小某某, score=86)]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这里需要注意，虽然 map 这个单词的意思是“地图”，但在当前的语境下，map 其实是<strong>转换、映射</strong>的意思，这时候，我们脑子要想到的是 HashMap 当中的 map 含义。</p><p>另外，map 的源码也很简单：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(transform: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: List&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(<span class="number">10</span>)), transform)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R, C : MutableCollection&lt;in R&gt;</span>&gt; Iterable<span class="type">&lt;T&gt;</span>.<span class="title">mapTo</span><span class="params">(destination: <span class="type">C</span>, transform: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: C &#123;</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> <span class="keyword">this</span>)</span><br><span class="line">        destination.add(transform(item))</span><br><span class="line">    <span class="keyword">return</span> destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上，map 就是对每一个集合元素都进行一次 transform() 方法的调用，它的类型是“transform: (T) -&gt; R”。</p><p>除了 map 以外，还有一个比较有用的转换 API，<strong>flatten</strong>。它的作用是将嵌套的集合“<strong>展开、铺平</strong>成为一个非嵌套的集合”。我们来看一个简单的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlatten</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), listOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">    <span class="keyword">val</span> result = list.flatten()</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>假设，我们现在想要过滤出 1 班、2 班当中所有未及格的同学，我们就可以结合 flatten、filter 来实现。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">filterAllNotPass</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = listOf(class1, class2)</span><br><span class="line">        .flatten()</span><br><span class="line">        .filter &#123; it.score &lt; <span class="number">60</span> &#125;</span><br><span class="line"></span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flatten 源代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;Iterable&lt;T&gt;</span>&gt;.<span class="title">flatten</span><span class="params">()</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = ArrayList&lt;T&gt;()</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        result.addAll(element) <span class="comment">// 注意addAll()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Student(name=小李, score=50),</span></span><br><span class="line"><span class="comment">Student(name=小强, score=57),</span></span><br><span class="line"><span class="comment">Student(name=大李, score=53),</span></span><br><span class="line"><span class="comment">Student(name=大强, score=58)]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先将嵌套的集合用 flatten 展平，得到 1 班、2 班所有同学的成绩，然后直接使用 filter 就完成了。</p><p>另外，如果你去看 flatten 的源代码，你也会发现它的代码非常简单。本质上，flatten 就是一个 for 循环，然后对每一个内部集合进行 addAll()。</p><p>下面我们接着来看看分组 API。</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>现在，我们还是基于学生成绩统计的场景。这次，我们希望把学生们按照成绩的分数段进行分组：50<del>59 的学生为一组、60</del>69 的学生为一组、70~79 的学生为一组，以此类推。</p><p>对于这样的需求，我们可以使用 Kotlin 提供的 **groupBy{}**。比如说：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">groupStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = class1.groupBy &#123; <span class="string">&quot;<span class="subst">$&#123;it.score / <span class="number">10</span>&#125;</span>0分组&quot;</span> &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">80分组=[Student(name=小明, score=83), Student(name=小林, score=86)], </span></span><br><span class="line"><span class="comment">90分组=[Student(name=小红, score=92), Student(name=小刚, score=97)], </span></span><br><span class="line"><span class="comment">50分组=[Student(name=小李, score=50), Student(name=小强, score=57)], </span></span><br><span class="line"><span class="comment">60分组=[Student(name=小白, score=67)], </span></span><br><span class="line"><span class="comment">70分组=[Student(name=小琳, score=72)]&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>groupBy{} 的意思就是<strong>以什么标准进行分组</strong>。在这段代码里，我们是以分数除以 10 得到的数字进行分组的，最终它的返回值类型其实是 Map&lt;&gt;。</p><p>在加餐 1当中，其实我们也用过 groupBy 来完善那个单词频率统计程序：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processText</span><span class="params">(text: <span class="type">String</span>)</span></span>: List&lt;WordFreq&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line">        .clean()</span><br><span class="line">        .split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        .filter &#123; it != <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        .groupBy &#123; it &#125; <span class="comment">// 注意这里</span></span><br><span class="line">        .map &#123; WordFreq(it.key, it.value.size) &#125;</span><br><span class="line">        .sortedByDescending &#123; it.frequency &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的 groupBy，作用就是将所有的单词按照单词本身进行分类，在这个阶段它的返回值是 Map&gt;。</p><p>我们也再来看看 groupBy 的源代码。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, K&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">groupBy</span><span class="params">(keySelector: (<span class="type">T</span>) -&gt; <span class="type">K</span>)</span></span>: Map&lt;K, List&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> groupByTo(LinkedHashMap&lt;K, MutableList&lt;T&gt;&gt;(), keySelector)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, K, M : MutableMap&lt;in K, MutableList&lt;T&gt;</span>&gt;&gt; Iterable<span class="type">&lt;T&gt;</span>.<span class="title">groupByTo</span><span class="params">(destination: <span class="type">M</span>, keySelector: (<span class="type">T</span>) -&gt; <span class="type">K</span>)</span></span>: M &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> key = keySelector(element)</span><br><span class="line">        <span class="comment">// 注意这里</span></span><br><span class="line">        <span class="keyword">val</span> list = destination.getOrPut(key) &#123; ArrayList&lt;T&gt;() &#125;</span><br><span class="line">        list.add(element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> destination</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> MutableMap<span class="type">&lt;K, V&gt;</span>.<span class="title">getOrPut</span><span class="params">(key: <span class="type">K</span>, defaultValue: () -&gt; <span class="type">V</span>)</span></span>: V &#123;</span><br><span class="line">    <span class="keyword">val</span> value = <span class="keyword">get</span>(key)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> answer = defaultValue()</span><br><span class="line">        put(key, answer)</span><br><span class="line">        answer</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 groupBy 的源代码中我们可以看到，它的本质就是用 for 循环遍历元素，然后使用 keySelector() 计算出 Map 的 Key，再把其中所有的元素添加到对应 Key 当中去。注意，在代码这里使用了一个 getOrPut(key) { ArrayList() }，它的作用就是尝试获取对应的 key 的值，如果不存在的话，就将 ArrayList() 存进去。</p><p>好，接下来，我们看看 Kotlin 的<strong>分割 API</strong>。</p><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>还是基于学生成绩统计的场景。这次，我们希望找出前三名和倒数后三名的学生。做法其实也很简单，我们使用 <strong>take()</strong> 就可以实现了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">takeStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> first3 = class1</span><br><span class="line">        .sortedByDescending &#123; it.score &#125;</span><br><span class="line">        .take(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> last3 = class1</span><br><span class="line">        .sortedByDescending &#123; it.score &#125;</span><br><span class="line">        .takeLast(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    println(first3)</span><br><span class="line">    println(last3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Student(name=小刚, score=97), Student(name=小红, score=92), Student(name=小林, score=86)]</span></span><br><span class="line"><span class="comment">[Student(name=小白, score=67), Student(name=小强, score=57), Student(name=小李, score=50)]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们先按照分数进行了降序排序，然后使用了 take、takeLast 从列表当中取出前三个和后三个数据，它们分别代表了：成绩排在前三名、后三名的同学。</p><p>而除了 take 以外，还有 drop、dropLast，它们的作用是<strong>剔除</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dropStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> middle = class1</span><br><span class="line">        .sortedByDescending &#123; it.score &#125;</span><br><span class="line">        .drop(<span class="number">3</span>)</span><br><span class="line">        .dropLast(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 剔除前三名、后三名，剩余的学生</span></span><br><span class="line">    println(middle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Student(name=小明, score=83), Student(name=小琳, score=72)]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们先把学生按照分数降序排序，然后剔除了前三名和后三名，得到了中间部分的学生。</p><p>另外 Kotlin 还提供了 <strong>slice</strong>，使用这个 API，我们同样可以取出学生中的前三名、后三名。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sliceStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> first3 = class1</span><br><span class="line">        .sortedByDescending &#123; it.score &#125;</span><br><span class="line">        .slice(<span class="number">0.</span><span class="number">.2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> size = class1.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> last3 = class1</span><br><span class="line">        .sortedByDescending &#123; it.score &#125;</span><br><span class="line">        .slice(size - <span class="number">3</span> until size)</span><br><span class="line"></span><br><span class="line">    println(first3)</span><br><span class="line">    println(last3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Student(name=小刚, score=97), Student(name=小红, score=92), Student(name=小林, score=86)]</span></span><br><span class="line"><span class="comment">[Student(name=小白, score=67), Student(name=小强, score=57), Student(name=小李, score=50)]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，slice 的作用是根据 index 来分割集合的，当它与 Range（特定范围）相结合的时候，代码的可读性也是不错的。</p><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>我们接着来看 Kotlin 的求和 API。这一次还是基于学生成绩统计的场景，我们希望计算全班学生的总分。</p><p>我们可以使用 Kotlin 提供的 <strong>sumOf、reduce、fold</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sumScore</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sum1 = class1.sumOf &#123; it.score &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sum2 = class1</span><br><span class="line">        .map &#123; it.score &#125;</span><br><span class="line">        .reduce &#123; acc, score -&gt; acc + score &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sum3 = class1</span><br><span class="line">        .map &#123; it.score &#125;</span><br><span class="line">        .fold(<span class="number">0</span>) &#123; acc, score -&gt; acc + score &#125;</span><br><span class="line"></span><br><span class="line">    println(sum1)</span><br><span class="line">    println(sum2)</span><br><span class="line">    println(sum3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">604</span></span><br><span class="line"><span class="comment">604</span></span><br><span class="line"><span class="comment">604</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>总的来说，sumOf 能做到的事情，reduce 可以想办法做；而 reduce 可以做到的事情，fold 也可以做到。它们的使用场景是具备包含关系的。</p><ul><li><p><strong>sumOf{}</strong> 仅可以用于数字类型的数据进行求和的场景。</p></li><li><p><strong>reduce</strong> 本质上是对数据进行遍历，然后进行某种“广义求和”的操作，这里不局限于数字类型。我们使用 reduce，也可以进行字符串拼接。相当于说，这里的求和规则，是我们从外部传进来的。</p></li><li><p><strong>fold</strong> 对比 reduce 来说，只是多了一个初始值，其他都跟 reduce 一样。</p></li></ul><p>比如，下面这段代码，我们就使用了 reduce、fold 进行了字符串拼接：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">joinScore</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sum2 = class1</span><br><span class="line">        .map &#123; it.score.toString() &#125;</span><br><span class="line">        .reduce &#123; acc, score -&gt; acc + score &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sum3 = class1</span><br><span class="line">        .map &#123; it.score.toString() &#125;</span><br><span class="line">        .fold(<span class="string">&quot;Prefix=&quot;</span>) &#123; acc, score -&gt; acc + score &#125;</span><br><span class="line"></span><br><span class="line">    println(sum2)</span><br><span class="line">    println(sum3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8392506772975786</span></span><br><span class="line"><span class="comment">Prefix=8392506772975786</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所以，reduce 就是 fold 的一种特殊情况。也就是说，fold 不需要初始值的时候，就是 reduce。我们可以来看看它们的源码定义：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;S, T : S&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">reduce</span><span class="params">(operation: (<span class="type">acc</span>: <span class="type">S</span>, <span class="type">T</span>) -&gt; <span class="type">S</span>)</span></span>: S &#123;</span><br><span class="line">    <span class="keyword">val</span> iterator = <span class="keyword">this</span>.iterator()</span><br><span class="line">    <span class="keyword">if</span> (!iterator.hasNext()) <span class="keyword">throw</span> UnsupportedOperationException(<span class="string">&quot;Empty collection can&#x27;t be reduced.&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> accumulator: S = iterator.next()</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        accumulator = operation(accumulator, iterator.next())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">acc</span>: <span class="type">R</span>, <span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">var</span> accumulator = initial</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) accumulator = operation(accumulator, element)</span><br><span class="line">    <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上定义，可以发现 fold 和 reduce 的名字虽然看起来很高大上，但它们的实现原理其实非常简单，就是一个简单的 for 循环。而 reduce 之所以看起来比 fold 要复杂一点的原因在于，<strong>reduce 需要兼容集合为空的情况，fold 不需要，因为 fold 具备初始值</strong>。</p><h3 id="跳水分值计算"><a href="#跳水分值计算" class="headerlink" title="跳水分值计算"></a>跳水分值计算</h3><p><code>场景：去掉一个最高分，去掉一个最低分，求平均值</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> scoreList = listOf(<span class="number">80</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">91</span>,<span class="number">95</span>,<span class="number">99</span>,<span class="number">91</span>)</span><br><span class="line">    <span class="keyword">val</span> average = scoreList</span><br><span class="line">        .sortedByDescending &#123; it &#125; <span class="comment">//按照分数从高到低排序</span></span><br><span class="line">        .drop(<span class="number">1</span>) <span class="comment">//去掉一个最高分</span></span><br><span class="line">        .dropLast(<span class="number">1</span>) <span class="comment">//去掉一个最低分</span></span><br><span class="line">        .average() <span class="comment">//求平均值</span></span><br><span class="line"><span class="comment">// 93.2</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好，这节课的内容就到这里了，我们来做一个简单的总结。</p><p>Kotlin 的集合 API，主要分为这几个大类：过滤、转换、分组、分割、求和、求平均值。</p><ul><li>过滤，filter、filterIsInstance，前者是以<strong>条件过滤</strong>，后者是以类型过滤，后者运用了 Kotlin 的<strong>类型实化</strong>。</li><li>转换，map、flatten，前者是<strong>转换集合元素</strong>，后者是<strong>转换集合的嵌套层级</strong>，flatten 会把嵌套的集合<strong>展平</strong>。</li><li>分组，groupBy，即以<strong>什么标准进行分组</strong>，它的返回值类型往往会是 Map。</li><li>分割，take、drop、slice。take 代表从集合中<strong>提取</strong>，drop 代表从集合中剔除，slice 代表以<strong>特定范围</strong>（Range）进行切割。</li><li>求和，sumOf、reduce、fold。sumOf 只适用于数字类型的求和，reduce、fold 则能够以特定规则对集合元素进行“广义的求和”，其中的“求和规则”我们可以灵活自定义，比如字符串拼接。</li></ul><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/ee/5e/ee951f5853d081ccc75d13cc49c29f5e.jpg?wh=2000x546" alt="img" style="zoom:50%;" /><p>其实，经过前面几十节课的学习，现在我们分析 Kotlin 集合的源代码，整个过程都是非常轻松的。因为它们无非就是<strong>高阶函数与 for 循环的简单结合</strong>。而你需要特别注意的是，以上所有的操作符，都不会修改原本的集合，它们返回的集合是一个全新的集合。这也体现出了 Kotlin 推崇的不变性和无副作用这两个特性。</p><p>另外正如我前面所讲的，Kotlin 的集合 API，不仅仅是 Kotlin 集合特有的 API，而是一种广泛存在的数<strong>据处理的模式</strong>。所以你会发现，Kotlin 的集合操作符跟 Kotlin 的 Sequence、Flow 里面的操作符也是高度重叠的。不仅如此，这些操作符跟 Java 8、C#、Scala、Python 等语言的 API 也高度重叠。</p><p>而这就意味着，通过这节课的学习，你不仅可以对 Kotlin 的 Flow、Sequence 有更全面的认识，将来你接触其他计算机语言的时候，也可以轻松上手。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>前面我们提到过，Kotlin 的集合操作符都不会修改原本的集合，它们返回的集合是一个全新的集合。这恰好就体现出了 Kotlin 推崇的不变性和无副作用的特点。那么请问，这样的方式是否存在劣势？我们平时该如何取舍？</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(答疑篇)答疑（一）| Java和Kotlin到底谁好谁坏？</title>
      <link href="/posts/85d82fa8/"/>
      <url>/posts/85d82fa8/</url>
      
        <content type="html"><![CDATA[<p>由于咱们课程的设计理念是简单易懂、贴近实际工作，所以我在课程内容的讲述上也会有一些侧重点，进而也会忽略一些细枝末节的知识点。不过，我看到很多同学都在留言区分享了自己的见解，算是对课程内容进行了很好的补充，这里给同学们点个赞，感谢你的仔细思考和认真学习。</p><p>另外，我看到不少同学提出的很多问题也都非常有价值，有些问题非常有深度，有些问题非常有实用性，有些问题则非常有代表性，这些问题也值得我们再一起探讨下。因此，这一次，我们来一次集中答疑。</p><h2>Java 和 Kotlin 到底谁好谁坏？</h2><p>很多同学看完开篇词以后，可能会留下一种印象，就是貌似 Java 就是坏的，Kotlin 就是好的。但其实在我看来，语言之间是不存在明确的优劣之分的。“XX 是世界上最好的编程语言”这种说法，也是没有任何意义的。</p><p>不过，虽然语言之间没有优劣之分，但在特定场景下，还是会有更优选择的。比如说，站在 Android 开发的角度上看，Kotlin 就的确要比 Java 强很多；但如果换一个角度，服务端开发，Kotlin 的优势则并不明显，因为 Spring Boot 之类的框架对 Java 的支持已经足够好了；甚至，如果我们再换一个角度，站在性能、编译期耗时的视角上看，Kotlin 在某些情况下其实是略逊于 Java 的。</p><p>如果用发展的眼光来看待这个问题的话，其实这个问题根本不重要。Kotlin 是一门基于 JVM 的语言，它更像是站在了巨人的肩膀上。<strong>Kotlin 的设计思路就是“扬长避短”</strong>。Java 的优点，Kotlin 都可以拿过来；Java 的缺点，Kotlin 尽量都把它扔掉！这就是为什么很多人会说：Kotlin 是一门更好的 Java 语言（Better Java）。</p><p>在开篇词里，我曾经提到过 Java 的一些问题：语法表现力差、可读性差，难维护、易出错、并发难。而这并不是说 Java 有多么不好，我想表达的其实是这两点：</p><ul><li><strong>Java 太老了</strong>。Java 为了自身的兼容性，它的语法很难发展和演进，这才导致它在几十年后的今天看起来“语法表现力差”。</li><li><strong>不是 Java 变差了，而是 Kotlin 做得更好了</strong>。因为 Kotlin 的理念就是扬长避短，因此，在 Java 特别容易出错的领域，Kotlin 做了足够多的优化，比如内部类默认静态，比如不允许隐式的类型转换，比如挂起函数优化异步逻辑，等等。</li></ul><p>所以，Kotlin 一定就比 Java 好吗？结论是并不一定。但在大部分场景下，我会愿意选 Kotlin。</p><h2 id="Double-类型字面量"><a href="#Double-类型字面量" class="headerlink" title="Double 类型字面量"></a>Double 类型字面量</h2><p>在 Java 当中，我们会习惯性使用“1F”代表 Float 类型，“1D”代表 Double 类型。但是这一行为在 Kotlin 当中其实会略有不同，而我发现，很多同学都会下意识地把 Java 当中的经验带入到 Kotlin（当然也包括我）。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> i = <span class="number">1F</span>   <span class="comment">// Float 类型</span></span><br><span class="line"><span class="keyword">val</span> j = <span class="number">1.0</span>  <span class="comment">// Double 类型</span></span><br><span class="line"><span class="keyword">val</span> k = <span class="number">1D</span>   <span class="comment">// 报错！！</span></span><br></pre></td></tr></table></figure><h2 id="逆序区间"><a href="#逆序区间" class="headerlink" title="逆序区间"></a>逆序区间</h2><p>在第 1 讲里，我曾提到过：如果我们想要逆序迭代一个区间，不能使用“6…0”这种写法，因为这种写法的区间要求是：右边的数字大于等于左边的数字。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">6.</span><span class="number">.0</span>) &#123;</span><br><span class="line">        println(i) <span class="comment">// 无法执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们实际工作中，我们也许不会直接写出类似代码段 2 这样的逻辑，但是，当我们的区间范围变成变量以后，这个问题就没那么容易被发现了。比如我们可以看看下面这个例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> start = calculateStart() <span class="comment">// 6</span></span><br><span class="line">    <span class="keyword">val</span> end = calculateEnd()     <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> start..end) &#123;</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，如果 end 小于 start，我们就很难通过读代码发现问题了。所以在实际的开发工作中，我们其实应该慎重使用“start…end”的写法。如果我们不管是正序还是逆序都需要迭代的话，这时候，我们可以考虑封装一个全局的顶层函数：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculateStart</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="number">6</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculateEnd</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> start = calculateStart()</span><br><span class="line">    <span class="keyword">val</span> end = calculateEnd()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> fromTo(start, end)) &#123;</span><br><span class="line">        println(i) <span class="comment">// end 小于start，无法执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fromTo</span><span class="params">(start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span> =</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= end) start..end <span class="keyword">else</span> start downTo end</span><br></pre></td></tr></table></figure><p>在上面的 fromTo() 当中，我们对区间的边界进行了简单的判断，如果左边界小于右边界，我们就使用逆序的方式迭代。</p><h2 id="密封类优势"><a href="#密封类优势" class="headerlink" title="密封类优势"></a>密封类优势</h2><p>在第 2 讲中，有不少同学觉得密封类不是特别好理解。在课程里，我们是拿密封类与枚举类进行对比来说明讲解的。我们知道，所谓<strong>枚举，就是一组有限数量的值</strong>。枚举的使用场景往往是某种事物的某些状态，比如，电视机有开关的状态，人类有女性和男性，等等。在 Kotlin 当中，同一个枚举，在内存当中是同一份引用。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    MAN, WOMAN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(Human.MAN == Human.MAN)</span><br><span class="line">    println(Human.MAN === Human.MAN)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>那么<strong>密封类，其实是对枚举的一种补充</strong>。枚举类能做的事情，密封类也能做到：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">object</span> MAN: Human()</span><br><span class="line">    <span class="keyword">object</span> WOMAN: Human()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(Human.MAN == Human.MAN)</span><br><span class="line">    println(Human.WOMAN === Human.WOMAN)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>所以，密封类，也算是用了枚举的思想。但它跟枚举不一样的地方是：<strong>同一个父类的所有子类</strong>。举个例子，我们在 IM 消息当中，就可以定义一个 BaseMsg，然后剩下的就是具体的消息子类型，比如文字消息 TextMsg、图片消息 ImageMsg、视频消息 VideoMsg，这些子类消息的种类肯定是有限的。</p><p>而密封类的好处就在于，对于每一种消息类型，它们都可以携带各自的数据。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">BaseMsg</span> &#123;</span><br><span class="line">    <span class="comment">//                密封类可以携带数据</span></span><br><span class="line">    <span class="comment">//                       ↓</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">TextMsg</span>(<span class="keyword">val</span> text: String) : BaseMsg()</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">ImageMsg</span>(<span class="keyword">val</span> url: String) : BaseMsg()</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">VideoMsg</span>(<span class="keyword">val</span> url: String) : BaseMsg()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们可以说：<strong>密封类，就是一组有限数量的子类</strong>。针对这里的子类，我们可以让它们创建不同的对象，这一点是枚举类无法做到的。</p><p>那么，<strong>使用密封类的第一个优势</strong>，就是如果我们哪天扩充了密封类的子类数量，所有密封类的使用处都会智能检测到，并且给出报错：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">BaseMsg</span> &#123;</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">TextMsg</span>(<span class="keyword">val</span> text: String) : BaseMsg()</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">ImageMsg</span>(<span class="keyword">val</span> url: String) : BaseMsg()</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">VideoMsg</span>(<span class="keyword">val</span> url: String) : BaseMsg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加了一个Gif消息</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">GisMsg</span>(<span class="keyword">val</span> url: String): BaseMsg()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错！！</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">display</span><span class="params">(<span class="keyword">data</span>: <span class="type">BaseMsg</span>)</span></span>: <span class="built_in">Unit</span> = <span class="keyword">when</span>(<span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="keyword">is</span> BaseMsg.TextMsg -&gt; TODO()</span><br><span class="line">    <span class="keyword">is</span> BaseMsg.ImageMsg -&gt; TODO()</span><br><span class="line">    <span class="keyword">is</span> BaseMsg.VideoMsg -&gt; TODO()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会报错，因为 BaseMsg 已经有 4 种子类型了，而 when 表达式当中只枚举了 3 种情况，所以它会报错。</p><p><strong>使用密封类的第二个优势</strong>在于，当我们扩充了子类型以后，IDE 可以帮我们快速补充分支类型：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/24/e6/24c3b78cd2e208f669f2804e7e9362e6.gif?wh=2088x1268" alt="img" style="zoom: 50%;" /><p>不过，还有一点需要特别注意，那就是 else 分支。一旦我们在枚举密封类的时候使用了 else 分支，那我们前面提到的两个密封类的优势就会不复存在！</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">BaseMsg</span> &#123;</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">TextMsg</span>(<span class="keyword">val</span> text: String) : BaseMsg()</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">ImageMsg</span>(<span class="keyword">val</span> url: String) : BaseMsg()</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">VideoMsg</span>(<span class="keyword">val</span> url: String) : BaseMsg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加了一个Gif消息</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">GisMsg</span>(<span class="keyword">val</span> url: String): BaseMsg()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">display</span><span class="params">(<span class="keyword">data</span>: <span class="type">BaseMsg</span>)</span></span>: <span class="built_in">Unit</span> = <span class="keyword">when</span>(<span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="keyword">is</span> BaseMsg.TextMsg -&gt; TODO()</span><br><span class="line">    <span class="keyword">is</span> BaseMsg.ImageMsg -&gt; TODO()</span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; TODO()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请留意这里的 display() 方法，当我们只有三种消息类型的时候，我们可以在枚举了 TextMsg、ImageMsg 以后，使得 else 就代表 VideoMsg。不过，一旦后续增加了 GifMsg 消息类型，这里的逻辑就会出错。而且，在这种情况下，我们的编译器还不会提示报错！</p><p>因此，<strong>在我们使用枚举或者密封类的时候，一定要慎重使用 else 分支</strong>。</p><h2 id="枚举类的-valueOf"><a href="#枚举类的-valueOf" class="headerlink" title="枚举类的 valueOf()"></a>枚举类的 valueOf()</h2><p>另外，在使用 Kotlin 枚举类的时候，还有一个坑需要我们特别注意。在第 4 讲实现的第一个版本的计算器里，我们使用了 valueOf() 尝试解析了操作符枚举类。而这只是理想状态下的代码，实际上，正确的方式应该使用 2.0 版本当中的方式。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> help = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">--------------------------------------</span></span><br><span class="line"><span class="string">使用说明：</span></span><br><span class="line"><span class="string">1. 输入 1 + 1，按回车，即可使用计算器；</span></span><br><span class="line"><span class="string">2. 注意：数字与符号之间要有空格；</span></span><br><span class="line"><span class="string">3. 想要退出程序，请输入：exit</span></span><br><span class="line"><span class="string">--------------------------------------&quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        println(help)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> input = readLine() ?: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="string">&quot;exit&quot;</span>) exitProcess(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> inputList = input.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> result = calculate(inputList)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;输入格式不对&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$input</span> = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(inputList: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputList.size != <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> left = inputList[<span class="number">0</span>].toInt()</span><br><span class="line">    <span class="comment">//                        注意这里</span></span><br><span class="line">    <span class="comment">//                           ↓</span></span><br><span class="line">    <span class="keyword">val</span> operation = Operation.valueOf(inputList[<span class="number">1</span>])?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> right = inputList[<span class="number">2</span>].toInt()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (operation) &#123;</span><br><span class="line">        Operation.ADD -&gt; left + right</span><br><span class="line">        Operation.MINUS -&gt; left - right</span><br><span class="line">        Operation.MULTI -&gt; left * right</span><br><span class="line">        Operation.DIVI -&gt; left / right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Operation</span>(<span class="keyword">val</span> value: String) &#123;</span><br><span class="line">    ADD(<span class="string">&quot;+&quot;</span>),</span><br><span class="line">    MINUS(<span class="string">&quot;-&quot;</span>),</span><br><span class="line">    MULTI(<span class="string">&quot;*&quot;</span>),</span><br><span class="line">    DIVI(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请留意上面的代码注释，这个 valueOf() 是无法正常工作的。Kotlin 为我们提供的这个方法，并不能为我们解析枚举类的 value。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">val</span> wrong = Operation.valueOf(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">val</span> right = Operation.valueOf(<span class="string">&quot;ADD&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现这个问题的原因就在于<strong>，Kotlin 提供的 valueOf() 就是用于解析“枚举变量名称”的</strong>。</p><p>这是一个非常常见的使用误区，不得不说，Kotlin 在这个方法的命名上并不是很好，导致开发者十分容易用错。Kotlin 提供的 valueOf() 还不如说是 nameOf()。</p><p>而如果我们希望可以根据 value 解析出枚举的状态，我们就需要自己动手。最简单的办法，就是使用伴生对象。在这里，我们只需要将 2.0 版本当中的逻辑挪进去即可：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Operation</span>(<span class="keyword">val</span> value: String) &#123;</span><br><span class="line">    ADD(<span class="string">&quot;+&quot;</span>),</span><br><span class="line">    MINUS(<span class="string">&quot;-&quot;</span>),</span><br><span class="line">    MULTI(<span class="string">&quot;*&quot;</span>),</span><br><span class="line">    DIVI(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">realValueOf</span><span class="params">(value: <span class="type">String</span>)</span></span>: Operation? &#123;</span><br><span class="line">            values().forEach &#123;</span><br><span class="line">                <span class="keyword">if</span> (value == it.value) &#123;</span><br><span class="line">                    <span class="keyword">return</span> it</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的，在我们尝试解析操作符的时候，我们就不再使用 Kotlin 提供的 valueOf()，而是使用自定义的 realValueOf() 了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> help = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">--------------------------------------</span></span><br><span class="line"><span class="string">使用说明：</span></span><br><span class="line"><span class="string">1. 输入 1 + 1，按回车，即可使用计算器；</span></span><br><span class="line"><span class="string">2. 注意：数字与符号之间要有空格；</span></span><br><span class="line"><span class="string">3. 想要退出程序，请输入：exit</span></span><br><span class="line"><span class="string">--------------------------------------&quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        println(help)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> input = readLine() ?: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="string">&quot;exit&quot;</span>) exitProcess(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> inputList = input.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> result = calculate(inputList)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;输入格式不对&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$input</span> = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(inputList: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputList.size != <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> left = inputList[<span class="number">0</span>].toInt()</span><br><span class="line">    <span class="comment">//                        变化在这里</span></span><br><span class="line">    <span class="comment">//                           ↓</span></span><br><span class="line">    <span class="keyword">val</span> operation = Operation.realValueOf(inputList[<span class="number">1</span>])?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> right = inputList[<span class="number">2</span>].toInt()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (operation) &#123;</span><br><span class="line">        Operation.ADD -&gt; left + right</span><br><span class="line">        Operation.MINUS -&gt; left - right</span><br><span class="line">        Operation.MULTI -&gt; left * right</span><br><span class="line">        Operation.DIVI -&gt; left / right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，对于枚举，我们在使用 valueOf() 的时候一定要足够小心！因为它解析的根本就不是 value，而是 name。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在我看来，专栏是“作者说，读者听”的过程，而留言区则是“读者说，作者听”的过程。这两者结合在一起之后，我们才能形成一个更好的沟通闭环。今天的这节答疑课，就是我在倾听了你的声音后，给到你的回应。</p><p>所以，如果你在学习的过程中遇到了什么问题，请一定要提出来，我们一起交流和探讨，共同进步。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>请问你在使用 Kotlin 的过程中，还遇到过哪些问题？请在留言区提出来，我们一起交流。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(协程篇)24  实战：让KtHttp支持Flow</title>
      <link href="/posts/6532289/"/>
      <url>/posts/6532289/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin编程第一课–-协程篇-24-实战：让KtHttp支持Flow"><a href="#Kotlin编程第一课–-协程篇-24-实战：让KtHttp支持Flow" class="headerlink" title="Kotlin编程第一课–(协程篇)24 | 实战：让KtHttp支持Flow"></a>Kotlin编程第一课–(协程篇)24 | 实战：让KtHttp支持Flow</h1><p>又到了熟悉的实战环节，这一次我们接着来改造 KtHttp，让它能够支持协程的 Flow API。</p><p>有了前面两次实战的基础，这次我们应该就轻车熟路了。在之前的4.0 版本中，为了让 KtHttp 支持挂起函数，我们有两种思路，一种是<strong>改造内部</strong>，另一种是扩展外部。同理，为了让 KtHttp 支持 Flow，这次的实战也是这两种思路。</p><p>因此，这节课我们仍然会分为两个版本。</p><ul><li><p>5.0 版本，基于 4.0 版本的代码，从 KtHttp 的<strong>外部扩展</strong>出 Flow 的能力。</p></li><li><p>6.0 版本，<strong>修改 KtHttp 内部</strong>，让它支持 Flow API。</p></li></ul><p>其实在实际的工作中，我们往往没有权限修改第三方提供的 SDK，那么这时候，如果想要让 SDK 获得 Flow 的能力，我们就只能借助 Kotlin 的扩展函数，为它<strong>扩展</strong>出 Flow 的能力。而对于工程内部的代码，我们希望某个功能模块获得 Flow 的能力，就可以<strong>直接修改它的源代码</strong>，让它直接支持 Flow。</p><p>那么在这节课里，我会同时用这两种手段来扩展并改造 KtHttp，为你演示其中的关键步骤。在这个过程中，我也会为你讲解其中的常见误区和陷阱，这样一来，你就可以放心地将 Flow 应用到你的实际工作中了。</p><p>OK，让我们正式开始吧！</p><h2 id="5-0-版本：Callback-转-Flow"><a href="#5-0-版本：Callback-转-Flow" class="headerlink" title="5.0 版本：Callback 转 Flow"></a>5.0 版本：Callback 转 Flow</h2><p>在上次的实战课当中，我们在 3.0 版本里，实现了 KtHttp 的异步 Callback 请求。之后在 4.0 版本里，我们并没有改动 KtHttp 的源代码，而是直接在 KtCall 的基础上扩展了<strong>挂起函数</strong>的支持。让我们重新回顾一下之前的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展函数</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T =</span><br><span class="line"><span class="comment">//      暴露挂起函数的continuation</span></span><br><span class="line"><span class="comment">//              ↓</span></span><br><span class="line">    suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class="line">        <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Request success!&quot;</span>)</span><br><span class="line">                continuation.resume(<span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Request fail!：<span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">                continuation.resumeWithException(throwable)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//          响应取消事件</span></span><br><span class="line"><span class="comment">//              ↓</span></span><br><span class="line">        continuation.invokeOnCancellation &#123;</span><br><span class="line">            println(<span class="string">&quot;Call cancelled!&quot;</span>)</span><br><span class="line">            call.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们知道，上面这种做法非常适合针对第三方 SDK 的扩展，而这一切，都要归功于 Kotlin 的<strong>扩展函数</strong>特性。那么这节课里，我们希望 KtHttp 支持 Flow，其实也同样可以借助扩展函数来实现。Kotlin 官方提供了一个 API：<strong>callbackFlow</strong>，它就是专门用于将 Callback 转为 Flow 的。</p><p>Callback 转 Flow，用法跟 Callback 转挂起函数是差不多的。如果你去分析代码段 1 当中的代码模式，会发现 Callback 转挂起函数，主要有三个步骤。</p><ul><li>第一步：使用 suspendCancellableCoroutine 执行 Callback 代码，等待 Callback 回调；</li><li>第二步：将 Callback 回调结果传出去，onSuccess 的情况就传结果，onFail 的情况就传异常；</li><li>第三步：响应协程取消事件 invokeOnCancellation{}。</li></ul><p>所以使用 callbackFlow，也是这样三个步骤。如果你看过 Google 官方写的文档，你可能会写出这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">asFlow</span><span class="params">()</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line">    <span class="comment">// 调用Callback</span></span><br><span class="line">    <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 1，传递成功数据，报错！</span></span><br><span class="line">            offer(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 2，传递失败数据</span></span><br><span class="line">            close(throwable)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3，响应协程取消</span></span><br><span class="line">    awaitClose &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码里，callbackFlow 的使用步骤也是分了三步。不过，由于 Google 官方写的文档已经有些过时了，如果你按照文档来写，会发现注释 1 处的代码其实会报错，IDE 会提示应该使用 trySend() 替代 offer()。</p><p>所以我们要再来改一改：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">asFlow</span><span class="params">()</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line">    <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            trySend(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            close(throwable)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    awaitClose &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么从上面的代码中，你会发现，callbackFlow 的底层用到了 Channel，所以你才可以使用 trySend() 这样的 API。这个 API 我在第 19 讲里提到过，它其实就是 Channel.send() 的<strong>非挂起函数</strong>版本的 API。这样改完以后，我们的代码就已经没有明显报错了。</p><p>但，它仍然还有优化空间，对应的地方我已经用注释标记出来了。</p><p>我们来看一下注释 1，这里使用 trySend()，虽然在这个案例当中用这个 API 确实没问题，但在大部分场景下，它其实是不够稳妥的。你可以查看一下它的源码文档，会看到它的返回值类型是 <strong>ChannelResult</strong>，代表 trySend() 的执行结果是成功还是失败。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">trySend</span><span class="params">(element: <span class="type">E</span>)</span></span>: ChannelResult&lt;<span class="built_in">Unit</span>&gt;</span><br></pre></td></tr></table></figure><p>也就是说，如果我们往 Channel 当中成功地添加了元素，那么 trySend() 的返回值就是成功，如果当前的 Channel 管道已经满了，那么 trySend() 的返回值就是失败。</p><p>其实，当 Channel 管道容量已满的时候，我们更希望 trySend() 可以多等等，直到管道容量空闲以后再返回成功。所以这时候，我们可以使用 <strong>trySendBlocking()</strong> 来替代它。它是 Kotlin 协程 1.5 出现的一个新的 API。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">asFlow</span><span class="params">()</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line">    <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 1，变化在这里</span></span><br><span class="line">            trySendBlocking(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            close(throwable)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    awaitClose &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，这里我们仅仅只是改为 trySendBlocking() 仍然还不够，让我们来运行一下程序，看看问题出在哪里：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiServiceV5</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: KtCall&lt;RepoList&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    testFlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow</span><span class="params">()</span></span> =</span><br><span class="line">    KtHttpV5.create(ApiServiceV5::<span class="keyword">class</span>.java)</span><br><span class="line">        .repos(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">        .asFlow()</span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;Catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出正常</span></span><br><span class="line"><span class="comment">程序不会终止</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>其实，问题的原因也很简单，由于 callbackFlow 的底层是 Channel 实现的，在我们用完它以后，应该主动将其关闭或者释放。不然的话，它就会一直<strong>占用计算机资源</strong>。所以这时候，我们可以进一步完善 trySendBlocking() 这部分的代码。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">asFlow</span><span class="params">()</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line">    <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 1，变化在这里</span></span><br><span class="line">            trySendBlocking(<span class="keyword">data</span>)</span><br><span class="line">                .onSuccess &#123; close() &#125;</span><br><span class="line">                .onFailure &#123; close(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            close(throwable)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    awaitClose &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">输出正常</span></span><br><span class="line"><span class="comment">程序等待一会后自动终止</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上面代码中的 onSuccess、onFailure 其实就相当于回调，在这里，不管是成功还是失败，我们都主动把 callbackFlow 当中的 Channel 关闭。这样一来，程序就可以正常终止了。</p><p><code>提示：在大部分场景下 trySendBlocking() 会比 trySend() 更稳妥一些，因为它会尽可能发送成功。但在某些特殊情况下，trySend() 也有它的优势，因为它不会出现阻塞问题。</code></p><p>好，现在，5.0 版本的代码其实就已经算是合格了。不过，我还想给你介绍下 callbackFlow 的一些使用细节：**close() 与 close(throwable)**。</p><p>close() 这个方法，我们既可以传入异常，也可以不传入。不过，这两者在 callbackFlow 当中是有差异的。如果你将代码段 7 当中所有的 close(throwable) 都改为不传异常的话，程序代码也会出现问题。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"><span class="comment">// 错误示范！错误示范！错误示范！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    testFlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow</span><span class="params">()</span></span> =</span><br><span class="line">    KtHttpV5.create(ApiServiceV5::<span class="keyword">class</span>.java)</span><br><span class="line">        .repos(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">        .asFlow()</span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;Catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">asFlow</span><span class="params">()</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line">    <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            trySendBlocking(<span class="keyword">data</span>)</span><br><span class="line">                .onSuccess &#123; close() &#125;</span><br><span class="line">                .onFailure &#123;</span><br><span class="line">                    <span class="comment">// 变化在这里</span></span><br><span class="line">                    close()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 变化在这里</span></span><br><span class="line">            close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    awaitClose &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">断网执行以上代码：</span></span><br><span class="line"><span class="comment">不会有任何结果，连异常信息都没有</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在以上代码中，我们断网执行了这段程序，但在控制台上看不到任何异常的输出信息。这就是因为，我们调用 close() 的时候没有传入异常信息。</p><p>所以，在 callbackFlow 当中的异常分支里，我们如果使用 close()，一定要<strong>带上对应的异常</strong>，就像代码段 7 的那样“close(throwable)”。或者，为了防止在开发的过程中忘记传入异常信息，我们可以使用 <strong>cancel() 方法</strong>。就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">asFlow</span><span class="params">()</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line">    <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            trySendBlocking(<span class="keyword">data</span>)</span><br><span class="line">                .onSuccess &#123; close() &#125;</span><br><span class="line">                .onFailure &#123;</span><br><span class="line">                    <span class="comment">// 变化在这里</span></span><br><span class="line">                    cancel(CancellationException(<span class="string">&quot;Send channel fail!&quot;</span>, it))</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 变化在这里</span></span><br><span class="line">            cancel(CancellationException(<span class="string">&quot;Request fail!&quot;</span>, throwable))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    awaitClose &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">断网执行</span></span><br><span class="line"><span class="comment">Catch: java.util.concurrent.CancellationException: Request fail!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>根据这里的运行结果，我们可以看到，把 close() 改成 cancel() 以后，程序运行结果也符合预期。而 cancel 其实还有一个优势：就算不小心忘记传 throwable，我们还是可以看到一个 CancellationException。</p><p>不过总的来说，只要我们可以记住传入异常信息，close() 和 cancel() 两者的差别并不大。</p><p>另外还有一点，如果我们在 callbackFlow 当中还启动了其他的协程任务，close() 和 cancel() 也同样可以取消对应的协程。如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    testFlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow</span><span class="params">()</span></span> =</span><br><span class="line">    KtHttpV5.create(ApiServiceV5::<span class="keyword">class</span>.java)</span><br><span class="line">        .repos(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">        .asFlow() <span class="comment">// 注意这里</span></span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;Catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">asFlow</span><span class="params">()</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        println(<span class="string">&quot;Coroutine start&quot;</span>)</span><br><span class="line">        delay(<span class="number">3000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Coroutine end&quot;</span>) <span class="comment">// 没有机会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    job.invokeOnCompletion &#123;</span><br><span class="line">        println(<span class="string">&quot;Coroutine completed <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            trySendBlocking(<span class="keyword">data</span>)</span><br><span class="line">                .onSuccess &#123; close() &#125;</span><br><span class="line">                .onFailure &#123;</span><br><span class="line">                    cancel(CancellationException(<span class="string">&quot;Send channel fail!&quot;</span>, it))</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            cancel(CancellationException(<span class="string">&quot;Request fail!&quot;</span>, throwable))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    awaitClose &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">断网执行</span></span><br><span class="line"><span class="comment">Coroutine start</span></span><br><span class="line"><span class="comment">Coroutine completed java.util.concurrent.CancellationException: Request fail!</span></span><br><span class="line"><span class="comment">Catch: java.util.concurrent.CancellationException: Request fail!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，由于协程是结构化的，所以，当我们取消 callbackFlow 的时候，在它内部创建的协程 job，也会跟着被取消。而且，它的异常信息也是一样的。</p><p>不过，如果我们把上面的 launch{} 改成了“launch(Job()){}”，那么，协程任务就不会跟随 callbackFlow 一起被取消了。我相信，如果你还记得上节课讲的第二条准则，那你一定可以轻松理解这句话。因为，它们的协程的父子关系已经被破坏了！</p><p>最后，我还想再提一下 awaitClose{} 这个挂起函数，它的作用其实就是监听 callbackFlow 的生命周期，当它被关闭或者取消的时候，我们应该同时把 OkHttp 当中的网络请求也取消掉。它的作用，跟代码段 1 当中的 continuation.invokeOnCancellation{} 是类似的。</p><p>好，callbackFlow 的用法我们就讲解完了，有了它，以后我们就可以轻松地把第三方 SDK 的 Callback 扩展成 Flow 了。</p><p>那么接下来，我们就进入 6.0 版本的开发吧！</p><h2 id="6-0-版本：直接支持-Flow"><a href="#6-0-版本：直接支持-Flow" class="headerlink" title="6.0 版本：直接支持 Flow"></a>6.0 版本：直接支持 Flow</h2><p>实际上，对于 KtHttp 来说，4.0 版本、5.0 版本都只是外部扩展，我们对 KtHttp 的内部源代码并没有做改动。</p><p>而对于 6.0 版本的开发，我们其实是希望 KtHttp 可以直接支持返回 Flow 类型的数据，也就是这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiServiceV5</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: KtCall&lt;RepoList&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reposFlow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Flow&lt;RepoList&gt; <span class="comment">// 注意这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请你留意上面的代码注释，在 ApiServiceV5 当中，我定义了一个接口方法 reposFlow()，它的返回值类型是 Flow，而不是之前的 KtCall。这样一来，我们在 main() 函数当中使用它的时候，就不需要使用 asFlow() 这个扩展函数了。就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow</span><span class="params">()</span></span> =</span><br><span class="line">    KtHttpV5.create(ApiServiceV5::<span class="keyword">class</span>.java)</span><br><span class="line">        .reposFlow(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">        <span class="comment">// 注意这里不需要asFlow，因为reposFlow()返回值类型就是Flow</span></span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;Catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    testFlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们把 reposFlow() 的返回值类型定义成 Flow 以后，就需要改动 KtHttp 的源代码了。因为，它的内部需要根据这种情况做一些特殊的判断。</p><p>其实，在前面 3.0 版本的开发中，我们就已经做过一次判断了。当时，我们特地判断了一下，返回值类型是 KtCall 还是T。让我们来重新回顾一下当时的代码细节：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (isKtCallReturn(method)) &#123;</span><br><span class="line">        <span class="comment">// 返回值类型是KtCall&lt;RepoList&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">        KtCall&lt;T&gt;(call, gson, genericReturnType)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值类型是 RepoList</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line">        <span class="keyword">val</span> genericReturnType = method.genericReturnType</span><br><span class="line">        <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">        gson.fromJson&lt;Any?&gt;(json, genericReturnType)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到上面的代码，相信你马上就能想明白了，如果要支持 Flow，我们只需要在这里判断一下，返回值类型是不是 Flow 即可。比如说：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">            KtCall&lt;T&gt;(call, gson, genericReturnType)</span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 直接返回Flow</span></span><br><span class="line">            flow&lt;T&gt; &#123;</span><br><span class="line">                <span class="comment">// 请求API</span></span><br><span class="line">                <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">                <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line">                <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">                <span class="keyword">val</span> result = gson.fromJson&lt;T&gt;(json, genericReturnType)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 传出结果</span></span><br><span class="line">                emit(result)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> genericReturnType = method.genericReturnType</span><br><span class="line">            <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">            gson.fromJson&lt;Any?&gt;(json, genericReturnType)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断返回值类型是不是 Flow&lt;T&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isFlowReturn</span><span class="params">(method: <span class="type">Method</span>)</span></span> =</span><br><span class="line">        getRawType(method.genericReturnType) == Flow::<span class="keyword">class</span>.java</span><br></pre></td></tr></table></figure><p>由于代码段 13 当中已经有了 if、else 两个条件分支了，再增加一个分支的话，我们选择了 when 表达式。这里，我们增加了一个 isFlowReturn(method) 的分支，意思就是判断返回值类型是不是 Flow，如果是的话，我们就直接使用 flow{} 创建一个 Flow 返回了。</p><p>至此，我们 6.0 版本的开发工作，其实就已经完成了。是不是觉得非常轻松？<strong>对比起 Callback 转 Flow，让 KtHttp 直接支持 Flow 确实要简单很多</strong>。从这一点上，我们也可以看到 Flow 的强大和易用性。</p><p>那么在这时候，我们就可以写一些简单的测试代码，来验证我们的代码是否可靠了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">            KtCall&lt;T&gt;(call, gson, genericReturnType)</span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 增加日志</span></span><br><span class="line">            logX(<span class="string">&quot;Start out&quot;</span>)</span><br><span class="line">            flow&lt;T&gt; &#123;</span><br><span class="line">                logX(<span class="string">&quot;Start in&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">                <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line">                <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">                <span class="keyword">val</span> result = gson.fromJson&lt;T&gt;(json, genericReturnType)</span><br><span class="line">                logX(<span class="string">&quot;Start emit&quot;</span>)</span><br><span class="line">                emit(result)</span><br><span class="line">                logX(<span class="string">&quot;End emit&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> genericReturnType = method.genericReturnType</span><br><span class="line">            <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">            gson.fromJson&lt;Any?&gt;(json, genericReturnType)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow</span><span class="params">()</span></span> =</span><br><span class="line">    KtHttpV5.create(ApiServiceV5::<span class="keyword">class</span>.java)</span><br><span class="line">        .reposFlow(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">        .flowOn(Dispatchers.IO) <span class="comment">//切换线程</span></span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;Catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            logX(<span class="string">&quot;<span class="subst">$&#123;it.count&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start out</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start in</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start emit</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">End emit</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">25</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们增加了一些日志，同时在调用处增加了“flowOn(Dispatchers.IO)”。可以看到，这样一来整个网络请求就执行在了 DefaultDispatcher 这个线程池当中，而其他部分的代码，仍然执行在 main() 线程。这也是符合预期的。</p><p>然后，我们可以通过断网来模拟出现异常的情况：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start out</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start in</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Catch: java.net.UnknownHostException:  nodename nor servname provided, or not known</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，程序的运行结果仍然是符合预期的。</p><p>下面，我们再来看看 6.0 完整的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiServiceV5</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: KtCall&lt;RepoList&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注释1</span></span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reposFlow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Flow&lt;RepoList&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> KtHttpV5 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> okHttpClient: OkHttpClient = OkHttpClient()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> gson: Gson = Gson()</span><br><span class="line">    <span class="keyword">var</span> baseUrl = <span class="string">&quot;https://baseUrl.com&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">create</span><span class="params">(service: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            service.classLoader,</span><br><span class="line">            arrayOf&lt;Class&lt;*&gt;&gt;(service)</span><br><span class="line">        ) &#123; proxy, method, args -&gt;</span><br><span class="line">            <span class="keyword">val</span> annotations = method.annotations</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">annotation</span> <span class="keyword">in</span> annotations) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">annotation</span> <span class="keyword">is</span> GET) &#123;</span><br><span class="line">                    <span class="keyword">val</span> url = baseUrl + <span class="keyword">annotation</span>.value</span><br><span class="line">                    <span class="keyword">return</span><span class="symbol">@newProxyInstance</span> invoke&lt;T&gt;(url, method, args!!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@newProxyInstance</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.parameterAnnotations.size != args.size) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> url = path</span><br><span class="line">        <span class="keyword">val</span> parameterAnnotations = method.parameterAnnotations</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> parameterAnnotations.indices) &#123;</span><br><span class="line">            <span class="keyword">for</span> (parameterAnnotation <span class="keyword">in</span> parameterAnnotations[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parameterAnnotation <span class="keyword">is</span> Field) &#123;</span><br><span class="line">                    <span class="keyword">val</span> key = parameterAnnotation.value</span><br><span class="line">                    <span class="keyword">val</span> value = args[i].toString()</span><br><span class="line">                    <span class="keyword">if</span> (!url.contains(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">                        url += <span class="string">&quot;?<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        url += <span class="string">&quot;&amp;<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">            .url(url)</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> call = okHttpClient.newCall(request)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">            isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">                KtCall&lt;T&gt;(call, gson, genericReturnType)</span><br><span class="line">            &#125;</span><br><span class="line">            isFlowReturn(method) -&gt; &#123;</span><br><span class="line">                logX(<span class="string">&quot;Start out&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注释2</span></span><br><span class="line">                flow&lt;T&gt; &#123;</span><br><span class="line">                    logX(<span class="string">&quot;Start in&quot;</span>)</span><br><span class="line">                    <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">                    <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line">                    <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">                    <span class="keyword">val</span> result = gson.fromJson&lt;T&gt;(json, genericReturnType)</span><br><span class="line">                    logX(<span class="string">&quot;Start emit&quot;</span>)</span><br><span class="line">                    emit(result)</span><br><span class="line">                    logX(<span class="string">&quot;End emit&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> genericReturnType = method.genericReturnType</span><br><span class="line">                <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">                gson.fromJson&lt;Any?&gt;(json, genericReturnType)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getTypeArgument</span><span class="params">(method: <span class="type">Method</span>)</span></span> =</span><br><span class="line">        (method.genericReturnType <span class="keyword">as</span> ParameterizedType).actualTypeArguments[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isKtCallReturn</span><span class="params">(method: <span class="type">Method</span>)</span></span> =</span><br><span class="line">        getRawType(method.genericReturnType) == KtCall::<span class="keyword">class</span>.java</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isFlowReturn</span><span class="params">(method: <span class="type">Method</span>)</span></span> =</span><br><span class="line">        getRawType(method.genericReturnType) == Flow::<span class="keyword">class</span>.java</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    testFlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow</span><span class="params">()</span></span> =</span><br><span class="line">    KtHttpV5.create(ApiServiceV5::<span class="keyword">class</span>.java)</span><br><span class="line">        .reposFlow(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">        .flowOn(Dispatchers.IO)</span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;Catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            logX(<span class="string">&quot;<span class="subst">$&#123;it.count&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>最后，我们也再来分析一下，为什么 6.0 的代码可以这么简单。这里有两个关键的地方，我也分别用注释标记了。</p><p>请你留意注释 1 处的 <strong>reposFlow()</strong> 方法的定义，它其实是一个普通的函数，并不是挂起函数。换言之，虽然它的返回值类型是 Flow，但我们并不要求它在协程当中被调用。</p><p>另外，请留意注释 2 处<strong>，flow{}</strong> 这个高阶函数，它也只是一个普通函数，同样也不是挂起函数，这就意味着，它可以在普通函数里面直接调用。我们可以看看 flow{} 的定义：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是挂起函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">flow</span><span class="params">(<span class="meta">@BuilderInference</span> block: <span class="type">suspend</span> <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span>)</span></span>: Flow&lt;T&gt; = SafeFlow(block)</span><br></pre></td></tr></table></figure><p>所以，正因为以上这两点，就使得 Flow 的易用性非常高，还记得我们在第 20 讲当中看过的那张 Flow“上游、下游”的示意图吗？我们其实可以进一步完善它：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/37/20/370553ac768913a0702fda89a85b8120.jpg?wh=2000x1125" alt="img"></p><p>也就是说，对于 Flow 的<strong>上游、中间操作符</strong>而言，它们其实根本就不需要协程作用域，只有在下游调用 collect{} 的时候，才需要协程作用域。</p><p>因此，我们前面在写 main() 函数的时候，也可以换成这样的写法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段19</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 协程作用域外</span></span><br><span class="line">    <span class="keyword">val</span> flow = KtHttpV5.create(ApiServiceV5::<span class="keyword">class</span>.java)</span><br><span class="line">        .reposFlow(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">        .flowOn(Dispatchers.IO)</span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;Catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="comment">// 协程作用域内</span></span><br><span class="line">        flow.collect &#123;</span><br><span class="line">            logX(<span class="string">&quot;<span class="subst">$&#123;it.count&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，正因为 Flow 的上游不需要协程作用域，我们才可以轻松完成 6.0 版本的代码。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节实战课，为了让 KtHttp 支持 Flow API，我们使用了两种方法。第一种，是从 KtHttp 的外部进行扩展，用这种思路，我们完成了 5.0 版本的开发；第二种，是修改 KtHttp 的内部，让 ApiService 当中的方法可以直接以 Flow 作为返回值类型，利用这种思路，我们完成了 6.0 的开发。</p><p>具体来说，我们是用到了这几个知识点，你可以重点关注一下：</p><ul><li>**callbackFlow{}**，它的作用就是把 Callback 转换成 Flow。它的底层其实用到了 Channel，因此，我们可以在 callbackFlow{} 当中调用 trySend()、trySendBlocking()，这两个方法都是 Channel 当中的“非挂起函数”的方法。需要注意的是，这里我们不能直接使用 Channel 的挂起函数 send()，因为它必须要在协程体当中执行。</li><li>在 callbackFlow{} 里，出现异常的逻辑分支当中，如果我们需要关闭 callbackFlow，那么在调用 close() 的时候，一定要传入对应的异常参数 **close(throwable)**。不然的话，Flow 的下游就无法收到任何的异常信息。</li><li>在 callbackFlow{} 当中创建的<strong>协程任务</strong>，也可以跟随 callbackFlow 一同被取消，只要我们不打破它原有的协程父子关系。</li><li>由于 <strong>Flow 的上游、中间操作符</strong>不需要协程作用域，因此，我们可以在非协程当中执行创建 Flow。这就导致我们 6.0 版本的代码轻松就可以实现。</li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>在 5.0 版本的代码中，awaitClose{} 的作用是响应协程的取消，同时取消 OkHttp 的请求。其实，它除了这个作用以外，还有另外一个作用。</p><p>你可以把 5.0 版本代码中的 awaitClose 删掉，看看会发生什么。对于这样的现象，你能想到 awaitClose{} 的另一个作用吗？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段20</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">asFlow</span><span class="params">()</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line">    <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            trySendBlocking(<span class="keyword">data</span>)</span><br><span class="line">                .onSuccess &#123; close() &#125;</span><br><span class="line">                .onFailure &#123;</span><br><span class="line">                    cancel(CancellationException(<span class="string">&quot;Send channel fail!&quot;</span>, it))</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            cancel(CancellationException(<span class="string">&quot;Request fail!&quot;</span>, throwable))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    <span class="comment">// awaitClose &#123;</span></span><br><span class="line">    <span class="comment">//     call.cancel()</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(协程篇)23  异常：try-catch 坑！</title>
      <link href="/posts/a3460e51/"/>
      <url>/posts/a3460e51/</url>
      
        <content type="html"><![CDATA[<p>这节课我们来学习 Kotlin 协程的异常处理。</p><p>其实到这里，我们就已经学完所有 Kotlin 协程的语法知识了。但在真正把 Kotlin 协程应用到生产环境之前，我们还需要掌握一个重要知识点，那就是异常处理。</p><p>比起 Kotlin 协程的语法知识点，协程的异常处理，其实更难掌握。在前面的课程中，我们已经了解到：<strong>协程就是互相协作的程序，协程是结构化的</strong>。正因为 Kotlin 协程有这两个特点，这就导致它的异常处理机制与我们普通的程序完全不一样。</p><p>换句话说：<strong>如果把 Java 里的那一套异常处理机制，照搬到 Kotlin 协程里来，你一定会四处碰壁</strong>。因为在普通的程序当中，你使用 try-catch 就能解决大部分的异常处理问题，但是在协程当中，根据不同的协程特性，它的异常处理策略是随之变化的。</p><p>我自己在工作中就踩过很多这方面的坑，遇到过各种匪夷所思的问题：协程无法取消、try-catch 不起作用导致线上崩溃率突然大增、软件功能错乱却追踪不到任何异常信息，等等。说实话，Kotlin 协程的普及率之所以不高，很大一部分原因也是因为它的异常处理机制太复杂了，稍有不慎就可能会掉坑里去。</p><p>那么今天这节课，我们就会来分析几个常见的协程代码模式，通过解决这些异常，我们可以总结出协程异常处理的 6 大准则。掌握了这些准则之后，你在以后遇到异常问题时，就能有所准备，也知道该怎么处理了。</p><h2 id="为什么-cancel-不起作用？"><a href="#为什么-cancel-不起作用？" class="headerlink" title="为什么 cancel() 不起作用？"></a>为什么 cancel() 不起作用？</h2><p>在 Kotlin 协程当中，我们通常把异常分为两大类，一类是<strong>取消异常</strong>（CancellationException），另一类是<strong>其他异常</strong>。之所以要这么分类，是因为在 Kotlin 协程当中，这两种异常的处理方式是不一样的。或者说，在 Kotlin 协程所有的异常当中，我们需要把 CancellationException 单独拎出来，特殊对待。</p><p>要知道，当协程任务被取消的时候，它的内部是会产生一个 CancellationException 的。而协程的结构化并发，最大的优势就在于：如果我们取消了父协程，子协程也会跟着被取消。但是我们也知道，很多初学者都会遇到一个问题，那就是协程无法被取消。</p><p>这里，主要涉及了三个场景，我们一个个来分析下。</p><h3 id="场景-1：cancel-不被响应"><a href="#场景-1：cancel-不被响应" class="headerlink" title="场景 1：cancel() 不被响应"></a>场景 1：cancel() 不被响应</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">            i ++</span><br><span class="line">            println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    job.cancel()</span><br><span class="line">    job.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">i = 1</span></span><br><span class="line"><span class="comment">i = 2</span></span><br><span class="line"><span class="comment">i = 3</span></span><br><span class="line"><span class="comment">i = 4</span></span><br><span class="line"><span class="comment">i = 5</span></span><br><span class="line"><span class="comment">// 永远停不下来</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们启动了一个协程，在这个协程的内部，我们一直对 i 进行自增。过了 2000 毫秒以后，我们调用了 job.cancel()。但通过运行的结果，我们可以看到协程并不会被取消。这是为什么呢？</p><p>其实前面课程里我们就讲过，协程是互相协作的程序。因此，对于协程任务的取消，也是需要互相协作的。协程外部取消，协程内部需要做出响应才行。具体来说，我们可以在协程体中加入状态判断：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 变化在这里</span></span><br><span class="line">        <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">            i ++</span><br><span class="line">            println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    job.cancel()</span><br><span class="line">    job.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">i = 1</span></span><br><span class="line"><span class="comment">i = 2</span></span><br><span class="line"><span class="comment">i = 3</span></span><br><span class="line"><span class="comment">i = 4</span></span><br><span class="line"><span class="comment">i = 5</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在这段代码里，我们把 while 循环的条件改成了 while (isActive)，这就意味着，只有协程处于活跃状态的时候，才会继续执行循环体内部的代码。</p><p>这里，我们就可以进一步分析代码段 1 无法取消的原因了：当我们调用 job.cancel() 以后，协程任务已经不是活跃状态了，但代码并没有把 isActive 作为循环条件，因此协程无法真正取消。</p><p>所以到这里，我们就可以总结出协程异常处理的第一准则了：<strong>协程的取消需要内部的配合</strong>。</p><h3 id="场景-2：结构被破坏"><a href="#场景-2：结构被破坏" class="headerlink" title="场景 2：结构被破坏"></a>场景 2：结构被破坏</h3><p>我们都知道，协程是结构化的，当我们取消父协程的时候，子协程也会跟着被取消。比如，我们在第 16 讲当中，就看到过这张图：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/9b/02/9bf8c808c91040e25fc62e468b7dfc02.gif?wh=1080x608" alt="img" style="zoom:50%;" /><p>但在某些情况下，我们嵌套创建的子协程并不会跟随父协程一起取消，比如下面这个案例：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> fixedDispatcher = Executors.newFixedThreadPool(<span class="number">2</span>) &#123;</span><br><span class="line">    Thread(it, <span class="string">&quot;MyFixedThread&quot;</span>).apply &#123; isDaemon = <span class="literal">false</span> &#125;</span><br><span class="line">&#125;.asCoroutineDispatcher()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 父协程</span></span><br><span class="line">    <span class="keyword">val</span> parentJob = launch(fixedDispatcher) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1，注意这里</span></span><br><span class="line">        launch(Job()) &#123; <span class="comment">// 子协程1</span></span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;First i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch &#123; <span class="comment">// 子协程2</span></span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;Second i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    parentJob.cancel()</span><br><span class="line">    parentJob.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">First i = 1</span></span><br><span class="line"><span class="comment">Second i = 1</span></span><br><span class="line"><span class="comment">First i = 2</span></span><br><span class="line"><span class="comment">Second i = 2</span></span><br><span class="line"><span class="comment">Second i = 3</span></span><br><span class="line"><span class="comment">First i = 3</span></span><br><span class="line"><span class="comment">First i = 4</span></span><br><span class="line"><span class="comment">Second i = 4</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">First i = 5</span></span><br><span class="line"><span class="comment">First i = 6</span></span><br><span class="line"><span class="comment">// 子协程1永远不会停下来</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上代码中，我们创建了一个 fixedDispatcher，它是由两个线程的线程池实现的。接着，我们通过 launch 创建了三个协程，其中 parentJob 是父协程，随后我们等待 2000 毫秒，然后取消父协程。</p><p>不过，通过程序的运行结果，我们发现，虽然“子协程 1”当中使用了 while(isActive) 作为判断条件，它也仍然无法被取消。其实，这里的主要原因还是在注释 1 处，我们在创建子协程的时候，**使用了 launch(Job()){}**。而这种创建方式，就打破了原有的协程结构。</p><p>为了方便你理解，我画了一张图，描述它们之间的父子关系。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/19/c2/191c4ffcf783a14a4aef9ca934dffec2.jpg?wh=2000x983" alt="img" style="zoom: 33%;" /><p>根据这张图，可以看到“子协程 1”已经不是 parentJob 的子协程了，而对应的，它的父 Job 是我们在 launch 当中传入的 Job() 对象。所以，在这种情况下，当我们调用 parentJob.cancel() 的时候，自然也就无法取消“子协程 1”了。</p><p>其实这个时候，如果我们稍微改动一下上面的代码，不传入 Job()，程序就可以正常运行了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> parentJob = launch(fixedDispatcher) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变化在这里</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;First i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;Second i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    parentJob.cancel()</span><br><span class="line">    parentJob.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">First i = 1</span></span><br><span class="line"><span class="comment">Second i = 1</span></span><br><span class="line"><span class="comment">First i = 2</span></span><br><span class="line"><span class="comment">Second i = 2</span></span><br><span class="line"><span class="comment">First i = 3</span></span><br><span class="line"><span class="comment">Second i = 3</span></span><br><span class="line"><span class="comment">First i = 4</span></span><br><span class="line"><span class="comment">Second i = 4</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，parentJob 与它内部的子协程 1、子协程 2 之间是父子关系，因此它们两个都是会响应协程取消的事件的。这时候，它们之间的关系就变成了下图这样：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/fb/7d/fb2bf0b6f4307dcb9b678557cb1f027d.jpg?wh=2000x856" alt="img" style="zoom:33%;" /><p>那么到这里，我们其实就可以总结出第二条准则了：<strong>不要轻易打破协程的父子结构！</strong></p><h3 id="场景-3：未正确处理-CancellationException"><a href="#场景-3：未正确处理-CancellationException" class="headerlink" title="场景 3：未正确处理 CancellationException"></a>场景 3：未正确处理 CancellationException</h3><p>其实，对于 Kotlin 提供的挂起函数，它们是可以自动响应协程的取消的，比如说，当我们把 Thread.sleep(500) 改为 delay(500) 以后，我们就不需要在 while 循环当中判断 isActive 了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> parentJob = launch(Dispatchers.Default) &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 变化在这里</span></span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;First i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 变化在这里</span></span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;Second i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    parentJob.cancel()</span><br><span class="line">    parentJob.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">First i = 1</span></span><br><span class="line"><span class="comment">Second i = 1</span></span><br><span class="line"><span class="comment">First i = 2</span></span><br><span class="line"><span class="comment">Second i = 2</span></span><br><span class="line"><span class="comment">First i = 3</span></span><br><span class="line"><span class="comment">Second i = 3</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>实际上，对于 delay() 函数来说，它可以自动检测当前的协程是否已经被取消，如果已经被取消的话，它会抛出一个 CancellationException，从而终止当前的协程。</p><p>为了证明这一点，我们可以在以上代码的基础上，增加一个 try-catch。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> parentJob = launch(Dispatchers.Default) &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 1</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    delay(<span class="number">500L</span>)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: CancellationException) &#123;</span><br><span class="line">                    println(<span class="string">&quot;Catch CancellationException&quot;</span>)</span><br><span class="line">                    <span class="comment">// 2</span></span><br><span class="line">                    <span class="keyword">throw</span> e</span><br><span class="line">                &#125;</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;First i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;Second i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    parentJob.cancel()</span><br><span class="line">    parentJob.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">First i = 1</span></span><br><span class="line"><span class="comment">Second i = 1</span></span><br><span class="line"><span class="comment">First i = 2</span></span><br><span class="line"><span class="comment">Second i = 2</span></span><br><span class="line"><span class="comment">First i = 3</span></span><br><span class="line"><span class="comment">Second i = 3</span></span><br><span class="line"><span class="comment">Second i = 4</span></span><br><span class="line"><span class="comment">Catch CancellationException</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>请看注释 1，在用 try-catch 包裹了 delay() 以后，我们就可以在输出结果中，看到“Catch CancellationException”，这就说明 delay() 确实可以自动响应协程的取消，并且产生 CancellationException 异常。</p><p>请看注释 1，在用 try-catch 包裹了 delay() 以后，我们就可以在输出结果中，看到“Catch CancellationException”，这就说明 delay() 确实可以自动响应协程的取消，并且产生 CancellationException 异常。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> parentJob = launch(Dispatchers.Default) &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    delay(<span class="number">500L</span>)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: CancellationException) &#123;</span><br><span class="line">                    println(<span class="string">&quot;Catch CancellationException&quot;</span>)</span><br><span class="line">                    <span class="comment">// 1，注意这里</span></span><br><span class="line">                    <span class="comment">// throw e</span></span><br><span class="line">                &#125;</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;First i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;Second i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    parentJob.cancel()</span><br><span class="line">    parentJob.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">First i = 1</span></span><br><span class="line"><span class="comment">Second i = 1</span></span><br><span class="line"><span class="comment">First i = 2</span></span><br><span class="line"><span class="comment">Second i = 2</span></span><br><span class="line"><span class="comment">First i = 3</span></span><br><span class="line"><span class="comment">Second i = 3</span></span><br><span class="line"><span class="comment">Second i = 4</span></span><br><span class="line"><span class="comment">..</span></span><br><span class="line"><span class="comment">First i = 342825</span></span><br><span class="line"><span class="comment">Catch CancellationException</span></span><br><span class="line"><span class="comment">// 程序将永远无法终止</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可见，在这段代码中，我们把“throw e”这行代码注释掉，重新运行之后，程序就永远无法终止了。这主要是因为，我们捕获了 CancellationException 以后没有重新抛出去，就导致子协程无法正常取消。所以到这里，</p><p>我们就可以总结出第三条准则了：<strong>捕获了 CancellationException 以后，要考虑是否应该重新抛出来</strong>。</p><p><code>题外话：很多开发者喜欢在代码里捕获 Exception 这个父类，比如这样：catch(e: Exception)&#123;&#125;，这也是很危险的。平时写 Demo 为了方便这样写没问题，但在生产环境则应该禁止。</code></p><p>好，到这里，我们就通过协程取消异常的三个场景，总结了三条准则，来应对 CancellationException 这个特殊的异常。</p><p>那么接下来，我们再来看看如何在协程当中处理普通的异常。</p><h2 id="为什么-try-catch-不起作用？"><a href="#为什么-try-catch-不起作用？" class="headerlink" title="为什么 try-catch 不起作用？"></a>为什么 try-catch 不起作用？</h2><p>如果你有 Java 经验，那你一定会习惯性地把 try-catch 当做是解决所有异常的手段。但是，在 Kotlin 协程当中，try-catch 并非万能的。有时候，即使你用 try-catch 包裹了可能抛异常的代码，软件仍然会崩溃。比如下面这个例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">            <span class="number">1</span> / <span class="number">0</span> <span class="comment">// 故意制造异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Catch: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">崩溃</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们使用 try-catch 包裹了 launch{}，在协程体内部，我们制造了一个异常。不过从运行结果这里，我们可以看到，try-catch 并没有成功捕获异常，程序等待了 100 毫秒左右，最终还是崩溃了。</p><p>类似的，如果我们把代码段 8 当中的 launch 换成 async，结果也是差不多的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> deferred: Deferred&lt;<span class="built_in">Unit</span>&gt;? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deferred = async &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">            <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Catch: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deferred?.await()</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">崩溃</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>其实，对于这种 try-catch 失效的问题，如果你还记得在第 14 讲当中，我提到的 launch、async 的代码<strong>运行顺序</strong>的问题，那你就一定可以理解其中的原因。这主要就是因为，当协程体当中的“1&#x2F;0”执行的时候，我们的程序已经跳出 try-catch 的作用域了。</p><p>当然，要解决这两个问题也很容易。对于代码段 8 来说，我们可以挪动一下 try-catch 的位置，比如说这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> deferred: Deferred&lt;<span class="built_in">Unit</span>&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    deferred = async &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">            <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">            println(<span class="string">&quot;Catch: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deferred?.await()</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，到这里，我们就可以总结出第四条准则了：<strong>不要用 try-catch 直接包裹 launch、async</strong>。</p><p>接下来，我们再看看 async 的另外一种手段，其实这种方式网上有些博客也介绍过，我们可以使用 try-catch 包裹“deferred.await()”。让我们来看看是否可行：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = async &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deferred.await()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Catch: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Catch: java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">崩溃：</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>那么，根据以上程序的运行结果可以看到，这样做其实是行不通的。如果你看过一些其他博客，甚至还有种说法是：await() 如果不调用的话，async 当中的异常甚至不会发生。我们再来试试看：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = async &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">崩溃：</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可见，async 当中产生异常，即使我们不调用 await() 同样是会导致程序崩溃的。那么，为什么会发生这样的情况？是不是我们忽略了什么？</p><h2 id="SupervisorJob"><a href="#SupervisorJob" class="headerlink" title="SupervisorJob"></a>SupervisorJob</h2><p>实际上，如果我们要使用 try-catch 包裹“deferred.await()”的话，还需要配合 <strong>SupervisorJob</strong> 一起使用。也就是说，借助 SupervisorJob 来改造代码段 13 的话，我们就可以实现“不调用 await() 就不会产生异常而崩溃”。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(SupervisorJob())</span><br><span class="line">    scope.async &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，当我们使用 SupervisorJob 创建一个 scope 以后，用 scope.async{}启动协程后，只要不调用“deferred.await()”，程序就不会因为异常而崩溃。</p><p>所以同样的，我们也能用类似的办法来改造代码段 12 当中的逻辑：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(SupervisorJob())</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> deferred = scope.async &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deferred.await()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Catch: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Catch: java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们仍然使用“scope.async {}”创建了协程，同时也用 try-catch 包裹“deferred.await()”，这样一来，这个异常就成功地被我们捕获了。</p><p>那么，<strong>SupervisorJob 到底是何方神圣</strong>？让我们来看看它的源码定义：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">SupervisorJob</span><span class="params">(parent: <span class="type">Job</span>? = <span class="literal">null</span>)</span></span> : CompletableJob </span><br><span class="line">                    = SupervisorJobImpl(parent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompletableJob</span> : <span class="type">Job</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">complete</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">completeExceptionally</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上代码，我们可以看到，SupervisorJob() 其实不是构造函数，<strong>它只是一个普通的顶层函数</strong>。而这个方法返回的对象，是 Job 的子类。</p><p>SupervisorJob 与 Job 最大的区别就在于，当它的子 Job 发生异常的时候，其他的子 Job 不会受到牵连。我这么说你可能会有点懵，下面我做了一个动图，来演示普通 Job 与 SupervisorJob 之间的差异。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/c0/64/c0eeea3b0b8b016df76ae7b3d9620264.gif?wh=1080x608" alt="img" style="zoom: 50%;" /><p>这个是普通 Job，对于子 Job 出现异常时的应对策略。可以看到，由于 parentJob 是一个普通的 Job 对象，当 job1 发生异常之后，它会导致 parentJob 取消，进而导致 job2、job3 也受到牵连。</p><p>而这时候，如果我们把 parentJob 改为 SupervisorJob，job1 发生异常的的话，就不会影响到其他的 Job 了。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/a4/cc/a482f7082d6d87dea51ffdb856e292cc.jpg?wh=2000x864" alt="img"></p><p>所以到这里，我们就可以总结出第五条准则了：<strong>灵活使用 SupervisorJob，控制异常传播的范围</strong>。</p><p><code>提示：并非所有情况下，我们都应该使用 SupervisorJob，有时候 Job 会更合适，这要结合实际场景分析。</code></p><p>好，到目前为止，我们就已经了解了 try-catch 和 SupervisorJob 这两种处理异常的手段。但是，由于协程是结构化的，当我们的协程任务出现复杂的层级时，这两种手段其实都无法很好的应对。所以这个时候，我们就需要 CoroutineExceptionHandler 出场了。</p><h2 id="CoroutineExceptionHandler"><a href="#CoroutineExceptionHandler" class="headerlink" title="CoroutineExceptionHandler"></a>CoroutineExceptionHandler</h2><p>对于 CoroutineExceptionHandler，我们其实在第 17 讲里也简单地提到过。它是 CoroutineContext 的元素之一，我们在创建协程的时候，可以指定对应的 CoroutineExceptionHandler。</p><p>那么 CoroutineExceptionHandler 究竟适用于什么样的场景呢？让我们来看一个例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段17</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(coroutineContext)</span><br><span class="line"></span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        async &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line"></span><br><span class="line">            launch &#123;</span><br><span class="line">                delay(<span class="number">100L</span>)</span><br><span class="line">                <span class="number">1</span> / <span class="number">0</span> <span class="comment">// 故意制造异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我模拟了一个复杂的协程嵌套场景。对于这样的情况，我们其实很难一个个在每个协程体里面去写 try-catch。所以这时候，为了捕获到异常，我们就可以使用 CoroutineExceptionHandler 了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段18</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> myExceptionHandler = CoroutineExceptionHandler &#123; _, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Catch exception: <span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(coroutineContext + Job() + myExceptionHandler)</span><br><span class="line"></span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        async &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line"></span><br><span class="line">            launch &#123;</span><br><span class="line">                delay(<span class="number">100L</span>)</span><br><span class="line">                <span class="number">1</span> / <span class="number">0</span> <span class="comment">// 故意制造异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Catch exception: ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上代码中，我们定义了一个 CoroutineExceptionHandler，然后把它传入了 scope 当中，这样一来，我们就可以捕获其中所有的异常了。</p><p>看到这里，你也许松了一口气：终于有了一个简单处理协程异常的方式了。不过，你也别高兴得太早，因为我曾经就踩过 CoroutineExceptionHandler 的一个坑，最终导致 App 功能大面积异常。</p><p>而出现这个问题的原因就是：CoroutineExceptionHandler 不起作用了！</p><p><em><strong>为什么 CoroutineExceptionHandler 不起作用？</strong></em></p><p>为了模拟我当时的业务场景，我把代码段 18 稍作改动。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段19</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">val</span> myExceptionHandler = CoroutineExceptionHandler &#123; _, throwable -&gt;</span><br><span class="line">       println(<span class="string">&quot;Catch exception: <span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 不再传入myExceptionHandler</span></span><br><span class="line">   <span class="keyword">val</span> scope = CoroutineScope(coroutineContext)</span><br><span class="line">   scope.launch &#123;</span><br><span class="line">       async &#123;</span><br><span class="line">           delay(<span class="number">100L</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       launch &#123;</span><br><span class="line">           delay(<span class="number">100L</span>)</span><br><span class="line">           <span class="comment">// 变化在这里</span></span><br><span class="line">           launch(myExceptionHandler) &#123;</span><br><span class="line">               delay(<span class="number">100L</span>)</span><br><span class="line">               <span class="number">1</span> / <span class="number">0</span> </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       delay(<span class="number">100L</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   delay(<span class="number">1000L</span>)</span><br><span class="line">   println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">崩溃：</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>请你留意上面的注释，我们把自定义的 myExceptionHandler，放到出现异常的 launch 那里传了进去。按理说，程序的执行结果是不会发生变化才对的。但实际上，myExceptionHandler 并不会起作用，我们的异常不会被它捕获。</p><p>如果你对比代码段 18 和代码段 19，你会发现，myExceptionHandler 直接定义在发生异常的位置反而不生效，而定义在最顶层却可以生效！你说它的作用域是不是很古怪？</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/22/13/22fyya9f9de13c8580b4508e7eabe813.gif?wh=1080x608" alt="img"></p><p>其实，出现这种现象的原因，就是因为：CoroutineExceptionHandler 只在顶层的协程当中才会起作用。也就是说，当子协程当中出现异常以后，它们都会统一上报给顶层的父协程，然后顶层的父协程才会去调用 CoroutineExceptionHandler，来处理对应的异常。</p><p>那么到这里，我们就可以总结出第六条准则了：<strong>使用 CoroutineExceptionHandler 处理复杂结构的协程异常，它仅在顶层协程中起作用</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，这节课的内容就接近尾声了，我们来做一个简单的总结。</p><p>在 Kotlin 协程当中，异常主要分为两大类，一类是协程取消异常（CancellationException），另一类是其他异常。为了处理这两大类问题，我们一共总结出了 6 大准则，这些我们都要牢记在心。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/72/c5/72b96aa44f68fde40f626fe536eb36c5.jpg?wh=2000x763" alt="img"></p><ul><li>第一条准则：<strong>协程的取消需要内部的配合</strong>。</li><li>第二条准则：<strong>不要轻易打破协程的父子结构</strong>！这一点，其实不仅仅只是针对协程的取消异常，而是要贯穿于整个协程的使用过程中。我们知道，协程的优势在于结构化并发，它的许多特性都是建立在这个特性之上的，如果我们无意中打破了它的父子结构，就会导致协程无法按照预期执行。</li><li>第三条准则：<strong>捕获了 CancellationException 以后，要考虑是否应该重新抛出来</strong>。在协程体内部，协程是依赖于 CancellationException 来实现结构化取消的，有的时候我们出于某些目的需要捕获 CancellationException，但捕获完以后，我们还需要思考是否需要将其重新抛出来。</li><li>第四条准则：不要用 try-catch 直接包裹 launch、async。这一点是很多初学者会犯的错误，考虑到协程代码的执行顺序与普通程序不一样，我们直接使用 try-catch 包裹 launch、async，是不会有任何效果的。</li><li>第五条准则：<strong>灵活使用 SupervisorJob，控制异常传播的范围。</strong>SupervisorJob 是一种特殊的 Job，它可以控制异常的传播范围。普通的 Job，它会因为子协程当中的异常而取消自身，而 SupervisorJob 则不会受到子协程异常的影响。在很多业务场景下，我们都不希望子协程影响到父协程，所以 SupervisorJob 的应用范围也非常广。比如说 Android 当中的 viewModelScope，它就使用了 SupervisorJob，这样一来，我们的 App 就不会因为某个子协程的异常导致整个应用的功能出现紊乱。</li><li>第六条准则：<strong>使用 CoroutineExceptionHandler 处理复杂结构的协程异常，它仅在顶层协程中起作用</strong>。我们都知道，传统的 try-catch 在协程当中并不能解决所有问题，尤其是在协程嵌套层级较深的情况下。这时候，Kotlin 官方为我们提供了 CoroutineExceptionHandler 作为补充。有了它，我们可以轻松捕获整个作用域内的所有异常。</li></ul><p>其实，这节课里我提到的这些案例，只是我平时工作中遇到的很小一部分。案例是讲不完的，在协程中处理异常，你将来肯定也会遇到千奇百怪的问题。但重要的是分析问题的思路，还有解决问题的手段。这节课我给你总结的 6 大准则呢，就是你将来遇到协程异常时，可以用的 6 种处理手段。</p><p>当我们遇到问题的时候，首先要分析是 CancellationException 导致的，还是其他异常导致的。接着我们就可以根据实际情况去思考，该用哪种处理手段了。</p><p>另外如果你足够细心的话，你会发现这节课总结出的 6 大准则，其实都跟协程的<strong>结构化并发</strong>有着密切联系。由于协程之间存在父子关系，因此它的异常处理也是遵循这一规律的。而协程的异常处理机制之所以这么复杂，也是因为它的结构化并发特性。</p><p>所以，除了这 6 大准则以外，我们还可以总结出一个核心理念：<strong>因为协程是“结构化的”，所以异常传播也是“结构化的”</strong>。</p><p>如果你能理解协程异常处理的核心理念，同时能够牢记前面的 6 大准则。我相信，将来不论你遇到什么样的古怪问题，你都可以分析出问题的根源，找到解决方案！</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>前面我们提到过，CoroutineExceptionHandler 可以一次性捕获整个作用域内所有协程的异常。那么，我们是不是可以抛弃 try-catch，只使用 CoroutineExceptionHandler 呢？为什么？</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(协程篇)22  并发：协程不需要处理同步吗？</title>
      <link href="/posts/778b5847/"/>
      <url>/posts/778b5847/</url>
      
        <content type="html"><![CDATA[<p><audio id="audioPlayer" controlslist="nodownload" controls="" src="https://github.com/winstone-su/imageHosting/blob/main/course/kotlin/kotlin-programming-first-lesson/22%20_%20%E5%B9%B6%E5%8F%91%EF%BC%9A%E5%8D%8F%E7%A8%8B%E4%B8%8D%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E5%90%8C%E6%AD%A5%E5%90%97%EF%BC%9F-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.mp3?raw=true" style="position: relative; width: 565px; height: 54px; left: 0px; top: 0px;"></audio></p><p>今天我们来讲讲协程的并发。</p><p>在大型软件的架构当中，并发也是一个不可避免的问题。然而，在传统的 Java 编程当中，并发却是个令人生畏的话题。因为 Java 的线程模型、内存模型、同步机制太复杂了，而当复杂的业务逻辑与复杂的并发模型混合在一起的时候，情况就更糟糕了！如果你用 Java 做过中大型软件，对此一定会深有体会。</p><p>我们都知道，Kotlin 的协程仍然是基于线程运行的。但是，经过一层封装以后，Kotlin 协程面对并发问题的时候，它的处理手段其实跟 Java 就大不一样。所以这节课，我们就来看看协程在并发问题上的处理，一起来探究下 Kotlin 协程的并发思路，从而真正解决并发的难题。</p><h2 id="协程与并发"><a href="#协程与并发" class="headerlink" title="协程与并发"></a>协程与并发</h2><p>在 Java 世界里，并发往往需要多个线程一起工作，而多线程往往就会有共享的状态，这时候程序就要处理同步问题了。很多初学者在这一步，都会把协程与线程的概念混淆在一起。比如你可以来看看下面这段代码，你觉得有多线程同步的问题吗？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default 线程池</span></span><br><span class="line">    launch(Dispatchers.Default) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码里，我是在 Default 线程池上创建了一个协程，然后对变量 i 进行了 1000 次自增操作，接着我又 delay 了一小会儿，防止程序退出，最后输出结果。</p><p>那么，在面对这段代码的时候，你也许会觉得，Default 线程池内部是多个线程，因此就需要考虑多线程同步的问题。其实，这就是典型的把协程、线程混淆的例子。</p><p>如果你仔细分析上面的代码，会发现<strong>代码中压根就没有并发执行的任务</strong>，除了 runBlocking，我只在 launch 当中创建了一个协程，所有的计算都发生在一个协程当中。所以，在这种情况下你根本就不需要考虑同步的问题。</p><p>我们再来看看多个协程并发执行的例子。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重复十次</span></span><br><span class="line">    repeat(<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待计算完成</span></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">i = 9972</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我创建了 10 个协程任务，每个协程任务都会工作在 Default 线程池，这 10 个协程任务，都会分别对 i 进行 1000 次自增操作。如果一切正常的话，代码的输出结果应该是 10000。但如果你实际运行这段代码，你会发现结果大概率不会是 10000。</p><p>出现这个问题的原因也很简单，这 10 个协程分别运行在不同的线程之上，与此同时，这 10 个协程之间还共享着 i 这个变量，并且它们还会以并发的形式对 i 进行自增，所以自然就会产生同步的问题。</p><p><code>补充：为了不偏离主题，这里我们不去深究出现这个问题的底层原因。这涉及到 Java 内存模型之类的底层细节，如果你不熟悉 Java 并发相关的知识点，可以自行去做一些了解。</code></p><p>所以在这里，我们就可以回答这节课标题里的问题了：<strong>Kotlin 协程也需要处理多线程同步的问题</strong>。</p><p>那么下面，我们就以这个简单的代码为例，一起来分析下 Kotlin 协程面对并发时，都有哪些可用的手段。</p><h2 id="借鉴-Java-的并发思路"><a href="#借鉴-Java-的并发思路" class="headerlink" title="借鉴 Java 的并发思路"></a>借鉴 Java 的并发思路</h2><p>首先，由于 Kotlin 协程也是基于 JVM 的，所以，当我们面对并发问题的时候，脑子里第一时间想到的肯定是 Java 当中的同步手段，比如 synchronized、Atomic、Lock，等等。</p><p>在 Java 当中，最简单的同步方式就是 synchronized 同步了。那么换到 Kotlin 里，我们就可以使用 <strong>@Synchronized</strong> 注解来修饰函数，也可以使用 synchronized(){} 的方式来实现同步代码块。</p><p>让我们用 synchronized 来改造一下上面的代码段 2：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> lock = Any() <span class="comment">// 变化在这里</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="comment">// 变化在这里</span></span><br><span class="line">                synchronized(lock) &#123;</span><br><span class="line">                    i++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">i = 10000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上代码中，我们创建了一个 lock 对象，然后使用 synchronized(){} 将“i++”包裹了起来。这样就可以确保在自增的过程中不会出现同步问题。这时候，如果你再来运行代码，就会发现结果已经是 10000 了。</p><p>不过，如果你在实际生产环境使用过协程的话，应该会感觉 synchronized 在协程当中也不是一直都很好用的。毕竟，<strong>synchronized 是线程模型下的产物</strong>。</p><p>就比如说，假设我们这里的自增操作需要一些额外的操作，需要用到挂起函数 prepare()。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 模拟准备工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> lock = Any()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                synchronized(lock) &#123;</span><br><span class="line">                    <span class="comment">// 编译器报错！</span></span><br><span class="line">                    prepare()</span><br><span class="line">                    i++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，你就不能天真地把协程看作是“Java 线程池的封装”，然后继续照搬 Java 的同步手段了。你会发现：<strong>synchronized(){} 当中调用挂起函数，编译器会给你报错！</strong></p><p>这是为什么呢？其实，如果你理解了第 15 讲当中“协程挂起恢复”的思维模型的话，那么编译器报错的原因你一定可以轻松理解。因为这里的挂起函数会被翻译成带有 Continuation 的异步函数，从而就造成了 synchronid 代码块无法正确处理同步。</p><p>另外从这个例子里，我们也可以看出：即使 Kotlin 协程是基于 Java 线程的，但它其实已经脱离 Java 原本的范畴了。所以，单纯使用 Java 的同步手段，是无法解决 Kotlin 协程里所有问题的。</p><p>那么接下来，我们就来看看 Kotlin 协程当中的并发思路。</p><h2 id="协程的并发思路"><a href="#协程的并发思路" class="headerlink" title="协程的并发思路"></a>协程的并发思路</h2><p>前面我也提到过，由于 Java 的线程模型是阻塞式的，比如说 Thread.sleep()，所以在 Java 当中，并发往往就意味着多线程，而多线程则往往会有状态共享，而状态共享就意味着要处理同步问题。</p><p>但是，因为 Kotlin 协程具备挂起、恢复的能力，而且还有非阻塞的特点，所以在使用协程处理并发问题的时候，我们的思路其实可以更宽。比如，我们可以使用<strong>单线程并发。</strong></p><h3 id="单线程并发"><a href="#单线程并发" class="headerlink" title="单线程并发"></a>单线程并发</h3><p>在 Kotlin 当中，单线程并发的实现其实非常轻松。不过如果你有 Java 经验的话，也许会对这个说法产生疑问，因为在 Java 当中，并发往往就意味着多线程。</p><p>实际上，在第 16 讲里我们就涉及到“单线程并发”这个概念了。让我们回过头，重新看看那段并发的代码。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult1</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        logX(<span class="string">&quot;Start getResult1&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        logX(<span class="string">&quot;End getResult1&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Result1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult2</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        logX(<span class="string">&quot;Start getResult2&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        logX(<span class="string">&quot;End getResult2&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Result2&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult3</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        logX(<span class="string">&quot;Start getResult3&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        logX(<span class="string">&quot;End getResult3&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Result3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> results: List&lt;String&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> result1 = async &#123; getResult1() &#125;</span><br><span class="line">        <span class="keyword">val</span> result2 = async &#123; getResult2() &#125;</span><br><span class="line">        <span class="keyword">val</span> result3 = async &#123; getResult3() &#125;</span><br><span class="line"></span><br><span class="line">        results = listOf(result1.await(), result2.await(), result3.await())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Time: <span class="variable">$time</span>&quot;</span>)</span><br><span class="line">    println(results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start getResult1</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start getResult2</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start getResult3</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">End getResult1</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">End getResult2</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">End getResult3</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Time: 1066</span></span><br><span class="line"><span class="comment">[Result1, Result2, Result3]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中启动了三个协程，它们之间是并发执行的，每个协程执行耗时是 1000 毫秒，程序总耗时也是接近 1000 毫秒。而且，这几个协程是运行在同一个线程 main 之上的。</p><p>所以，当我们在协程中面临并发问题的时候，首先可以考虑：<strong>是否真的需要多线程</strong>？如果不需要的话，其实是可以不考虑多线程同步问题的。</p><p>那么，对于前面代码段 2 的例子来说，我们则可以把计算的逻辑分发到单一的线程之上。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> mySingleDispatcher = Executors.newSingleThreadExecutor &#123;</span><br><span class="line">        Thread(it, <span class="string">&quot;MySingleThread&quot;</span>).apply &#123; isDaemon = <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;.asCoroutineDispatcher()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(mySingleDispatcher) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">i = 10000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可见，在这段代码中，我们使用“launch(mySingleDispatcher)”，把所有的协程任务都分发到了单线程的 Dispatcher 当中，这样一来，我们就不必担心同步问题了。另外，如果仔细分析的话，上面创建的 10 个协程之间，其实仍然是并发执行的。</p><p>所以这时候，如果你运行上面的代码，就一定可以得到正确的结果了：i &#x3D; 10000。</p><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>在 Java 当中，其实还有 Lock 之类的同步锁。但由于 Java 的锁是阻塞式的，会大大影响协程的非阻塞式的特性。所以，在 Kotlin 协程当中，我们也是不<strong>推荐</strong>直接使用传统的同步锁的，甚至在某些场景下，在协程中使用 Java 的锁也会遇到意想不到的问题。</p><p>为此，Kotlin 官方提供了“非阻塞式”的锁：Mutex。下面我们就来看看，如何用 Mutex 来改造代码段 2。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> mutex = Mutex()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="comment">// 变化在这里</span></span><br><span class="line">                mutex.lock()</span><br><span class="line">                i++</span><br><span class="line">                mutex.unlock()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用 mutex.lock()、mutex.unlock() 包裹了需要同步的计算逻辑，这样一来，代码就可以实现多线程同步了，程序的输出结果也会是 10000。</p><p>实际上，Mutex 对比 JDK 当中的锁，最大的优势就在于<strong>支持挂起和恢复</strong>。让我们来看看它的源码定义：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mutex</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isLocked: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     注意这里</span></span><br><span class="line">    <span class="comment">//        ↓</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">lock</span><span class="params">(owner: <span class="type">Any</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">unlock</span><span class="params">(owner: <span class="type">Any</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Mutex 是一个接口，它的 lock() 方法其实是一个挂起函数。而这就是实现非阻塞式同步锁的根本原因。</p><p>不过，在代码段 7 当中，我们对于 Mutex 的使用其实是错误的。因为这样的做法并不安全，我们可以来看一个场景：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> mutex = Mutex()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mutex.lock()</span><br><span class="line">                    i++</span><br><span class="line">                    i/<span class="number">0</span> <span class="comment">// 故意制造异常</span></span><br><span class="line">                    mutex.unlock()</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                    println(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序无法退出</span></span><br></pre></td></tr></table></figure><p>以上代码会在 mutex.lock()、mutex.unlock() 之间发生异常，从而导致 mutex.unlock() 无法被调用。这个时候，整个程序的执行流程就会一直卡住，无法结束。</p><p>所以，为了避免出现这样的问题，我们应该使用 Kotlin 提供的一个扩展函数：**mutex.withLock{}**。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> mutex = Mutex()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="comment">// 变化在这里</span></span><br><span class="line">                mutex.withLock &#123;</span><br><span class="line">                    i++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// withLock的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Mutex.<span class="title">withLock</span><span class="params">(owner: <span class="type">Any</span>? = <span class="literal">null</span>, action: () -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    lock(owner)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> action()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock(owner)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，withLock{} 的本质，其实是在 finally{} 当中调用了 unlock()。这样一来，我们就再也不必担心因为异常导致 unlock() 无法执行的问题了。</p><h3 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h3><p>Actor，其实是在很多编程语言当中都存在的一个并发同步模型。在 Kotlin 当中，也同样存在这样的模型，它本质上是<strong>基于 Channel 管道消息实现的</strong>。下面我们还是来看一个例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Msg</span></span><br><span class="line"><span class="keyword">object</span> AddMsg : Msg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResultMsg</span>(</span><br><span class="line">    <span class="keyword">val</span> result: CompletableDeferred&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line">) : Msg()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">addActor</span><span class="params">()</span></span> = actor&lt;Msg&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (msg <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            <span class="keyword">when</span> (msg) &#123;</span><br><span class="line">                <span class="keyword">is</span> AddMsg -&gt; counter++</span><br><span class="line">                <span class="keyword">is</span> ResultMsg -&gt; msg.result.complete(counter)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> actor = addActor()</span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                actor.send(AddMsg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred = CompletableDeferred&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    actor.send(ResultMsg(deferred))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = deferred.await()</span><br><span class="line">    actor.close()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="subst">$&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们定义了 addActor() 这个挂起函数，而它其实调用了 actor() 这个高阶函数。而这个函数的返回值类型其实是 SendChannel。由此可见，Kotlin 当中的 <strong>Actor 其实就是 Channel 的简单封装</strong>。Actor 的多线程同步能力都源自于 Channel。</p><p>这里，我们借助<strong>密封类</strong>定义了两种消息类型，AddMsg、ResultMsg，然后在 <strong>actor{} 内部</strong>，我们处理这两种消息类型，如果我们收到了 AddMsg，则计算“i++”；如果收到了 ResultMsg，则返回计算结果。</p><p>而在 actor{} 的外部，我们则只需要发送 10000 次的 AddMsg 消息，最后再发送一次 ResultMsg，取回计算结果即可。</p><p>由于 Actor 的结构比较抽象，这里我做了一个小视频，帮你更好地理解它。</p><iframe src="https://github.com/winstone-su/imageHosting/blob/main/course/kotlin/kotlin-programming-first-lesson/22%20_%20Actor-%E6%BC%94%E7%A4%BA%E8%A7%86%E9%A2%91.mp4?raw=true" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>需要注意的是，虽然在上面的演示视频中，AddMsg、ResultMsg 是串行发送的，但实际上，它们是在多线程并行发送的，而 Channel 可以保证接收到的消息可以同步接收并处理。</p><p>这也就证明了我们前面的说法：Actor 本质上是基于 Channel 管道消息实现的。</p><p><code>补充：Kotlin 目前的 Actor 实现其实还比较简陋，在不远的将来，Kotlin 官方会对 Actor API 进行重构，具体可以参考这个链接。虽然它的 API 可能会改变，但我相信它的核心理念是不会变的。</code></p><p>好，到现在为止，我们已经学习了三种协程并发的思路。不过我们还要反思一个问题：<strong>多线程并发，一定需要同步机制吗</strong>？</p><h2 id="反思：可变状态"><a href="#反思：可变状态" class="headerlink" title="反思：可变状态"></a>反思：可变状态</h2><p>前面我们提到过，多线程并发，往往会有共享的可变状态，而共享可变状态的时候，就需要考虑同步问题。</p><p>弄清楚这一点后，我们其实会找到一个新的思路：<strong>避免共享可变状态</strong>。有了这个思路以后，我们的代码其实就非常容易实现了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferreds = mutableListOf&lt;Deferred&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> deferred = async (Dispatchers.Default) &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                    i++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@async</span> i</span><br><span class="line">        &#125;</span><br><span class="line">        deferreds.add(deferred)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    deferreds.forEach &#123;</span><br><span class="line">        result += it.await()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们不再共享可变状态 i，对应的，在每一个协程当中，都有一个局部的变量 i，同时将 launch 都改为了 async，让每一个协程都可以返回计算结果。</p><p>这种方式，相当于将 10000 次计算，平均分配给了 10 个协程，让它们各自计算 1000 次。这样一来，每个协程都可以进行独立的计算，然后我们将 10 个协程的结果汇总起来，最后累加在一起。</p><p>其实，我们上面的思路，也是借鉴自函数式编程的思想，因为在函数式编程当中，就是追求<strong>不变性、无副作用</strong>。不过，以上代码其实还是命令式的代码，如果我们用函数式风格来重构的话，代码会更加简洁。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = (<span class="number">1.</span><span class="number">.10</span>).map &#123;</span><br><span class="line">        async (Dispatchers.Default) &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@async</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.awaitAll()</span><br><span class="line">        .sum()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们使用函数式风格代码重构了代码段 12，我们仍然创建了 10 个协程，并发了计算了 10000 次自增操作。</p><p>在加餐一当中，我曾提到过，函数式编程的一大优势就在于，它具有不变性、无副作用的特点，所以<strong>无惧并发编程</strong>。上面的这个代码案例，其实就体现出了 Kotlin 函数式编程的这个优势。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课，我们学习了 Kotlin 协程解决并发的两大思路，分别是 Java 思路、协程思路。要注意，对于 Java 当中的同步手段，我们并不能直接照搬到 Kotlin 协程当中来，其中最大的问题，就是 <strong>synchronized 不支持挂起函数</strong>。</p><p>而对于协程并发手段，我也给你介绍了 4 种手段，这些你都需要掌握好。</p><ul><li>第一种手段，<strong>单线程并发</strong>，在 Java 世界里，并发往往意味着多线程，但在 Kotlin 协程当中，我们可以轻松实现单线程并发，这时候我们就不用担心多线程同步的问题了。</li><li>第二种手段，Kotlin 官方提供的协程同步锁，Mutex，由于它的 lock 方法是挂起函数，所以它跟 JDK 当中的锁不一样，Mutex 是非阻塞的。需要注意的是，我们在使用 Mutex 的时候，应该使用 withLock{} 这个高阶函数，而不是直接使用 lock()、unlock()。</li><li>第三种手段，Kotlin 官方提供的 <strong>Actor</strong>，这是一种普遍存在的并发模型。在目前的版本当中，Kotlin 的 Actor 只是 Channel 的简单封装，它的 API 会在未来的版本发生改变。</li><li>第四种手段，借助<strong>函数式思维</strong>。我们之所以需要处理多线程同步问题，主要还是因为存在<strong>共享的可变状态</strong>。其实，共享可变状态，既不符合<strong>无副作用</strong>的特性，也不符合<strong>不变性</strong>的特性。当我们借助函数式编程思维，实现无副作用和不变性以后，并发代码也会随之变得安全。</li></ul><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/99/c2/99497ab151d77415c3fd2f5fc2fyy0c2.jpg?wh=2000x897" alt="img"></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>Kotlin 提供的 Mutex，它会比 JDK 的锁性能更好吗？为什么？欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(协程篇)21  select：到底是在选择什么？</title>
      <link href="/posts/4b3d9f4d/"/>
      <url>/posts/4b3d9f4d/</url>
      
        <content type="html"><![CDATA[<p><audio id="audioPlayer" controlslist="nodownload" controls="" src="https://github.com/winstone-su/imageHosting/blob/main/course/kotlin/kotlin-programming-first-lesson/21%20_%20select%EF%BC%9A%E5%88%B0%E5%BA%95%E6%98%AF%E5%9C%A8%E9%80%89%E6%8B%A9%E4%BB%80%E4%B9%88%EF%BC%9F-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.mp3?raw=true" style="position: relative; width: 565px; height: 54px; left: 0px; top: 0px;"></audio></p><p>今天我们来学习 Kotlin 协程的 select。</p><p>select，在目前的 Kotlin 1.6 当中，仍然是一个<strong>实验性的特性</strong>（Experimental）。但是，考虑到 select 具有较强的实用性，我决定还是来给你介绍一下它。</p><p>select 可以说是软件架构当中非常重要的一个组件，在很多业务场景下，select 与 Deferred、Channel 结合以后，在大大提升程序的响应速度的同时，还可以提高程序的灵活性、扩展性。</p><p>今天这节课，我会从 select 的<strong>使用角度</strong>着手，带你理解 select 的核心使用场景，之后也会通过源码帮你进一步分析 select API 的底层规律。学完这节课以后，你完全可以将 select 应用到自己的工作当中去。</p><p>好，接下来，我们就一起来学习 select 吧！</p><h3>select 就是选择“更快的结果”</h3><p>由于 select 的工作机制比较抽象，我们先来假设一个场景，看看 select 适用于什么样的场景。</p><p>客户端，想要查询一个商品的详情。目前有两个服务：缓存服务，速度快但信息可能是旧的；网络服务，速度慢但信息一定是最新的。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/50/86/50f7c90d8a01e42834500bb5yy705486.jpg?wh=1576x707" alt="img"></p><p>对于这个场景，如果让我们来实现其中的逻辑的话，我们非常轻松地就能实现类似这样的代码逻辑：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCacheInfo</span><span class="params">(productId: <span class="type">String</span>)</span></span>: Product? &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="keyword">return</span> Product(productId, <span class="number">9.9</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNetworkInfo</span><span class="params">(productId: <span class="type">String</span>)</span></span>: Product? &#123;</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        <span class="keyword">return</span> Product(productId, <span class="number">9.8</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">(product: <span class="type">Product</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;product.productId&#125;</span>==<span class="subst">$&#123;product.price&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> productId = <span class="string">&quot;xxxId&quot;</span></span><br><span class="line">    <span class="comment">// 查询缓存</span></span><br><span class="line">    <span class="keyword">val</span> cacheInfo = getCacheInfo(productId)</span><br><span class="line">    <span class="keyword">if</span> (cacheInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        updateUI(cacheInfo)</span><br><span class="line">        println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询网络</span></span><br><span class="line">    <span class="keyword">val</span> latestInfo = getNetworkInfo(productId)</span><br><span class="line">    <span class="keyword">if</span> (latestInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        updateUI(latestInfo)</span><br><span class="line">        println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Product</span>(</span><br><span class="line">    <span class="keyword">val</span> productId: String,</span><br><span class="line">    <span class="keyword">val</span> price: <span class="built_in">Double</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">xxxId==9.9</span></span><br><span class="line"><span class="comment">Time cost: 112</span></span><br><span class="line"><span class="comment">xxxId==9.8</span></span><br><span class="line"><span class="comment">Time cost: 314</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>考虑到缓存服务速度更快，我们自然而然会这么写，先去查询缓存服务，如果查询到了信息，我们就会去更新 UI 界面。之后去查询网络服务，拿到最新的信息之后，我们再来更新 UI 界面。也就是这样：</p><ul><li>第一步：查询缓存信息；</li><li>第二步：缓存服务返回信息，更新 UI；</li><li>第三步：查询网络服务；</li><li>第四步：网络服务返回信息，更新 UI。</li></ul><p>这种做法的好处在于，用户可以第一时间看到商品的信息，虽然它暂时会展示旧的信息，但由于我们同时查询了网络服务，旧缓存信息也马上会被替代成新的信息。这样的做法，可以最大程度保证用户体验。</p><p>不过，以上整个流程都是建立在“缓存服务一定更快”的前提下的，万一我们的缓存服务出了问题，它的速度变慢了，甚至是超时、无响应呢？</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/12/b1/1267b73837eaa9370651e468c1c536b1.jpg?wh=1607x717" alt="img"></p><p>这时候，如果你回过头来分析代码段 1 的话，你就会发现：程序执行流程会卡在第二步，迟迟无法进行第三步。具体来说，是因为 getCacheInfo() 它是一个挂起函数，只有这个程序执行成功以后，才可以继续执行后面的任务。你也可以把 getCacheInfo() 当中的 delay 时间修改成 2000 毫秒，去验证一下。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行结果：</span></span><br><span class="line"><span class="comment">xxxId==9.9</span></span><br><span class="line"><span class="comment">Time cost: 2013</span></span><br><span class="line"><span class="comment">xxxId==9.8</span></span><br><span class="line"><span class="comment">Time cost: 2214</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>那么，面对这样的场景，我们其实需要一个可以灵活选择的语法：“两个挂起函数同时执行，谁返回的速度更快，我们就选择谁”。这其实就是 select 的典型使用场景。</p><h2 id="select-和-async"><a href="#select-和-async" class="headerlink" title="select 和 async"></a>select 和 async</h2><p>上面的这个场景，我们可以用 async 搭配 select 来使用。async 可以实现并发，select 则可以选择最快的结果。</p><p>让我们来看看，代码具体该怎么写。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> productId = <span class="string">&quot;xxxId&quot;</span></span><br><span class="line">    <span class="comment">//          1，注意这里</span></span><br><span class="line">    <span class="comment">//               ↓</span></span><br><span class="line">    <span class="keyword">val</span> product = select&lt;Product?&gt; &#123;</span><br><span class="line">        <span class="comment">// 2，注意这里</span></span><br><span class="line">        async &#123; getCacheInfo(productId) &#125;</span><br><span class="line">            .onAwait &#123; <span class="comment">// 3，注意这里</span></span><br><span class="line">                it</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 4，注意这里</span></span><br><span class="line">        async &#123; getNetworkInfo(productId) &#125;</span><br><span class="line">            .onAwait &#123;  <span class="comment">// 5，注意这里</span></span><br><span class="line">                it</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span>) &#123;</span><br><span class="line">        updateUI(product)</span><br><span class="line">        println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">xxxId==9.9</span></span><br><span class="line"><span class="comment">Time cost: 127</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从上面的执行结果，我们可以看到，由于缓存的服务更快，所以，select 确实帮我们选择了更快的那个结果。代码中一共有四个注释，我们一起来看看：</p><ul><li>注释 1，我们使用 select 这个高阶函数包裹了两次查询的服务，同时传入了泛型参数 Product，代表我们要选择的数据类型是 Product。</li><li>注释 2，4 中，我们使用了 async 包裹了 getCacheInfo()、getNetworkInfo() 这两个挂起函数，这是为了让这两个查询实现并发执行。</li><li>注释 3，5 中，我们使用 onAwait{} 将执行结果传给了 select{}，而 select 才能进一步将数据返回给 product 局部变量。<strong>注意了，这里我们用的 onAwait{}，而不是 await()。</strong></li></ul><p>现在，假设，我们的缓存服务出现了问题，需要 2000 毫秒才能返回：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCacheInfo</span><span class="params">(productId: <span class="type">String</span>)</span></span>: Product? &#123;</span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line">    <span class="keyword">return</span> Product(productId, <span class="number">9.9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">xxxId==9.8</span></span><br><span class="line"><span class="comment">Time cost: 226</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这时候，通过执行结果，我们可以发现，我们的 select 可以在缓存服务出现问题的时候，灵活选择网络服务的结果。从而避免用户等待太长的时间，得到糟糕的体验。</p><p>不过，你也许发现了，“代码段 1”和“代码段 2”其实并不是完全等价的。因为在代码段 2 当中，用户大概率是会展示旧的缓存信息。但实际场景下，我们是需要进一步更新最新信息的。</p><p>其实，在代码段 2 的基础上，我们也可以轻松实现，只是说，这里我们需要为 Product 这个数据类增加一个标记。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Product</span>(</span><br><span class="line">    <span class="keyword">val</span> productId: String,</span><br><span class="line">    <span class="keyword">val</span> price: <span class="built_in">Double</span>,</span><br><span class="line">    <span class="comment">// 是不是缓存信息</span></span><br><span class="line">    <span class="keyword">val</span> isCache: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后，我们还需要对代码段 2 的逻辑进行一些提取：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCacheInfo</span><span class="params">(productId: <span class="type">String</span>)</span></span>: Product? &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="keyword">return</span> Product(productId, <span class="number">9.9</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNetworkInfo</span><span class="params">(productId: <span class="type">String</span>)</span></span>: Product? &#123;</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        <span class="keyword">return</span> Product(productId, <span class="number">9.8</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">(product: <span class="type">Product</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;product.productId&#125;</span>==<span class="subst">$&#123;product.price&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> productId = <span class="string">&quot;xxxId&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1，缓存和网络，并发执行</span></span><br><span class="line">    <span class="keyword">val</span> cacheDeferred = async &#123; getCacheInfo(productId) &#125;</span><br><span class="line">    <span class="keyword">val</span> latestDeferred = async &#123; getNetworkInfo(productId) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2，在缓存和网络中间，选择最快的结果</span></span><br><span class="line">    <span class="keyword">val</span> product = select&lt;Product?&gt; &#123;</span><br><span class="line">        cacheDeferred.onAwait &#123;</span><br><span class="line">                it?.copy(isCache = <span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        latestDeferred.onAwait &#123;</span><br><span class="line">                it?.copy(isCache = <span class="literal">false</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3，更新UI</span></span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span>) &#123;</span><br><span class="line">        updateUI(product)</span><br><span class="line">        println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4，如果当前结果是缓存，那么再取最新的网络服务结果</span></span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span> &amp;&amp; product.isCache) &#123;</span><br><span class="line">        <span class="keyword">val</span> latest = latestDeferred.await()?: <span class="keyword">return</span><span class="symbol">@runBlocking</span></span><br><span class="line">        updateUI(latest)</span><br><span class="line">        println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">xxxId==9.9</span></span><br><span class="line"><span class="comment">Time cost: 120</span></span><br><span class="line"><span class="comment">xxxId==9.8</span></span><br><span class="line"><span class="comment">Time cost: 220</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果你对比代码段 1 和代码段 5 的执行结果，会发现代码段 5 的总体耗时更短。</p><p>另外在上面的代码中，还有几个注释，我们一个个看：</p><ul><li>首先看注释 1，我们将 getCacheInfo()、getNetworkInfo() 提取到了 select 的外部，让它们通过 async 并发执行。如果你还记得第 16 讲思考题当中的逻辑，你一定可以理解这里的 async 并发。（如果你忘了，可以回过头去看看。）</li><li>注释 2，我们仍然是通过 select 选择最快的那个结果，接着在注释 3 这里我们第一时间更新 UI 界面。</li><li>注释 4，我们判断当前的 product 是不是来自于缓存，如果是的话，我们还需要用最新的信息更新 UI。</li></ul><p>然后在这里，假设我们的缓存服务出现了问题，需要 2000 毫秒才能返回：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCacheInfo</span><span class="params">(productId: <span class="type">String</span>)</span></span>: Product? &#123;</span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line">    <span class="keyword">return</span> Product(productId, <span class="number">9.9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">xxxId==9.8</span></span><br><span class="line"><span class="comment">Time cost: 224</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，代码仍然可以正常执行。其实，当前的这个例子很简单，不使用 select 同样也可以实现。不过，select 这样的代码模式的优势在于，<strong>扩展性非常好。</strong></p><p>下面，我们可以再来假设一下，现在我们有了多个缓存服务。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/dy/2b/dyydce7b6a709e2725bbffec9726312b.jpg?wh=1550x736" alt="img"></p><p>对于这个问题，我们其实只需要稍微改动一下代码段 3 就行了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> productId = <span class="string">&quot;xxxId&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> cacheDeferred = async &#123; getCacheInfo(productId) &#125;</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> cacheDeferred2 = async &#123; getCacheInfo2(productId) &#125;</span><br><span class="line">    <span class="keyword">val</span> latestDeferred = async &#123; getNetworkInfo(productId) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> product = select&lt;Product?&gt; &#123;</span><br><span class="line">        cacheDeferred.onAwait &#123;</span><br><span class="line">            it?.copy(isCache = <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变化在这里</span></span><br><span class="line">        cacheDeferred2.onAwait &#123;</span><br><span class="line">            it?.copy(isCache = <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latestDeferred.onAwait &#123;</span><br><span class="line">            it?.copy(isCache = <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span>) &#123;</span><br><span class="line">        updateUI(product)</span><br><span class="line">        println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span> &amp;&amp; product.isCache) &#123;</span><br><span class="line">        <span class="keyword">val</span> latest = latestDeferred.await() ?: <span class="keyword">return</span><span class="symbol">@runBlocking</span></span><br><span class="line">        updateUI(latest)</span><br><span class="line">        println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">xxxId==9.9</span></span><br><span class="line"><span class="comment">Time cost: 125</span></span><br><span class="line"><span class="comment">xxxId==9.8</span></span><br><span class="line"><span class="comment">Time cost: 232</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，当增加一个缓存服务进来的时候，我们的代码只需要做很小的改动，就可以实现。</p><p>所以，总的来说，对比传统的挂起函数串行的执行流程，select 这样的代码模式，不仅可以提升程序的整体响应速度，还可以大大提升程序的<strong>灵活性、扩展性</strong>。</p><h2 id="select-和-Channel"><a href="#select-和-Channel" class="headerlink" title="select 和 Channel"></a>select 和 Channel</h2><p>在前面的课程我们提到过，在协程中返回一个内容的时候，我们可以使用挂起函数、async，但如果要返回多个结果的话，就要用 Channel 和 Flow。</p><p>那么，这里我们来看看 select 和 Channel 的搭配使用。这里，我们有两个管道，channel1、channel2，它们里面的内容分别是 1、2、3；a、b、c，我们通过 select，将它们当中的数据收集出来并打印。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/d2/e4/d2d280yy62f88e03522a435b3abyy9e4.gif?wh=1080x608" alt="img"></p><p>对于这个问题，如果我们不借助 select 来实现的话，其实可以大致做到，但结果不会令人满意。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> channel1 = produce &#123;</span><br><span class="line">        send(<span class="number">1</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="number">2</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="number">3</span>)</span><br><span class="line">        delay(<span class="number">150L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> channel2 = produce &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        send(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    channel1.consumeEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    channel2.consumeEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">Time cost: 989</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，通过普通的方式，我们的代码是串行执行的，执行结果并不符合预期。channel1 执行完毕以后，才会执行 channel2，程序总体的执行时间，也是两者的总和。最关键的是，如果 channel1 当中如果迟迟没有数据的话，我们的程序会一直卡着不执行。</p><p>当然，以上的问题，我们通过其他方式也可以解决，但最方便的解决方案，还是 select。让我们来看看 select 与 Channel 搭配后，会带来什么样的好处。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> channel1 = produce &#123;</span><br><span class="line">        send(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">        delay(<span class="number">150L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> channel2 = produce &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        send(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectChannel</span><span class="params">(channel1: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;, channel2: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;)</span></span>: String = select&lt;String&gt; &#123;</span><br><span class="line">        <span class="comment">// 1， 选择channel1</span></span><br><span class="line">        channel1.onReceive&#123;</span><br><span class="line">            it.also &#123; println(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2， 选择channel1</span></span><br><span class="line">        channel2.onReceive&#123;</span><br><span class="line">            it.also &#123; println(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">6</span>)&#123;<span class="comment">// 3， 选择6次结果</span></span><br><span class="line">        selectChannel(channel1, channel2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">Time cost: 540</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从程序的执行结果中，我们可以看到，程序的输出结果符合预期，同时它的执行耗时，也比代码段 8 要少很多。上面的代码中有几个注释，我们来看看：</p><ul><li>注释 1 和 2，onReceive{} 是 Channel 在 select 当中的语法，当 Channel 当中有数据以后，它就会被回调，通过这个 Lambda，我们也可以将结果传出去。</li><li>注释 3，这里我们执行了 6 次 select，目的是要把两个管道中的所有数据都消耗掉。管道 1 有 3 个数据、管道 2 有 3 个数据，所以加起来，我们需要选择 6 次。</li></ul><p>这时候，假设 channel1 出了问题，它不再产生数据了，我们看看程序会怎么样执行。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> channel1 = produce&lt;String&gt; &#123;</span><br><span class="line">        <span class="comment">// 变化在这里</span></span><br><span class="line">        delay(<span class="number">15000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> channel2 = produce &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        send(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectChannel</span><span class="params">(channel1: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;, channel2: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;)</span></span>: String = select&lt;String&gt; &#123;</span><br><span class="line">        channel1.onReceive&#123;</span><br><span class="line">            it.also &#123; println(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        channel2.onReceive&#123;</span><br><span class="line">            it.also &#123; println(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    repeat(<span class="number">3</span>)&#123;</span><br><span class="line">        selectChannel(channel1, channel2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">Time cost: 533</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们将 channel1 当中的 send() 都删除了，并且，repeat() 的次数变成了 3 次，因为管道里只有三个数据了。</p><p>这时候，我们发现，select 也是可以正常执行的。</p><p>不过，我们有时候可能并不清楚每个 Channel 当中有多少个数据，比如说，这里如果我们还是写 repeat(6) 的话，程序就会出问题了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅改动这里</span></span><br><span class="line">repeat(<span class="number">6</span>)&#123;</span><br><span class="line">    selectChannel(channel1, channel2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">崩溃：</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ClosedReceiveChannelException: Channel was closed</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这时候，你应该就能反应过来了，由于我们的 channel2 当中只有 3 个数据，它发送完数据以后就会被关闭，而我们的 select 是会被调用 6 次的，所以就会触发上面的 ClosedReceiveChannelException 异常。</p><p>在 19 讲当中，我们学过 receiveCatching() 这个方法，它可以封装 Channel 的结果，防止出现 ClosedReceiveChannelException。类似的，当 Channel 与 select 配合的时候，我们可以使用 onReceiveCatching{} 这个高阶函数。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> channel1 = produce&lt;String&gt; &#123;</span><br><span class="line">        delay(<span class="number">15000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> channel2 = produce &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        send(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectChannel</span><span class="params">(channel1: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;, channel2: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;)</span></span>: String =</span><br><span class="line">        select&lt;String&gt; &#123;</span><br><span class="line">            channel1.onReceiveCatching &#123;</span><br><span class="line">                it.getOrNull() ?: <span class="string">&quot;channel1 is closed!&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            channel2.onReceiveCatching &#123;</span><br><span class="line">                it.getOrNull() ?: <span class="string">&quot;channel2 is closed!&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> result = selectChannel(channel1, channel2)</span><br><span class="line">        println(result)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">channel2 is closed!</span></span><br><span class="line"><span class="comment">channel2 is closed!</span></span><br><span class="line"><span class="comment">channel2 is closed!</span></span><br><span class="line"><span class="comment">Time cost: 541</span></span><br><span class="line"><span class="comment">程序不会立即退出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这时候，即使我们不知道管道里有多少个数据，我们也不用担心崩溃的问题了。在 onReceiveCatching{} 这个高阶函数当中，我们可以使用 it.getOrNull() 来获取管道里的数据，如果获取的结果是 null，就代表管道已经被关闭了。</p><p>不过，上面的代码仍然还有一个问题，那就是，当我们得到所有结果以后，程序不会立即退出，因为我们的 channel1 一直在 delay()。这时候，当我们完成 6 次 repeat() 调用以后，我们将 channel1、channel2 取消即可。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> channel1 = produce&lt;String&gt; &#123;</span><br><span class="line">        delay(<span class="number">15000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> channel2 = produce &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        send(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectChannel</span><span class="params">(channel1: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;, channel2: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;)</span></span>: String =</span><br><span class="line">        select&lt;String&gt; &#123;</span><br><span class="line">            channel1.onReceiveCatching &#123;</span><br><span class="line">                it.getOrNull() ?: <span class="string">&quot;channel1 is closed!&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            channel2.onReceiveCatching &#123;</span><br><span class="line">                it.getOrNull() ?: <span class="string">&quot;channel2 is closed!&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> result = selectChannel(channel1, channel2)</span><br><span class="line">        println(result)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    channel1.cancel()</span><br><span class="line">    channel2.cancel()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，我们对比一下代码段 13 和代码段 10 的话，就会发现程序的执行效率提升的同时，扩展性和灵活性也更好了。</p><p><code>提示：这种将多路数据以非阻塞的方式合并成一路数据的模式，在其他领域也有广泛的应用，比如说操作系统、Java NIO（Non-blocking I/O），等等。如果你能理解这个案例中的代码，相信你对操作系统、NIO 之类的技术也会有一个新的认识。</code></p><h2 id="思考与实战"><a href="#思考与实战" class="headerlink" title="思考与实战"></a>思考与实战</h2><p>如果你足够细心的话，你会发现，当我们的 Deferred、Channel 与 select 配合的时候，它们原本的 API 会多一个 on 前缀。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deferred</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">()</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="comment">// select相关  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onJoin: SelectClause0</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onAwait: SelectClause1&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SendChannel</span>&lt;<span class="type">in E</span>&gt; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(element: <span class="type">E</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// select相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onSend: SelectClause2&lt;E, SendChannel&lt;E&gt;&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReceiveChannel</span>&lt;<span class="type">out E</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">receive</span><span class="params">()</span></span>: E</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">receiveCatching</span><span class="params">()</span></span>: ChannelResult&lt;E&gt;</span><br><span class="line">    <span class="comment">// select相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onReceive: SelectClause1&lt;E&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onReceiveCatching: SelectClause1&lt;ChannelResult&lt;E&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，只要你记住了 Deferred、Channel 的 API，你是不需要额外记忆 select 的 API 的，只需要在原本的 API 的前面加上一个 on 就行了。</p><p>另外你要注意，当 select 与 Deferred 结合使用的时候，当并行的 Deferred 比较多的时候，你往往需要在得到一个最快的结果以后，去取消其他的 Deferred。</p><p>比如说，对于 Deferred1、Deferred2、Deferred3、Deferred4、Deferred5，其中 Deferred2 返回的结果最快，这时候，我们往往会希望取消其他的 Deferred，以节省资源。那么在这个时候，我们可以使用类似这样的方式：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">fastest</span><span class="params">(<span class="keyword">vararg</span> deferreds: <span class="type">Deferred</span>&lt;<span class="type">T</span>&gt;)</span></span>: T = select &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">cancelAll</span><span class="params">()</span></span> = deferreds.forEach &#123; it.cancel() &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (deferred <span class="keyword">in</span> deferreds) &#123;</span><br><span class="line">            deferred.onAwait &#123;</span><br><span class="line">                cancelAll()</span><br><span class="line">                it</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred1 = async &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        println(<span class="string">&quot;done1&quot;</span>)    <span class="comment">// 没机会执行</span></span><br><span class="line">        <span class="string">&quot;result1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred2 = async &#123;</span><br><span class="line">        delay(<span class="number">50L</span>)</span><br><span class="line">        println(<span class="string">&quot;done2&quot;</span>)</span><br><span class="line">        <span class="string">&quot;result2&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred3 = async &#123;</span><br><span class="line">        delay(<span class="number">10000L</span>)</span><br><span class="line">        println(<span class="string">&quot;done3&quot;</span>)    <span class="comment">// 没机会执行</span></span><br><span class="line">        <span class="string">&quot;result3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred4 = async &#123;</span><br><span class="line">        delay(<span class="number">2000L</span>)</span><br><span class="line">        println(<span class="string">&quot;done4&quot;</span>)    <span class="comment">// 没机会执行</span></span><br><span class="line">        <span class="string">&quot;result4&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred5 = async &#123;</span><br><span class="line">        delay(<span class="number">14000L</span>)</span><br><span class="line">        println(<span class="string">&quot;done5&quot;</span>)    <span class="comment">// 没机会执行</span></span><br><span class="line">        <span class="string">&quot;result5&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = fastest(deferred1, deferred2, deferred3, deferred4, deferred5)</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">done2</span></span><br><span class="line"><span class="comment">result2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所以，借助这样的方式，我们不仅可以通过 async 并发执行协程，也可以借助 select 得到最快的结果，而且，还可以避免不必要的资源浪费。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好，这节课的内容就到这儿了，我们来做一个简单的总结。</p><ul><li>select，就是选择“更快的结果”。</li><li>当 select 与 async、Channel 搭配以后，我们可以并发执行协程任务，以此大大提升程序的执行效率甚至用户体验，并且还可以改善程序的扩展性、灵活性。</li><li>关于 select 的 API，我们完全不需要去刻意记忆，只需要在 Deferred、Channel 的 API 基础上加上 on 这个前缀即可。</li><li>最后，我们还结合实战，分析了 select 与 async 产生太多并发协程的时候，还可以定义一个类似 fastest() 的方法，去统一取消剩余的协程任务。这样的做法，就可以大大节省计算资源，从而平衡性能与功耗。</li></ul><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/5c/5b/5c3e1e2b9e00c367e413428d40994f5b.jpg?wh=2000x853" alt="img"></p><p>其实，和 Kotlin 的 Channel 一样，select 并不是 Kotlin 独创的概念。select 在很多编程语言当中都有类似的实现，比如 Go、Rust，等等。在这些计算机语言当中，select 的语法可能与 Kotlin 的不太一样，但背后的核心理念都是“选择更快的结果”。</p><p>所以，只要你掌握了 Kotlin 的 select，今后学习其他编程语言的 select，都不再是问题。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>前面我们已经说过，select 的 API，只需要在 Deferred、Channel 原本 API 的基础上加一个 on 前缀即可。比如 onAwait{}。那么，你有没有觉得它跟我们前面学的 onStart{}、onCompletion{} 之类的回调 API 很像？</p><p>你能从中悟出 select 的实现原理吗？ 欢迎在留言区说说你的想法，也欢迎你把今天的内容分享给更多的朋友。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(协程篇)20  Flow：为什么说Flow是“冷”的？</title>
      <link href="/posts/e7c23ba1/"/>
      <url>/posts/e7c23ba1/</url>
      
        <content type="html"><![CDATA[<p>今天我们来学习 Kotlin 协程 Flow 的基础知识。</p><p>Flow，可以说是在 Kotlin 协程当中自成体系的知识点。<strong>Flow 极其强大、极其灵活</strong>，在它出现之前，业界还有很多质疑 Kotlin 协程的声音，认为 Kotlin 的挂起函数、结构化并发，并不足以形成核心竞争力，在异步、并发任务的领域，RxJava 可以做得更好。</p><p>但是，随着 2019 年 Kotlin 推出 Flow 以后，这样的质疑声就渐渐没有了。有了 Flow 以后，Kotlin 的协程已经没有明显的短板了。简单的异步场景，我们可以直接使用挂起函数、launch、async；至于复杂的异步场景，我们就可以使用 Flow。</p><p>实际上，在很多技术领域，Flow 已经开始占领 RxJava 原本的领地，在 Android 领域，Flow 甚至还要取代原本 LiveData 的地位。因为，Flow 是真的香啊！</p><p>接下来，我们就一起来学习 Flow。</p><h2 id="Flow-就是“数据流”"><a href="#Flow-就是“数据流”" class="headerlink" title="Flow 就是“数据流”"></a>Flow 就是“数据流”</h2><p>Flow 这个单词有“流”的意思，比如 Cash Flow 代表了“现金流”；Traffic Flow 代表了“车流”；Flow 在 Kotlin 协程当中，其实就是“数据流”的意思。因为 Flow 当中“流淌”的，都是数据。</p><p>为了帮你建立思维模型，我做了一个动图，来描述 Flow 的行为模式。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/d3/81/d3138d1386ef7c863086fe9fdcbc0a81.gif?wh=1080x495" alt="img"></p><p>可以看到，Flow 和我们上节课学习的 Channel 不一样，Flow 并不是只有“发送”“接收”两个行为，它当中流淌的数据是<strong>可以在中途改变</strong>的。</p><p>Flow 的数据发送方，我们称之为“上游”；数据接收方称之为“下游”。跟现实生活中一样，上下游其实也是相对的概念。比如我们可以看到下面的图，对于中转站 2 来说，中转站 1 就相当于它的上游。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/ff/31/ffb1b4f8256ae249108d60600947c031.jpg?wh=2000x1125" alt="img"></p><p>另外我们也可以看到，在发送方、接收方的中间，是可以有多个“中转站”的。在这些中转站里，我们就可以对数据进行一些处理了。</p><p>其实，Flow 这样的数据模型，在现实生活中也存在，比如说长江，它有发源地和下游，中间还有很多大坝、水电站，甚至还有一些污水净化厂。</p><p>好，相信你现在对 Flow 已经有比较清晰的概念了。下面我们来看一段代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flow &#123;                  <span class="comment">// 上游，发源地</span></span><br><span class="line">        emit(<span class="number">1</span>)             <span class="comment">// 挂起函数</span></span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">        emit(<span class="number">4</span>)</span><br><span class="line">        emit(<span class="number">5</span>)</span><br><span class="line">    &#125;.filter &#123; it &gt; <span class="number">2</span> &#125;     <span class="comment">// 中转站1</span></span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;     <span class="comment">// 中转站2</span></span><br><span class="line">        .take(<span class="number">2</span>)            <span class="comment">// 中转站3</span></span><br><span class="line">        .collect&#123;           <span class="comment">// 下游</span></span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：                       </span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果你结合着之前的图片来分析这段代码的话，相信马上就能分析出它的执行结果。因为 Flow 的这种<strong>链式调用</strong>的 API，本身就非常符合人的阅读习惯。</p><p>而且，Flow 写出来的代码非常清晰易懂，我们可以对照前面的示意图来看一下：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/a0/f6/a0a912dfffebb66f428d2b8789a914f6.jpg?wh=2000x1125" alt="img"></p><p>说实话，Flow 这样代码模式，谁不爱呢？我们可以来简单分析一下：</p><ul><li>**flow{}**，是一个高阶函数，它的作用就是创建一个新的 Flow。在它的 Lambda 当中，我们可以使用 emit() 这个挂起函数往下游发送数据，这里的 emit 其实就是“发射”“发送”的意思。上游创建了一个“数据流”，同时也要负责发送数据。这跟现实生活也是一样的：长江里的水从上游产生，这是天经地义的。所以，对于上游而言，只需要创建 Flow，然后发送数据即可，其他的都交给中转站和下游。</li><li><strong>filter{}、map{}、take(2)<strong>，它们是</strong>中间操作符</strong>，就像中转站一样，它们的作用就是对数据进行处理，这很好理解。Flow 最大的优势，就是它的操作符跟集合操作符高度一致。只要你会用 List、Sequence，那你就可以快速上手 Flow 的操作符，这中间几乎没有额外的学习成本。</li><li>collect{}，也被称为<strong>终止操作符</strong>或者<strong>末端操作符</strong>，它的作用其实只有一个：终止 Flow 数据流，并且接收这些数据。</li></ul><p>除了使用 flow{} 创建 Flow 以外，我们还可以使用 <strong>flowOf()</strong> 这个函数。所以，从某种程度上讲，Flow 跟 Kotlin 的集合其实也是有一些相似之处的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).filter &#123; it &gt; <span class="number">2</span> &#125;</span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).filter &#123; it &gt; <span class="number">2</span> &#125;</span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .forEach &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以看到 Flow API 与集合 API 之间的共性。listOf 创建 List，flowOf 创建 Flow。遍历 List，我们使用 forEach{}；遍历 Flow，我们使用 collect{}。</p><p>在某些场景下，我们甚至可以把 Flow 当做集合来使用，或者反过来，把集合当做 Flow 来用。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// Flow转List</span></span><br><span class="line">    flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .toList()</span><br><span class="line">        .filter &#123; it &gt; <span class="number">2</span> &#125;</span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .forEach &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// List转Flow</span></span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .asFlow()</span><br><span class="line">        .filter &#123; it &gt; <span class="number">2</span> &#125;</span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们使用了 Flow.toList()、List.asFlow() 这两个扩展函数，让数据在 List、Flow 之间来回转换，而其中的代码甚至不需要做多少改变。</p><p>到这里，我其实已经给你介绍了三种创建 Flow 的方式，我来帮你总结一下。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/7a/2e/7a0a85927254e66e4847c17de49d052e.jpg?wh=2000x697" alt="img"></p><p>好，现在我们就对 Flow 有一个整体的认识了，我们知道它的 API 总体分为三个部分：上游、中间操作、下游。其中对于上游来说，一般有三种创建方式，这些我们也都需要好好掌握。</p><p>那么接下来，我们重点看看中间操作符。</p><h2 id="中间操作符"><a href="#中间操作符" class="headerlink" title="中间操作符"></a>中间操作符</h2><p>中间操作符（Intermediate Operators），除了之前提到的 map、filter、take 这种从集合那边“抄”来的操作符之外，还有一些特殊的操作符需要我们特别注意。这些操作符跟 Kotlin 集合 API 是没关系的，它们是<strong>专门为 Flow 设计的</strong>。我们一个个来看。</p><h2 id="Flow-生命周期"><a href="#Flow-生命周期" class="headerlink" title="Flow 生命周期"></a>Flow 生命周期</h2><p>在 Flow 的中间操作符当中，<strong>onStart、onCompletion</strong> 这两个是比较特殊的。它们是以操作符的形式存在，但实际上的作用，是监听生命周期回调。</p><p>onStart，它的作用是注册一个监听事件：当 flow 启动以后，它就会被回调。具体我们可以看下面这个例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .filter &#123;</span><br><span class="line">            println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .map &#123;</span><br><span class="line">            println(<span class="string">&quot;map: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .onStart &#123; println(<span class="string">&quot;onStart&quot;</span>) &#125; <span class="comment">// 注意这里</span></span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">onStart</span></span><br><span class="line"><span class="comment">filter: 1</span></span><br><span class="line"><span class="comment">filter: 2</span></span><br><span class="line"><span class="comment">filter: 3</span></span><br><span class="line"><span class="comment">map: 3</span></span><br><span class="line"><span class="comment">collect: 6</span></span><br><span class="line"><span class="comment">filter: 4</span></span><br><span class="line"><span class="comment">map: 4</span></span><br><span class="line"><span class="comment">collect: 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，onStart 的执行顺序，并不是严格按照上下游来执行的。虽然 onStart 的位置是处于下游，而 filter、map、take 是上游，但 onStart 是最先执行的。因为它本质上是一个回调，不是一个数据处理的中间站。</p><p>相应的，filter、map、take 这类操作符，它们的执行顺序是跟它们的位置相关的。最终的执行结果，也会受到位置变化的影响。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .take(<span class="number">2</span>) <span class="comment">// 注意这里</span></span><br><span class="line">        .filter &#123;</span><br><span class="line">            println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .map &#123;</span><br><span class="line">            println(<span class="string">&quot;map: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onStart &#123; println(<span class="string">&quot;onStart&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">onStart</span></span><br><span class="line"><span class="comment">filter: 1</span></span><br><span class="line"><span class="comment">filter: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可见，在以上代码中，我们将 take(2) 的位置挪到了上游的起始位置，这时候程序的执行结果就完全变了。</p><p>OK，理解了 onStart 以后，onCompletion 也就很好理解了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .onCompletion &#123; println(<span class="string">&quot;onCompletion&quot;</span>) &#125; <span class="comment">// 注意这里</span></span><br><span class="line">        .filter &#123;</span><br><span class="line">            println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">filter: 1</span></span><br><span class="line"><span class="comment">filter: 2</span></span><br><span class="line"><span class="comment">filter: 3</span></span><br><span class="line"><span class="comment">collect: 3</span></span><br><span class="line"><span class="comment">filter: 4</span></span><br><span class="line"><span class="comment">collect: 4</span></span><br><span class="line"><span class="comment">onCompletion</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>和 onStart 类似，onCompletion 的执行顺序，跟它在 Flow 当中的位置无关。onCompletion 只会在 Flow 数据流执行完毕以后，才会回调。</p><p>还记得在第 16 讲里，我们提到的 Job.invokeOnCompletion{} 这个生命周期回调吗？在这里，Flow.onCompletion{} 也是类似的，onCompletion{} 在面对以下三种情况时都会进行回调:</p><ul><li>情况 1，Flow 正常执行完毕；</li><li>情况 2，Flow 当中出现异常；</li><li>情况 3，Flow 被取消。</li></ul><p>对于情况 1，我们已经在上面的代码中验证过了。接下来，我们看看后面两种情况：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        flow &#123;</span><br><span class="line">            emit(<span class="number">1</span>)</span><br><span class="line">            emit(<span class="number">2</span>)</span><br><span class="line">            emit(<span class="number">3</span>)</span><br><span class="line">        &#125;.onCompletion &#123; println(<span class="string">&quot;onCompletion first: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">            .collect &#123;</span><br><span class="line">                println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> (it == <span class="number">2</span>) &#123;</span><br><span class="line">                    cancel()            <span class="comment">// 1</span></span><br><span class="line">                    println(<span class="string">&quot;cancel&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">100L</span>)</span><br><span class="line"></span><br><span class="line">    flowOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        .onCompletion &#123; println(<span class="string">&quot;onCompletion second: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            <span class="comment">// 仅用于测试，生产环境不应该这么创建异常</span></span><br><span class="line">            <span class="keyword">throw</span> IllegalStateException() <span class="comment">// 2</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">collect: 1</span></span><br><span class="line"><span class="comment">collect: 2</span></span><br><span class="line"><span class="comment">cancel</span></span><br><span class="line"><span class="comment">onCompletion first: JobCancellationException: // 3</span></span><br><span class="line"><span class="comment">collect: 4</span></span><br><span class="line"><span class="comment">onCompletion second: IllegalStateException    // 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的注释 1 当中，我们在 collect{} 里调用了 cancel 方法，这会取消掉整个 Flow，这时候，flow{} 当中剩下的代码将不会再被执行。最后，onCompletion 也会被调用，同时，请你留意注释 3，这里还会带上对应的异常信息 JobCancellationException。</p><p>同样的，根据注释 2、4，我们也能分析出一样的结果。</p><p>而且从上面的代码里，我们也可以看到，当 Flow 当中发生异常以后，Flow 就会终止。那么对于这样的问题，我们该如何处理呢？</p><p>下面我就带你来看看，Flow 当中如何处理异常。</p><h2 id="catch-异常处理"><a href="#catch-异常处理" class="headerlink" title="catch 异常处理"></a>catch 异常处理</h2><p>前面我已经介绍过，Flow 主要有三个部分：上游、中间操作、下游。那么，Flow 当中的异常，也可以根据这个标准来进行分类，也就是异常发生的位置。</p><p>对于发生在上游、中间操作这两个阶段的异常，我们可以直接使用 <strong>catch</strong> 这个操作符来进行捕获和进一步处理。如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> flow = flow &#123;</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flow.map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;catch: <span class="variable">$it</span>&quot;</span>) &#125; <span class="comment">// 注意这里</span></span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">catch: java.lang.IllegalStateException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所以，catch 这个操作符，其实就相当于我们平时使用的 try-catch 的意思。只是说，后者是用于普通的代码，而前者是用于 Flow 数据流的，两者的核心理念是一样的。不过，考虑到 Flow 具有上下游的特性，catch 这个操作符的作用是<strong>和它的位置</strong>强相关的。</p><p><strong>catch 的作用域，仅限于 catch 的上游</strong>。换句话说，发生在 catch 上游的异常，才会被捕获，发生在 catch 下游的异常，则不会被捕获。为此，我们可以换一个写法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> flow = flow &#123;</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flow.map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .filter &#123; it / <span class="number">0</span> &gt; <span class="number">1</span>&#125;  <span class="comment">// 故意制造异常</span></span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从上面代码的执行结果里，我们可以看到，catch 对于发生在它下游的异常是无能为力的。这一点，借助我们之前的思维模型来思考，也是非常符合直觉的。比如说，长江上面的污水处理厂，当然只能处理它上游的水，而对于发生在下游的污染，是无能为力的。</p><p>那么，发生在上游源头，还有发生在中间操作的异常，处理起来其实很容易，我们只需要留意 catch 的作用域即可。最后就是发生在下游末尾处的异常了。</p><p>如果你回过头去看代码段 7 当中的异常，会发现它也是一个典型的“发生在下游的异常”，所以对于这种情况，我们就不能用 catch 操作符了。那么最简单的办法，其实是使用 <strong>try-catch</strong>，把 collect{} 当中可能出现问题的代码包裹起来。比如像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flowOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        .onCompletion &#123; println(<span class="string">&quot;onCompletion second: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                println(<span class="string">&quot;Catch <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，针对 Flow 当中的异常处理，我们主要有两种手段：一个是 catch 操作符，它主要用于上游异常的捕获；而 try-catch 这种传统的方式，更多的是应用于下游异常的捕获。</p><p><code>提示：关于更多协程异常处理的话题，我们会在第 23 讲深入介绍。</code></p><h2 id="切换-Context：flowOn、launchIn"><a href="#切换-Context：flowOn、launchIn" class="headerlink" title="切换 Context：flowOn、launchIn"></a>切换 Context：flowOn、launchIn</h2><p>前面我们介绍过，Flow 非常适合复杂的异步任务。在大部分的异步任务当中，我们都需要频繁切换工作的线程。对于耗时任务，我们需要线程池当中执行，对于 UI 任务，我们需要在主线程执行。</p><p>而在 Flow 当中，我们借助 <strong>flowOn</strong> 这一个操作符，就可以灵活实现以上的需求。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> flow = flow &#123;</span><br><span class="line">        logX(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        logX(<span class="string">&quot;Emit: 1&quot;</span>)</span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line">        logX(<span class="string">&quot;Emit: 2&quot;</span>)</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">        logX(<span class="string">&quot;Emit: 3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flow.filter &#123;</span><br><span class="line">            logX(<span class="string">&quot;Filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .flowOn(Dispatchers.IO)  <span class="comment">// 注意这里</span></span><br><span class="line">        .collect &#123;</span><br><span class="line">            logX(<span class="string">&quot;Collect <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Filter: 1</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Emit: 1</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Filter: 2</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Emit: 2</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Filter: 3</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Emit: 3</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Collect 3</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br></pre></td></tr></table></figure><p>flowOn 操作符也是和它的位置强相关的。它的作用域跟前面的 catch 类似：<strong>flowOn 仅限于它的上游</strong>。</p><p>在上面的代码中，flowOn 的上游，就是 flow{}、filter{} 当中的代码，所以，它们的代码全都运行在 DefaultDispatcher 这个线程池当中。只有 collect{} 当中的代码是运行在 main 线程当中的。</p><p>对应的，如果你挪动一下上面代码中 flowOn 的位置，会发现执行结果就会不一样，比如这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line">flow.flowOn(Dispatchers.IO) <span class="comment">// 注意这里</span></span><br><span class="line">    .filter &#123;</span><br><span class="line">        logX(<span class="string">&quot;Filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it &gt; <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    .collect &#123;</span><br><span class="line">        logX(<span class="string">&quot;Collect <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">filter当中的代码会执行在main线程</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这里的代码执行结果，我们很容易就能推测出来，因为 flowOn 的作用域仅限于上游，所以它只会让 flow{} 当中的代码运行在 DefaultDispatcher 当中，剩下的代码则执行在 main 线程。</p><p>但是到这里，我们就会遇到一个类似 catch 的困境：如果想要指定 collect 当中的 Context，该怎么办呢？</p><p>我们能想到的最简单的办法，就是用前面学过的：**withContext{}**。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">flow.flowOn(Dispatchers.IO)</span><br><span class="line">    .filter &#123;</span><br><span class="line">        logX(<span class="string">&quot;Filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it &gt; <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    .collect &#123;</span><br><span class="line">        withContext(mySingleDispatcher) &#123;</span><br><span class="line">            logX(<span class="string">&quot;Collect <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">collect&#123;&#125;将运行在MySingleThread</span></span><br><span class="line"><span class="comment">filter&#123;&#125;运行在main</span></span><br><span class="line"><span class="comment">flow&#123;&#125;运行在DefaultDispatcher</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们直接在 collect{} 里使用了 withContext{}，所以它的执行就交给了 MySingleThread。不过，有的时候，我们想要改变除了 flowOn 以外所有代码的 Context。比如，我们希望 collect{}、filter{} 都运行在 MySingleThread。</p><p>那么这时候，我们可以考虑使用 withContext{} 进一步<strong>扩大包裹的范围</strong>，就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">withContext(mySingleDispatcher) &#123;</span><br><span class="line">    flow.flowOn(Dispatchers.IO)</span><br><span class="line">        .filter &#123;</span><br><span class="line">            logX(<span class="string">&quot;Filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .collect&#123;</span><br><span class="line">            logX(<span class="string">&quot;Collect <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">collect&#123;&#125;将运行在MySingleThread</span></span><br><span class="line"><span class="comment">filter&#123;&#125;运行在MySingleThread</span></span><br><span class="line"><span class="comment">flow&#123;&#125;运行在DefaultDispatcher</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>不过，这种写法终归是有些丑陋，因此，Kotlin 官方还为我们提供了另一个操作符，<strong>launchIn</strong>。</p><p>我们来看看这个操作符是怎么用的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(mySingleDispatcher)</span><br><span class="line">flow.flowOn(Dispatchers.IO)</span><br><span class="line">    .filter &#123;</span><br><span class="line">        logX(<span class="string">&quot;Filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it &gt; <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    .onEach &#123;</span><br><span class="line">        logX(<span class="string">&quot;onEach <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .launchIn(scope)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">onEach&#123;&#125;将运行在MySingleThread</span></span><br><span class="line"><span class="comment">filter&#123;&#125;运行在MySingleThread</span></span><br><span class="line"><span class="comment">flow&#123;&#125;运行在DefaultDispatcher</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，在这段代码中，我们不再直接使用 collect{}，而是借助了 onEach{} 来实现类似 collect{} 的功能。同时我们在最后使用了 launchIn(scope)，把它上游的代码都分发到指定的线程当中。</p><p>如果你去看 launchIn 的源代码的话，你会发现它的定义极其简单：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">launchIn</span><span class="params">(scope: <span class="type">CoroutineScope</span>)</span></span>: Job = scope.launch &#123;</span><br><span class="line">    collect() <span class="comment">// tail-call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，launchIn 从严格意义来讲，应该算是一个下游的终止操作符，因为它本质上是调用了 collect()。</p><p>因此，上面的代码段 16，也会等价于下面的写法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段17</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(mySingleDispatcher)</span><br><span class="line">    <span class="keyword">val</span> flow = flow &#123;</span><br><span class="line">        logX(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        logX(<span class="string">&quot;Emit: 1&quot;</span>)</span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line">        logX(<span class="string">&quot;Emit: 2&quot;</span>)</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">        logX(<span class="string">&quot;Emit: 3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">        .flowOn(Dispatchers.IO)</span><br><span class="line">        .filter &#123;</span><br><span class="line">            logX(<span class="string">&quot;Filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onEach &#123;</span><br><span class="line">            logX(<span class="string">&quot;onEach <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    scope.launch &#123; <span class="comment">// 注意这里</span></span><br><span class="line">        flow.collect()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    delay(<span class="number">100L</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，总的来说，对于 Flow 当中的线程切换，我们可以使用 flowOn、launchIn、withContext，但其实，flowOn、launchIn 就已经可以满足需求了。</p><p>另外，由于 Flow 当中直接使用 withContext 是很容易引发其他问题的，因此，<strong>withContext 在 Flow 当中是不被推荐的，即使要用，也应该谨慎再谨慎</strong>。</p><p><code>提示：针对 Flow 当中 withContext 引发的问题，我会在这节课的思考题里给出具体案例。</code></p><h2 id="下游：终止操作符"><a href="#下游：终止操作符" class="headerlink" title="下游：终止操作符"></a>下游：终止操作符</h2><p>最后，我们就到了下游阶段，我们来看看终止操作符（Terminal Operators）的含义和使用.</p><p><code>这里的 Terminal，其实有终止、末尾、终点的意思。</code></p><p>在 Flow 当中，终止操作符的意思就是终止整个 Flow 流程的操作符。这里的“终止”，其实是跟前面的“中间”操作符对应的。</p><p>具体来说，就是在 filter 操作符的后面，还可以继续添加其他的操作符，比如说 map，因为 filter 本身就是一个“中间”操作符。但是，collect 操作符之后，我们无法继续使用 map 之类的操作，因为 collect 是一个“终止”操作符，代表 Flow 数据流的终止。</p><p>Flow 里面，最常见的终止操作符就是 collect。除此之外，还有一些从集合当中“抄”过来的操作符，也是 Flow 的终止操作符。比如 first()、single()、fold{}、reduce{}。</p><p>另外，当我们尝试将 Flow 转换成集合的时候，它本身也就意味着 Flow 数据流的终止。比如说，我们前面用过的 toList：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段18</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// Flow转List</span></span><br><span class="line">    flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .toList()           <span class="comment">// 注意这里</span></span><br><span class="line">        .filter &#123; it &gt; <span class="number">2</span> &#125;</span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .forEach &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，当我们调用了 toList() 以后，往后所有的操作符，都不再是 Flow 的 API 调用了，虽然它们的名字没有变，filter、map，这些都只是集合的 API。所以，严格意义上讲，toList 也算是一个终止操作符。</p><h2 id="为什么说-Flow-是“冷”的？"><a href="#为什么说-Flow-是“冷”的？" class="headerlink" title="为什么说 Flow 是“冷”的？"></a>为什么说 Flow 是“冷”的？</h2><p>现在我们就算是把 Flow 这个 API 给搞清楚了，但还有一个疑问我们没解决，就是这节课的标题：为什么说 Flow 是“冷”的？</p><p>实际上，如果你理解了上节课 Channel 为什么是“热”的，那你就一定可以理解 Flow 为什么是“冷”的。我们可以模仿上节课的 Channel 代码，写一段 Flow 的代码，两相对比之下其实马上就能发现它们之间的差异了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段19</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 冷数据流</span></span><br><span class="line">    <span class="keyword">val</span> flow = flow &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            println(<span class="string">&quot;Before send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            emit(it)</span><br><span class="line">            println(<span class="string">&quot;Send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 热数据流</span></span><br><span class="line">    <span class="keyword">val</span> channel = produce&lt;<span class="built_in">Int</span>&gt;(capacity = <span class="number">0</span>) &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            println(<span class="string">&quot;Before send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            send(it)</span><br><span class="line">            println(<span class="string">&quot;Send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Before send 1</span></span><br><span class="line"><span class="comment">// Flow 当中的代码并未执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们知道，Channel 之所以被认为是“热”的原因，是因为<strong>不管有没有接收方，发送方都会工作</strong>。那么对应的，Flow 被认为是“冷”的原因，就是因为<strong>只有调用终止操作符之后，Flow 才会开始工作</strong>。</p><p><em><strong>Flow 还是“懒”的</strong></em></p><p>其实，如果你去仔细调试过代码段 1 的话，应该就已经发现了，Flow 不仅是“冷”的，它还是“懒”的。为了暴露出它的这个特点，我们稍微改造一下代码段 1，然后加一些日志进来。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flow &#123;</span><br><span class="line">        println(<span class="string">&quot;emit: 3&quot;</span>)</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">        println(<span class="string">&quot;emit: 4&quot;</span>)</span><br><span class="line">        emit(<span class="number">4</span>)</span><br><span class="line">        println(<span class="string">&quot;emit: 5&quot;</span>)</span><br><span class="line">        emit(<span class="number">5</span>)</span><br><span class="line">    &#125;.filter &#123;</span><br><span class="line">        println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it &gt; <span class="number">2</span></span><br><span class="line">    &#125;.map &#123;</span><br><span class="line">        println(<span class="string">&quot;map: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it * <span class="number">2</span></span><br><span class="line">    &#125;.collect &#123;</span><br><span class="line">        println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">emit: 3</span></span><br><span class="line"><span class="comment">filter: 3</span></span><br><span class="line"><span class="comment">map: 3</span></span><br><span class="line"><span class="comment">collect: 6</span></span><br><span class="line"><span class="comment">emit: 4</span></span><br><span class="line"><span class="comment">filter: 4</span></span><br><span class="line"><span class="comment">map: 4</span></span><br><span class="line"><span class="comment">collect: 8</span></span><br><span class="line"><span class="comment">emit: 5</span></span><br><span class="line"><span class="comment">filter: 5</span></span><br><span class="line"><span class="comment">map: 5</span></span><br><span class="line"><span class="comment">collect: 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>通过上面的运行结果，我们可以发现，Flow 一次只会处理一条数据。虽然它也是 Flow“冷”的一种表现，但这个特性准确来说是“懒”。</p><p>如果你结合上节课“服务员端茶送水”的场景来思考的话，Flow 不仅是一个“冷淡”的服务员，还是一个“懒惰”的服务员：明明饭桌上有 3 个人需要喝水，但服务员偏偏不一次性上 3 杯水，而是要这 3 个人，每个人都叫服务员一次，服务员才会一杯一杯地送 3 杯水过来。</p><p>对比 Channel 的思维模型来看的话：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/4a/59/4aaae2c6b5e14c7ae938b630d2794e59.jpg?wh=2000x762" alt="img"></p><p><code>提示：Flow 默认情况下是“懒惰”的，但也可以通过配置让它“勤快”起来。</code></p><h2 id="思考与实战"><a href="#思考与实战" class="headerlink" title="思考与实战"></a>思考与实战</h2><p>我们都知道，Flow 非常适合复杂的异步任务场景。借助它的 flowOn、launchIn，我们可以写出非常灵活的代码。比如说，在 Android、Swing 之类的 UI 平台之上，我们可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段21</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadData</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">        repeat(<span class="number">3</span>)&#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">            emit(it)</span><br><span class="line">            logX(<span class="string">&quot;emit <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟Android、Swing的UI</span></span><br><span class="line">    <span class="keyword">val</span> uiScope = CoroutineScope(mySingleDispatcher)</span><br><span class="line"></span><br><span class="line">    loadData()</span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .flowOn(Dispatchers.IO) <span class="comment">// 1，耗时任务</span></span><br><span class="line">        .onEach &#123;</span><br><span class="line">            logX(<span class="string">&quot;onEach <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .launchIn(uiScope)      <span class="comment">// 2，UI任务</span></span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很容易理解，我们让耗时任务在 IO 线程池执行，更新 UI 则在 UI 线程。</p><p>如果结合我们前面学过的 Flow 操作符，我们还可以设计出更加有意思的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段22</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadData</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">        repeat(<span class="number">3</span>) &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">            emit(it)</span><br><span class="line">            logX(<span class="string">&quot;emit <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">(it: <span class="type">Int</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">showLoading</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;Show loading&quot;</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hideLoading</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;Hide loading&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> uiScope = CoroutineScope(mySingleDispatcher)</span><br><span class="line"></span><br><span class="line">    loadData()</span><br><span class="line">        .onStart &#123; showLoading() &#125;          <span class="comment">// 显示加载弹窗</span></span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .flowOn(Dispatchers.IO)</span><br><span class="line">        .<span class="keyword">catch</span> &#123; throwable -&gt;</span><br><span class="line">            println(throwable)</span><br><span class="line">            hideLoading()                   <span class="comment">// 隐藏加载弹窗</span></span><br><span class="line">            emit(-<span class="number">1</span>)                   <span class="comment">// 发生异常以后，指定默认值</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onEach &#123; updateUI(it) &#125;            <span class="comment">// 更新UI界面 </span></span><br><span class="line">        .onCompletion &#123; hideLoading() &#125;     <span class="comment">// 隐藏加载弹窗</span></span><br><span class="line">        .launchIn(uiScope)</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">10000L</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们通过监听 onStart、onCompletion 的回调事件，就可以实现 Loading 弹窗的显示和隐藏。而对于出现异常的情况，我们也可以在 catch{} 当中调用 emit()，给出一个默认值，这样就可以有效防止 UI 界面出现空白。</p><p>不得不说，以上代码的可读性是非常好的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课的内容到这里就差不多结束了，我们来做一个简单的总结。</p><ul><li>Flow，就是<strong>数据流</strong>。整个 Flow 的 API 设计，可以大致分为三个部分，上游的源头、中间操作符、下游终止操作符。</li><li>对于<strong>上游源头</strong>来说，它主要负责：创建 Flow，并且产生数据。而创建 Flow，主要有三种方式：flow{}、flowOf()、asFlow()。</li><li>对于<strong>中间操作符</strong>来说，它也分为几大类。第一类是从集合“抄”过来的操作符，比如 map、filter；第二类是生命周期回调，比如 onStart、onCompletion；第三类是功能型 API，比如说 flowOn 切换 Context、catch 捕获上游的异常。</li><li>对于<strong>下游的终止操作符</strong>，也是分为三大类。首先，就是 collect 这个最基础的终止操作符；其次，就是从集合 API“抄”过来的操作符，比如 fold、reduce；最后，就是 Flow 转换成集合的 API，比如说 flow.toList()。</li></ul><p>你也要清楚为什么我们说“Flow 是冷的”的原因，以及它对比 Channel 的优势和劣势。另外在课程里，我们还探索了 Flow 在 Android 里的实际应用场景，当我们将 Flow 与它的操作符灵活组合到一起的时候，就可以设计出可读性非常好的代码。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/74/1a/747837c1b0657ae4042fbce9eae75f1a.jpg?wh=2000x1306" alt="img"></p><p>其实，Flow 本身就是一个非常大的话题，能讲的知识点实在太多了。但考虑到咱们课程学习需要循序渐进，现阶段我只是从中挑选一些最重要、最关键的知识点来讲。更多 Flow 的高阶用法，等我们学完协程篇、源码篇之后，我会再考虑增加一些更高阶的内容进来。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>前面我曾提到过，Flow 当中直接使用 withContext{}，是很容易出现问题的，下面代码是其中的一种。请问你能解释其中的缘由吗？Kotlin 官方为什么要这么设计？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段23</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flow &#123;</span><br><span class="line">        withContext(Dispatchers.IO) &#123;</span><br><span class="line">            emit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .collect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">IllegalStateException: Flow invariant is violated</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个问题的答案，我会在第 32 讲介绍 Flow 源码的时候给出详细的解释。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin编程第一课--(协程篇)19  channel：为什么说channel是热的?</title>
      <link href="/posts/8f28ab97/"/>
      <url>/posts/8f28ab97/</url>
      
        <content type="html"><![CDATA[<p>前面我们学习的挂起函数、async，它们一次都只能返回一个结果。但在某些业务场景下，我们往往需要协程返回多个结果，比如微信等软件的 IM 通道接收的消息，或者是手机 GPS 定位返回的经纬度坐标需要实时更新。那么，在这些场景下，我们之前学习的协程知识就无法直接解决了。</p><p>而今天我要讲解的 Kotlin 协程中的 Channel，就是专门用来做这种事情的。类似的需求，如果我们不使用 Channel 而是用其他的并发手段配合集合来做的话，其实也能实现，但复杂度会大大增加。那么接下来，我们就一起来学习下 Channel。</p><h2 id="Channel-就是管道"><a href="#Channel-就是管道" class="headerlink" title="Channel 就是管道"></a>Channel 就是管道</h2><p>顾名思义，Channel 就是一个管道。我们可以用这个概念，先来建立一个思维模型：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/10/RqanlCzUek5PVdM.gif" alt="Channel"></p><p>Channel 这个管道的其中一端，是发送方；管道的另一端是接收方。而管道本身，则可以用来传输数据。</p><p>所以，我们根据上面的思维模型，很容易就能写出下面的代码。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 1，创建管道</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="comment">// 2，在一个单独的协程当中发送管道消息</span></span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            channel.send(it) <span class="comment">// 挂起函数</span></span><br><span class="line">            logX(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="comment">// 3，在一个单独的协程当中接收管道消息</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> channel) &#123;  <span class="comment">// 挂起函数</span></span><br><span class="line">            logX(<span class="string">&quot;Receive: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Receive: 1</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#3</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Send: 1</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Send: 2</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Receive: 2</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#3</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Receive: 3</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#3</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Send: 3</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">// 4，程序不会退出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>通过运行的结果，我们首先可以看到的就是：coroutine#2、coroutine#3，这两个协程是交替执行的。这段代码，其实和我们第 13 讲当中提到的“互相协作”的模式是类似的，两个协程会轮流执行。</p><p>我们还可以看出来，Channel 可以跨越不同的协程进行通信。我们是在“coroutine#1”当中创建的 Channel，然后分别在 coroutine#2、coroutine#3 当中使用 Channel 来传递数据。</p><p>另外在代码中，还有四个注释，我们一个个来看：</p><ul><li>注释 1，我们通过“Channel()”这样的方式，就可以创建一个管道。其中传入的泛型 Int，就代表了这个管道里面传递的数据类型。也就是说这里创建的 Channel，就是用于传递 Int 数据的。</li><li>注释 2，我们创建了一个新的协程，然后在协程当中调用了 send() 方法，发送数据到管道里。其中的 send() 方法是一个挂起函数。</li><li>注释 3，在另一个协程当中，我们通过遍历 channel，将管道当中的数据都取了出来。这里，我们使用的是 for 循环。</li><li>注释 4，通过运行结果，我们还可以发现一个细节，那就是程序在输出完所有的结果以后，并不会退出。主线程不会结束，整个程序还会处于运行状态。</li></ul><p>而如果要解决上面的问题，其实也不难，只需要加上一行代码即可：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            channel.send(it)</span><br><span class="line">            logX(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close() <span class="comment">// 变化在这里</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            logX(<span class="string">&quot;Receive: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，channel 其实也是一种<strong>协程资源</strong>，在用完 channel 以后，如果我们不去主动关闭它的话，是会造成不必要的资源浪费的。在上面的案例中，如果我们忘记调用“channel.close()”，程序将永远不会停下来。</p><p>现在，我们来看看创建 Channel 的源代码。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> <span class="title">Channel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    capacity: <span class="type">Int</span> = RENDEZVOUS,</span></span></span><br><span class="line"><span class="params"><span class="function">    onBufferOverflow: <span class="type">BufferOverflow</span> = BufferOverflow.SUSPEND,</span></span></span><br><span class="line"><span class="params"><span class="function">    onUndeliveredElement: ((<span class="type">E</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Channel&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们调用“Channel()”的时候，感觉像是在调用一个构造函数，但实际上它却只是一个普通的顶层函数。这个函数带有一个泛型参数 E，另外还有三个参数。</p><p>第一个参数，<strong>capacity</strong>，代表了管道的容量。这个也很好理解，我们日常生活中的管道，自身也是有容量的，即使接收方不将数据取走，管道本身也可以存储一些数据。而 Kotlin 的 Channel，在默认情况下是“RENDEZVOUS”，也就代表了 Channel 的容量为 0。</p><p><code>题外话：RENDEZVOUS 这个单词源自法语。它有约会、碰面的意思，我们可以理解为“发送方、接收方，不见不散”。</code></p><p>除此之外，capacity 还有其他几种情况，比如说：</p><ul><li>UNLIMITED，代表了无限容量；</li><li>CONFLATED，代表了容量为 1，新的数据会替代旧的数据；</li><li>BUFFERED，代表了具备一定的缓存容量，默认情况下是 64，具体容量由这个 VM 参数决定 “kotlinx.coroutines.channels.defaultBuffer”。</li></ul><p>第二个参数，<strong>onBufferOverflow</strong>，也就是指当我们指定了 capacity 的容量，等管道的容量满了时，Channel 的应对策略是怎么样的。这里，它主要有三种做法：</p><ul><li><p>SUSPEND，当管道的容量满了以后，如果发送方还要继续发送，我们就会挂起当前的 send() 方法。由于它是一个挂起函数，所以我们可以以非阻塞的方式，将发送方的执行流程<strong>挂起</strong>，等管道中有了空闲位置以后再<strong>恢复</strong>。</p></li><li><p>DROP_OLDEST，顾名思义，就是丢弃最旧的那条数据，然后发送新的数据；</p></li><li><p>DROP_LATEST，丢弃最新的那条数据。这里要注意，这个动作的含义是丢弃当前正准备发送的那条数据，而管道中的内容将维持不变。</p></li></ul><p>由于这部分有点抽象，我画了一张图，来描述上面的几种模式，你可以看看。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/10/PrARNautXmZ1ofg.jpg" alt="Channel策略"></p><p>在创建 Channel 的方法中，还有第三个参数，<strong>onUndeliveredElement</strong>，它其实相当于一个异常处理回调。当管道中的某些数据没有被成功接收的时候，这个回调就会被调用。</p><p>这里，为了让你对这三个参数有个更具体的认识，我们来看几个代码的案例。</p><p>案例 1：capacity &#x3D; UNLIMITED</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(capacity = Channel.Factory.UNLIMITED)</span><br><span class="line">    launch &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            channel.send(it)</span><br><span class="line">            println(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close() <span class="comment">// 变化在这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            println(<span class="string">&quot;Receive: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Send: 1</span></span><br><span class="line"><span class="comment">Send: 2</span></span><br><span class="line"><span class="comment">Send: 3</span></span><br><span class="line"><span class="comment">Receive: 1</span></span><br><span class="line"><span class="comment">Receive: 2</span></span><br><span class="line"><span class="comment">Receive: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上代码对比代码段 1，其实只改动了一点点。我们在创建 Channel 的时候，设置了 capacity &#x3D; Channel.Factory.UNLIMITED。不过，通过分析运行的结果，可以发现代码的运行顺序就跟之前完全不一样了。</p><p>对于发送方来说，由于 Channel 的容量是无限大的，所以发送方可以一直往管道当中塞入数据，等数据都塞完以后，接收方才开始接收。这跟之前的交替执行是不一样的。</p><p>好，接下来我们看看 capacity &#x3D; CONFLATED 的情况。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(capacity = Channel.Factory.CONFLATED)</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            channel.send(it)</span><br><span class="line">            println(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            println(<span class="string">&quot;Receive: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Send: 1</span></span><br><span class="line"><span class="comment">Send: 2</span></span><br><span class="line"><span class="comment">Send: 3</span></span><br><span class="line"><span class="comment">Receive: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，当设置 capacity &#x3D; CONFLATED 的时候，发送方也会一直发送数据，而且，对于接收方来说，它永远只能接收到最后一条数据。</p><p>我们再来看看 onBufferOverflow 的用法。其实，我们可以运用 onBufferOverflow 与 capacity，来实现 CONFLATED 的效果。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(</span><br><span class="line">        capacity = <span class="number">1</span>,</span><br><span class="line">        onBufferOverflow = BufferOverflow.DROP_OLDEST</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            channel.send(it)</span><br><span class="line">            println(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            println(<span class="string">&quot;Receive: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Send: 1</span></span><br><span class="line"><span class="comment">Send: 2</span></span><br><span class="line"><span class="comment">Send: 3</span></span><br><span class="line"><span class="comment">Receive: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从这个运行结果里，我们就可以看出来，其实 capacity &#x3D; 1, onBufferOverflow &#x3D; BufferOverflow.DROP_OLDEST，就代表了 capacity &#x3D; CONFLATED。</p><p>对应的，我们再来看看 onBufferOverflow &#x3D; BufferOverflow.DROP_LATEST 的情况。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(</span><br><span class="line">        capacity = <span class="number">3</span>,</span><br><span class="line">        onBufferOverflow = BufferOverflow.DROP_LATEST</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            channel.send(it)</span><br><span class="line">            println(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.send(<span class="number">4</span>) <span class="comment">// 被丢弃</span></span><br><span class="line">        println(<span class="string">&quot;Send: 4&quot;</span>)</span><br><span class="line">        channel.send(<span class="number">5</span>) <span class="comment">// 被丢弃</span></span><br><span class="line">        println(<span class="string">&quot;Send: 5&quot;</span>) </span><br><span class="line"></span><br><span class="line">        channel.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            println(<span class="string">&quot;Receive: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Send: 1</span></span><br><span class="line"><span class="comment">Send: 2</span></span><br><span class="line"><span class="comment">Send: 3</span></span><br><span class="line"><span class="comment">Send: 4</span></span><br><span class="line"><span class="comment">Send: 5</span></span><br><span class="line"><span class="comment">Receive: 1</span></span><br><span class="line"><span class="comment">Receive: 2</span></span><br><span class="line"><span class="comment">Receive: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>由此可见，onBufferOverflow &#x3D; BufferOverflow.DROP_LATEST 就意味着，当 Channel 容量满了以后，之后再继续发送的内容，就会直接被丢弃。</p><p>最后，我们来看看 onUndeliveredElement 这个参数的作用。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 无限容量的管道</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(Channel.UNLIMITED) &#123;</span><br><span class="line">        println(<span class="string">&quot;onUndeliveredElement = <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价这种写法</span></span><br><span class="line"><span class="comment">//    val channel = Channel&lt;Int&gt;(Channel.UNLIMITED, onUndeliveredElement = &#123; println(&quot;onUndeliveredElement = $it&quot;) &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入三个数据</span></span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">        channel.send(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出一个，剩下两个</span></span><br><span class="line">    channel.receive()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消当前channel</span></span><br><span class="line">    channel.cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">onUndeliveredElement = 2</span></span><br><span class="line"><span class="comment">onUndeliveredElement = 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，onUndeliveredElement 的作用，就是一个回调，当我们发送出去的 Channel 数据无法被接收方处理的时候，就可以通过 onUndeliveredElement 这个回调，来进行监听。</p><p>它的使用场景一般都是用于“接收方对数据是否被消费特别关心的场景”。比如说，我发送出去的消息，接收方是不是真的收到了？对于接收方没收到的信息，发送方就可以灵活处理了，比如针对这些没收到的消息，发送方可以先记录下来，等下次重新发送。</p><h2 id="Channel-关闭引发的问题"><a href="#Channel-关闭引发的问题" class="headerlink" title="Channel 关闭引发的问题"></a>Channel 关闭引发的问题</h2><p>在前面提到的代码段 1 里，由于我们忘记调用了 close()，所以会导致程序一直运行无法终止。这个问题其实是很严重的。我们有没有办法避免这个问题呢？</p><p>当然是有的。Kotlin 官方其实还为我们提供了另一种创建 Channel 的方式，也就是 <strong>produce{} 高阶函数</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> channel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = produce &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            send(it)</span><br><span class="line">            logX(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="comment">// 3，接收数据</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            logX(<span class="string">&quot;Receive: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，我们使用 produce{} 以后，就不用再去调用 close() 方法了，因为 produce{} 会自动帮我们去调用 close() 方法。具体的源码，我们会在源码篇的时候再去深入分析。不过，现在我们也可以通过代码来验证这一点。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 1，创建管道</span></span><br><span class="line">    <span class="keyword">val</span> channel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = produce &#123;</span><br><span class="line">        <span class="comment">// 发送3条数据</span></span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            send(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用4次receive()</span></span><br><span class="line">    channel.receive() <span class="comment">// 1</span></span><br><span class="line">    channel.receive() <span class="comment">// 2</span></span><br><span class="line">    channel.receive() <span class="comment">// 3</span></span><br><span class="line">    channel.receive() <span class="comment">// 异常</span></span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">ClosedReceiveChannelException: Channel was closed</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在前面所有的代码当中，我们都是以 for 循环来迭代 channel 当中的元素的，但实际上，channel 还有一个 <strong>receive() 方法</strong>，它是与 send(it) 对应的。在上面代码中，我们只调用了 3 次 send()，却调用 4 次 receive()。</p><p>当我们第 4 次调用 receive() 的时候，代码会抛出异常“ClosedReceiveChannelException”，这其实也代表：我们的 Channel 已经被关闭了。所以这也就说明了，produce {}确实会帮我们调用 close() 方法。不然的话，第 4 次 receive() 会被挂起，而不是抛出异常。</p><p>我们可以再写一段代码来验证下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channel: Channel&lt;<span class="built_in">Int</span>&gt; = Channel()</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            channel.send(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用4次receive()</span></span><br><span class="line">    channel.receive()       <span class="comment">// 1</span></span><br><span class="line">    println(<span class="string">&quot;Receive: 1&quot;</span>)</span><br><span class="line">    channel.receive()       <span class="comment">// 2</span></span><br><span class="line">    println(<span class="string">&quot;Receive: 2&quot;</span>)</span><br><span class="line">    channel.receive()       <span class="comment">// 3</span></span><br><span class="line">    println(<span class="string">&quot;Receive: 3&quot;</span>)</span><br><span class="line">    channel.receive()       <span class="comment">// 永远挂起</span></span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Receive: 1</span></span><br><span class="line"><span class="comment">Receive: 2</span></span><br><span class="line"><span class="comment">Receive: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可见，第 4 次调用 receive()，就会导致程序被永久挂起，后面的 logX(“end”) 是没有机会继续执行的。也就是说，我们<strong>直接使用 receive() 是很容易出问题的</strong>。这也是我在前面的代码中一直使用 for 循环，而没有用 receive() 的原因。</p><p>那么，有没有办法解决这个问题呢？如果你足够细心的话，你会发现 Channel 其实还有两个属性：isClosedForReceive、isClosedForSend。</p><p>这两个属性，就可以用来判断当前的 Channel 是否已经被关闭。由于 Channel 分为发送方和接收方，所以这两个参数也是针对这两者的。也就是说，对于发送方，我们可以使用“isClosedForSend”来判断当前的 Channel 是否关闭；对于接收方来说，我们可以用“isClosedForReceive”来判断当前的 Channel 是否关闭。</p><p>这时候，你也许就会想到用它们来改造前面的代码段 10。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 1，创建管道</span></span><br><span class="line">    <span class="keyword">val</span> channel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = produce &#123;</span><br><span class="line">        <span class="comment">// 发送3条数据</span></span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            send(it)</span><br><span class="line">            println(<span class="string">&quot;Send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用while循环判断isClosedForReceive</span></span><br><span class="line">    <span class="keyword">while</span> (!channel.isClosedForReceive) &#123;</span><br><span class="line">        <span class="keyword">val</span> i = channel.receive()</span><br><span class="line">        println(<span class="string">&quot;Receive <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Send 1</span></span><br><span class="line"><span class="comment">Receive 1</span></span><br><span class="line"><span class="comment">Receive 2</span></span><br><span class="line"><span class="comment">Send 2</span></span><br><span class="line"><span class="comment">Send 3</span></span><br><span class="line"><span class="comment">Receive 3</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上代码看起来是可以正常工作了。但是，我仍然不建议你用这种方式。因为，<strong>当你为管道指定了 capacity 以后，以上的判断方式将会变得不可靠</strong>！原因是目前的 1.6.0 版本的协程库，运行这样的代码会崩溃，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> channel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = produce(capacity = <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 变化在这里</span></span><br><span class="line">        (<span class="number">1.</span><span class="number">.300</span>).forEach &#123;</span><br><span class="line">            send(it)</span><br><span class="line">            println(<span class="string">&quot;Send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!channel.isClosedForReceive) &#123;</span><br><span class="line">        <span class="keyword">val</span> i = channel.receive()</span><br><span class="line">        println(<span class="string">&quot;Receive <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">// 省略部分</span></span><br><span class="line"><span class="comment">Receive 300</span></span><br><span class="line"><span class="comment">Send 300</span></span><br><span class="line"><span class="comment">ClosedReceiveChannelException: Channel was closed</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所以，最好不要用 **channel.receive()**。即使配合 isClosedForReceive 这个判断条件，我们直接调用 channel.receive() 仍然是一件非常危险的事情！</p><p>实际上，以上代码除了可以使用 for 循环以外，还可以使用 Kotlin 为我们提供的另一个高阶函数：**channel.consumeEach {}**。我们再来看一个例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = produce(capacity = <span class="number">3</span>) &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.300</span>).forEach &#123;</span><br><span class="line">            send(it)</span><br><span class="line">            println(<span class="string">&quot;Send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    channel.consumeEach &#123;</span><br><span class="line">        println(<span class="string">&quot;Receive <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">正常</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所以，当我们想要读取 Channel 当中的数据时，我们一定要使用 for 循环，或者是 channel.consumeEach {}，千万不要直接调用 channel.receive()。</p><p><code>补充：在某些特殊场景下，如果我们必须要自己来调用 channel.receive()，那么可以考虑使用 receiveCatching()，它可以防止异常发生。</code></p><h2 id="为什么说-Channel-是“热”的？"><a href="#为什么说-Channel-是“热”的？" class="headerlink" title="为什么说 Channel 是“热”的？"></a>为什么说 Channel 是“热”的？</h2><p>我们现在已经知道了，Channel 其实就是用来传递“数据流”的。注意，这里的数据流，指的是<strong>多个数据组合形成的流</strong>。前面挂起函数、async 返回的数据，就像是水滴一样，而 Channel 则像是自来水管当中的水流一样。</p><p>在业界一直有一种说法：Channel 是“热”的。也是因为这句话，在 Kotlin 当中，我们也经常把 Channel 称为“热数据流”。</p><p>这话我们乍一听，可能会有点懵。我们能直接把 Channel 想象成“热的自来水”吗？当然不能了。所以，为了对 Channel 的“热”有一个更具体的概念，我们可以来看一段代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 只发送不接受</span></span><br><span class="line">    <span class="keyword">val</span> channel = produce&lt;<span class="built_in">Int</span>&gt;(capacity = <span class="number">10</span>) &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            send(it)</span><br><span class="line">            println(<span class="string">&quot;Send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Send 1</span></span><br><span class="line"><span class="comment">Send 2</span></span><br><span class="line"><span class="comment">Send 3</span></span><br><span class="line"><span class="comment">程序结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个 Channel，管道的容量是 10，然后我们发送了 3 个数据。但你是否注意到了，在代码中并没有消费 Channel 当中的数据。所以，这种“<strong>不管有没有接收方，发送方都会工作</strong>”的模式，就是我们将其认定为“热”的原因。</p><p>这就有点像是一个热心的饭店服务员，不管你有没有提要求，服务员都会给你端茶送水，把茶水摆在你的饭桌上。当你想要喝水的时候，就可以直接从饭桌上拿了（当你想要数据的时候，就可以直接从管道里取出来了）。</p><p>又或者，你可以接着前面的水龙头的思维模型去思考，Channel 的发送方，其实就像是“自来水厂”，不管你是不是要用水，自来水厂都会把水送到你家门口的管道当中来。这样当你想要用水的时候，打开水龙头就会马上有水了。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/10/oyQI9ma2sHwXgtC.jpg" alt="Channel发送数据"></p><p>不过，也许你会想，是不是因为前面的代码中，设置了“capacity &#x3D; 10”的原因？如果设置成“capacity &#x3D; 0”，那 Channel 的发送方是不是就不会主动工作了？让我们来试试。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = produce&lt;<span class="built_in">Int</span>&gt;(capacity = <span class="number">0</span>) &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            println(<span class="string">&quot;Before send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            send(it)</span><br><span class="line">            println(<span class="string">&quot;Send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Befour send 1</span></span><br><span class="line"><span class="comment">程序将无法退出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>当我们把 capacity 改成 0 以后，可以看到 Channel 的发送方仍然是会工作的，只是说，在它调用 send() 方法的时候，由于接收方还未就绪，且管道容量为 0，所以它会被挂起。所以，它仍然还是有在工作的。最直接的证据就是：<strong>这个程序将无法退出，一直运行下去</strong>。这个后果是不是更加严重？</p><p>但是，总的来说，不管接收方是否存在，Channel 的发送方一定会工作。对应的，你可以想象成：虽然你的饭桌已经没有空间了，但服务员还是端来了茶水站在了你旁边，只是没有把茶水放在你桌上，等饭桌有了空间，或者你想喝水了，你就能马上喝到。</p><p>至于自来水的那个场景，你可以想象成，你家就在自来水厂的门口，你们之间的管道容量为 0，但这并不意味着自来水厂没有工作。</p><h2 id="思考与实战"><a href="#思考与实战" class="headerlink" title="思考与实战"></a>思考与实战</h2><p>其实，如果你去看 Channel 的源代码定义，你会发现，Channel 本身只是一个接口。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span>&lt;<span class="type">E</span>&gt; : <span class="type">SendChannel</span>&lt;<span class="type">E</span>&gt;, <span class="type">ReceiveChannel</span>&lt;<span class="type">E</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>而且，Channel 本身并没有什么方法和属性，它其实只是 SendChannel、ReceiveChannel 这两个接口的组合。也就是说，Channel 的所有能力，都是来自于 SendChannel、ReceiveChannel 这两个接口。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SendChannel</span>&lt;<span class="type">in E</span>&gt; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isClosedForSend: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(element: <span class="type">E</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1，select相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onSend: SelectClause2&lt;E, SendChannel&lt;E&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2，非挂起函数的接收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">trySend</span><span class="params">(element: <span class="type">E</span>)</span></span>: ChannelResult&lt;<span class="built_in">Unit</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">(cause: <span class="type">Throwable</span>? = <span class="literal">null</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnClose</span><span class="params">(handler: (<span class="type">cause</span>: <span class="type">Throwable</span>?) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReceiveChannel</span>&lt;<span class="type">out E</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isClosedForReceive: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">receive</span><span class="params">()</span></span>: E</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">receiveCatching</span><span class="params">()</span></span>: ChannelResult&lt;E&gt;</span><br><span class="line">    <span class="comment">// 3，select相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onReceive: SelectClause1&lt;E&gt;</span><br><span class="line">    <span class="comment">// 4，select相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onReceiveCatching: SelectClause1&lt;ChannelResult&lt;E&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5，非挂起函数的接收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">tryReceive</span><span class="params">()</span></span>: ChannelResult&lt;E&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: ChannelIterator&lt;E&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">(cause: <span class="type">CancellationException</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的源码中，大部分的接口我们其实已经见过了。只有 5 个我们还没见过：</p><ul><li>注释 1、3、4，它们是跟 select 相关的，我们会在第 21 讲介绍。</li><li>注释 2、5，是专门为非协程环境提供的 API，也就是说，当我们不在协程作用域的时候，也可以调用这两个方法来操作 Channel。不过大部分情况下，我们都应该优先使用挂起函数版本的 API。</li></ul><p>所以，如果说 Channel 是一个管道，那么 SendChannel、ReceiveChannel 就是组成这个管道的两个零件。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/10/ylexnN9uGCOYZqk.jpg" alt="img"></p><p>还记得我们在之前不变性思维当中提到的，对外暴露不变性集合的思路吗？其实对于 Channel 来说，我们也可以做到类似的事情。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChannelModel</span> &#123;</span><br><span class="line">    <span class="comment">// 对外只提供读取功能</span></span><br><span class="line">    <span class="keyword">val</span> channel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; <span class="keyword">by</span> ::_channel</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _channel: Channel&lt;<span class="built_in">Int</span>&gt; = Channel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            _channel.send(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> model = ChannelModel()</span><br><span class="line">    launch &#123;</span><br><span class="line">        model.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    model.channel.consumeEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是对于 Channel 来说，它的 send() 就相当于集合的写入 API，当我们想要做到“对写入封闭，对读取开放”的时候，就可以用之前学过的知识轻松做到。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/10/iBluzAso45WLV6x.jpg" alt="img"></p><p>而这一切，都得益于 Channel 的能力都是通过“组合”得来的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课的内容就到这里，我们来总结一下。</p><ul><li>Channel 是一个<strong>管道</strong>，当我们想要用协程传递多个数据组成的流的话，就没办法通过挂起函数、async 来实现了。这时候，Channel 是一个不错的选择。</li><li>我们可以通过 Channel() 这个顶层函数来创建 Channel 管道。在创建 Channel 的时候，有三个重要参数：capacity 代表了容量；onBufferOverflow 代表容量满了以后的应对策略；onUndeliveredElement 则是一个异常回调。在某些场景下，比如“<strong>发送方对于数据是否被接收方十分关心</strong>”的情况下，可以注册这个回调。</li><li>Channel 有两个关键的方法：send()、receive()，前者用于发送管道数据，后者用于接收管道数据。但是，由于 Channel 是存在关闭状态的，如果我们直接使用 receive()，就会导致各种问题。因此，对于管道数据的接收方来说，我们应该尽可能地使用 for 循环、consumeEach {}。</li><li>Channel 是“热”的。这是因为“不管有没有接收方，发送方都会工作”。</li><li>最后，我们也分析了 Channel 的源码定义，发现它其实是 SendChannel、ReceiveChannel 这两个接口的组合。而我们也可以借助它的这个特点，实现“对读取开放，对写入封闭”的设计。</li></ul><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/10/xlZfHiQ1B8vXTms.jpg" alt="img"></p><p>其实 Channel 也不是 Kotlin 独创的概念，在某些其他编程语言当中，也有这样的组件，最典型的就是 Go 语言。所以，当你学会 Kotlin 的 Channel，以后在别的语言中再遇到 Channel，或者是基于 Channel 的 Actor，你也就能快速地把 Kotlin 的知识迁移过去。</p><p>另外，学到这里相信你也发现了：编程语言里面的概念都是互通的。为什么有些人学习一门新的编程语言，可以特别快，还学得特别好？</p><p>原因往往就是，人家早已掌握了编程语言当中所有互通的概念。这就是所谓的<strong>触类旁通</strong>。学完这门课程以后，我相信，你也可以做到。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>请问，Channel 是“热”的，这一特点有什么坏处吗？为什么？ 欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(协程篇)题目解答  期中考试版本参考实现</title>
      <link href="/posts/aa27c6dc/"/>
      <url>/posts/aa27c6dc/</url>
      
        <content type="html"><![CDATA[<p>上节课我给你布置了一份考试题，你完成得怎么样了呢？这节课呢，我会来告诉你我是如何用 Kotlin 来做这个图片处理程序的，供你参考。</p><p>由于上节课我们已经做好了前期准备，所以这里我们直接写代码就行了。</p><h1 id="1-0-版本"><a href="#1-0-版本" class="headerlink" title="1.0 版本"></a>1.0 版本</h1><p>对于图片反转和裁切的这个问题，如果一开始你就去想象一个大图片，里面有几万个像素点，那你可能会被吓到。但是，如果你将数据规模缩小，再来分析的话，你会发现这个问题其实很简单。</p><p>这里，我们就以一张 4X4 像素的照片为例来分析一下。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/2f/20/2f31e490e0b973c9511e4aaa921f0520.jpg?wh=1498x646" alt="img"></p><p>这其实就相当于一个抽象的模型，如果我们基于这张 4X4 的照片，继续分析翻转和裁切，就会容易很多。我们可以来画一个简单的图形：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/b6/8d/b6a1a1f3b70b9b1a8132c51a92660d8d.jpg?wh=2000x814" alt="img"></p><p>上面这张图，从左到右分别是原图、横向翻转、纵向翻转、裁切。其中，翻转看起来是要复杂一些，而裁切是最简单的。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/64/c3/64001cb039dbcff66c4e9eec48dcf6c3.jpg?wh=2000x789" alt="img"></p><p>我们先来处理裁切。对于裁切，其实只需要将图片当中某个部分的像素拷贝到内存，然后存储成为一张新图片就行了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片裁切</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Image.<span class="title">crop</span><span class="params">(startY: <span class="type">Int</span>, startX: <span class="type">Int</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span>: Image &#123;</span><br><span class="line">    <span class="keyword">val</span> pixels = Array(height) &#123; y -&gt;</span><br><span class="line">        Array(width) &#123; x -&gt;</span><br><span class="line">            getPixel(startY + y, startX + x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Image(pixels)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，我们创建了一个新数组 pixels，它的创建方式是通过 Lambda 来实现的，而 Lambda 当中最关键的逻辑，就是 getPixel(startY + y, startX + x)，也就是从原图当中取像素点。</p><p>这代码是不是比你想象中简单很多？其实，图片的翻转也是一样的。只要我们能<strong>找出坐标的对应关系</strong>，代码也非常简单。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/7a/c8/7aeeb78bb0a4a6f8cb4a3308e2842fc8.jpg?wh=1633x880" alt="img"></p><p>可以看到，对于原图的 (1, 0) 这个像素点来说，它横向翻转以后就变成了 (2, 0)。所以，对于 (x, y) 坐标来说，横向翻转以后，就应该变成 (width-1-x, y)。找到这个对应关系以后，我们就直接抄代码了！</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 横向翻转图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Image.<span class="title">flipHorizontal</span><span class="params">()</span></span>: Image &#123;</span><br><span class="line">    <span class="keyword">val</span> pixels = Array(height()) &#123; y -&gt;</span><br><span class="line">        Array(width()) &#123; x -&gt;</span><br><span class="line">            getPixel(y, width() - <span class="number">1</span> - x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Image(pixels)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，以上这段代码几乎跟裁切是一模一样的，只是说，裁切要限制宽高，而翻转则是跟原图保持一致。</p><p>看到这里，相信你也马上就能想明白纵向翻转的代码该如何写了！</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/2e/1e/2e7ae2ec91856141ff2881ec2cdb441e.jpg?wh=1671x899" alt="img"></p><p>我们还是以 (1, 0) 这个像素点为例，在纵向翻转以后就变成了 (1, 3)，它们的转换规则是 (x, height-1-y)。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 纵向翻转图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Image.<span class="title">flipVertical</span><span class="params">()</span></span>: Image &#123;</span><br><span class="line">    <span class="keyword">val</span> pixels = Array(height()) &#123; y -&gt;</span><br><span class="line">        Array(width()) &#123; x -&gt;</span><br><span class="line">            getPixel(height() - <span class="number">1</span> - y, x) <span class="comment">// 改动这里</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Image(pixels)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，只要我们能找到中间的转换关系，纵向翻转的代码，只需要在横向翻转的基础上，改动一行即可。</p><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>其实针对图像算法的单元测试，我们最好的方式，就是准备一些现有的图片案例。比如说，我们随便找一张图，用其他的软件工具，对它进行翻转、裁切，然后存储起来。比如还是这四张图：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/85/d8/85f71d3914e23b7ed8664ae57f0e9fd8.png?wh=1128x424" alt="img"></p><p>我们可以把处理后的图片保存在单元测试的文件夹下，方便我们写对应的测试用例。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/47/d2/47ff01b7fd65dcf6e99e298be6e104d2.png?wh=478x327" alt="img"></p><p>那么，有了这些图片之后，我想你应该就能想到要怎么办了。这时候，你只需要写一个图片像素对比的方法 checkImageSame() 就好办了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkImageSame</span><span class="params">(picture: <span class="type">Image</span>, expected: <span class="type">Image</span>)</span></span> &#123;</span><br><span class="line">    assertEquals(picture.height(), expected.height())</span><br><span class="line">    assertEquals(picture.width(), expected.width())</span><br><span class="line">    <span class="keyword">for</span> (row <span class="keyword">in</span> <span class="number">0</span> until picture.height()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (column <span class="keyword">in</span> <span class="number">0</span> until picture.width()) &#123;</span><br><span class="line">            <span class="keyword">val</span> actualPixel = picture.getPixel(row, column)</span><br><span class="line">            <span class="keyword">val</span> expectedPixel = expected.getPixel(row, column)</span><br><span class="line">            assertEquals(actualPixel, expectedPixel)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，这个函数的思路也很简单，就是逐个对比两张图片之间的像素，看看它们是不是一样的，如果两张图所有的像素都一样，那肯定就是一样的。</p><p>有了这个方法以后，我们就可以快速实现单元测试代码了。整体流程大致如下：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/d3/a6/d37e162b313258fa01ed4f1a99d7d0a6.png?wh=1114x394" alt="img"></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testCrop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> image = loadImage(File(<span class="string">&quot;<span class="subst">$&#123;TEST_BASE_PATH&#125;</span>android.png&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> height = image.height() / <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> width = image.width() / <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> target = loadImage(File(<span class="string">&quot;<span class="subst">$&#123;TEST_BASE_PATH&#125;</span>android_half_crop.png&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> crop = image.crop(<span class="number">0</span>, <span class="number">0</span>, width, height)</span><br><span class="line">    checkImageSame(crop, target)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFlipVertical</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> origin = loadImage(File(<span class="string">&quot;<span class="subst">$&#123;TEST_BASE_PATH&#125;</span>android.png&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> target = loadImage(File(<span class="string">&quot;<span class="subst">$&#123;TEST_BASE_PATH&#125;</span>android_up_side_down.png&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> flipped = origin.flipVertical()</span><br><span class="line">    checkImageSame(flipped, target)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFlipHorizontal</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> origin = loadImage(File(<span class="string">&quot;<span class="subst">$&#123;TEST_BASE_PATH&#125;</span>android.png&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> target = loadImage(File(<span class="string">&quot;<span class="subst">$&#123;TEST_BASE_PATH&#125;</span>android_flipped.png&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> flipped = origin.flipHorizontal()</span><br><span class="line">    checkImageSame(flipped, target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了单元测试，我们就再也不用担心以后改代码的时候，不小心改出问题了。</p><p>好，那么到这里，1.0 版本就算是完成了。我们接着来看看 2.0 版本。</p><h1 id="2-0-版本"><a href="#2-0-版本" class="headerlink" title="2.0 版本"></a>2.0 版本</h1><p>2.0 版本的任务，我们需要支持下载网络上面的图片，并且还要能够存起来。由于这是一个比较耗时的操作，我们希望它是一个挂起函数。</p><p>关于下载 HTTP 的图片，其实，我们借助 OkHttp 就可以简单实现。下面我们来看看代码。</p><p><code>补充：为了不偏离主题，我们不考虑 HTTPS 的问题。</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">downloadSync</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logX(<span class="string">&quot;Download start!&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> okHttpClient = OkHttpClient().newBuilder()</span><br><span class="line">        .connectTimeout(<span class="number">10L</span>, TimeUnit.SECONDS)</span><br><span class="line">        .readTimeout(<span class="number">10L</span>, TimeUnit.SECONDS)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> request = Request.Builder().url(url).build()</span><br><span class="line">    <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> body = response.body</span><br><span class="line">    <span class="keyword">val</span> responseCode = response.code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (responseCode &gt;= HttpURLConnection.HTTP_OK &amp;&amp;</span><br><span class="line">        responseCode &lt; HttpURLConnection.HTTP_MULT_CHOICE &amp;&amp;</span><br><span class="line">        body != <span class="literal">null</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 1， 注意这里</span></span><br><span class="line">        body.byteStream().apply &#123;</span><br><span class="line">            outputFile.outputStream().use &#123; fileOut -&gt;</span><br><span class="line">                copyTo(fileOut)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    logX(<span class="string">&quot;Download finish!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，有一个地方是需要注意的，我用注释标记了。也就是当我们想要把网络流中的数据存起来的时候，我们可以借助 Kotlin 提供的 <strong>IO 扩展函数</strong>快速实现，这样不仅方便，而且还不用担心 FileOutputStream 调用 close() 的问题。这个部分的代码，在 Java 当中，是要写一堆模板代码的。</p><p>下载本身的功能实现以后，挂起函数的封装也就容易了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">downloadImage</span><span class="params">(url: <span class="type">String</span>, outputFile: <span class="type">File</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> withContext(Dispatchers.IO) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            downloadSync()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            println(e)</span><br><span class="line">            <span class="comment">// return@withContext  不可省略</span></span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@withContext</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return@withContext 可省略</span></span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@withContext</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们可以直接用 <strong>withContext</strong>，让下载的任务直接分发到 IO 线程。</p><p>代码写到这里，2.0 版本要求的功能基本上就算是完成了。这样一来，我们就可以在 main 函数当中去调用它了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> url = <span class="string">&quot;http://xxxx.jpg&quot;</span></span><br><span class="line">    <span class="keyword">val</span> path = <span class="string">&quot;<span class="subst">$&#123;BASE_PATH&#125;</span>downloaded.png&quot;</span></span><br><span class="line"></span><br><span class="line">    downloadImage(url, File(path))</span><br><span class="line"></span><br><span class="line">    loadImage(File(path))</span><br><span class="line">        .flipVertical()</span><br><span class="line">        .writeToFile(File(<span class="string">&quot;<span class="subst">$&#123;BASE_PATH&#125;</span>download_flip_vertical.png&quot;</span>))</span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内存图片保存到硬盘</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Image.<span class="title">writeToFile</span><span class="params">(outputFile: <span class="type">File</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> width = width()</span><br><span class="line">        <span class="keyword">val</span> height = height()</span><br><span class="line">        <span class="keyword">val</span> image = BufferedImage(width, height, BufferedImage.TYPE_INT_RGB)</span><br><span class="line">        <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">0</span> until width) &#123;</span><br><span class="line">            <span class="keyword">for</span> (y <span class="keyword">in</span> <span class="number">0</span> until height) &#123;</span><br><span class="line">                <span class="keyword">val</span> awtColor = getPixel(y, x)</span><br><span class="line">                image.setRGB(x, y, awtColor.rgb)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ImageIO.write(image, <span class="string">&quot;png&quot;</span>, outputFile)</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(e)</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Download start!</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Download finish!</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Done</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>通过运行结果，我们会发现图片下载的任务，已经被分发到 IO 线程池了，而其他的代码仍然在主线程之上。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实，课程进行到这里，你就会发现，Kotlin 和 Java、C 之类的语言的编程方式是完全不一样的。Kotlin 提供了丰富的扩展函数，在很多业务场景下，Kotlin 是可以大大减少代码量的。</p><p>另外，你也会发现，当你熟悉 Kotlin 协程以后，它的使用一点都不难。对于上面的代码，我们通过 withContext(Dispatchers.IO) 就能切换线程，之后，我们就可以在协程作用域当中随意调用了！</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>你觉得，我们在 downloadImage() 这个挂起函数内部，直接写死 Dispatchers.IO 的方式好吗？如果换成下面这种写法，会不会更好？为什么？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">downloadImage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    coroutineContext: <span class="type">CoroutineContext</span> = Dispatchers.IO,</span></span></span><br><span class="line"><span class="params"><span class="function">    url: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    outputFile: <span class="type">File</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> withContext(coroutineContext) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            downloadSync()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            println(e)</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@withContext</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@withContext</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(协程篇)期中考试  用Kotlin实现图片处理程序</title>
      <link href="/posts/849ea54c/"/>
      <url>/posts/849ea54c/</url>
      
        <content type="html"><![CDATA[<p>不知不觉间，咱们的课程就已经进行一半了，我们已经学完很多内容：</p><ul><li>基础篇，我们学完了所有 Kotlin 基础语法和重要特性。</li><li>加餐篇，我们学习了 Kotlin 编程的 5 大编程思维：函数式思维、表达式思维、不变性思维、空安全思维、协程思维。</li><li>协程篇，我们也已经学完了所有基础的协程概念。</li></ul><p>所以现在，是时候来一次阶段性的验收了。这次，我们一起来做一个<strong>图片处理程序</strong>，来考察一下自己对于 Kotlin 编程知识的理解和应用掌握情况。初始化工程的代码在这里GitHub，你可以像往常那样，将其 clone 下来，然后用 IntelliJ 打开即可。</p><p>我们仍然会分为两个版本 1.0、2.0，不过，这一次要轮到你亲自动手写代码了！</p><h1 id="1-0-版本：处理本地图片"><a href="#1-0-版本：处理本地图片" class="headerlink" title="1.0 版本：处理本地图片"></a>1.0 版本：处理本地图片</h1><p>当你将初始化工程打开以后，你会发现“src&#x2F;main&#x2F;resources&#x2F;images&#x2F;”这个目录下有一张图片：android.png，它就是我们要处理的图片对象。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/0d/64/0de4da2977353d97631d88531feff464.png?wh=1817x704" alt="img"></p><p>一般来说，我们想要处理图片，会第一时间想到 Photoshop，但其实简单的图片处理任务，我们完全可以通过代码来实现，比如图片横向翻转、图片纵向翻转、图片裁切。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/45/c6/456e395f69c12b20e095959046fccac6.png?wh=1128x424" alt="img"></p><p>关于图片的底层定义，Java SDK 已经提供了很好的支持，我们在 Kotlin 代码当中可以直接使用相关的类。为了防止你对 JDK 不熟悉，我在初始化工程当中，已经为你做好了前期准备工作：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span>(<span class="keyword">private</span> <span class="keyword">val</span> pixels: Array&lt;Array&lt;Color&gt;&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">height</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pixels.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">width</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pixels[<span class="number">0</span>].size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 底层不处理越界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPixel</span><span class="params">(y: <span class="type">Int</span>, x: <span class="type">Int</span>)</span></span>: Color &#123;</span><br><span class="line">        <span class="keyword">return</span> pixels[y][x]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我定义的一个 Image 类，它的作用就是封装图片的内存对象。我们都知道，图片的本质是一堆像素点（Pixel），而每个像素点，都可以用 RGB 来表示，这里我们用 Java SDK 当中的 Color 来表示。</p><p>当我们把图片放大到足够倍数的时候，我们就可以看到其中的<strong>正方形像素点</strong>了。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/4a/a2/4a833f282d7f56e6c10707f9b36yy4a2.png?wh=1489x862" alt="img"></p><p>所以，最终我们就可以用“Array&gt;”这样一个二维数组来表示一张图片。</p><p>另外，从本地加载图片到内存的代码，我也帮你写好了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> BASE_PATH = <span class="string">&quot;./src/main/resources/images/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> image = loadImage(File(<span class="string">&quot;<span class="subst">$&#123;BASE_PATH&#125;</span>android.png&quot;</span>))</span><br><span class="line">    println(<span class="string">&quot;Width = <span class="subst">$&#123;image.width()&#125;</span>;Height = <span class="subst">$&#123;image.height()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载本地图片到内存中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loadImage</span><span class="params">(imageFile: <span class="type">File</span>)</span></span> =</span><br><span class="line">    ImageIO.read(imageFile)</span><br><span class="line">        .let &#123;</span><br><span class="line">            Array(it.height) &#123; y -&gt;</span><br><span class="line">                Array(it.width) &#123; x -&gt;</span><br><span class="line">                    Color(it.getRGB(x, y))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.let &#123;</span><br><span class="line">            Image(it)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>那么，唯一需要你做的，就是实现这几个函数的功能：<strong>图片横向翻转、图片纵向翻转、图片裁切</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 横向翻转图片</span></span><br><span class="line"><span class="comment"> * 待实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Image.<span class="title">flipHorizontal</span><span class="params">()</span></span>: Image = TODO()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 纵向翻转图片</span></span><br><span class="line"><span class="comment"> * 待实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Image.<span class="title">flipVertical</span><span class="params">()</span></span>: Image = TODO()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片裁切</span></span><br><span class="line"><span class="comment"> * 待实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Image.<span class="title">crop</span><span class="params">(startY: <span class="type">Int</span>, startX: <span class="type">Int</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span>: Image = TODO()</span><br></pre></td></tr></table></figure><p>另外，如果你有兴趣的话，还可以去实现对应的单元测试代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestImageProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待实现的单元测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFlipHorizontal</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待实现的单元测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFlipVertical</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待实现的单元测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testCrop</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们 1.0 版本的代码就算完成了。不过，我们还没用上协程的知识啊！</p><p>请看 2.0 版本。</p><h2 id="2-0-版本：增加图片下载功能"><a href="#2-0-版本：增加图片下载功能" class="headerlink" title="2.0 版本：增加图片下载功能"></a>2.0 版本：增加图片下载功能</h2><p>在上个版本中，我们的代码仅支持本地图片的处理，但有的时候，我们想要处理网络上的图片该怎么办呢？所以这时候，我们可以增加一个下载网络图片的功能。</p><p>这个版本，你只需要实现一个函数：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 挂起函数，以http的方式下载图片，保存到本地</span></span><br><span class="line"><span class="comment"> * 待实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">downloadImage</span><span class="params">(url: <span class="type">String</span>, outputFile: <span class="type">File</span>)</span></span>: <span class="built_in">Boolean</span> = TODO()</span><br></pre></td></tr></table></figure><p>需要注意的是，由于下载网络图片比较耗时，我们需要将其定义成一个<strong>挂起函数</strong>，这样一来，我们后续在使用它的时候就可以更得心应手了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 不一定非要下载我提供的链接</span></span><br><span class="line">    <span class="keyword">val</span> url = <span class="string">&quot;https://raw.githubusercontent.com/chaxiu/ImageProcessor/main/src/main/resources/images/android.png&quot;</span></span><br><span class="line">    <span class="keyword">val</span> path = <span class="string">&quot;<span class="subst">$&#123;BASE_PATH&#125;</span>downloaded.png&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用挂起函数</span></span><br><span class="line">    downloadImage(url, File(path))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> image = loadImage(File(path))</span><br><span class="line">    println(<span class="string">&quot;Width = <span class="subst">$&#123;image.width()&#125;</span>;Height = <span class="subst">$&#123;image.height()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我是以“<a href="https://raw.githubusercontent.com/chaxiu/ImageProcessor/main/src/main/resources/images/android.png%E2%80%9D">https://raw.githubusercontent.com/chaxiu/ImageProcessor/main/src/main/resources/images/android.png”</a> 这个链接为例，这是一个 HTTPS 的链接，你在实际开发的时候，也可以随便去找一个普通的 HTTP 图片链接，这样就不必处理 SSL 的问题了。</p><p>程序实际运行效果会是这样的：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/e7/71/e7b549e6e97cffdd67e8379004773171.gif?wh=1026x764" alt="img"></p><p>在下节课里，我会给出我的代码参考，不过在看我的代码之前，记得先要自己动手啊。</p><p>其实，以我们这个工程为基础，再加上一些图形学算法，我们完全可以做出 Photoshop 当中的一些高级功能，比如图片缩放、图片参数调节、图片滤镜、抠像，甚至图片识别，等等。如果你本身就有图形学方面的知识储备，也欢迎你在此基础上实现更复杂的功能！</p><p>好了，我们下节课再见！</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(协程篇)18  实战：让KtHttp支持挂起函数</title>
      <link href="/posts/95448d7b/"/>
      <url>/posts/95448d7b/</url>
      
        <content type="html"><![CDATA[<p>今天这节实战课，我们接着前面第 12 讲里实现的网络请求框架，来进一步完善这个 KtHttp，让它支持挂起函数。</p><p>在上一次实战课当中，我们已经开发出了两个版本的 KtHttp，1.0 版本的是基于命令式风格的，2.0 版本的是基于函数式风格的。其中 2.0 版本的代码风格，跟我们平时工作写的代码风格很不一样，之前我也说了，这主要是因为业界对 Kotlin 函数式编程接纳度并不高，所以这节课的代码，我们将基于 1.0 版本的代码继续改造。这样，也能让课程的内容更接地气一些，甚至你都可以借鉴今天写代码的思路，复用到实际的 Android 或者后端开发中去。</p><p>跟往常一样，这节课的代码还是会分为两个版本：</p><ul><li>3.0 版本，在之前 1.0 版本的基础上，扩展出异步请求的能力。</li><li>4.0 版本，进一步扩展异步请求的能力，让它支持挂起函数。</li></ul><p>好，接下来就正式开始吧！</p><h2 id="3-0-版本：支持异步（Call）"><a href="#3-0-版本：支持异步（Call）" class="headerlink" title="3.0 版本：支持异步（Call）"></a>3.0 版本：支持异步（Call）</h2><p>有了上一次实战课的基础，这节课就会轻松一些了。关于动态代理、注解、反射之类的知识不会牵涉太多，我们今天主要把精力都集中在协程上来。不过，在正式开始写协程代码之前，我们需要先让 KtHttp 支持异步请求，也就是 Callback 请求。</p><p>这是为什么呢？别忘了第 15 讲的内容：挂起函数本质就是 Callback！所以，为了让 KtHttp 支持挂起函数，我们可以采用迂回的策略，让它先支持 Callback。在之前 1.0、2.0 版本的代码中，KtHttp 是只支持同步请求的，你可能对异步同步还有些懵，我带你来看个例子吧。</p><p>首先，这个是同步代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 同步代码</span></span><br><span class="line">    <span class="keyword">val</span> api: ApiService = KtHttpV1.create(ApiService::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: RepoList = api.repos(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 main 函数当中，我们调用了 KtHttp 1.0 的代码，其中 3 行代码的运行顺序是 1、2、3，这就是典型的同步代码。它的另一个特点就是：所有代码都会在一个线程中执行，因此这样的代码如果运行在 Android、Swing 之类的 UI 编程平台上，是会导致主线程卡死的。</p><p>那么，异步代码又是长什么样的呢？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testAsync</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 异步代码</span></span><br><span class="line">    KtHttpV3.create(ApiServiceV3::<span class="keyword">class</span>.java).repos(</span><br><span class="line">        lang = <span class="string">&quot;Kotlin&quot;</span>,</span><br><span class="line">        since = <span class="string">&quot;weekly&quot;</span></span><br><span class="line">    ).call(<span class="keyword">object</span> : Callback&lt;RepoList&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">RepoList</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            println(throwable)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 testAsync() 方法当中的代码，就是典型的异步代码，它跟同步代码最大的差异就是，有了一个 Callback，而且代码不再是按照顺序执行的了。你可以参考下面这个动图：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/a8/ff/a8d0c46d74a17d0ddfb683e0ac7468ff.gif?wh=1080x608" alt="img"></p><p>所以，在 3.0 版本的开发中，我们就是要实现类似上面 testAsync() 的请求方式。为此，我们首先需要创建一个 <strong>Callback 接口</strong>，在这个 Callback 当中，我们可以拿到 API 请求的结果。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span>&lt;<span class="type">T: Any</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Callback 这个接口里，有一个泛型参数 T，还有两个回调，分别是 onSuccess 代表接口请求成功、onFail 代表接口请求失败。需要特别注意的是，这里我们运用了空安全思维当中的<strong>泛型边界“T: Any”</strong>，这样一来，我们就可以保证 T 类型一定是非空的。</p><p>除此之外，我们还需要一个 <strong>KtCall 类</strong>，它的作用是承载 Callback，或者说，它是用来调用 Callback 的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KtCall</span>&lt;<span class="type">T: Any</span>&gt;(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> call: Call,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> gson: Gson,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> type: Type</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">(callback: <span class="type">Callback</span>&lt;<span class="type">T</span>&gt;)</span></span>: Call &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KtCall 这个类仍然使用了泛型边界“T: Any”，另外，它还有几个关键的成员分别是：OkHttp 的 Call 对象、JSON 解析的 Gson 对象，以及反射类型 Type。然后还有一个 call() 方法，它接收的是前面我们定义的 Callback 对象，返回的是 OkHttp 的 Call 对象。所以总的来说，call() 方法当中的逻辑会分为三个步骤。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KtCall</span>&lt;<span class="type">T: Any</span>&gt;(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> call: Call,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> gson: Gson,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> type: Type</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">(callback: <span class="type">Callback</span>&lt;<span class="type">T</span>&gt;)</span></span>: Call &#123;</span><br><span class="line">        <span class="comment">// 步骤1， 使用call请求API</span></span><br><span class="line">        <span class="comment">// 步骤2， 根据请求结果，调用callback.onSuccess()或者是callback.onFail()</span></span><br><span class="line">        <span class="comment">// 步骤3， 返回OkHttp的Call对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一步步来分析这三个步骤：</p><ul><li>步骤 1，使用 OkHttp 的 call 对象请求 API，这里需要注意的是，为了将请求任务派发到异步线程，我们需要使用 OkHttp 的异步请求方法 enqueue()。</li><li>步骤 2，根据请求结果，调用 callback.onSuccess() 或者是 callback.onFail()。如果请求成功了，我们在调用 onSuccess() 之前，还需要用 Gson 将请求结果进行解析，然后才返回。</li><li>步骤 3，返回 OkHttp 的 Call 对象。</li></ul><p>接下来，我们看看具体代码是怎么样的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KtCall</span>&lt;<span class="type">T: Any</span>&gt;(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> call: Call,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> gson: Gson,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> type: Type</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">(callback: <span class="type">Callback</span>&lt;<span class="type">T</span>&gt;)</span></span>: Call &#123;</span><br><span class="line">        call.enqueue(<span class="keyword">object</span> : okhttp3.Callback &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">                callback.onFail(e)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; <span class="comment">// ①</span></span><br><span class="line">                    <span class="keyword">val</span> t = gson.fromJson&lt;T&gt;(response.body?.string(), type)</span><br><span class="line">                    callback.onSuccess(t)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                    callback.onFail(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> call</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过前面的解释，这段代码就很好理解了，唯一需要注意的是注释①处，由于 API 返回的结果并不可靠，即使请求成功了，其中的 JSON 数据也不一定合法，所以这里我们一般还需要进行额外的判断。在实际的商业项目当中，我们可能还需要根据当中的状态码，进行进一步区分和封装，这里为了便于理解，我就简单处理了。</p><p>那么在实现了 KtCall 以后，我们就只差 <strong>ApiService</strong> 这个接口了，这里我们定义 ApiServiceV3，以作区分。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiServiceV3</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: KtCall&lt;RepoList&gt; <span class="comment">// ①</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要格外留意以上代码中的注释①，这其实就是 <strong>3.0 和 1.0 之间的最大区别</strong>。由于 repo() 方法的返回值类型是 KtCall，为了支持这种写法，我们的 invoke 方法就需要跟着做一些小的改动：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这里也同样使用了泛型边界</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.parameterAnnotations.size != args.size) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> url = path</span><br><span class="line">    <span class="keyword">val</span> parameterAnnotations = method.parameterAnnotations</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> parameterAnnotations.indices) &#123;</span><br><span class="line">        <span class="keyword">for</span> (parameterAnnotation <span class="keyword">in</span> parameterAnnotations[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parameterAnnotation <span class="keyword">is</span> Field) &#123;</span><br><span class="line">                <span class="keyword">val</span> key = parameterAnnotation.value</span><br><span class="line">                <span class="keyword">val</span> value = args[i].toString()</span><br><span class="line">                <span class="keyword">if</span> (!url.contains(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">                    url += <span class="string">&quot;?<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    url += <span class="string">&quot;&amp;<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">        .url(url)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> call = okHttpClient.newCall(request)</span><br><span class="line">    <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">return</span> KtCall&lt;T&gt;(call, gson, genericReturnType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到 KtCall&lt;RepoList&gt; 当中的 RepoList类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getTypeArgument</span><span class="params">(method: <span class="type">Method</span>)</span></span> =</span><br><span class="line">    (method.genericReturnType <span class="keyword">as</span> ParameterizedType).actualTypeArguments[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>在上面的代码中，大部分代码和 1.0 版本的一样的，只是在最后封装了一个 KtCall 对象，直接返回。所以在后续调用它的时候，我们就可以这么写了：ktCall.call()。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testAsync</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建api对象</span></span><br><span class="line">    <span class="keyword">val</span> api: ApiServiceV3 = KtHttpV3.create(ApiServiceV3::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取ktCall</span></span><br><span class="line">    <span class="keyword">val</span> ktCall: KtCall&lt;RepoList&gt; = api.repos(</span><br><span class="line">        lang = <span class="string">&quot;Kotlin&quot;</span>,</span><br><span class="line">        since = <span class="string">&quot;weekly&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起call异步请求</span></span><br><span class="line">    ktCall.call(<span class="keyword">object</span> : Callback&lt;RepoList&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">RepoList</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            println(throwable)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码很好理解，我们一步步创建 API 对象、ktCall 对象，最后发起请求。不过，在工作中一般是不会这么写代码的，因为创建太多一次性临时对象了。我们完全可以用<strong>链式调用</strong>的方式来做：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testAsync</span><span class="params">()</span></span> &#123;</span><br><span class="line">    KtHttpV3.create(ApiServiceV3::<span class="keyword">class</span>.java)</span><br><span class="line">    .repos(</span><br><span class="line">        lang = <span class="string">&quot;Kotlin&quot;</span>,</span><br><span class="line">        since = <span class="string">&quot;weekly&quot;</span></span><br><span class="line">    ).call(<span class="keyword">object</span> : Callback&lt;RepoList&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">RepoList</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            println(throwable)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你没有很多编程经验，那你可能会对这种方式不太适应，但在实际写代码的过程中，你会发现这种模式写起来会比上一种舒服很多，因为<strong>你再也不用为临时变量取名字伤脑筋了</strong>。</p><p>总的来说，到这里的话，我们的异步请求接口就已经完成了。而且，由于我们的实际请求已经通过 OkHttp 派发（enqueue）到统一的线程池当中去了，并不会阻塞主线程，所以这样的代码模式执行在 Android、Swing 之类的 UI 编程平台，也不会引起 UI 界面卡死的问题。</p><p>那么，3.0 版本是不是到这里就结束了呢？其实并没有，因为我们还有一种情况没有考虑。我们来看看下面这段代码示例：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiServiceV3</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: KtCall&lt;RepoList&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reposSync</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: RepoList <span class="comment">// 注意这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSync</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> api: ApiServiceV3 = KtHttpV3.create(ApiServiceV3::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: RepoList = api.reposSync(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请留意注释的地方，repoSync() 的返回值类型是 RepoList，而不是 KtCall 类型，这其实是我们 1.0 版本的写法。看到这，你是不是发现问题了？虽然 KtHttp 支持了异步请求，但原本的同步请求反而不支持了。</p><p>所以，为了让 KtHttp 同时支持两种请求方式，我们只需要<strong>增加一个 if 判断</strong>即可</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (isKtCallReturn(method)) &#123;</span><br><span class="line">        <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">        KtCall&lt;T&gt;(call, gson, genericReturnType)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 注意这里</span></span><br><span class="line">        <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> genericReturnType = method.genericReturnType</span><br><span class="line">        <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">        gson.fromJson&lt;Any?&gt;(json, genericReturnType)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前接口的返回值类型是不是KtCall</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isKtCallReturn</span><span class="params">(method: <span class="type">Method</span>)</span></span> =</span><br><span class="line">    getRawType(method.genericReturnType) == KtCall::<span class="keyword">class</span>.java</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个方法 isKtCallReturn()，它的作用是判断当前接口方法的返回值类型是不是 KtCall，如果是的话，我们就认为它是一个异步接口，这时候返回 KtCall 对象；如果不是，我们就认为它是同步接口。这样我们只需要将 1.0 的逻辑挪到 else 分支，就可以实现兼容了。</p><p>那么到这里，我们 3.0 版本的开发就算是完成了。接下来，我们进入 4.0 版本的开发。</p><h2 id="4-0-版本：支持挂起函数"><a href="#4-0-版本：支持挂起函数" class="headerlink" title="4.0 版本：支持挂起函数"></a>4.0 版本：支持挂起函数</h2><p>终于来到协程实战的部分了。在日常的开发工作当中，你也许经常会面临这样的一个问题：虽然很想用 Kotlin 的协程来简化异步开发，但公司的底层框架全部都是 Callback 写的，根本不支持挂起函数，我一个上层的业务开发工程师，能有什么办法呢？</p><p>其实，我们当前的 KtHttp 就面临着类似的问题：3.0 版本只支持 Callback 异步调用，现在我们想要扩展出挂起函数的功能。这其实就是大部分 Kotlin 开发者会遇到的场景。</p><p>就我这几年架构迁移的实践经验来看，针对这个问题，我们主要有两种解法：</p><ul><li>第一种解法，不改动 SDK 内部的实现，直接在 SDK 的基础上扩展出协程的能力。</li><li>第二种解法，改动 SDK 内部，让 SDK 直接支持挂起函数。</li></ul><p>下面我们先来看看第一种解法。至于第二种解法，其实还可以细分出好几种思路，由于它涉及到挂起函数更底层的一些知识，具体方案我会在源码篇的第 27 讲介绍。</p><h3 id="解法一：扩展-KtCall"><a href="#解法一：扩展-KtCall" class="headerlink" title="解法一：扩展 KtCall"></a>解法一：扩展 KtCall</h3><p>这种方式有一个优势，那就是我们不需要改动 3.0 版本的任何代码。这种场景在工作中也是十分常见的，比如说，项目中用到的 SDK 是开源的，或者 SDK 是公司其他部门开发的，我们无法改动 SDK。</p><p>具体的做法，就是为 KtCall 这个类扩展出一个挂起函数。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意这里                   函数名称</span></span><br><span class="line"><span class="comment">   ↓                        ↓        */</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T = TODO()</span><br></pre></td></tr></table></figure><p>那么，现在我们就只剩下一个问题了：<strong>await() 具体该如何实现？</strong></p><p>在这里，我们需要用到 Kotlin 官方提供的一个顶层函数：suspendCoroutine{}，它的函数签名是这样的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">suspendCoroutine</span><span class="params">(<span class="keyword">crossinline</span> block: (<span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="comment">// 省略细节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从它的函数签名，我们可以发现，它是一个挂起函数，也是一个高阶函数，参数类型是“(Continuation) -&gt; Unit”，如果你还记得第 15 讲当中的内容，你应该就已经发现了，<strong>它其实就等价于挂起函数类型！</strong></p><p>所以，我们可以使用 suspendCoroutine{} 来实现 await() 方法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意这里                   </span></span><br><span class="line"><span class="comment">   ↓                                */</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T = suspendCoroutine&#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    <span class="comment">//   ↑</span></span><br><span class="line">    <span class="comment">// 注意这里 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你仔细分析这段代码的话，会发现 suspendCoroutine{} 的作用，<strong>其实就是将挂起函数当中的 continuation 暴露出来</strong>。</p><p>那么，suspendCoroutine{} 当中的代码具体该怎么写呢？答案应该也很明显了，当然是要用这个被暴露出来的 continuation 来做文章啦！</p><p>这里我们再来回顾一下 Continuation 这个接口：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">    <span class="comment">// 关键在于这个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过定义可以看到，整个 Continuation 只有一个方法，那就是 resumeWith()，根据它的名字我们就可以推测出，它是用于“恢复”的，参数类型是 Result。所以很明显，这就是一个带有泛型的“结果”，它的作用就是承载协程执行的结果。</p><p>所以，综合来看，我们就可以进一步写出这样的代码了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T =</span><br><span class="line">    suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">        call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">                continuation.resumeWith(Result.success(<span class="keyword">data</span>))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                continuation.resumeWith(Result.failure(throwable))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上代码也很容易理解，当网络请求执行成功以后，我们就调用 resumeWith()，同时传入 Result.success(data)；如果请求失败，我们就传入 Result.failure(throwable)，将对应的异常信息传进去。</p><p>不过，也许你会觉得创建 Result 的写法太繁琐了，没关系，你可以借助 Kotlin 官方提供的扩展函数提升代码可读性。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T =</span><br><span class="line">    suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">        call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">                continuation.resume(<span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                continuation.resumeWithException(throwable)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到目前为止，await() 这个扩展函数其实就已经实现了。这时候，如果我们在协程当中调用 await() 方法的话，代码是可以正常执行的。不过，这种做法其实还有一点瑕疵，那就是<strong>不支持取消</strong>。</p><p>让我们来写一个简单的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> deferred = async &#123;</span><br><span class="line">        KtHttpV3.create(ApiServiceV3::<span class="keyword">class</span>.java)</span><br><span class="line">            .repos(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">            .await()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deferred.invokeOnCompletion &#123;</span><br><span class="line">        println(<span class="string">&quot;invokeOnCompletion!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">50L</span>)</span><br><span class="line"></span><br><span class="line">    deferred.cancel()</span><br><span class="line">    println(<span class="string">&quot;Time cancel: <span class="subst">$&#123;System.currentTimeMillis() - start&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        println(deferred.await())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Time exception: <span class="subst">$&#123;System.currentTimeMillis() - start&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Catch exception:<span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Time total: <span class="subst">$&#123;System.currentTimeMillis() - start&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T =</span><br><span class="line">    suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">        call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Request success!&quot;</span>) <span class="comment">// ①</span></span><br><span class="line">                continuation.resume(<span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Request fail!：<span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">                continuation.resumeWithException(throwable)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Time cancel: 536   // ②</span></span><br><span class="line"><span class="comment">Request success!   // ③</span></span><br><span class="line"><span class="comment">invokeOnCompletion!</span></span><br><span class="line"><span class="comment">Time exception: 3612  // ④</span></span><br><span class="line"><span class="comment">Catch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine&#123;Cancelled&#125;@6043cd28</span></span><br><span class="line"><span class="comment">Time total: 3612</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 main 函数当中，我们在 async 里调用了挂起函数，接着 50ms 过去后，我们就去尝试取消协程。这段代码中一共有三处地方需要注意，我们来分析一下：</p><ul><li>结合注释①、③一起分析，我们发现，即使调用了 deferred.cancel()，网络请求仍然会继续执行。根据“Catch exception:”输出的异常信息，我们也发现，当 deferred 被取消以后我们还去调用 await() 的时候，会抛出异常。</li><li>对比注释②、④，我们还能发现，deferred.await() 虽然会抛出异常，但是它却耗时 3000ms。虽然 deferred 被取消了，但是当我们调用 await() 的时候，它并不会马上就抛出异常，而是会等到内部的网络请求执行结束以后，才抛出异常，在此之前都会被挂起。</li></ul><p>综上所述，当我们使用 suspendCoroutine{} 来实现挂起函数的时候，默认情况下是不支持取消的。那么，具体该怎么做呢？其实也很简单，就是使用 Kotlin 官方提供的另一个 **API：suspendCancellableCoroutine{}**。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T =</span><br><span class="line"><span class="comment">//            变化1</span></span><br><span class="line"><span class="comment">//              ↓</span></span><br><span class="line">    suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class="line">        <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Request success!&quot;</span>)</span><br><span class="line">                continuation.resume(<span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Request fail!：<span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">                continuation.resumeWithException(throwable)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//            变化2</span></span><br><span class="line"><span class="comment">//              ↓</span></span><br><span class="line">        continuation.invokeOnCancellation &#123;</span><br><span class="line">            println(<span class="string">&quot;Call cancelled!&quot;</span>)</span><br><span class="line">            call.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当我们使用 suspendCancellableCoroutine{} 的时候，可以往 continuation 对象上面设置一个监听：invokeOnCancellation{}，它代表当前的协程被取消了，这时候，我们只需要将 OkHttp 的 call 取消即可。</p><p>这样一来，main() 函数就能保持不变，得到的输出结果却大不相同.</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">suspendCoroutine结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time cancel: 536   </span></span><br><span class="line"><span class="comment">Request success!   </span></span><br><span class="line"><span class="comment">invokeOnCompletion!</span></span><br><span class="line"><span class="comment">Time exception: 3612  // ①</span></span><br><span class="line"><span class="comment">Catch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine&#123;Cancelled&#125;@6043cd28</span></span><br><span class="line"><span class="comment">Time total: 3612</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">suspendCancellableCoroutine结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Call cancelled!</span></span><br><span class="line"><span class="comment">Time cancel: 464</span></span><br><span class="line"><span class="comment">invokeOnCompletion!</span></span><br><span class="line"><span class="comment">Time exception: 466  // ②</span></span><br><span class="line"><span class="comment">Catch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine&#123;Cancelled&#125;@6043cd28</span></span><br><span class="line"><span class="comment">Time total: 466</span></span><br><span class="line"><span class="comment">Request fail!：java.io.IOException: Canceled  // ③</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>对比注释①、②，可以发现，后者是会立即响应协程取消事件的，所以当代码执行到 deferred.await() 的时候，会立即抛出异常，而不会挂起很长时间。另外，通过注释③这里的结果，我们也可以发现，OkHttp 的网络请求确实被取消了。</p><p>所以，我们可以得出一个结论，使用 suspendCancellableCoroutine{}，我们可以避免不必要的挂起，比如例子中的 deferred.await()；另外也可以节省计算机资源，因为这样可以避免不必要的协程任务，比如这里被成功取消的网络请求。</p><p>到这里，我们的解法一就已经完成了。这种方式并没有改动 KtHttp 的源代码，而是以扩展函数来实现的。所以，从严格意义上来讲，KtHttp 4.0 版本并没有开发完毕，等到第 27 讲我们深入理解了挂起函数的底层原理后，我们再来完成解法二的代码。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课，我们在 KtHttp 1.0 版本的基础上，扩展出了异步请求的功能，完成了 3.0 版本的开发；接着，我们又在 3.0 版本的基础上，让 KtHttp 支持了挂起函数，这里我们是用的外部扩展的思路，并没有碰 KtHttp 内部的代码。</p><p>这里主要涉及以下几个知识点：</p><ul><li>在 3.0 版本开发中，我们运用了泛型边界“T: Any”，落实对泛型的非空限制，同时通过封装 KtCall，为下一个版本打下了基础。</li><li>接着，在 4.0 版本中，我们借助扩展函数的特性，为 KtCall 扩展了 await() 方法。</li><li>在实现 await() 的过程中，我们使用了两个协程 API，分别是 suspendCoroutine{}、suspendCancellableCoroutine{}，在 Kotlin 协程当中，<strong>我们永远都要优先使用后者</strong>。</li><li>suspendCancellableCoroutine{} 主要有两大优势：第一，它可以避免不必要的挂起，提升运行效率；第二，它可以避免不必要的资源浪费，改善软件的综合指标。</li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>你能分析出下面的代码执行结果吗？为什么会是这样的结果？它能给你带来什么启发？欢迎给我留言，也欢迎你把今天的内容分享给更多的朋友。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> deferred = async &#123;</span><br><span class="line">        KtHttpV3.create(ApiServiceV3::<span class="keyword">class</span>.java)</span><br><span class="line">            .repos(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">            .await()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deferred.invokeOnCompletion &#123;</span><br><span class="line">        println(<span class="string">&quot;invokeOnCompletion!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">50L</span>)</span><br><span class="line"></span><br><span class="line">    deferred.cancel()</span><br><span class="line">    println(<span class="string">&quot;Time cancel: <span class="subst">$&#123;System.currentTimeMillis() - start&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        println(deferred.await())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Time exception: <span class="subst">$&#123;System.currentTimeMillis() - start&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Catch exception:<span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Time total: <span class="subst">$&#123;System.currentTimeMillis() - start&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T =</span><br><span class="line">    suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class="line">        <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Request success!&quot;</span>)</span><br><span class="line">                continuation.resume(<span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Request fail!：<span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">                continuation.resumeWithException(throwable)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里</span></span><br><span class="line"><span class="comment">//        continuation.invokeOnCancellation &#123;</span></span><br><span class="line"><span class="comment">//            println(&quot;Call cancelled!&quot;)</span></span><br><span class="line"><span class="comment">//            call.cancel()</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(协程篇)17  Context：万物皆为Context？</title>
      <link href="/posts/12ca5097/"/>
      <url>/posts/12ca5097/</url>
      
        <content type="html"><![CDATA[<p>今天我们来学习 Kotlin 协程的 Context。</p><p>协程的 Context，在 Kotlin 当中有一个具体的名字，叫做 CoroutineContext。它是我们理解 Kotlin 协程非常关键的一环。</p><p>从概念上讲，CoroutineContext 很容易理解，它只是个上下文而已，实际开发中它最常见的用处就是切换线程池。不过，CoroutineContext 背后的代码设计其实比较复杂，如果不能深入理解它的设计思想，那我们在后面阅读协程源码，并进一步建立复杂并发结构的时候，都将会困难重重。</p><p>所以这节课，我将会从应用的角度出发，带你了解 CoroutineContext 的使用场景，并会对照源码带你理解它的设计思路。另外，知识点之间的串联也是很重要的，所以我还会带你分析它跟我们前面学的 Job、Deferred、launch、async 有什么联系，让你能真正理解和掌握协程的上下文，<strong>并建立一个基于 CoroutineContext 的协程知识体系</strong>。</p><h2 id="Context-的应用"><a href="#Context-的应用" class="headerlink" title="Context 的应用"></a>Context 的应用</h2><p>前面说过，CoroutineContext 就是协程的上下文。你在前面的第 14~16 讲里其实就已经见过它了。在第 14 讲我介绍 launch 源码的时候，CoroutineContext 其实就是函数的第一个参数：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//                这里</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//                 ↓</span></span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里我先说一下，之前我们在调用 launch 的时候，都没有传 context 这个参数，因此它会使用默认值 EmptyCoroutineContext，顾名思义，这就是一个空的上下文对象。而如果我们想要指定 launch 工作的线程池的话，就需要自己传 context 这个参数了。</p><p>另外，在第 15 讲里，我们在挂起函数 getUserInfo() 当中，也用到了 withContext() 这个函数，当时我们传入的是“Dispatchers.IO”，这就是 Kotlin 官方提供的一个 CoroutineContext 对象。让我们来回顾一下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    logX(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    logX(<span class="string">&quot;Before IO Context.&quot;</span>)</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        logX(<span class="string">&quot;In IO Context.&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    logX(<span class="string">&quot;After IO Context.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;BoyCoder&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Before IO Context.</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">In IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">After IO Context.</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">BoyCoder</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，当我们在 withContext() 这里指定线程池以后，Lambda 当中的代码就会被分发到 DefaultDispatcher 线程池中去执行，而它外部的所有代码仍然还是运行在 main 之上。</p><p>其实，Kotlin 官方还提供了挂起函数版本的 main() 函数，所以我们的代码也可以改成这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    logX(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，你要注意的是：挂起函数版本的 main() 的底层做了很多封装，虽然它可以帮我们省去写 runBlocking 的麻烦，但不利于我们学习阶段的探索和研究。因此，后续的 Demo 我们仍然以 runBlocking 为主，你只需要知道 Kotlin 有这么一个东西，等到你深入理解协程以后，就可以直接用“suspend main()”写 Demo 了。</p><p>我们说回 runBlocking 这个函数，第 14 讲里我们介绍过，它的第一个参数也是 CoroutineContext，所以，我们也可以传入一个 Dispatcher 对象作为参数：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                          变化在这里</span></span><br><span class="line"><span class="comment">//                             ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking(Dispatchers.IO) &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    logX(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Before IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">In IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">After IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">BoyCoder</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这时候，我们会发现，所有的代码都运行在 DefaultDispatcher 这个线程池当中了。而 Kotlin 官方除了提供了 Dispatchers.IO 以外，还提供了 Dispatchers.Main、Dispatchers.Unconfined、Dispatchers.Default 这几种内置 Dispatcher。我来分别给你介绍一下：</p><ul><li><strong>Dispatchers.Main</strong>，它只在 UI 编程平台才有意义，在 Android、Swing 之类的平台上，一般只有 Main 线程才能用于 UI 绘制。这个 Dispatcher 在普通的 JVM 工程当中，是无法直接使用的。</li><li><strong>Dispatchers.Unconfined</strong>，代表无所谓，当前协程可能运行在任意线程之上。</li><li><strong>Dispatchers.Default</strong>，它是用于 CPU 密集型任务的线程池。一般来说，它内部的线程个数是与机器 CPU 核心数量保持一致的，不过它有一个最小限制 2。</li><li><strong>Dispatchers.IO</strong>，它是用于 IO 密集型任务的线程池。它内部的线程数量一般会更多一些（比如 64 个），具体线程的数量我们可以通过参数来配置：kotlinx.coroutines.io.parallelism。</li></ul><p>需要特别注意的是，Dispatchers.IO 底层是可能复用 Dispatchers.Default 当中的线程的。如果你足够细心的话，会发现前面我们用的都是 Dispatchers.IO，但实际运行的线程却是 DefaultDispatcher 这个线程池。</p><p>为了让这个问题更加清晰，我们可以把上面的例子再改一下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                          变化在这里</span></span><br><span class="line"><span class="comment">//                             ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking(Dispatchers.Default) &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    logX(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Before IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">In IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-2 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">After IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-2 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">BoyCoder</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-2 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><em><strong>当 Dispatchers.Default 线程池当中有富余线程的时候，它是可以被 IO 线程池复用的</strong></em>。可以看到，后面三个结果的输出都是在同一个线程之上的，这就是因为 Dispatchers.Default 被 Dispatchers.IO 复用线程导致的。如果我们换成自定义的 Dispatcher，结果就会不一样了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> mySingleDispatcher = Executors.newSingleThreadExecutor &#123;</span><br><span class="line">    Thread(it, <span class="string">&quot;MySingleThread&quot;</span>).apply &#123; isDaemon = <span class="literal">true</span> &#125;</span><br><span class="line">&#125;.asCoroutineDispatcher()</span><br><span class="line"></span><br><span class="line"><span class="comment">//                          变化在这里</span></span><br><span class="line"><span class="comment">//                             ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking(mySingleDispatcher) &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    logX(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> ExecutorService.<span class="title">asCoroutineDispatcher</span><span class="params">()</span></span>: ExecutorCoroutineDispatcher =</span><br><span class="line">    ExecutorCoroutineDispatcherImpl(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Before IO Context.</span></span><br><span class="line"><span class="comment">Thread:MySingleThread @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">In IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">After IO Context.</span></span><br><span class="line"><span class="comment">Thread:MySingleThread @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">BoyCoder</span></span><br><span class="line"><span class="comment">Thread:MySingleThread @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们是通过 asCoroutineDispatcher() 这个扩展函数，创建了一个 Dispatcher。从这里我们也能看到，Dispatcher 的本质仍然还是线程。这也再次验证了我们之前的说法：<strong>协程运行在线程之上</strong>。</p><p>然后在这里，当我们为 runBlocking 传入自定义的 mySingleDispatcher 以后，程序运行的结果就不一样了，由于它底层并没有复用线程，因此只有“In IO Context”是运行在 DefaultDispatcher 这个线程池的，其他代码都运行在 mySingleDispatcher 之上。</p><p>另外，前面提到的 <strong>Dispatchers.Unconfined</strong>，我们也要额外注意。还记得之前学习 launch 的时候，我们遇到的例子吗？请问下面 4 行代码，它们的执行顺序是怎样的？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    logX(<span class="string">&quot;Before launch.&quot;</span>) <span class="comment">// 1</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        logX(<span class="string">&quot;In launch.&quot;</span>) <span class="comment">// 2</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;End launch.&quot;</span>) <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    logX(<span class="string">&quot;After launch&quot;</span>)   <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你理解了第 14 讲的内容，那你一定能分析出它们的运行顺序应该是：1、4、2、3。</p><p>但你要注意，同样的代码模式在特殊的环境下，结果可能会不一样。比如在 Android 平台，或者是如果我们指定了 Dispatchers.Unconfined 这个特殊的 Dispatcher，它的这种行为模式也会被打破。比如像这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    logX(<span class="string">&quot;Before launch.&quot;</span>)  <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//               变化在这里</span></span><br><span class="line"><span class="comment">//                  ↓</span></span><br><span class="line">    launch(Dispatchers.Unconfined) &#123;</span><br><span class="line">        logX(<span class="string">&quot;In launch.&quot;</span>)  <span class="comment">// 2</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;End launch.&quot;</span>) <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    logX(<span class="string">&quot;After launch&quot;</span>)    <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Before launch.</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">In launch.</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">After launch</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">End launch.</span></span><br><span class="line"><span class="comment">Thread:kotlinx.coroutines.DefaultExecutor @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上代码的运行顺序就变成了：1、2、4、3。这一点，就再一次说明了 Kotlin 协程的难学。传了一个不同的参数进来，整个代码的执行顺序都变了，这谁不头疼呢？最要命的是，Dispatchers.Unconfined 设计的本意，也并不是用来改变代码执行顺序的。</p><p>请你留意“End launch”运行的线程“DefaultExecutor”，是不是觉得很乱？其实 Unconfined 代表的意思就是，<strong>当前协程可能运行在任何线程之上，不作强制要求</strong>。</p><p>由此可见，Dispatchers.Unconfined 其实是很危险的。<strong>所以，我们不应该随意使用 Dispatchers.Unconfined</strong>。</p><p>好，现在我们也了解了 CoroutineContext 的常见应用场景。不过，我们还没解释这节课的标题，什么是“万物皆为 Context”？</p><h2 id="万物皆有-Context"><a href="#万物皆有-Context" class="headerlink" title="万物皆有 Context"></a>万物皆有 Context</h2><p>所谓的“万物皆为 Context”，当然是一种夸张的说法，我们换成“万物皆有 Context”可能更加准确。</p><p>在 Kotlin 协程当中，但凡是重要的概念，都或多或少跟 CoroutineContext 有关系：Job、Dispatcher、CoroutineExceptionHandler、CoroutineScope，甚至挂起函数，它们都跟 CoroutineContext 有着密切的联系。甚至，它们之中的 Job、Dispatcher、CoroutineExceptionHandler 本身，就是 Context。</p><p>我这么一股脑地告诉你，你肯定觉得晕乎乎，所以下面我们就一个个来看。</p><h2 id="CoroutineScope"><a href="#CoroutineScope" class="headerlink" title="CoroutineScope"></a>CoroutineScope</h2><p>在学习 launch 的时候，我提到过如果要调用 launch，就必须先有“协程作用域”，也就是 CoroutineScope。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            注意这里</span></span><br><span class="line"><span class="comment">//               ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CoroutineScope 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineScope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你去看 CoroutineScope 的源码，你会发现，它其实就是一个简单的接口，而这个接口只有唯一的成员，就是 CoroutineContext。所以，CoroutineScope 只是对 CoroutineContext 做了一层封装而已，它的核心能力其实都来自于 CoroutineContext。</p><p>而 CoroutineScope 最大的作用，就是可以方便我们批量控制协程。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 仅用于测试，生成环境不要使用这么简易的CoroutineScope</span></span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        logX(<span class="string">&quot;First start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;First end!&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        logX(<span class="string">&quot;Second start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;Second end!&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        logX(<span class="string">&quot;Third start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;Third end!&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line"></span><br><span class="line">    scope.cancel()</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">First start!</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Third start!</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-3 @coroutine#4</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Second start!</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-2 @coroutine#3</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们自己创建了一个简单的 CoroutineScope，接着，我们使用这个 scope 连续创建了三个协程，在 500 毫秒以后，我们就调用了 scope.cancel()，这样一来，代码中每个协程的“end”日志就不会输出了。</p><p>这同样体现了<strong>协程结构化并发</strong>的理念，相同的功能，我们借助 Job 也同样可以实现。关于 CoroutineScope 更多的底层细节，我们会在源码篇的时候深入学习。</p><p>那么接下来，我们就看看 Job 跟 CoroutineContext 的关系。</p><h2 id="Job-和-Dispatcher"><a href="#Job-和-Dispatcher" class="headerlink" title="Job 和 Dispatcher"></a>Job 和 Dispatcher</h2><p>如果说 CoroutineScope 是封装了 CoroutineContext，那么 Job 就是一个真正的 CoroutineContext 了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Job</span> : <span class="type">CoroutineContext.Element</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> : <span class="type">CoroutineContext</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码很有意思，Job 继承自 CoroutineContext.Element，而 CoroutineContext.Element 仍然继承自 CoroutineContext，这就意味着 Job 是间接继承自 CoroutineContext 的。所以说，Job 确实是一个真正的 CoroutineContext。</p><p>所以，我们写这样的代码也完全没问题：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job: CoroutineContext = Job()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，更有趣的是 CoroutineContext 本身的接口设计。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Key</span>&lt;<span class="type">E : Element</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中的 get()、plus()、minusKey()、fold() 这几个方法，我们可以看到 CoroutineContext 的接口设计，就跟集合 API 一样。准确来说，它的 API 设计和 Map 十分类似。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/a6/26/a611d29c307f953ebb099554a06a5d26.png?wh=1429x627" alt="img"></p><p>所以，我们完全可以<strong>把 CoroutineContext 当作 Map 来用</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@OptIn(ExperimentalStdlibApi::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job() + mySingleDispatcher)</span><br><span class="line"></span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        <span class="comment">// 注意这里</span></span><br><span class="line">        logX(coroutineContext[CoroutineDispatcher] == mySingleDispatcher)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;First end!&quot;</span>)  <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    scope.cancel()</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">Thread:MySingleThread @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用了“Job() + mySingleDispatcher”这样的方式创建 CoroutineScope，代码之所以这么写，是因为 CoroutineContext 的 plus() 进行了<strong>操作符重载</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     操作符重载</span></span><br><span class="line"><span class="comment">//        ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">plus</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br></pre></td></tr></table></figure><p>你注意这里代码中的 <strong>operator 关键字</strong>，如果少了它，我们就得换一种方式了：mySingleDispatcher.plus(Job())。因为，当我们用 operator 修饰 plus() 方法以后，就可以用“+”来重载这个方法，类似的，List 和 Map 都支持这样的写法：list3 &#x3D; list1+list2、map3 &#x3D; map1 + map2，这代表集合之间的合并。</p><p>另外，我们还使用了“coroutineContext[CoroutineDispatcher]”这样的方式，访问当前协程所对应的 Dispatcher。这也是因为 CoroutineContext 的 get()，支持了<strong>操作符重载</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     操作符重载</span></span><br><span class="line"><span class="comment">//        ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br></pre></td></tr></table></figure><p>实际上，在 Kotlin 当中很多集合也是支持 get() 方法重载的，比如 List、Map，我们都可以使用这样的语法：list[0]、map[key]，以数组下标的方式来访问集合元素。</p><p>还记得我们在第 1 讲提到的“集合与数组的访问方式一致”这个知识点吗？现在我们知道了，这都要归功于操作符重载。实际上，Kotlin 官方的源代码当中大量使用了操作符重载来简化代码逻辑，而 CoroutineContext 就是一个最典型的例子。</p><p>如果你足够细心的话，这时候你应该也发现了：Dispatcher 本身也是 CoroutineContext，不然它怎么可以实现“Job() + mySingleDispatcher”这样的写法呢？最重要的是，当我们以这样的方式创建出 scope 以后，后续创建的协程就全部都运行在 mySingleDispatcher 这个线程之上了。</p><p>那么，<strong>Dispatcher 到底是如何跟 CoroutineContext 建立关系的呢？</strong>让我们来看看它的源码吧。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">object</span> Dispatchers &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Default: CoroutineDispatcher = DefaultScheduler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Main: MainCoroutineDispatcher <span class="keyword">get</span>() = MainDispatcherLoader.dispatcher</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> IO: CoroutineDispatcher = DefaultIoScheduler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">shutdown</span><span class="params">()</span></span> &#123;    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoroutineDispatcher</span> :</span><br><span class="line">    <span class="type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Dispatchers 其实是一个 object 单例，它的内部成员的类型是 CoroutineDispatcher，而它又是继承自 ContinuationInterceptor，这个类则是实现了 CoroutineContext.Element 接口。由此可见，Dispatcher 确实就是 CoroutineContext</p><h2 id="其他-CoroutineContext"><a href="#其他-CoroutineContext" class="headerlink" title="其他 CoroutineContext"></a>其他 CoroutineContext</h2><p>除了上面几个重要的 CoroutineContext 之外，协程其实还有一些上下文是我们还没提到的。比如 CoroutineName，当我们创建协程的时候，可以传入指定的名称。比如：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段18</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@OptIn(ExperimentalStdlibApi::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job() + mySingleDispatcher)</span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    scope.launch(CoroutineName(<span class="string">&quot;MyFirstCoroutine!&quot;</span>)) &#123;</span><br><span class="line">        logX(coroutineContext[CoroutineDispatcher] == mySingleDispatcher)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;First end!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    scope.cancel()</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">Thread:MySingleThread @MyFirstCoroutine!#2  // 注意这里</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们调用 launch 的时候，传入了“CoroutineName(“MyFirstCoroutine!”)”作为协程的名字。在后面输出的结果中，我们得到了“@MyFirstCoroutine!#2”这样的输出。由此可见，其中的数字“2”，其实是一个自增的唯一 ID。</p><p>CoroutineContext 当中，还有一个重要成员是 <strong>CoroutineExceptionHandler</strong>，它主要负责处理协程当中的异常。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineExceptionHandler</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleException</span><span class="params">(context: <span class="type">CoroutineContext</span>, exception: <span class="type">Throwable</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，CoroutineExceptionHandler 的接口定义其实很简单，我们基本上一眼就能看懂。CoroutineExceptionHandler 真正重要的，其实只有 handleException() 这个方法，如果我们要自定义异常处理器，我们就只需要实现该方法即可。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  这里使用了挂起函数版本的main()</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> myExceptionHandler = CoroutineExceptionHandler &#123; _, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Catch exception: <span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job() + mySingleDispatcher)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> job = scope.launch(myExceptionHandler) &#123;</span><br><span class="line">        <span class="keyword">val</span> s: String? = <span class="literal">null</span></span><br><span class="line">        s!!.length <span class="comment">// 空指针异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Catch exception: java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>不过，虽然 CoroutineExceptionHandler 的用法看起来很简单，但当它跟协程“结构化并发”理念相结合以后，内部的异常处理逻辑是很复杂的。关于协程异常处理的机制，我们会在第 23 讲详细介绍。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课的内容到这里就结束了，我们来总结一下吧。</p><ul><li>CoroutineContext，是 Kotlin 协程当中非常关键的一个概念。它本身是一个接口，但它的接口设计与 Map 的 API 极为相似，我们在使用的过程中，也可以<strong>把它当作 Map 来用</strong>。</li><li>协程里很多重要的类，它们本身都是 CoroutineContext。比如 Job、Deferred、Dispatcher、ContinuationInterceptor、CoroutineName、CoroutineExceptionHandler，它们都继承自 CoroutineContext 这个接口。也正因为它们都继承了 CoroutineContext 接口，所以我们可以通过<strong>操作符重载</strong>的方式，写出更加灵活的代码，比如“Job() + mySingleDispatcher+CoroutineName(“MyFirstCoroutine!”)”。</li><li>协程当中的 CoroutineScope，本质上也是 CoroutineContext 的一层<strong>简单封装</strong>。</li><li>另外，协程里极其重要的“挂起函数”，它与 CoroutineContext 之间也有着非常紧密的联系。</li></ul><p>另外我也画了一张结构图，来描述 CoroutineContext 元素之间的关系，方便你建立完整的知识体系。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/eb/76/eb225787718e0d2cff8a55bcba86yy76.jpg?wh=2000x1125" alt="img"></p><p>所以总的来说，我们前面学习的 Job、Dispatcher、CoroutineName，它们本质上只是 CoroutieContext 这个集合当中的一种数据类型，只是恰好 Kotlin 官方让它们都继承了 CoroutineContext 这个接口。而 CoroutineScope 则是对 CoroutineContext 的进一步封装，它的核心能力，全部都是源自于 CoroutineContext。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>课程里，我提到了“挂起函数”与 CoroutineContext 也有着紧密的联系，请问，你能找到具体的证据吗？或者，你觉得下面的代码能成功运行吗？为什么？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.coroutines.coroutineContext</span><br><span class="line"></span><br><span class="line"><span class="comment">//                        挂起函数能可以访问协程上下文吗？</span></span><br><span class="line"><span class="comment">//                                 ↓                              </span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testContext</span><span class="params">()</span></span> = coroutineContext</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(testContext())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(协程篇)16  Job：协程也有生命周期吗？</title>
      <link href="/posts/5b46e6ea/"/>
      <url>/posts/5b46e6ea/</url>
      
        <content type="html"><![CDATA[<p>今天我们来学习 Kotlin 协程的 Job。</p><p>Job 其实就是协程的句柄。从某种程度上讲，当我们用 launch 和 async 创建一个协程以后，同时也会创建一个对应的 Job 对象。另外，Job 也是我们理解<strong>协程生命周期、结构化并发</strong>的关键知识点。通过 Job 暴露的 API，我们还可以让不同的协程之间互相配合，从而实现更加复杂的功能。</p><p>虽然前面已经解释过，Job 就是协程的句柄，但你可能还是不清楚它到底是什么，因为句柄本身就是一个比较“虚”的概念。所以在这节课中，我们会从使用的角度入手，来看看 Job 到底能干什么。在充分理解了 Job 的用法以后，我们再来结合它的源代码进一步分析，这样对 Job 也会有一个更加清晰的认知。</p><h2 id="Job-生命周期"><a href="#Job-生命周期" class="headerlink" title="Job 生命周期"></a>Job 生命周期</h2><p>在上节课我们学习 launch、async 的时候，我们知道它们两个返回值类型分别是 Job 和 Deferred。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deferred</span>&lt;<span class="type">out T</span>&gt; : <span class="type">Job</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果你去看 Deferred 的源代码，你会发现，它其实也是继承自 Job 的。对应的，它只是多了一个泛型参数 T，还多了一个返回类型为 T 的 await() 方法。所以，不管是 launch 还是 async，<strong>它们本质上都会返回一个 Job 对象</strong>。</p><p>通过 Job 对象，我们主要可以做两件事情：</p><ul><li>使用 Job <strong>监测</strong>协程的生命周期状态；</li><li>使用 Job <strong>操控</strong>协程。</li></ul><p>让我们来看一个具体的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job.log()       <span class="comment">// ①</span></span><br><span class="line">    job.cancel()    <span class="comment">// ②</span></span><br><span class="line">    job.log()       <span class="comment">// ③</span></span><br><span class="line">    delay(<span class="number">1500L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印Job的状态信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Job.<span class="title">log</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logX(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        isActive = <span class="variable">$isActive</span></span></span><br><span class="line"><span class="string">        isCancelled = <span class="variable">$isCancelled</span></span></span><br><span class="line"><span class="string">        isCompleted = <span class="variable">$isCompleted</span></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimIndent())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制台输出带协程信息的log</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">logX</span><span class="params">(any: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">================================</span></span><br><span class="line"><span class="string"><span class="variable">$any</span></span></span><br><span class="line"><span class="string">Thread:<span class="subst">$&#123;Thread.currentThread().name&#125;</span></span></span><br><span class="line"><span class="string">================================&quot;&quot;&quot;</span>.trimIndent())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = true</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = false</span></span><br><span class="line"><span class="comment">isCancelled = true</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在这段代码当中，我们定义了一个 Job.log() 扩展函数，它的作用就是打印 Job 的生命周期状态。通过调用这个函数，我们就可以知道对应的协程处于什么状态。</p><p>注释①处的调用结果，“isActive &#x3D; true”，这代表了当前的协程处于活跃状态。注释②，我们调用了 job.cancel() 以后，协程任务就会被取消。因此，注释③处的调用结果就会变成“isCancelled &#x3D; true”，这代表了协程任务处于取消状态。</p><p>所以从上面的代码中，我们可以看到：job.log()，其实就是在<strong>监测协程</strong>；job.cancel()，其实就是在<strong>操控协程</strong>。</p><p>而除了 job.cancel() 可以操控协程以外，我们还经常使用 job.start() 来启动协程任务，一般来说，它都是搭配“CoroutineStart.LAZY”来使用的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">//                  变化在这里</span></span><br><span class="line">    <span class="comment">//                      ↓</span></span><br><span class="line">    <span class="keyword">val</span> job = launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">        logX(<span class="string">&quot;Coroutine start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500L</span>)     </span><br><span class="line">    job.log()       </span><br><span class="line">    job.start()     <span class="comment">// 变化在这里</span></span><br><span class="line">    job.log()</span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    job.cancel()</span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    job.log()</span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = false</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = true</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Coroutine start!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = false</span></span><br><span class="line"><span class="comment">isCancelled = true</span></span><br><span class="line"><span class="comment">isCompleted = true</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>根据以上代码的运行结果，可以发现，当我们使用 CoroutineStart.LAZY 作为启动模式的时候，协程任务被 launch 以后，并不会立即执行，即使我们在代码中 delay 了 500 毫秒，launch 内部的”Coroutine start!”也仍然没有输出。这是典型的<strong>懒加载</strong>行为模式。</p><p>当我们在外部调用了 job.start() 以后，job 的状态才变成了 Active 活跃。而当调用了 cancel 以后，job 的状态才变成 isCancelled、isCompleted。</p><p>到这里，我们基本上就可以想象出 Job 整个的生命周期了。请参考下面这张图：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/c1/52/c1d2515fcb7c3fa4130fcf85e9dd2852.jpg?wh=2000x846" alt="img"></p><p>从图中，我们可以看到，对于协程的 Job 来说，它有两种初始状态，如果 Job 是以<strong>懒加载</strong>的方式创建的，那么它的初始状态将会是 New；而如果一个协程是以<strong>非懒加载</strong>的方式创建的，那么它的初始状态就会是 Active。</p><p>另外如果你仔细分析了上面代码的输出结果，你会发现，当调用 cancel 以后，会出现一个奇怪的现象：isCancelled &#x3D; true、isCompleted &#x3D; true。也就是说，当协程任务被取消以后，isCancelled 和 isCompleted 同时都是 true。但这跟上面的流程图并不一致啊！这是为什么呢？</p><p>这是因为，协程认为由于某种原因取消的协程，也仍然是一种“<strong>结束状态</strong>”，这其实也就对应了流程图中的“最终状态”。</p><p>换句话说，流程图当中的 New、Active、Completing、Cancelling、Completed、Cancelled 这些状态，都是 Job 内部私有的状态。而 Job 对外暴露出的 isCompleted 并不是与其一一对应的。Job 内部私有的 Completed、Cancelled 状态，都会认为是外部的 isCompleted 状态。</p><p>测试了协程 cancel() 方法以后，我们再来看看协程正常执行完毕的情况：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">        logX(<span class="string">&quot;Coroutine start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    job.log()</span><br><span class="line">    job.start()</span><br><span class="line">    job.log()</span><br><span class="line">    delay(<span class="number">1100L</span>)    <span class="comment">// ①</span></span><br><span class="line">    job.log()</span><br><span class="line">    delay(<span class="number">2000L</span>)    <span class="comment">// ②</span></span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">================================</span><br><span class="line">isActive = <span class="literal">false</span></span><br><span class="line">isCancelled = <span class="literal">false</span></span><br><span class="line">isCompleted = <span class="literal">false</span></span><br><span class="line">Thread:main <span class="meta">@coroutine</span>#<span class="number">1</span></span><br><span class="line">================================</span><br><span class="line">================================</span><br><span class="line">isActive = <span class="literal">true</span></span><br><span class="line">isCancelled = <span class="literal">false</span></span><br><span class="line">isCompleted = <span class="literal">false</span></span><br><span class="line">Thread:main <span class="meta">@coroutine</span>#<span class="number">1</span></span><br><span class="line">================================</span><br><span class="line">================================</span><br><span class="line">Coroutine start!</span><br><span class="line">Thread:main <span class="meta">@coroutine</span>#<span class="number">2</span></span><br><span class="line">================================</span><br><span class="line">================================</span><br><span class="line">isActive = <span class="literal">false</span></span><br><span class="line">isCancelled = <span class="literal">false</span></span><br><span class="line">isCompleted = <span class="literal">true</span></span><br><span class="line">Thread:main <span class="meta">@coroutine</span>#<span class="number">1</span></span><br><span class="line">================================</span><br><span class="line">================================</span><br><span class="line">Process end!</span><br><span class="line">Thread:main <span class="meta">@coroutine</span>#<span class="number">1</span></span><br><span class="line">================================</span><br></pre></td></tr></table></figure><p>在这段代码中，我们可以清晰地看到，协程的状态从 Start 到 Active，最后到 Completed，这很好理解。</p><p>不过，需要注意的是注释①处，为了等待 job 任务执行完毕，我们在外面等待了 1100 毫秒，这种方式其实并不好，因为大部分情况下，<strong>我们很难从外部判断协程需要多长的时间才能结束</strong>（比如网络请求任务、下载任务）。</p><p>另外，请留意上面的注释②处，我们使用 delay(2000L) 的方式，希望在 job 执行完毕以后输出“Process end!”，这样的代码，也是建立在“我们知道 Job 只需要 1000 毫秒就能执行完毕”的前提。如果协程内部的 delay 远大于外部的 delay，以上的运行结果就会完全不一样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">        logX(<span class="string">&quot;Coroutine start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">4000L</span>) <span class="comment">// 变化在这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    job.log()</span><br><span class="line">    job.start()</span><br><span class="line">    job.log()</span><br><span class="line">    delay(<span class="number">1100L</span>)    </span><br><span class="line">    job.log()</span><br><span class="line">    delay(<span class="number">2000L</span>)    </span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = false</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = true</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Coroutine start!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = true</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">到这里，job仍然还在delay，整个程序并没有完全退出。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，当我们将 job 内部的 delay 改为 4000 毫秒以后，执行结果就完全不一样了，我们无法监测到 isCompleted 状态。</p><p>另外，如果你实际运行了上面的代码，你会发现“Process end!”输出以后，程序并没有立即结束，而是等待了大约 900 毫秒才结束，这是因为 runBlocking 会一直阻塞，等到 job 任务执行完毕以后才真正退出。</p><p>所以，为了更加灵活地<strong>等待和监听</strong>协程的结束事件，我们可以用 job.join() 以及 invokeOnCompletion {} 来优化上面的代码。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">download</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 模拟下载任务</span></span><br><span class="line">        <span class="keyword">val</span> time = (Random.nextDouble() * <span class="number">1000</span>).toLong()</span><br><span class="line">        logX(<span class="string">&quot;Delay time: = <span class="variable">$time</span>&quot;</span>)</span><br><span class="line">        delay(time)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> job = launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">        logX(<span class="string">&quot;Coroutine start!&quot;</span>)</span><br><span class="line">        download()</span><br><span class="line">        logX(<span class="string">&quot;Coroutine end!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    job.log()</span><br><span class="line">    job.start()</span><br><span class="line">    job.log()</span><br><span class="line">    job.invokeOnCompletion &#123;</span><br><span class="line">        job.log() <span class="comment">// 协程结束以后就会调用这里的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    job.join()      <span class="comment">// 等待协程执行完毕</span></span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = false</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = true</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Coroutine start!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Delay time: = 252</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Coroutine end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = false</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = true</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这里我们可以看到，invokeOnCompletion {} 的作用，其实就是监听协程结束的事件。需要注意的是，它和前面的 isCompleted 类似，如果 job 被取消了，invokeOnCompletion {} 这个回调仍然会被调用。</p><p>而 job.join() 其实是一个“挂起函数”，它的作用就是：<strong>挂起当前的程序执行流程，等待 job 当中的协程任务执行完毕，然后再恢复当前的程序执行流程</strong>。可以看到，上节课学的“挂起函数”的概念再一次出现了，它对我们后续理解协程的 API 非常重要，如果你无法理解上面那句话的意思，一定要去重新回顾上节课的内容。</p><p>至此，我们就对 Job 的两种使用场景都已经有了充分认识了。我们来大概看看 Job 的源代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Job</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ 状态查询API ------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isActive: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isCompleted: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isCancelled: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCancellationException</span><span class="params">()</span></span>: CancellationException</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ 操控状态API ------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">(cause: <span class="type">CancellationException</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = cancel(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">(cause: <span class="type">Throwable</span>? = <span class="literal">null</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ 等待状态API ------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onJoin: SelectClause0</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ 完成状态回调API ------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnCompletion</span><span class="params">(handler: <span class="type">CompletionHandler</span>)</span></span>: DisposableHandle</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnCompletion</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        onCancelling: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        invokeImmediately: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        handler: <span class="type">CompletionHandler</span>)</span></span>: DisposableHandle</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，Kotlin 官方对 Job 的 API 做了更加详细的划分，但实际上来说都属于“<strong>监测状态</strong>”“<strong>操控状态</strong>”这两个大的范畴。</p><p>现在我们对 Job 也有了更加深入的认识了，不过到底该如何理解“<strong>Job 是协程的句柄</strong>”这句话呢？</p><p>这里，我们还是可以从现实生活中找例子，来建立大致的思维模型。Job 和协程的关系，就有点像“遥控器和空调的关系”。</p><ul><li>空调遥控器可以<strong>监测</strong>空调的运行状态；Job 也可以监测协程的运行状态；</li><li>空调遥控器可以<strong>操控</strong>空调的运行状态，Job 也可以简单操控协程的运行状态。</li></ul><p>所以，从某种程度来讲，遥控器也是空调对外暴露的一个“句柄”。</p><p>好，充分理解了 Job 以后，我们来看看 Deferred。</p><h2 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h2><p>前面我们介绍过 Deferred 其实就是继承自 Job 的一个接口，它并没有在 Job 的基础上扩展出很多其他功能，最重要的就是 await() 这个方法。让我们来看一个简单的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = async &#123;</span><br><span class="line">        logX(<span class="string">&quot;Coroutine start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;Coroutine end!&quot;</span>)</span><br><span class="line">        <span class="string">&quot;Coroutine result!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> result = deferred.await()</span><br><span class="line">    println(<span class="string">&quot;Result = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Coroutine start!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Coroutine end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Result = Coroutine result!</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从代码的执行结果中，我们可以发现，deferred.await() 这个方法，不仅可以帮助我们获取协程的执行结果，它还会阻塞当前协程的执行流程，直到协程任务执行完毕。在这一点的行为上，await() 和 join() 是类似的。</p><p>我们也来看看 await() 的函数签名：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deferred</span>&lt;<span class="type">out T</span>&gt; : <span class="type">Job</span> &#123;</span><br><span class="line"><span class="comment">//          注意这里</span></span><br><span class="line"><span class="comment">//            ↓</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，await() 这个方法其实是一个挂起函数，这也就意味着，这个方法拥有挂起和恢复的能力。如果当前的 Deferred 任务还没执行完毕，那么，await() 就会挂起当前的协程执行流程，等待 Deferred 任务执行完毕，再恢复执行后面剩下的代码。</p><p>看到这里，也许你会觉得奇怪，<strong>挂起函数不是非阻塞的吗？怎么这里又出现了阻塞</strong>？注意，这里其实只是看起来像是阻塞了，但它实际上是将剩下的代码存了起来，留在后面才执行了。</p><p>为了让你更加透彻地理解 await() 挂起函数背后的细节，我进一步完善了之前协程思维模型的动图。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/e3/37/e30c901b79682faaa00fd0d978521b37.gif?wh=1080x517" alt="img"></p><p>所以，这里 await() 后面的代码，虽然看起来是阻塞了，但它只是执行流程被挂起和恢复的一种表现。而且如果你仔细思考的话，你会发现上面这个动图，同样也描述了之前 job.join() 的行为模式，在协程执行完毕之前，后面的协程代码都被暂时挂起了，等到协程执行完毕，才有机会继续执行。</p><p>所以，总的来说，Deferred 只是比 Job 多了一个 await() 挂起函数而已，通过这个挂起函数，我们可以等待协程执行完毕的同时，还可以直接拿到协程的执行结果。</p><p>至此，我们就已经把 Job 和 Deferred 的生命周期讲清楚了。对于 Job，我们了解了<strong>监测生命周期状态、操控生命周期状态</strong>；对于 Deferred，我们也明白了如何拿到它的<strong>执行结果</strong>。</p><p>那么接下来，就只剩下一个话题了：<strong>结构化并发</strong>。</p><h2 id="Job-与结构化并发"><a href="#Job-与结构化并发" class="headerlink" title="Job 与结构化并发"></a>Job 与结构化并发</h2><p>也许你会经常看到类似这样的话：协程的优势在于结构化并发。在我看来，Kotlin 协程的结构化并发，它的重要性，是仅次于“挂起函数”的。</p><p>也就是说，“<strong>结构化并发”是 Kotlin 协程的第二大优势</strong>。那么，到底什么是结构化并发呢？其实，这是一个非常大的话题，三言两语真的很难讲清楚。“结构化并发”会贯穿我们整个课程，随着课程的进展，你会发现，它跟很多其他协程概念都会发生牵连。</p><p>简单来说，“结构化并发”就是：<strong>带有结构和层级的并发</strong>。</p><p>说实话，在抽象的概念面前，语言和文字总会显得苍白无力。所以，我们还是来看一个具体的例子吧。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> parentJob: Job</span><br><span class="line">    <span class="keyword">var</span> job1: Job? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> job2: Job? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> job3: Job? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    parentJob = launch &#123;</span><br><span class="line">        job1 = launch &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        job2 = launch &#123;</span><br><span class="line">            delay(<span class="number">3000L</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        job3 = launch &#123;</span><br><span class="line">            delay(<span class="number">5000L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line"></span><br><span class="line">    parentJob.children.forEachIndexed &#123; index, job -&gt;</span><br><span class="line">        <span class="keyword">when</span> (index) &#123;</span><br><span class="line">            <span class="number">0</span> -&gt; println(<span class="string">&quot;job1 === job is <span class="subst">$&#123;job1 === job&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="number">1</span> -&gt; println(<span class="string">&quot;job2 === job is <span class="subst">$&#123;job2 === job&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="number">2</span> -&gt; println(<span class="string">&quot;job3 === job is <span class="subst">$&#123;job3 === job&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parentJob.join() <span class="comment">// 这里会挂起大约5秒钟</span></span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">job1 === job is true</span></span><br><span class="line"><span class="comment">job2 === job is true</span></span><br><span class="line"><span class="comment">job3 === job is true</span></span><br><span class="line"><span class="comment">// 等待大约5秒钟</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们一共定义了 4 个 Job，parentJob 是最外层的 launch 返回的对象，而在这个 launch 的内部，还额外嵌套了三个 launch，它们的 Job 对象分别赋值给了 job1、job2、job3。</p><p>接着，我们对“parentJob.children”进行了遍历，然后逐一对比了它们与 job1、job2、job3 的引用是否相等（“&#x3D;&#x3D;&#x3D;”代表了引用相等，即是否是同一个对象）。</p><p>通过这样的方式，我们可以确定，job1、job2、job3 其实就是 parentJob 的 children。也就是说，我们使用 launch 创建出来的协程，是存在<strong>父子关系</strong>的。</p><p>如果你去看 Job 的源代码，你会发现它还有两个 API 是用来描述父子关系的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Job</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ parent-child ------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> children: Sequence&lt;Job&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InternalCoroutinesApi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">attachChild</span><span class="params">(child: <span class="type">ChildJob</span>)</span></span>: ChildHandle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，每个 Job 对象，都会有一个 children 属性，它的类型是 Sequence，它是一个惰性的集合，我们可以对它进行遍历。而 attachChild() 则是一个协程内部的 API，用于绑定 ChildJob 的，这个我们到源码篇的时候再深入了解。</p><p>所以，我们其实可以用一个简单的结构图来描述上面 4 个 Job 之间的关系：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/b0/4c/b03c8e45f00bf7276c988e7038fcc44c.png?wh=1436x776" alt="img"></p><p>那么，这样的父子关系到底意味着什么呢？如果你实际运行这里的代码，你就会注意到：“parentJob.join()”这行代码会被挂起大约 5 秒钟。</p><p>注意了，我们调用的是 parentJob 的 join() 方法，但是，它会等待其内部的 job1、job2、job3 全部执行完毕，才会恢复执行。换句话说，只有当 job1、job2、job3 全部执行完毕，parentJob 才算是执行完毕了。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/83/a0/838728245b22e99c7900ba50968dcba0.gif?wh=1080x608" alt="img"></p><p>所以到这里，也许你就已经可以理解前面的那句话了：<strong>结构化并发就是带有结构和层级的并发</strong>。</p><p>实际上，协程不像我们之前学过的线程，线程之间是不存在父子关系的，但协程之间是会存在父子关系的。不过要命的是，协程的这种父子关系并不明显，如果我们不深入 Job 的源码，就无法意识到这一点。这也是很多人无法理解协程运行模式的原因所在。</p><p>毕竟，如果你将上面的 4 个 launch 都割裂来看，那么无论如何，你都无法理解上面代码的运行顺序，可是一旦你建立了协程 Job 父子关系的思维模型，你就可以轻而易举地理解以上的代码。</p><p>现在，我们将上面的代码做一些修改，我相信你也可以马上弄明白它的运行模式！</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> parentJob: Job</span><br><span class="line">    <span class="keyword">var</span> job1: Job? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> job2: Job? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> job3: Job? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    parentJob = launch &#123;</span><br><span class="line">        job1 = launch &#123;</span><br><span class="line">            logX(<span class="string">&quot;Job1 start!&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            logX(<span class="string">&quot;Job1 done!&quot;</span>) <span class="comment">// ①，不会执行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        job2 = launch &#123;</span><br><span class="line">            logX(<span class="string">&quot;Job2 start!&quot;</span>)</span><br><span class="line">            delay(<span class="number">3000L</span>)</span><br><span class="line">            logX(<span class="string">&quot;Job2 done!&quot;</span>) <span class="comment">// ②，不会执行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        job3 = launch &#123;</span><br><span class="line">            logX(<span class="string">&quot;Job3 start!&quot;</span>)</span><br><span class="line">            delay(<span class="number">5000L</span>)</span><br><span class="line">            logX(<span class="string">&quot;Job3 done!&quot;</span>)<span class="comment">// ③，不会执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line"></span><br><span class="line">    parentJob.children.forEachIndexed &#123; index, job -&gt;</span><br><span class="line">        <span class="keyword">when</span> (index) &#123;</span><br><span class="line">            <span class="number">0</span> -&gt; println(<span class="string">&quot;job1 === job is <span class="subst">$&#123;job1 === job&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="number">1</span> -&gt; println(<span class="string">&quot;job2 === job is <span class="subst">$&#123;job2 === job&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="number">2</span> -&gt; println(<span class="string">&quot;job3 === job is <span class="subst">$&#123;job3 === job&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parentJob.cancel() <span class="comment">// 变化在这里</span></span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Job1 start!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#3</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Job2 start!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#4</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Job3 start!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#5</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">job1 === job is true</span></span><br><span class="line"><span class="comment">job2 === job is true</span></span><br><span class="line"><span class="comment">job3 === job is true</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">// 这里不会等待5秒钟</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这段代码，最大的改变就在于我们将“parentJob.join”改为了“parentJob.cancel()”。从运行结果中我们可以看到，即使我们调用的只是 parentJob 的 cancel() 方法，并没有碰过 job1、job2、job3，但是它们内部的协程任务也全都被取消了。</p><p>这里，我们也可以用一个简单的动图来描述它们之间的关系：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/26/7a/269a6130578ed243e436469ac75c4d7a.gif?wh=1080x484" alt="img"></p><p>所以，当我们以<strong>结构化</strong>的方式构建协程以后，我们的 join()、cancel() 等操作，也会以结构化的模式来执行。</p><h2 id="思考与实战"><a href="#思考与实战" class="headerlink" title="思考与实战"></a>思考与实战</h2><p>在学完 Job 和 Deferred 以后，也许你已经可以非常明确地判断出什么场景该用 launch，什么场景该用 async 了。那么，这是不是就意味着你已经完成了学习的目标呢？</p><p>当然不是！理论学得再多，如果不能结合实际落地场景来分析，那终究都是一场空。接下来，我们来看一个常见的代码模式：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult1</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Result1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult2</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Result2&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult3</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Result3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> results = mutableListOf&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        results.add(getResult1())</span><br><span class="line">        results.add(getResult2())</span><br><span class="line">        results.add(getResult3())</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Time: <span class="variable">$time</span>&quot;</span>)</span><br><span class="line">    println(results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Time: 3018</span></span><br><span class="line"><span class="comment">[Result1, Result2, Result3]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这段代码里，我们在内部定义了三个挂起函数 getResult1()、getResult2()、getResult3()，它们各自都会耗时 1000 毫秒，而且它们之间的运行结果也互不相干。代码逻辑也很简单，也是我们平时在工作中会经常遇到的业务场景。</p><p>不过请问，你知道该如何优化上面的代码吗？</p><p>我们进一步来分析一下。当我们直接调用这三个挂起函数，并且拿到结果以后，整个过程大约需要消耗 3000 毫秒，也就是这几个函数耗时的总和。对于这样的情况，我们其实完全可以使用 async 来优化：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult1</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Result1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult2</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Result2&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult3</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Result3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> results: List&lt;String&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> result1 = async &#123; getResult1() &#125;</span><br><span class="line">        <span class="keyword">val</span> result2 = async &#123; getResult2() &#125;</span><br><span class="line">        <span class="keyword">val</span> result3 = async &#123; getResult3() &#125;</span><br><span class="line"></span><br><span class="line">        results = listOf(result1.await(), result2.await(), result3.await())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Time: <span class="variable">$time</span>&quot;</span>)</span><br><span class="line">    println(results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Time: 1032</span></span><br><span class="line"><span class="comment">[Result1, Result2, Result3]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所以，当我们总是拿 launch 和 async 来做对比的时候，就会不自觉地认为 async 是用来替代 launch 的。但实际上，async 最常见的使用场景是：<strong>与挂起函数结合，优化并发</strong>。</p><p>请不要小看这个场景，在实际工作中，如果你仔细去分析嵌套的异步代码，你会发现，很多异步任务之间都是没有互相依赖的，这样的代码结合挂起函数后，再通过 async 并发来执行，是可以大大提升代码运行效率的。</p><p>换句话说，如果我们的任务是 IO 密集型的，代码运行效率是可以实现成倍提升的。一个简单的改造，能极大地提升运行效率，何乐而不为呢？</p><p>那么，万一我们的任务在某些场景下，并发反而会降低效率呢？这也很简单，我们也完全可以使用 CoroutineStart 来控制它的启动模式。所以，这种方式的<strong>扩展性和灵活性</strong>都很好。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课，我们主要学习了 Job、Deferred，通过对它们两者的学习，我们知道了，<strong>协程是有生命周期的</strong>，同时也发现，<strong>协程其实是结构化的</strong>。</p><p>具体来说，有以下几个要点我们需要好好掌握：</p><ul><li>Job，相当于协程的句柄，Job 与协程的关系，有点像“遥控器与空调的关系”。</li><li>Job，在它的内部，维护了一系列的生命周期状态，它也对应着协程的生命周期状态。</li><li>通过 Job，我们可以<strong>监测</strong>协程的状态，比如 isActive、isCancelled、isCompleted；另外，我们也可以一定程度地<strong>操控</strong>协程的状态，比如 start()、cancel()。</li><li>除此之外，我们还可以通过 Job.invokeOnCompletion {} 来监听协程执行完毕的事件；通过 Job.join() 这个挂起函数，我们可以<strong>挂起</strong>当前协程的执行流程，等到协程执行完毕以后，再<strong>恢复</strong>执行后面的代码。</li><li>而对于 Deferred.await()，它的行为模式和 Job.join() 类似，只是它还会返回协程的执行结果。</li><li>另外，<strong>协程是结构化的并发</strong>，这是它的第二大优势。通过分析 Job 的源码，我们发现，一个 Job 可以拥有多个 ChildJob；对应的，协程也可拥有多个“子协程”。</li><li>那么结构化并发带来的最大优势就在于，我们可以实现只控制“父协程”，从而达到控制一堆子协程的目的。在前面的例子中，parentJob.join() 不仅仅只会等待它自身执行完毕，还会等待它内部的 job1、job2、job3 执行完毕。parentJob.cancel() 同理。</li></ul><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/5b/50/5bb335f24e87237067ed78a67ee2eb50.jpg?wh=2000x1240" alt="img"></p><p>最后呢，我也想跟你分享一下我学习协程的一些方法论。</p><p>其实，人学习新知识最快的方式，就是与<strong>旧的知识建立关联</strong>。举个例子，第一门计算机语言往往是最难学的，因为这是一个无中生有的过程；但当你掌握 C、C++ 以后，再去学习 Java、Python 就会简单很多，因为你可以用脑子里的旧知识与其建立关联。</p><p>所以，虽然我在学习协程的时候也走了很多弯路，但总的来说，我做对了以下几件事，这里我也把经验分享给你。</p><p>第一，<strong>横向对比</strong>。在初次学习 Kotlin 协程失败以后，我去粗略学习了其他语言的协程，在那个时候，C# 之类的协程学习资源更加丰富。通过对比 C#、Go 等语言的协程后，<strong>我理解了“广义协程”的概念</strong>，并且也知道 yield、async、await 只是一种广泛存在的协程模式。而当我理解了广义协程这个旧的知识之后，我突然发现 Kotlin 的协程就不难理解了。</p><p>第二，<strong>建立思维模型</strong>。这是我的一个“习惯”，不管是计算机网络、操作系统、数据结构、设计模式，还是其他领域，比如说高中的电磁学、大学的线性代数，在学习抽象知识的时候，我都喜欢虚构一些思维模型，来模拟它们内部的运行机制。</p><p>协程，就是一门非常抽象的技术，我喜欢用协程 API 编写一些简单的 Demo 来分析它们的行为模式，同时为其建立思维模型。这样一来，我脑海里的知识既不容易遗忘，也更成体系。比如，launch 就像射箭；async 就像钓鱼，这既是思维模型，<strong>同时也是在用旧知识学新知识。</strong></p><p>所以，现在回过头来看，其实最重要的，还是用旧知识学新知识。希望我的方法能对你有所启发。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>请问下面这段代码的执行结果是什么？你能分析出原因吗？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        logX(<span class="string">&quot;First coroutine start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;First coroutine end!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    job.join()      </span><br><span class="line">    <span class="keyword">val</span> job2 = launch(job) &#123;</span><br><span class="line">        logX(<span class="string">&quot;Second coroutine start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;Second coroutine end!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job2.join()</span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(协程篇)15  挂起函数：Kotlin协程的核心</title>
      <link href="/posts/96509131/"/>
      <url>/posts/96509131/</url>
      
        <content type="html"><![CDATA[<p>这节课，我们来学习协程的挂起函数。</p><p>挂起函数，是 Kotlin 协程当中最基础、最重要的知识点。如果对协程的挂起函数没有足够的认识，我们后续的学习将会困难重重。如果不理解挂起函数，我们将无法理解协程的非阻塞；如果不了解挂起函数，我们将无法掌握 Channel、Flow 等 API；如果不理解挂起函数，我们写出来的代码也会漏洞百出，就更别提优化软件架构了。</p><p>相反，如果能将挂起函数理解透彻，我们后面的学习也会更加轻松一些。所以这节课，我会从应用和原理两个角度，来带你理解挂起函数，包括如何使用挂起函数来优化异步任务，以及挂起函数的 CPS 当中的 Continuation 到底是什么。通过对这两个维度的学习，你在更轻易地掌握挂起函数应用场景的同时，对它的底层原理也会有一定认识。</p><p>那么接下来，你一定要打起精神，我们一起来攻克这个关键的知识点！</p><h2 id="挂起函数：Kotlin-协程的优势"><a href="#挂起函数：Kotlin-协程的优势" class="headerlink" title="挂起函数：Kotlin 协程的优势"></a>挂起函数：Kotlin 协程的优势</h2><p>通过前面课程的学习，我们已经知道了：协程就像是轻量级的线程一样。用线程能实现的功能，我们借助 launch 和 async 也同样可以做到。</p><p>不过你可能会好奇，如果只是把 thread{} 替换成 launch{}，那协程比起线程也没什么特殊的优势吧？仅<strong>仅只是因为“轻量”“非阻塞”，我们就应该放弃线程，拥抱协程吗？</strong></p><p>其实，Kotlin 协程最大的优势，就在于它的挂起函数。虽然很多编程语言都有协程的特性，但目前为止，只有 Kotlin 独树一帜，引入了“挂起函数”的概念。另外尽管有些语言的协程底层，也存在“挂起恢复”的概念，但是将这一概念直接暴露给开发者，直接用于修饰一个函数的，Kotlin 算是做了一种创新。</p><p>那么，挂起函数到底有什么神奇的呢？我们先来看一段简单的 Java 代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line">getUserInfo(new CallBack() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onSuccess(String response) &#123;</span><br><span class="line">        <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这段代码中，我们发起了一个异步请求，从服务端查询用户的信息，通过 CallBack 返回 response。这样的代码看起来没什么问题，平时我们写代码的时候也经常写类似的代码。不过实际的商业项目不可能这么简单，有的时候，我们可能需要连续执行几个异步任务，比如说，查询用户信息 –&gt; 查找该用户的好友列表 –&gt; 拿到好友列表后，查找该好友的动态。</p><p>这样一来，我们的代码就难免会往下面这个方向发展：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line">getUserInfo(<span class="keyword">new</span> <span class="title class_">CallBack</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">            getFriendList(user, <span class="keyword">new</span> <span class="title class_">CallBack</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String friendList)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (friendList != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(friendList);</span><br><span class="line">                        getFeedList(friendList, <span class="keyword">new</span> <span class="title class_">CallBack</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String feed)</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (feed != <span class="literal">null</span>) &#123;</span><br><span class="line">                                    System.out.println(feed);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>只要你参与过大型软件的开发，不管你用的是什么编程语言，你大概率都见到过类似上面的代码模式：<strong>回调地狱</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> user = getUserInfo()</span><br><span class="line"><span class="keyword">val</span> friendList = getFriendList(user)</span><br><span class="line"><span class="keyword">val</span> feedList = getFeedList(friendList)</span><br></pre></td></tr></table></figure><p>你看，是不是简洁到了极致？这就是 Kotlin 协程的魅力：<strong>以同步的方式完成异步任务</strong>。</p><p>注意，以上代码之所以能写成类似同步的方式，关键还是在于 getUserInfo()、getFriendList()、getFeedList() 这三个请求函数的定义。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delay(1000L)用于模拟网络请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起函数</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;BoyCoder&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起函数</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getFriendList</span><span class="params">(user: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Tom, Jack&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起函数</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getFeedList</span><span class="params">(list: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;FeedList..&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码中，我们可以看到，<strong>所谓的挂起函数，其实就是比普通的函数多了一个 suspend 关键字而已</strong>。如果去掉这个 suspend 关键字，所有的函数都会变成普通函数。</p><p><code>代码中的 withContext(Dispatchers.IO)，作用是控制协程执行的线程池，具体细节我们会在第 17 讲中介绍。</code></p><p>既然如此，那么这个 suspend 关键字的作用是啥呢？挂起函数到底特别在哪呢？</p><p>实际上，挂起函数最神奇的地方，就在于它的挂起和恢复功能。从字面上看，suspend 这个词就是“挂起”的意思，而它既然能被<strong>挂起</strong>，自然就还可以被<strong>恢复</strong>。它们两个一般是成对出现的。</p><p><code>还记得我们在讲协程思维模型的时候提到的“非阻塞”概念吗？这主要就归功于 Kotlin 协程的挂起函数的能力。</code></p><p>不过，我单纯用文字告诉你 Kotlin 协程支持挂起和恢复，你一定没有什么概念，我做了一个小动画，描述了挂起函数整体的执行流程，同时也展示了其背后更多的细节。需要注意的是，动画当中出现的“闪烁”，模拟的是请求网络。你一定要多看几遍，确保没有遗漏其中的细节。</p><p>不过，我单纯用文字告诉你 Kotlin 协程支持挂起和恢复，你一定没有什么概念，我做了一个小动画，描述了挂起函数整体的执行流程，同时也展示了其背后更多的细节。需要注意的是，动画当中出现的“闪烁”，模拟的是请求网络。<strong>你一定要多看几遍，确保没有遗漏其中的细节。</strong></p><iframe  src="http://rpheez113.hn-bkt.clouddn.com/course/kotlin/kotlin-first-lesson/image/202302071615595.mp4"  scrolling="no"  border="0"  frameborder="no"  framespacing="0"  allowfullscreen="true"  height=600  width=800>  </iframe><p>然后，我也再给你重点解释下其中的关键点：</p><ul><li>在 IntelliJ 当中，挂起函数会有一个特殊的箭头标记，这样就便于我们分辨出当前调用的函数是否是普通函数。调用挂起函数的位置，我们叫做是<strong>挂起点</strong>。</li><li>另外，表面上看起来是同步的代码，实际上也涉及到了线程切换，一行代码，切换了两个线程。<ul><li>比如“val user &#x3D; getUserInfo()”，其中“&#x3D;”左边的代码运行在主线程，而“&#x3D;”右边的代码运行在 IO 线程。</li><li>每一次从主线程到 IO 线程，都是一次协程挂起。</li><li>每一次从 IO 线程到主线程，都是一次协程恢复。</li></ul></li><li>挂起和恢复，这是挂起函数<strong>特有的能力</strong>，普通函数是不具备的。</li><li>挂起，只是将程序执行流程转移到了其他线程，主线程不会被阻塞。如果以上代码运行在 Android 系统，我们的 App 仍然可以响应用户的操作，主线程并不繁忙。相信现在，你对协程思维模型又会有更加深刻的体会了。</li></ul><p>好，挂起函数的执行流程我们已经很清楚了。借助挂起函数，我们可以用同步的方式来写异步代码，对比起前面“回调地狱”式的代码，挂起函数写出来的代码可读性更好、扩展性更好、维护性更好，并且更难出错。</p><p>这个时候，你也许会感慨：挂起函数真的是太神奇了！简直就跟魔法一样！<strong>那么，Kotlin 协程到底是如何做到一行代码切换两个线程的呢？</strong></p><p>其实，Kotlin 协程当中并不存在什么“魔法”。这一切的细节，都藏在了挂起函数的 <strong>suspend</strong> 关键字里。</p><h2 id="深入理解-suspend"><a href="#深入理解-suspend" class="headerlink" title="深入理解 suspend"></a>深入理解 suspend</h2><p>到目前为止，我们已经知道了：suspend，是 Kotlin 当中的一个关键字，它主要的作用是用于定义“挂起函数”。不过如果你有仔细留意上节课当中的一段代码，你就会发现，同样的一个函数，加上 suspend 修饰以后，它的<strong>函数类型</strong>就会发生改变。</p><p>我们来回忆一下上节课的那段代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">func1</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func1与func3唯一的区别</span></span><br><span class="line"><span class="comment">   ↓                         */</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">func3</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    delay(<span class="number">100L</span>)</span><br><span class="line">    <span class="keyword">return</span> num.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f1: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = ::func1</span><br><span class="line"><span class="keyword">val</span> f2: <span class="keyword">suspend</span> (<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = ::func3</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f3: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = ::func3 <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">val</span> f4: <span class="keyword">suspend</span> (<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = ::func1 <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>可见，同样是 Int 作为参数，Double 作为返回值，有没有 suspend 修饰，它们两者的函数类型是不一样的。“suspend (Int) -&gt; Double”与“(Int) -&gt; Double”并不能互相赋值。</p><p>在讲高阶函数的时候，我提到过 Kotlin 的函数类型，其实只跟参数、返回值、接收者相关，不过现在又加了一条：还跟 suspend 相关。</p><p><code>补充：如果你接触过Compose，你会发现其中的 @Composable 跟 suspend 一样，也可以改变一个函数的类型，不过这个并不是我们要了解的重点，这里只是帮助你建立一个知识连接，如果你将来遇到了 Compose，你就可以快速理解了。</code></p><p><strong>那么，suspend 修饰的函数，到底会变成什么类型？</strong>如果你将挂起函数与前面“回调地狱的代码”放在一起对比，再结合我们第 3 讲学过的 Kotlin 原理，应该就会找到一些头绪了：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/08/68/08c49bd12047359fc8cea409fc6a2568.png?wh=1442x811" alt="img"></p><p>其实，<strong>挂起函数的本质，就是 Callback</strong>。</p><p>别忘了，我们还有 Kotlin 编译器这个“幕后的翻译官”啊！虽然我们写出来的挂起函数并没有任何 Callback 的逻辑，但是，当 Kotlin 编译器检测到 suspend 关键字修饰的函数以后，就会自动将挂起函数转换成带有 CallBack 的函数。</p><p>如果我们将上面的挂起函数反编译成 Java，结果会是这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                              Continuation 等价于 CallBack</span></span><br><span class="line"><span class="comment">//                                         ↓         </span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> Object getUserInfo(Continuation $completion) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;BoyCoder&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反编译的结果来看，挂起函数确实变成了一个带有 CallBack 的函数，只是这个 CallBack 换了个名字，叫做 Continuation。我们来看看 Continuation 在 Kotlin 中的定义：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      相当于 CallBack的onSuccess   结果   </span></span><br><span class="line"><span class="comment">//                 ↓                 ↓</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CallBack</span> &#123;</span><br><span class="line">    void onSuccess(String response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上定义我们其实能发现，<strong>Continuation 本质上也就是一个带有泛型参数的 CallBack</strong>，只是它的名字看起来有点吓人而已。这个“从挂起函数转换成 CallBack 函数”的过程，被叫做是 CPS 转换（Continuation-Passing-Style Transformation）。</p><p>看，Kotlin 官方要将 CallBack 命名为 Continuation 的原因也出来了：Continuation 道出了它的实现原理。当然，为了理解挂起函数，我们用 CallBack 会更加简明易懂。</p><p>下面我用动画来演示一下挂起函数在 CPS 转换过程中，函数签名的变化：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/37/92/3732f7a3473e82c5a5d109a18d87f992.gif?wh=720x405" alt="img"></p><p><code>注意：挂起函数 CPS 转换后的内部逻辑，其实要远比演示的复杂，这个我们到源码篇再深究，我们暂时只关注它函数签名的变化。</code></p><p>你能看到，在上面 CPS 转换的过程中，函数的类型发生了变化：“suspend ()-&gt;String” 变成了 “(Continuation)-&gt; Any?”。</p><p>而这就意味着，如果你在 Java 中访问一个 Kotlin 挂起函数 getUserInfo()，会看到 Java 里的 getUserInfo() 的类型是“(Continuation)-&gt; Object”（即接收 Continuation 为参数，返回值是 Object）。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/5b/90/5b81e4a51acaafa1ce56f7a888037790.png?wh=792x286" alt="img"></p><p>到这里，我们就只剩下最后一个问题需要搞清楚了，那就是：Continuation 到底是什么？如果你查词典和维基百科，可能会一头雾水，因为这个词太抽象了。</p><p>让我结合前面的代码案例，用更加通俗的语言解释给你听。</p><p>首先，我们只需要把握住 Continuation 的词源 Continue 即可。Continue 是“继续”的意思，Continuation 则是“接下来要做的事情”。放到程序中，Continuation 就代表了，“程序继续运行下去需要执行的代码”，“接下来要执行的代码”，或者是“剩下的代码”。</p><p>就以上面的代码为例，当程序运行 getUserInfo() 这个挂起函数的时候，它的“Continuation”则是下图红框的代码：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/06/yb/060c08db5f586ed8e189cfa26eaa6yyb.png?wh=960x376" alt="img"></p><p>这样理解了 Continuation 以后，CPS 也就容易理解了，<strong>它其实就是将程序接下来要执行的代码进行传递的一种模式</strong>。</p><p>而 CPS 转换，就是<strong>将原本的同步挂起函数转换成 CallBack 异步代码的过程</strong>。这个转换是编译器在背后做的，我们程序员对此并无感知。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/03/22/03d156ec6a31d650c6634f486dc06222.gif?wh=720x405" alt="img"></p><p>根据这个动图，可以看到当程序执行到 getUserInfo() 的时候，剩下的未执行代码都被一起打包了起来，以 Continuation 的形式，传递给了 getUserInfo() 的 Callback 回调当中。当然，这种方式其实只是大致模拟了挂起函数的 CPS 转换过程，实际细节要远比这个复杂。但这对于现阶段的学习来说，已经完全够用了。</p><p>以上就是 Kotlin 挂起函数的核心原理，它的挂起和恢复，其实也是通过 CPS 转换来实现的。在后面学习源码篇的时候，我们还会继续跟 Continuation 继续打交道。现在我们看着 CPS 的过程好像很简单，等到深入底层的时候，你会发现 Continuation 是多么的复杂和精妙。</p><p>这里，我们再来看看之前的协程思维模型：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/c6/1b/c6e735653c09f05ea94f5478d5e0d61b.gif?wh=1080x492" alt="img"></p><p>所以，现在我们可以理出一条线索了：<strong>协程之所以是非阻塞，是因为它支持“挂起和恢复”；而挂起和恢复的能力，主要是源自于“挂起函数”；而挂起函数是由 CPS 实现的，其中的 Continuation，本质上就是 Callback</strong>。</p><p>读完上面的这段话，也许你会忍不住好奇：<strong>协程跟挂起函数之间是什么关系？</strong></p><h2 id="协程与挂起函数"><a href="#协程与挂起函数" class="headerlink" title="协程与挂起函数"></a>协程与挂起函数</h2><p>你可能觉得，既然协程和挂起函数都是支持挂起和恢复的，那它们两个是不是同一个东西呢？</p><p>答案当然是否定的。</p><p>关于协程和挂起函数的关系，我们暂时还不适合深入源码层面去做探讨。不过，从我们目前已有的信息，就可以直接推断出，它们之间肯定是有着千丝万缕的联系的。让我们来看个简单的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    getUserInfo() <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;BoyCoder&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们直接在 main 函数当中调用了 getUserInfo() 这个挂起函数，这时候，我们发现 IDE 会报错，报错的具体内容是这样的：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/68/aa/68010f8b8bd5de8d58dd8576828d92aa.png?wh=945x247" alt="img"></p><p>这个报错信息的意思是：<strong>挂起函数，只能在协程当中被调用，或者是被其他挂起函数调用</strong>。这个意思也很好理解，对于这样的要求，我们很容易就能写出下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在协程中调用getUserInfo()</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个挂起函数中调用getUserInfo()</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">anotherSuspendFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码写到这里，很多人都会满足于这样的结果。但实际上，以上两种方式，它们之间是可以继续深入并且挖掘出共性的。</p><p>让我们回过头来看看 runBlocking 的函数签名：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">runBlocking</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: T &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重点关注它的第二个参数 block 的类型“suspend CoroutineScope.() -&gt; T”，看到其中的 suspend 关键字了吗？<strong>原来 block 也是一个挂起函数的类型！</strong>那么，在 block 当中可以调用挂起函数，就一点也不奇怪了！</p><p>所以说，虽然“协程和挂起函数”都可以调用“挂起函数”，但是协程的 Lambda，也是挂起函数。所以，它们本质上都是因为“挂起函数可以调用挂起函数”。</p><p>也就是说，站在目前的阶段来看，我们可以认为：<strong>挂起和恢复，是协程的一种底层能力；而挂起函数，是这种底层能力的一种表现形式，通过暴露出来的 suspend 关键字，我们开发者可以在上层，非常方便地使用这种底层能力。</strong></p><p><strong>小结</strong></p><p>这节课，我们主要学习了 Kotlin 协程当中的最核心的特性：<strong>挂起函数</strong>。</p><p>挂起函数可以极大地简化异步编程，让我们能够<strong>以同步的方式写异步代码</strong>。相比“回调地狱”式的代码，挂起函数写出来的代码<strong>可读性更好、扩展性更好、维护性更好，也更难出错</strong>。而除此之外，你也需要牢记以下这些核心要点，来更好地掌握挂起函数。</p><ul><li>要定义挂起函数，我们只需在普通函数的基础上，增加一个 <strong>suspend 关键字</strong>。suspend 这个关键字，是会改变函数类型的，“suspend (Int) -&gt; Double”与“(Int) -&gt; Double”并不是同一个类型。</li><li>挂起函数，由于它拥有挂起和恢复的能力，因此对于同一行代码来说，“&#x3D;”左右两边的代码分别可以执行在不同的线程之上。而这一切，都是因为 Kotlin 编译器这个幕后的翻译官在起作用。</li><li><strong>挂起函数的本质，就是 Callback</strong>。只是说，Kotlin 底层用了一个更加高大上的名字，叫 Continuation。而 Kotlin 编译器将 suspend 翻译成 Continuation 的过程，则是 CPS 转换。这里的 Continuation 是代表了，“程序继续运行下去需要执行的代码”，“接下来要执行的代码”，或者是 “剩下的代码”。</li></ul><p>最后，我们还探索了协程与挂起函数之间的关系。我们发现：<strong>挂起函数，只能在协程当中被调用，或者是被其他挂起函数调用。</strong>但协程中的 block，本质上仍然是挂起函数。</p><p>所以，我们可以认为：挂起和恢复是协程的一种底层能力；而挂起函数则是一种上层的表现形式。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/19/bd/19591ff06ebc553ca6fa695a3914bdbd.jpg?wh=2000x1279" alt="img"></p><p><strong>思考题</strong></p><p>前面我们提到“挂起函数只能在协程当中被调用，或者是被其他挂起函数调用”，而本质上，还是因为“挂起函数可以调用挂起函数”。那么，你能找出更加底层的证据吗？</p><p>换个方式理解就是：凭什么挂起函数可以调用挂起函数，而普通函数不能调用挂起函数？它的底层逻辑到底什么？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">normalFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo() <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">anotherSuspendFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo() <span class="comment">// 通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(协程篇)14  如何启动协程？</title>
      <link href="/posts/608fa63f/"/>
      <url>/posts/608fa63f/</url>
      
        <content type="html"><![CDATA[<p>从今天开始，咱们正式进入协程 API 的学习，一起来攻克 Kotlin 当中最关键的部分。这节课呢，我会给你介绍下如何启动协程，主要包括协程的调试技巧、启动协程的三种方式。这些都是学习协程最基本的概念，也是后续学习更多高阶概念的基础。</p><p>注意，在这节课当中，我会使用协程 API 编写大量的案例。我也希望你能够打开 IDE，跟着我一起来运行对应的代码。通过这样的方式，你一定会有更多的收获。</p><p>好，接下来，让我们直接开始学习吧！</p><h2 id="协程调试"><a href="#协程调试" class="headerlink" title="协程调试"></a>协程调试</h2><p>想要学好 Kotlin 协程，掌握它的调试技巧很重要。一般来说，我们可以通过两种手段来进行调试：设置 VM 参数、断点调试。</p><h3 id="协程-VM-参数"><a href="#协程-VM-参数" class="headerlink" title="协程 VM 参数"></a>协程 VM 参数</h3><p>我们先来看第一种。具体的做法呢，其实很简单，我们只需要将 VM 参数设置成“-Dkotlinx.coroutines.debug”。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/bvj7mxYFOr2d1My.gif" alt="img"></p><p>完成这个设置后，当我们在 log 当中打印“Thread.currentThread().name”的时候，如果当前代码是运行在协程当中的，那么它就会带上协程的相关信息。具体我们可以看个代码的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 不必关心代码逻辑，关心输出结果即可</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">        println(<span class="string">&quot;Coroutine started:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;After launch:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">After launch:main</span></span><br><span class="line"><span class="comment">Coroutine started:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，当代码处于协程当中的时候，“Thread.currentThread().name”是会带上协程相关的信息的，这里的“@coroutine#1”就代表了 launch 创建的协程。</p><h3 id="断点调试协程"><a href="#断点调试协程" class="headerlink" title="断点调试协程"></a>断点调试协程</h3><p>除了设置 VM 参数之外，我们还可以直接使用 IDE 的调试功能，直接以打断点的形式来调试协程。具体来说，主要有这样几个注意事项。</p><p>第一步，将 IntelliJ 升级到最新版本，目前我使用的版本是 2021.3.2 版本。</p><p>第二步，确保 IDE 自带的 Kotlin 编译器插件版本号大于 1.4，目前我使用的是 1.6.10。具体做法你可以参考下面的动图：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/vLUi7RlOnTj8wJS.gif" alt="img"></p><p>第三步，为协程代码打断点，并且右击断点处，勾选 suspend、All，这代表了我们的断点将会对协程生效。具体可以参考我下面的截图：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/7okASCsVq2bBUj5.png" alt="img"></p><p>第四步，直接进行调试，当程序停留到断点处以后，我们就需要确保协程调试窗口已经被开启了。具体可以参考这个动图：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/bf/y5/bf997189170645abc1586af534782yy5.gif?wh=1392x878" alt="img"></p><p>让我们来单独看看最后出现的那个协程调试窗口：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/QuLN3vcEelqW2Cz.png" alt="img"></p><p>在这个专属的协程调试窗口当中，我们可以看到很多有用的协程信息，包括：</p><ul><li>当前协程的名字，这里是“coroutine#1”；</li><li>当前协程运行在哪个线程之上，这里是“DefaultDispatcher-worker-1”；</li><li>当前协程的运行状态，这里是“RUNNING”；</li><li>当前协程的“创建调用栈”。</li></ul><p>通过调试，我们可以真真切切地看到，我们用 launch 创建了一个协程，“coroutine#1”，这个协程是运行在“DefaultDispatcher-worker-1”这个线程之上的。而通过这样调试的手段，我们也进一步验证了上节课提到的协程思维模型。</p><p>接下来，我们就一起来学习启动协程的三种方式。</p><h2 id="launch-启动协程"><a href="#launch-启动协程" class="headerlink" title="launch 启动协程"></a>launch 启动协程</h2><p>上节课我们讲到协程思维模型的时候，其实是把协程想象成了<strong>更加轻量的线程</strong>。线程的启动方式我们都知道，也就是 new Thread()、或者是 thread{}。那么，如何才能启动一个真正的协程呢？如果你之前看过一些协程的教程，一定见过类似这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* delay 函数的定义</span></span><br><span class="line"><span class="comment">     注意这个关键字</span></span><br><span class="line"><span class="comment">          ↓                                            */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(timeMillis: <span class="type">Long</span>)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅用于研究，生产环境不建议使用GlobalScope</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        <span class="comment">// ②</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果；</span></span><br><span class="line"><span class="comment">Hello World!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这段代码的逻辑很简单，核心代码只有三行，我已经用注释标记了，我们一个个看。</p><p>注释①，GlobalScope.launch{}，它是一个高阶函数，它的作用就是启动一个协程。GlobalScope 是 Kotlin 官方为我们提供的“协程作用域”，这涉及到协程的“结构化并发”理念，我们会在后面的第 16、17 讲里解释。</p><p>注释②，delay()，它的作用就是字面上的意思，“延迟”。以上代码中，我们是延迟了 1 秒。从 delay() 的函数签名这里可以发现，它的定义跟普通的函数不太一样，它多了一个“suspend”关键字，这代表了它是一个<strong>挂起函数</strong>。而这也就意味着，delay 将会拥有“<strong>挂起和恢复</strong>”的能力。</p><p>在上节课我们提到过，delay() 是<strong>非阻塞</strong>，那现在我们应该就终于明白了，既然它拥有“挂起和恢复”的能力，那么它肯定能实现非阻塞（如果你无法理解这句话，一定要回过头去看上节课的思维模型）。关于挂起函数的更多知识点，我们会在下节课介绍。</p><p>注释③，它的作用是让当前线程休眠 2 秒钟。</p><p>我们暂时先将注意力放在注释③这行代码上，很多协程的初学者都会很好奇，为什么上面的代码当中需要一个 Thread.sleep(2000L) 呢？它的作用是什么？</p><p>现在我们把它删掉，看看到底会发生什么。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果；</span></span><br><span class="line"><span class="comment">无</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>很奇怪，当我们删掉线程休眠的代码以后，协程代码就无法正常工作了。这是为什么？为了弄清楚这个问题，其实，我们可以做一个类比，暂时先将协程代码改成线程代码。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//              守护线程</span></span><br><span class="line">    <span class="comment">//                 ↓</span></span><br><span class="line">    thread(isDaemon = <span class="literal">true</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果；</span></span><br><span class="line"><span class="comment">无</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，当我们将代码改为线程以后，程序仍然没有输出任何结果。而这里，我们创建的 Thread 其实是一个“守护线程”。守护线程，就意味着当主线程结束的时候，它也会跟着被销毁。所以这样，相信你应该就能明白了，我们前面用 GlobalScope 创建的协程之所以不会正常运行，也是因为类似的原因。</p><p>那么，为了让问题能够更明确地暴露出来，我们可以为之前的代码增加一些日志。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;Coroutine started!&quot;</span>)</span><br><span class="line"></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果；</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>根据输出结果，我们可以推测出：<strong>通过 launch 创建的协程还没来得及开始执行，整个程序就已经结束了</strong>。相应的，我们也就能推测出，之前案例中 Thread.sleep(2000) 的作用了，其实，它就是为了不让我们的主线程退出。</p><p>这里，你还会发现一个协程代码特殊的行为模式，那就是：<strong>它的代码不是按照顺序执行的</strong>。为了让这一点更加明显，我们再增加一些日志：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;                <span class="comment">// 1</span></span><br><span class="line">        println(<span class="string">&quot;Coroutine started!&quot;</span>)   <span class="comment">// 2</span></span><br><span class="line">        delay(<span class="number">1000L</span>)                    <span class="comment">// 3</span></span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)         <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;After launch!&quot;</span>)            <span class="comment">// 5</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)                 <span class="comment">// 6</span></span><br><span class="line">    println(<span class="string">&quot;Process end!&quot;</span>)             <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">After launch!</span></span><br><span class="line"><span class="comment">Coroutine started!</span></span><br><span class="line"><span class="comment">Hello World!</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>根据这个程序运行结果，我们发现，以上的协程代码运行顺序是 1、5、6、2、3、4、7。也就是说，launch 并不会阻塞线程的执行，甚至，我们可以认为 launch() 当中 Lambda 一定就是在函数调用之后才执行的。当然，在特殊情况下，这种行为模式也是可以打破的，这一点我们会在第 17 讲中详细探讨。</p><p>那么，如果你足够细心，你会发现，我们通过 launch 启动一个协程以后，并没有让协程为我们返回一个执行结果，这其实就是典型的 <a href="https://en.wikipedia.org/wiki/Fire-and-forget">Fire-and-forget</a> 的应用场景。打个比方，launch 一个协程任务，就像猎人射箭一样。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/vHqpbRWyPtSC3NU.png" alt="img"></p><p>launch 和射箭，有几个共同点：</p><ul><li>箭一旦射出去了，目标就无法再被改变；协程一旦被 launch，那么它当中执行的任务也不会被中途改变。</li><li>箭如果命中了猎物，猎物也不会自动送到我们手上来；launch 的协程任务一旦完成了，即使有了结果，也没办法直接返回给调用方</li></ul><p>那么，<strong>launch 为什么无法将结果返回给调用方呢</strong>？如果你去看 launch 函数的源代码，你就会发现，这个函数的返回值是一个 Job，它其实代表的是协程的<a href="https://en.wikipedia.org/wiki/Handle_(computing)">句柄</a>（Handle），它并不能为我们返回协程的执行结果。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>不过，从 launch 的函数签名这里，我们还是可以得到很多有用的信息的，我们一个个看.</p><p>首先是 **CoroutineScope.launch()**，代表了 launch 其实是一个扩展函数，而它的“扩展接收者类型”是 CoroutineScope。这就意味着，我们的 launch() 会等价于 CoroutineScope 的成员方法。而如果我们要调用 launch() 来启动协程，就必须要先拿到 CoroutineScope 的对象。前面的案例，我们使用的 GlobalScope，其实就是 Kotlin 官方为我们提供的一个 CoroutineScope 对象，方便我们开发者直接启动协程。</p><p>接着是第一个参数：<strong>CoroutineContext</strong>，它代表了我们协程的上下文，它的默认值是 EmptyCoroutineContext，如果我们不传这个参数，默认就会使用 EmptyCoroutineContext。一般来说，我们也可以传入 Kotlin 官方为我们提供的 Dispatchers，来指定协程运行的线程池。协程上下文，是协程当中非常关键的元素，具体细节我会在 17 节课的时候再探讨。</p><p>然后是第二个参数：<strong>CoroutineStart</strong>，它代表了协程的启动模式。如果我们不传这个参数，它会默认使用 CoroutineStart.DEFAULT。CoroutineStart 其实是一个枚举类，一共有：DEFAULT、LAZY、ATOMIC、UNDISPATCHED。我们最常使用的就是 DEFAULT、LAZY，它们分别代表：立即执行、懒加载执行。</p><p>最后一个参数，是一个函数类型的 block，它的类型是“<strong>suspend CoroutineScope.() -&gt; Unit</strong>”。这个类型看起来有点复杂，不过不要担心，我们可以一步步来推理，让我们先以“(Int) -&gt; Double”这个函数类型开始：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">func1</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f1: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = ::func1</span><br></pre></td></tr></table></figure><p>上面的代码很好理解，“(Int) -&gt; Double”代表了参数类型是 Int，返回值类型是 Double 的函数，::func1 这里，我们使用了<strong>函数引用</strong>的语法。接下来，我们再来看看“CoroutineScope.(Int) -&gt; Double”意味着什么：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">func2</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f2: CoroutineScope.(<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = CoroutineScope::func2</span><br></pre></td></tr></table></figure><p>很明显，当我们在函数类型前面增加了一个接收者类型后，它的含义就变成了：这个函数应该是 CoroutineScope 类的<strong>成员方法</strong>或是<strong>扩展方法</strong>，并且，它的参数类型必须是 Int，返回值类型必须是 Double。</p><p>那么，“suspend (Int) -&gt; Double”这个类型代表了什么呢？我们来看个例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">func3</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    delay(<span class="number">100L</span>)</span><br><span class="line">    <span class="keyword">return</span> num.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f3: <span class="keyword">suspend</span> (<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = ::func3</span><br></pre></td></tr></table></figure><p>有了前面的基础，相信你很容易就能理解了，“suspend (Int) -&gt; Double”，其实就代表了一个“挂起函数”，同时它的参数类型是 Int，返回值类型是 Double。</p><p>到这里，我们还可以再做一次推理，请看下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">func4</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    delay(<span class="number">100L</span>)</span><br><span class="line">    <span class="keyword">return</span> num.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f4: <span class="keyword">suspend</span> CoroutineScope.(<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = CoroutineScope::func4</span><br></pre></td></tr></table></figure><p>这时候，对于“suspend CoroutineScope.(Int) -&gt; Double”这个函数类型，你应该也能轻松解释了。首先，它应该是一个“挂起函数”，同时，它还应该是 CoroutineScope 类的成员方法或是扩展方法，并且，它的参数类型必须是 Int，返回值类型必须是 Double。</p><p>那么现在，我们回过头再来看看 launch() 函数的第三个参数“suspend CoroutineScope.() -&gt; Unit”，其实就能轻松分析出它的类型了。所以，当我们遇到复杂的函数类型的时候，一定不能害怕，只要我们一步步来拆解、推理，就一定能分析清楚了。</p><p>到这里，我们就弄清楚 launch 的作用了。我们通过调用 launch() 可以创建一个新的协程。那么，除了 launch 以外，还有其他办法启动协程吗？有的，那就是 runBlocking。</p><h2 id="runBlocking-启动协程"><a href="#runBlocking-启动协程" class="headerlink" title="runBlocking 启动协程"></a>runBlocking 启动协程</h2><p>runBlocking 跟我们前面学的 launch 的行为模式不太一样，通过它的名字，我们就可以看出来，它是存在某种阻塞行为的。让我们将前面 launch 的代码直接改为 runBlocking，看看运行结果是否有差异。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;                       <span class="comment">// 1</span></span><br><span class="line">        println(<span class="string">&quot;Coroutine started!&quot;</span>)   <span class="comment">// 2</span></span><br><span class="line">        delay(<span class="number">1000L</span>)                    <span class="comment">// 3</span></span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)         <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;After launch!&quot;</span>)            <span class="comment">// 5</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)                 <span class="comment">// 6</span></span><br><span class="line">    println(<span class="string">&quot;Process end!&quot;</span>)             <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Coroutine started!</span></span><br><span class="line"><span class="comment">Hello World!</span></span><br><span class="line"><span class="comment">After launch!</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>通过分析上面的运行结果，我们可以发现，使用 runBlocking 启动的协程会阻塞当前线程的执行，这样一来，所有的代码就<strong>变成了顺序执行</strong>：1、2、3、4、5、6、7。这其实就是 runBlocking 与 launch 的最大差异。</p><p>为了验证这一点，我们可以将上面的例子再改造一下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        println(<span class="string">&quot;First:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Hello First!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        println(<span class="string">&quot;Second:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Hello Second!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        println(<span class="string">&quot;Third:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Hello Third!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删掉了 Thread.sleep</span></span><br><span class="line">    println(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">First:main @coroutine#1</span></span><br><span class="line"><span class="comment">Hello First!</span></span><br><span class="line"><span class="comment">Second:main @coroutine#2</span></span><br><span class="line"><span class="comment">Hello Second!</span></span><br><span class="line"><span class="comment">Third:main @coroutine#3</span></span><br><span class="line"><span class="comment">Hello Third!</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>请注意这里的输出结果，我们调用三次 runBlocking，对应地，程序就启动了三个协程。另外还有一点：以上代码中，我们删掉了末尾的“Thread.sleep(2000L)”，而程序仍然按照顺序执行了。这就进一步说明，runBlocking 确实会阻塞当前线程的执行。对于这一点，Kotlin 官方也强调了：runBlocking 只推荐用于<strong>连接线程与协程</strong>，并且，大部分情况下，都只应该用于编写 Demo 或是测试代码。</p><p>所以，<strong>请不要在生产环境当中使用 runBlocking</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">runBlocking</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，runBlocking 就是一个普通的<strong>顶层函数</strong>，它并不是 CoroutineScope 的扩展函数，因此，我们调用它的时候，不需要 CoroutineScope 的对象。前面我们提到过，GlobalScope 是不建议使用的，因此，<strong>后面的案例我们将不再使用 GlobalScope</strong>。</p><p>另外，你可以注意到它的第二个参数“suspend CoroutineScope.() -&gt; T”，这个函数类型是有返回值类型 T 的，而它刚好跟 runBlocking 的返回值类型是一样的。因此，我们可以推测，runBlocking 其实是可以从协程当中返回执行结果的。让我们来试试：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = runBlocking &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        <span class="comment">// return@runBlocking 可写可不写</span></span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@runBlocking</span> <span class="string">&quot;Coroutine done!&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Result is: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Result is: Coroutine done!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所以，从表面上看，runBlocking 是对 launch 的一种补充，但由于它是阻塞式的，因此，runBlocking 并不适用于实际的工作当中。那么，还有什么办法可以让我们拿到协程当中的执行结果吗？</p><p>答案就是：async。</p><h2 id="async-启动协程"><a href="#async-启动协程" class="headerlink" title="async 启动协程"></a>async 启动协程</h2><p>async，是在很多其他编程语言都存在的一种协程模式，比如 C#。在 Kotlin 当中，我们可以使用 async{} 创建协程，并且还能通过它返回的句柄拿到协程的执行结果。让我们看个简单的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;In runBlocking:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred: Deferred&lt;String&gt; = async &#123;</span><br><span class="line">        println(<span class="string">&quot;In async:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@async</span> <span class="string">&quot;Task completed!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;After async:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = deferred.await()</span><br><span class="line">    println(<span class="string">&quot;Result is: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">In runBlocking:main @coroutine#1</span></span><br><span class="line"><span class="comment">After async:main @coroutine#1 // 注意，它比“In async”先输出</span></span><br><span class="line"><span class="comment">In async:main @coroutine#2</span></span><br><span class="line"><span class="comment">Result is: Task completed!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上面的代码中，我们直接使用 runBlocking 来实现了 main 函数。注意，由于 runBlocking 的最后一个参数的类型是“suspend CoroutineScope.() -&gt; T”，因此在 Lambda 当中已经有了 CoroutineScope，所以我们可以直接在 runBlocking 当中，用 async 启动一个协程。从程序的输出结果，我们也可以看到，确实存在两个协程，runBlocking 启动的叫做“coroutine#1”；async 启动的叫做“coroutine#2”。</p><p>另外，你应该还注意到了一个细节，那就是 async 启动协程以后，它也不会阻塞当前程序的执行流程，因为：“After async”在“In async”的前面就已经输出了。</p><p><code>这种行为模式在特殊情况下也是可以打破的，我们在第 17 讲的时候会介绍。</code></p><p>还有，请注意 async{}的返回值，它是一个 Deferred 对象，我们通过调用它的 await() 方法，就可以拿到协程的执行结果。对比前面 launch 我们举的“射箭”的例子，这里的 async，就更加像是“钓鱼”：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/yvHcRgClDzwG2nt.png" alt="img"></p><p>在我们钓鱼的时候，我们手里的鱼竿，就有点像是 async 当中的 <strong>Deferred 对象</strong>。只要我们手里有这根鱼竿，<strong>一旦有鱼儿上钩了，我们就可以直接拿到结果</strong>。</p><p>这里，我们再来看看 async 的函数签名，顺便对比一下它跟 launch 之间的差异：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span> <span class="comment">// 不同点1</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;&#125; <span class="comment">// 不同点2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> CoroutineScope.<span class="title">async</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span> <span class="comment">// 不同点1</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Deferred&lt;T&gt; &#123;&#125; <span class="comment">// 不同点2</span></span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以发现 launch 和 async 的两个不同点，一个是 <strong>block 的函数类型</strong>，前者的返回值类型是 Unit，后者则是泛型 T；另外一个不同点在<strong>返回值</strong>上，前者返回值类型是 Job，后者返回值类型是 Deferred。而 async 可以返回协程执行结果的原因也在于此。关于 Job 与 Deferred 的更多细节，我们会在第 16 讲讨论。</p><p>这里，我制作了一张动图，来演示程序整体的执行流程：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/ec/ee/ec5b7e1f88ac38391f9503102yyee6ee.gif?wh=720x405" alt="img"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由于协程是一个非常抽象的概念，因此，它的<strong>调试手段就显得尤为重要</strong>，我们研究协程的时候，通常有两种手段，一种是设置 VM 参数：-Dkotlinx.coroutines.debug。另一种是直接在 IDE 当中打断点，不过协程调试是在 Kotlin 1.4 之后才支持的新特性，因此我们要确保 IDE 和 Kotlin 的版本都更新到最新。</p><p>另外，我们还学到了三种启动协程的方式，分别是 launch、runBlocking、async。</p><ul><li><strong>launch</strong>，是典型的“Fire-and-forget”场景，它不会阻塞当前程序的执行流程，使用这种方式的时候，我们无法直接获取协程的执行结果。它有点像是生活中的<strong>射箭</strong>。</li><li><strong>runBlocking</strong>，我们可以获取协程的执行结果，但这种方式会阻塞代码的执行流程，因为它一般用于测试用途，生产环境当中是不推荐使用的。</li><li><strong>async</strong>，则是很多编程语言当中普遍存在的协程模式。它像是结合了 launch 和 runBlocking 两者的优点。它既不会阻塞当前的执行流程，还可以直接获取协程的执行结果。它有点像是生活中的<strong>钓鱼</strong>。</li></ul><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/9b/4a/9b116c03897214c6d899177d459e354a.jpg?wh=2000x904" alt="img"></p><p><strong>思考题</strong></p><p>下面这段代码是我在当面试官时，问过其他候选人的，你能推测出这段代码的执行结果吗？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred: Deferred&lt;String&gt; = async &#123;</span><br><span class="line">        println(<span class="string">&quot;In async:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        println(<span class="string">&quot;In async after delay!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@async</span> <span class="string">&quot;Task completed!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不再调用 deferred.await()</span></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(协程篇)13 什么是“协程思维模型”？</title>
      <link href="/posts/e6b226ff/"/>
      <url>/posts/e6b226ff/</url>
      
        <content type="html"><![CDATA[<p>学完基础篇以后，相信现在你对 Kotlin 的基础语法和特性都有了全面的认识。那么从今天开始，我们就要进入一个新的模块，一起来学习 Kotlin 当中<strong>最重要、最难学</strong>，也是最受期待的特性——协程。</p><h2 id="为什么协程如此重要"><a href="#为什么协程如此重要" class="headerlink" title="为什么协程如此重要?"></a><strong>为什么协程如此重要?</strong></h2><p><strong>协程是 Kotlin 对比 Java 的最大优势</strong>，这也是我说协程是 Kotlin 中最重要特性的主要原因。虽说 Java 也在计划着实现自己的协程：Loom，不过这个毕竟还处于相当初级的阶段。而 Kotlin 的协程，可以帮我们极大地<strong>简化异步、并发编程、优化软件架构</strong>。通过协程，我们不仅可以提高开发效率，还能提高代码的可读性，由此也就可以降低代码出错的概率。</p><p>不过，遗憾的是，Kotlin 协程在业界的普及率并不高。因为，你如果对协程没有足够的认识，贸然在生产环境里使用协程，一定会遇到各种各样的问题，并要为之付出昂贵的代价（典型的反面例子就是滥用 GlobalScope，导致大量的计算资源浪费以及出现生命周期错乱的问题）。</p><p>Kotlin 的协程就是这样，表面上看，它的语法很简单，但行为模式却让人难以捉摸。举个简单的例子，同样是 5 行代码，普通的程序，这 5 行代码的运行顺序一般会是 1、2、3、4、5；但对于协程来说，代码执行顺序可能会是 1、4、5、3、2 这样错乱的。如果我们不能在脑子里建立协程的思维模型，那我们将很难理解协程的行为模式。</p><p>所以说，协程也是一个典型的“<strong>易学难精</strong>”的框架。</p><p>如果你之前尝试过自学 Kotlin 协程，你一定会跟我有相似的体会：要记住协程的几个 API 很容易，困难的是形成一套完整的协程知识体系。不过，我想告诉你的是：形成知识体系也不算什么，更难的是建立一个具体的协程思维模型，来辅助自己理解协程背后的运行机制；甚至，建立协程思维模型也没什么了不起，更难的是理解协程背后的设计理念。</p><p>换句话说，如果我们能站在 Kotlin 协程设计者的角度，去评判、欣赏它背后的设计理念，并且能体会到协程设计的精妙之处，那才算是达到了最高的境界。</p><p>那么，学习 Kotlin 协程，到底意味着什么呢？</p><p>其实，学习协程，相当于一次<strong>编程思维的升级</strong>。协程思维，它与我们常见的线程思维迥然不同，当我们能够用协程的思维来分析问题以后，<strong>线程当中某些棘手的问题在协程面前都会变成小菜一碟</strong>。因此，我们相当于多了一种解决问题的手段。</p><p>另外，学习 Kotlin 协程，也相当于为我们打开了一扇新世界的大门，当我们对 Kotlin 协程有了透彻的认识以后，再去看 C#、Python、Dart、JS、Golang、Rust、C++20、Java Loom 当中的“类协程”概念，就会觉得无比亲切。这时候我们就会发现：<strong>原来协程的世界是如此广阔</strong>。</p><p>到这里，相信你已经认识到了 Kotlin 协程的重要性，也知道了学习协程的好处了。</p><p>不过，在正式开始学习 Kotlin 协程之前，我想先给你打一剂“预防针”：这个部分的学习难度会比前面基础篇更大，虽然我还是会尽量用简单直白的方式来向你介绍协程，但由于它本身是一种颠覆性的技术，因此，刚开始肯定是会有些难以接受的。在这里，我也建议你在遇到问题的时候多思考，并去反复琢磨和理解课程当中的知识点与示例代码。</p><p>好，接下来，我们先来了解一下协程的发展史，这会有助于我们理解协程到底是个什么东西。</p><h2 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h2><p>Kotlin 的协程，是 2017 年初在 1.1 版本加入进来的，那时协程还只是实验性的（Experimental）；等到 2018 年底，Kotlin 更新到 1.3 版本的时候，协程才成为 Kotlin 的正式特性；接着又过了一年，到 2019 年 Kotlin 协程才推出 Flow 相关的 API。我们常说 Kotlin 是一门年轻的语言，那么 Kotlin 协程这个特性，就更加显得年轻了。毕竟从它正式推出到现在，也才三年多。</p><p>虽然 Kotlin 协程很年轻，但“协程”这个概念本身并不年轻。早在 1967 年的 Simula 语言当中，就已经出现了协程。不过，在之后的几十年里，协程并没有被推广开，后续涌现出的 C、C++、Java 之类的语言，更多的是使用线程来进行异步和并发。直到 2012 年左右，C# 重新拾起了协程这个特性，实现了 async、await、yield。之后，JavaScript、Python、Kotlin 等语言才继续跟进实现了对应的协程。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="http://rpheez113.hn-bkt.clouddn.com/course/kotlin/kotlin-first-lesson/image/202302061107768.png"/><p>很多人在刚开始接触协程的时候，都觉得协程很难学，因为从学校一路学习 C、Java 过来以后，我们只知道线程是什么，对协程根本没有任何概念。</p><p>其实，如果要用简单的语言来描述协程的话，我们可以将其称为：“互相协作的程序”。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/12/6a/121f70df4206972e88de427ef5157f6a.jpg?wh=2000x448" alt="img"></p><p>为了帮你弄清楚普通的程序（Routine）与协程（Coroutine）之间的差异，我们来看一个具体的例子。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = getList()</span><br><span class="line">    printList(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getList</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    println(<span class="string">&quot;Add 1&quot;</span>)</span><br><span class="line">    list.add(<span class="number">1</span>)</span><br><span class="line">    println(<span class="string">&quot;Add 2&quot;</span>)</span><br><span class="line">    list.add(<span class="number">2</span>)</span><br><span class="line">    println(<span class="string">&quot;Add 3&quot;</span>)</span><br><span class="line">    list.add(<span class="number">3</span>)</span><br><span class="line">    println(<span class="string">&quot;Add 4&quot;</span>)</span><br><span class="line">    list.add(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printList</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> i = list[<span class="number">0</span>]</span><br><span class="line">    println(<span class="string">&quot;Get<span class="variable">$i</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> j = list[<span class="number">1</span>]</span><br><span class="line">    println(<span class="string">&quot;Get<span class="variable">$j</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> k = list[<span class="number">2</span>]</span><br><span class="line">    println(<span class="string">&quot;Get<span class="variable">$k</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> m = list[<span class="number">3</span>]</span><br><span class="line">    println(<span class="string">&quot;Get<span class="variable">$m</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果：</span></span><br><span class="line"><span class="comment">Add 1</span></span><br><span class="line"><span class="comment">Add 2</span></span><br><span class="line"><span class="comment">Add 3</span></span><br><span class="line"><span class="comment">Add 4</span></span><br><span class="line"><span class="comment">Get1</span></span><br><span class="line"><span class="comment">Get2</span></span><br><span class="line"><span class="comment">Get3</span></span><br><span class="line"><span class="comment">Get4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上代码非常简单，程序会先运行 getList()，然后再运行 printList()。从运行的结果我们可以看出来，程序是按照顺序执行的，这没什么特别的。这就是一个典型的<strong>普通程序</strong>的例子。</p><p>下面让我们来看一个<strong>协程</strong>的例子。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 看不懂代码没关系，目前咱们只需要关心代码的执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> sequence = getSequence()</span><br><span class="line">    printSequence(sequence)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getSequence</span><span class="params">()</span></span> = sequence &#123;</span><br><span class="line">    println(<span class="string">&quot;Add 1&quot;</span>)</span><br><span class="line">    yield(<span class="number">1</span>)</span><br><span class="line">    println(<span class="string">&quot;Add 2&quot;</span>)</span><br><span class="line">    yield(<span class="number">2</span>)</span><br><span class="line">    println(<span class="string">&quot;Add 3&quot;</span>)</span><br><span class="line">    yield(<span class="number">3</span>)</span><br><span class="line">    println(<span class="string">&quot;Add 4&quot;</span>)</span><br><span class="line">    yield(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSequence</span><span class="params">(sequence: <span class="type">Sequence</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> iterator = sequence.iterator()</span><br><span class="line">    <span class="keyword">val</span> i = iterator.next()</span><br><span class="line">    println(<span class="string">&quot;Get<span class="variable">$i</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> j = iterator.next()</span><br><span class="line">    println(<span class="string">&quot;Get<span class="variable">$j</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> k = iterator.next()</span><br><span class="line">    println(<span class="string">&quot;Get<span class="variable">$k</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> m = iterator.next()</span><br><span class="line">    println(<span class="string">&quot;Get<span class="variable">$m</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Add 1</span></span><br><span class="line"><span class="comment">Get1</span></span><br><span class="line"><span class="comment">Add 2</span></span><br><span class="line"><span class="comment">Get2</span></span><br><span class="line"><span class="comment">Add 3</span></span><br><span class="line"><span class="comment">Get3</span></span><br><span class="line"><span class="comment">Add 4</span></span><br><span class="line"><span class="comment">Get4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这段代码做的事情和前面的代码其实差不多，只是我们是借助了 Kotlin 当中的 Sequence 来实现的。这次，我们从程序的运行结果会发现，getSequence() 与 printSequence() 这两个函数，它们是交替执行的。为了方便你理解，我用一张图来描述它们之间的调用顺序。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/a3/2c/a3caffed1ced7663c0595c9ce2800a2c.png?wh=1287x418" alt="img"></p><p>这段程序，给人的感觉就像是两位彬彬有礼的绅士，每个人执行一会代码以后，就会<strong>让出执行权</strong>给对方，让对方执行一会。这样的运行模式，就好像两个人在<strong>协作</strong>一样。</p><p>而对应的，前面的 getList() 和 printList() 的执行流程则完全不一样，getList() 执行完以后，才会轮到 printList() 来执行。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/a1/7d/a1052f9ce56bb228e82da4cc4218137d.png?wh=1271x732" alt="img"></p><p>这两种迥然不同的代码运行方式，其实就是协程与普通程序之间最大的差异。</p><ul><li>普通程序在被调用以后，只会在末尾的地方返回，并且只会返回一次，比如前面的 getList() 函数；而协程则不受此限制，协程的代码可以在任意 yield 的地方挂起（Suspend）让出执行权，然后等到合适的时机再恢复（Resume）。在这个情况下，yield 是代表了“让步”的意思。</li><li>普通程序需要一次性收集完所有的值，然后统一返回；而协程则可以每次只返回（yield）一个值，比如我们前面写的 getSequence() 方法。在这个情况下，yield 既有“让步”的意思，也有“产出”的意思。它不仅能让出执行权，还同时产生一个值，比如前面的 yield(1)，就代表产出的值为 1。</li></ul><p>除了 yield 以外，我们也可以借助 Kotlin 协程当中的 Channel 来实现类似的代码模式：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 看不懂代码没关系，目前咱们只需要关心代码的执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = getProducer(<span class="keyword">this</span>)</span><br><span class="line">    testConsumer(channel)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getProducer</span><span class="params">(scope: <span class="type">CoroutineScope</span>)</span></span> = scope.produce &#123;</span><br><span class="line">    println(<span class="string">&quot;Send:1&quot;</span>)</span><br><span class="line">    send(<span class="number">1</span>)</span><br><span class="line">    println(<span class="string">&quot;Send:2&quot;</span>)</span><br><span class="line">    send(<span class="number">2</span>)</span><br><span class="line">    println(<span class="string">&quot;Send:3&quot;</span>)</span><br><span class="line">    send(<span class="number">3</span>)</span><br><span class="line">    println(<span class="string">&quot;Send:4&quot;</span>)</span><br><span class="line">    send(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testConsumer</span><span class="params">(channel: <span class="type">ReceiveChannel</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">val</span> i = channel.receive()</span><br><span class="line">    println(<span class="string">&quot;Receive<span class="variable">$i</span>&quot;</span>)</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">val</span> j = channel.receive()</span><br><span class="line">    println(<span class="string">&quot;Receive<span class="variable">$j</span>&quot;</span>)</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">val</span> k = channel.receive()</span><br><span class="line">    println(<span class="string">&quot;Receive<span class="variable">$k</span>&quot;</span>)</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">val</span> m = channel.receive()</span><br><span class="line">    println(<span class="string">&quot;Receive<span class="variable">$m</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Send:1</span></span><br><span class="line"><span class="comment">Receive1</span></span><br><span class="line"><span class="comment">Send:2</span></span><br><span class="line"><span class="comment">Receive2</span></span><br><span class="line"><span class="comment">Send:3</span></span><br><span class="line"><span class="comment">Receive3</span></span><br><span class="line"><span class="comment">Send:4</span></span><br><span class="line"><span class="comment">Receive4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可见，以上代码中的 getProducer() 和 testConsumer() 之间，它们也是交替执行的。</p><p>所以，<strong>从广义上来讲，协程就代表了“互相协作的程序</strong>”。这样的标准，几乎适用于所有语言的协程。不管是 Python 的协程还是 C# 的协程，还是其他语言的协程，它们都是以这样的模式来实现的。而且，很多语言的协程都支持 yield。理解了这一点以后，将来不管你是遇到 Python 的协程，还是其他语言的协程也好，相信你也可以很快地把 Kotlin 协程当中的概念迁移过去。</p><p>聊完广义的协程以后，我们再来看看 Kotlin 协程的另外两个概念：协程、协程框架。注意，这是两个不一样的概念，前者是代表了程序当中被创建的协程；后者，则是一个整体的框架。</p><h2 id="如何理解-Kotlin-的协程？"><a href="#如何理解-Kotlin-的协程？" class="headerlink" title="如何理解 Kotlin 的协程？"></a>如何理解 Kotlin 的协程？</h2><p>在 Kotlin 当中，协程是一个独立的框架。跟 Kotlin 的反射库类似，协程并不是直接集成在标准库当中的。如果我们想要使用 Kotlin 的协程，就必须手动进行依赖：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.0&#x27;</span></span><br></pre></td></tr></table></figure><p>Kotlin 官方之所以将协程作为一个单独的框架独立出来，也是为了减小标准库的体积，给开发者更多的灵活性。另外，Kotlin 协程框架也是开源的，我们可以去 GitHub 上去浏览它的<a href="https://github.com/Kotlin/kotlinx.coroutines">源代码</a>。在这里，我们可以找到许多前沿的信息，也可以跟世界顶级的开发者交流。</p><p>业界一直有一种说法：<strong>Kotlin 协程其实就是一个封装的线程框架</strong>。如果我们站在框架的层面来看的话，这种说法也有一定道理：协程框架将线程池进一步封装，对开发者暴露出统一的协程 API。</p><p>不过，这种说法无法解释另一个语境下的问题，让我们来看一个代码例子。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码中一共启动了两个线程</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(Thread.currentThread().name)</span><br><span class="line">    thread &#123;</span><br><span class="line">        println(Thread.currentThread().name)</span><br><span class="line">        Thread.sleep(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">main</span></span><br><span class="line"><span class="comment">Thread-0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上面这段代码的逻辑很简单，就是在 main 函数当中启动了一个新的线程。“代码中一共启动了两个线程”，这句话的意思也很容易理解：main() 函数本身会启动一个主线程 main，然后在 thread{} 当中，又启动了一个新的线程“Thread-0”。所以，以上代码一共会启动两个线程。这没什么问题，关键是下一个例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码中一共启动了两个协程</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(Thread.currentThread().name)</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        println(Thread.currentThread().name)</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">main @coroutine#1</span></span><br><span class="line"><span class="comment">main @coroutine#2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里要配置特殊的VM参数：-Dkotlinx.coroutines.debug</span></span><br><span class="line"><span class="comment">这样一来，Thread.currentThread().name就能会包含：协程的名字@coroutine#1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在这段代码的注释当中，有这样一句话：<strong>代码中一共启动了两个协程</strong>。请问，这个语境下的“两个协程”，到底是什么？通过程序的输出结果，我们可以看到，main 函数当中出现了两个协程，一个是“coroutine#1”，一个是“coroutine#2”。</p><p>那么，这里的“协程”，到底是什么呢？它看起来好像跟 Java 的线程有点类似，但又好像是两个完全不一样的东西。这其实就是很多初学者会困扰的地方。</p><p>Kotlin 的协程，它要比线程更加抽象，因为 Java 的线程，我们起码可以找到 Thread 的源代码，同时，线程也是操作系统当中的一个概念，所以理解起来并不困难。而 Kotlin 的协程则没有类似的知识点可以建立关联。所以，我自己在学习 Kotlin 协程的时候，做法就是建立起<strong>协程的思维模型</strong>（Mental Model）。</p><p>很多人可能不太理解思维模型到底是什么，它在有些语境下，也被称为心智模型。人为了理解真实世界的运作规律，会自然而然地在脑子里建立起对应的模型。举个例子，我们为了理解公司内部的组织架构，经常会在脑子里建立一个类似这样的树状思维模型：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/38/a1/38d10ff8262caacae94733d77a6f88a1.jpg?wh=2000x1055" alt="img"></p><p>那么，我们该如何为 Kotlin 的协程建立思维模型呢？其实，Kotlin 的协程，我们可以将其想象成一个“更加轻量的线程”。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/df/62/dfab62d3f0c8558de5768e359fcb0462.png?wh=1920x1080" alt="img"></p><p>从包含关系上看，协程跟线程的关系，有点像线程与进程的关系，毕竟协程不可能脱离线程运行。所以，协程可以理解为<strong>运行在线程当中的、更加轻量的 Task</strong>。</p><h2 id="协程的轻量"><a href="#协程的轻量" class="headerlink" title="协程的轻量"></a>协程的轻量</h2><p>那么，协程的轻量，到底意味着什么呢？我们可以先来看一段这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 仅用作研究，工作中别这么写</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    repeat(<span class="number">1000_000_000</span>) &#123;</span><br><span class="line">        thread &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">10000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread</span></span><br><span class="line"><span class="comment">    at java.lang.Thread.start0(Native Method)</span></span><br><span class="line"><span class="comment">    at java.lang.Thread.start(Thread.java:717)</span></span><br><span class="line"><span class="comment">    at kotlin.concurrent.ThreadsKt.thread(Thread.kt:42)</span></span><br><span class="line"><span class="comment">    at kotlin.concurrent.ThreadsKt.thread$default(Thread.kt:20)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们尝试启动 10 亿个线程，这样的代码运行在大部分的机器上都是会因为内存不足等原因而异常退出的。而如果我们将代码改用协程来实现的话，结果会怎样呢？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 仅用作研究，工作中别这么写</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    repeat(<span class="number">1000_000_000</span>) &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">1000000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">10000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">正常</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们启动了 10 亿个协程。由于协程是非常轻量的，所以代码不会因为内存不足而异常退出。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">注意：虽然协程非常轻量，但在工作当中，我们也应该尽量避免写出类似上面这样的代码。</span><br></pre></td></tr></table></figure><p>另外，协程虽然运行在线程之上，但协程并不会和某个线程绑定，在某些情况下，协程是可以在不同的线程之间切换的。我们可以来看看下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking(Dispatchers.IO) &#123;</span><br><span class="line">    repeat(<span class="number">3</span>) &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            repeat(<span class="number">3</span>) &#123;</span><br><span class="line">                println(Thread.currentThread().name)</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">5000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">DefaultDispatcher-worker-3 @coroutine#2</span></span><br><span class="line"><span class="comment">DefaultDispatcher-worker-2 @coroutine#3</span></span><br><span class="line"><span class="comment">DefaultDispatcher-worker-4 @coroutine#4</span></span><br><span class="line"><span class="comment">DefaultDispatcher-worker-1 @coroutine#2 // 线程切换了</span></span><br><span class="line"><span class="comment">DefaultDispatcher-worker-4 @coroutine#4</span></span><br><span class="line"><span class="comment">DefaultDispatcher-worker-2 @coroutine#3</span></span><br><span class="line"><span class="comment">DefaultDispatcher-worker-2 @coroutine#2 // 线程切换了</span></span><br><span class="line"><span class="comment">DefaultDispatcher-worker-1 @coroutine#4</span></span><br><span class="line"><span class="comment">DefaultDispatcher-worker-4 @coroutine#3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上代码的运行结果是随机的，这里以我运行的结果来分析的话，可以看到，“coroutine#2”的三次执行，每一次都在不同的线程上。第一次，它在“worker-3”执行，第二次在“worker-1”执行，第三次在“worker-2”执行。</p><p>这时候，我们就可以进一步更新脑海中的思维模型了。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/d8/a9/d89e8744663d45635a5125829a9037a9.gif?wh=1080x608" alt="img"></p><p>让我们来做个小结：</p><ul><li>协程，可以理解为更加轻量的线程，成千上万个协程可以同时运行在一个线程当中；</li><li>协程，其实是运行在线程当中的轻量的 Task；</li><li>协程，不会与特定的线程绑定，它可以在不同的线程之间灵活切换。</li></ul><h2 id="协程的“非阻塞”"><a href="#协程的“非阻塞”" class="headerlink" title="协程的“非阻塞”"></a>协程的“非阻塞”</h2><p>另外，协程对比线程还有一个特点，那就是<strong>非阻塞</strong>（Non Blocking），而线程则往往是阻塞式的。这个概念有点抽象，我们来看个具体的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    repeat(<span class="number">3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Print-1:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">900L</span>)</span><br><span class="line">        println(<span class="string">&quot;Print-2:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Print-1:main</span></span><br><span class="line"><span class="comment">Print-1:main</span></span><br><span class="line"><span class="comment">Print-1:main</span></span><br><span class="line"><span class="comment">Print-2:main</span></span><br><span class="line"><span class="comment">Print-2:main</span></span><br><span class="line"><span class="comment">Print-2:main</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码里有两个 repeat，第一个 repeat 当中，我们每次调用 sleep() 方法，让线程休眠 1 秒钟，而第二个 repeat 当中，我们每次只休眠 0.9 秒。由于线程的 sleep() 方法是阻塞式的，所以程序的执行流程是线性的。也就是说，“Print-1”会连续输出三次，然后“Print-2”会连续输出三次。即使 Print-2 休眠的时间更短。</p><p>让我们来看看协程代码的表现有哪些不一样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">3</span>) &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            println(<span class="string">&quot;Print-1:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">3</span>) &#123;</span><br><span class="line">            delay(<span class="number">900L</span>)</span><br><span class="line">            println(<span class="string">&quot;Print-2:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">3000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Print-2:main @coroutine#3</span></span><br><span class="line"><span class="comment">Print-1:main @coroutine#2</span></span><br><span class="line"><span class="comment">Print-2:main @coroutine#3</span></span><br><span class="line"><span class="comment">Print-1:main @coroutine#2</span></span><br><span class="line"><span class="comment">Print-2:main @coroutine#3</span></span><br><span class="line"><span class="comment">Print-1:main @coroutine#2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们用协程实现了类似的逻辑，但这次的执行结果却完全不一样。可以看到，Print-2 和 Print-1 是交替输出的，“coroutine#2”、“coroutine#3”这两个协程是并行的（Concurrent）。同时，由于协程的 delay() 方法是非阻塞的，所以，即使 Print-1 会先执行 delay(1000L)，但它也并不会阻塞 Print-2 的 delay(900L) 的运行。</p><p>而如果我们将代码中的 delay 修改成 sleep，程序的运行结果就会不一样。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">3</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">            println(<span class="string">&quot;Print-1:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">3</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">900L</span>)</span><br><span class="line">            println(<span class="string">&quot;Print-2:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">3000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Print-1:main @coroutine#2</span></span><br><span class="line"><span class="comment">Print-1:main @coroutine#2</span></span><br><span class="line"><span class="comment">Print-1:main @coroutine#2</span></span><br><span class="line"><span class="comment">Print-2:main @coroutine#3</span></span><br><span class="line"><span class="comment">Print-2:main @coroutine#3</span></span><br><span class="line"><span class="comment">Print-2:main @coroutine#3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>由此可见，Kotlin 协程的“非阻塞”其实<strong>只是语言层面</strong>的，当我们调用 JVM 层面的 Thread.sleep() 的时候，它仍然会变成阻塞式的。与此同时，这也意味着我们在协程当中应该尽量避免出现阻塞式的行为。尽量使用 delay，而不是 sleep。</p><p>那么，我们该如何理解 Kotlin 协程的“非阻塞”？答案是：<strong>挂起和恢复</strong>。</p><p>这两个能力也是协程才拥有的特殊能力，普通的程序是不具备的。</p><p>挂起和恢复，初学者看到这两个概念可能会比较陌生。它俩的字面意思我们都能看懂，但当发生在程序世界里之后，就无法理解了，因为我们根本就看不见，也摸不着。那怎么办呢？</p><p>我的做法还是：<strong>建立思维模型</strong>。</p><p>对于执行在普通线程当中的程序来说，如果我们站在 CPU 的角度上看，最终它会以类似这样的方式执行：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/dd/bc/dd4cfa1246e6141262a9de48d31dbcbc.gif?wh=1080x358" alt="img"></p><p>这时候，当某个任务发生了阻塞行为的时候，比如 sleep，当前执行的 Task 就会阻塞后面所有任务的执行。就像下面这张动图所展示的一样：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/e8/41/e862e19363f44c56a01709643791ee41.gif?wh=1080x346" alt="img"></p><p><strong>那么，协程是如何通过挂起和恢复来实现非阻塞的呢？</strong></p><p>大部分的语言当中都会存在一个类似“调度中心”的东西，它会来实现 Task 任务的执行和调度。如下图所示：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/f2/f9/f28fa6fb2ba6d147de33ccb649969cf9.png?wh=1920x937" alt="img"></p><p>而协程除了拥有“调度中心”以外，对于每个协程的 Task，还会多出一个类似“抓手”“挂钩”的东西，可以方便我们对它进行“挂起和恢复”。协程任务的总体执行流程，大致会像下图描述的这样：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/50/26/50ayycf2b8d015cf8cef7dcde541ae26.gif?wh=1080x499" alt="img"></p><p>通过对比可以看出，线程的 sleep 之所以是阻塞式的，是因为它会阻挡后续 Task 的执行。而协程之所以是非阻塞式的，是因为它可以支持挂起和恢复。当 Task 由于某种原因被挂起后，后续的 Task 并不会因此被阻塞。</p><p>这时候，如果我们回过头再来看之前的代码，相信也会有新的体会：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">3</span>) &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            println(<span class="string">&quot;Print-1:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">3</span>) &#123;</span><br><span class="line">            delay(<span class="number">900L</span>)</span><br><span class="line">            println(<span class="string">&quot;Print-2:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">3000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Print-2:main @coroutine#3</span></span><br><span class="line"><span class="comment">Print-1:main @coroutine#2</span></span><br><span class="line"><span class="comment">Print-2:main @coroutine#3</span></span><br><span class="line"><span class="comment">Print-1:main @coroutine#2</span></span><br><span class="line"><span class="comment">Print-2:main @coroutine#3</span></span><br><span class="line"><span class="comment">Print-1:main @coroutine#2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>好了，到这里，我们今天的内容就差不多结束了。这节课我并没有给你介绍任何具体的协程 API，而是先带你建立协程的思维模型，目的就是让你在这个过程中，真正理解协程的核心概念，并建立起一个清晰的认知，从而为后面 API 的学习打下基础。毕竟，磨刀不误砍柴工嘛！</p><p>那么在学完这节课之后，你也需要掌握以下几个要点：</p><ul><li>广义的协程，可以理解为“互相协作的程序”，也就是“Cooperative-routine”。</li><li>协程框架，是独立于 Kotlin 标准库的一套框架，它封装了 Java 的线程，对开发者暴露了协程的 API。</li><li>程序当中运行的“协程”，可以理解为<strong>轻量的线程</strong>；</li><li>一个线程当中，可以运行成千上万个协程；</li><li>协程，也可以理解为运行在线程当中的<strong>非阻塞的 Task</strong>；</li><li>协程，通过<strong>挂起和恢复</strong>的能力，实现了“非阻塞”；</li><li>协程不会与特定的线程绑定，它可以在不同的线程之间灵活切换，而这其实也是通过“挂起和恢复”来实现的。</li></ul><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/bd/9d/bd90de594f1209631cec647a876eee9d.jpg?wh=2000x716" alt="img"></p><p>说实话，学习协程，真的不是一件容易的事情。如果这节课我不介绍协程的思维模型，一上来就介绍协程的 API，你一定会觉得云里雾里、找不着方向。所以，也请你不要轻视这节课的重要性，一定要充分理解本节课的内容，再去学习后面的知识点。</p><p>下节课开始，我会正式介绍 Kotlin 协程相关的 API，同时，也会进一步完善我们的协程思维模型。</p><p><strong>思考题</strong></p><p>有人说：协程会比线程更加高效，请问你认同这种说法吗？为什么？ 欢迎在留言区分享你的看法和见解，也欢迎你把今天的内容分享给更多的朋友，我们一起交流探讨。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(特别放送)刷题计划（四） 一题三解，搞定分式加减法</title>
      <link href="/posts/9ab13196/"/>
      <url>/posts/9ab13196/</url>
      
        <content type="html"><![CDATA[<p>在上节课里呢，我给你留了一个作业：用 Kotlin 来完成 LeetCode 的 592 号题《分数加减运算》。那么今天这节课，我们就一起来看看它的解题思路吧。</p><p>这其实也是一道典型的模拟题，分式的加减法这样的题目，我们小学就知道怎么做了，核心解题思路主要是这几步：</p><ul><li>第一步，求出分母的最小公倍数。比如，2 和 3 的最小公倍数就是 6。</li><li>第二步，根据计算出来的最小公倍数，将分数进行通分。举个例子：“1&#x2F;2-1&#x2F;6”，如果把它们两个通分，就会变成“3&#x2F;6-1&#x2F;6”。</li><li>第三步，将分子进行加减法，计算出分子的结果。比如，“3&#x2F;6-1&#x2F;6”计算过后，就会变成“2&#x2F;6”。</li><li>最后一步，将计算结果转换成“最简分数”，比如“2&#x2F;6”化成最简分数以后，应该是“1&#x2F;3”。</li></ul><p>经过这四个步骤，我们就可以计算出“1&#x2F;2-1&#x2F;6&#x3D;1&#x2F;3”。不过呢，这道题里，我们除了要计算分数的加减法以外，还要先完成分数的解析。程序的输入是字符串“1&#x2F;2-1&#x2F;6”，但它是不会帮我们自动解析的，所以，解析这一步也需要我们来做。</p><p>所以，自然而然地，我们就会定义一个分数的<strong>数据类 Expression</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Expression</span>(<span class="keyword">val</span> numerator: <span class="built_in">Int</span>, <span class="keyword">val</span> denominator: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$numerator</span>/<span class="variable">$denominator</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个数据类 Expression 当中，一共有两个属性，<strong>numerator</strong> 代表了分子，<strong>denominator</strong> 代表了分母，它们的类型都是 Int。另外，分数都是带有符号的，这里我们按照约定俗成来处理：分子可能是正数或负数，分母则一定是正整数。比如“1&#x2F;2”，我们就用 Expression(1,2) 来表示；而“-1&#x2F;2”，我们就用 Expression(-1,2) 来表示，而不会使用 Expression(1,-2) 表示。</p><p>另外在正式开始做题之前，还有一些额外的条件是需要我们弄清楚的：</p><ul><li>第一，只需要支持分数的加减法，乘除法不需要考虑；</li><li>第二，输入的式子中间不会有空格，且式子也一定是正确的，这就意味着，我们的输入只会包含“0-9”、“&#x2F;”，“+”、“-”这些字符，不会出现其他的字符；</li><li>第三，整数也会用分数来表示，比如说“2”，会用“2&#x2F;1”来表示；</li><li>第四，计算结果保证不会整型溢出。</li></ul><p>好，问题的细节我们弄清楚了，大致思路也有了，接下来，我们就用三种解法来搞定这道题。</p><h2 id="解法一：命令式"><a href="#解法一：命令式" class="headerlink" title="解法一：命令式"></a>解法一：命令式</h2><p>命令式的代码是最符合编程直觉的，我们的思路大致如下：</p><ul><li>第一步，将式子当中的“-”统一替换成“+-”，然后再用split(“+”)将式子分割成一个个独立分数。这种技巧我们在上节课就已经用过了。</li><li>第二步，解析出独立的分数以后，我们就要将每一个分数解析成对应的 Expression 了。这里具体做法也很简单，我们可以用“&#x2F;”来分割分数，前面的就是分子，后面的就是分母。比如“-1&#x2F;2”，我们就可以解析出 Expression(-1,2)。</li><li>第三步，就是根据解析出来的所有分母，计算出所有分母的最小公倍数。比如，“1&#x2F;2+1&#x2F;3+1&#x2F;4”，我们就把分母都提取出来“2，3，4”，而它们的最小公倍数应该是 12。</li><li>第四步，就是将所有的分数都通分。比如“1&#x2F;2+1&#x2F;3+1&#x2F;4”，就会变成“6&#x2F;12+4&#x2F;12+3&#x2F;12”。</li><li>后面的步骤就简单了，我们只需要将分子都相加起来，确保结果是“最简分数”即可。</li></ul><p>整个过程如下图：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/8d/75/8d56a2f3f4c07946417863810cf16275.gif?wh=1080x608" alt="img" style="zoom:50%;" /><p>所以，我们就可以把代码分为以下几个步骤：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fractionAddition</span><span class="params">(expression: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="comment">// ①，分割式子</span></span><br><span class="line">    <span class="comment">// ②，解析分数成Expression</span></span><br><span class="line">    <span class="comment">// ③，计算所有分母的最小公倍数</span></span><br><span class="line">    <span class="comment">// ④，将所有的分数都通分</span></span><br><span class="line">    <span class="comment">// ⑤，将所有分子加起来进行计算，得到结果</span></span><br><span class="line">    <span class="comment">// ⑥，将结果化为“最简分数”</span></span><br><span class="line">    <span class="comment">// ⑦，最后，返回toString()的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把编码步骤梳理清楚了以后，其实我们每一个步骤都不难实现了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fractionAddition</span><span class="params">(expression: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="comment">// ①，分割式子</span></span><br><span class="line">    <span class="keyword">val</span> list = expression.replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;+-&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> fractionList = list.split(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> expressionList = mutableListOf&lt;Expression&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ②，解析分数成Expression</span></span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> fractionList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.trim() != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            expressionList.add(parseExpression(item))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③，计算所有分母的最小公倍数</span></span><br><span class="line">    <span class="keyword">var</span> lcm = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (exp <span class="keyword">in</span> expressionList) &#123;</span><br><span class="line">        lcm = lcm(lcm, exp.denominator)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ④，将所有的分数都通分</span></span><br><span class="line">    <span class="keyword">val</span> commonDenominatorFractions = mutableListOf&lt;Expression&gt;()</span><br><span class="line">    <span class="keyword">for</span> (exp <span class="keyword">in</span> expressionList) &#123;</span><br><span class="line">        commonDenominatorFractions.add(toCommonDenominatorExp(exp, lcm))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⑤，将所有分子加起来进行计算，得到结果</span></span><br><span class="line">    <span class="keyword">var</span> numerator = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (fraction <span class="keyword">in</span> commonDenominatorFractions) &#123;</span><br><span class="line">        numerator += fraction.numerator</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⑥，将结果化为“最简分数”</span></span><br><span class="line">    <span class="keyword">val</span> result = Expression(numerator, lcm)</span><br><span class="line">    <span class="keyword">val</span> reducedFraction = result.reducedFraction()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⑦，最后，返回toString()的结果</span></span><br><span class="line">    <span class="keyword">return</span> reducedFraction.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码当中，还涉及到几个辅助函数，它们的实现也很简单。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 解析分数，“1/2” -&gt; Expression(1,2)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseExpression</span><span class="params">(expression: <span class="type">String</span>)</span></span>: Expression &#123;</span><br><span class="line">    <span class="keyword">val</span> list = expression.trim().split(<span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list.size != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Expression(list[<span class="number">0</span>].toInt(), list[<span class="number">1</span>].toInt())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通分</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">toCommonDenominatorExp</span><span class="params">(expression: <span class="type">Expression</span>, lcm: <span class="type">Int</span>)</span></span>: Expression &#123;</span><br><span class="line">    <span class="keyword">return</span> Expression(</span><br><span class="line">        numerator = expression.numerator * lcm / expression.denominator,</span><br><span class="line">        denominator = lcm</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最简化分数</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Expression.<span class="title">reducedFraction</span><span class="params">()</span></span>: Expression &#123;</span><br><span class="line">    <span class="keyword">val</span> gcd = gcd(Math.abs(numerator), denominator)</span><br><span class="line">    <span class="keyword">return</span> Expression(numerator / gcd, denominator / gcd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求两个数的最小公倍数，Least Common Multiple</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">lcm</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a * b / gcd(a, b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求两个数的最大公约数，Greatest Common Divisor</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">gcd</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (big, small) = <span class="keyword">if</span> (a &gt; b) a to b <span class="keyword">else</span> b to a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (small != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> temp = small</span><br><span class="line">        small = big % small</span><br><span class="line">        big = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> big</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个辅助函数，需要注意的是 **reducedFraction()**，它的作用是计算最简分数，计算过程，其实就是计算出分子、分母的最大公约数，然后同时除以最大公约数。而最大公约数 <strong>gcd()</strong> 这个方法，本质上就是我们小学学过的辗转相除法。而最小公倍数 <strong>lcm()</strong> 这个方法，则是通过两数相乘，然后除以最大公约数求出来的。</p><p>至此，我们的第一种解法就完成了。</p><h2 id="解法二：函数式"><a href="#解法二：函数式" class="headerlink" title="解法二：函数式"></a>解法二：函数式</h2><p>其实，利用同样的思想，我们还可以写出函数式的解法。如果你足够细心的话，你会发现解法一的代码可读性并不是很好，而如果用函数式思想重构上面的代码的话，可读性将会得到很大改善。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fractionAddition</span><span class="params">(expression: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">var</span> lcm: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">return</span> expression</span><br><span class="line">        .replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;+-&quot;</span>)</span><br><span class="line">        .split(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">        .filter &#123; it.trim() != <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        .map(::parseExpression)</span><br><span class="line">        .also &#123; lcm = getCommonDenominator(it) &#125;</span><br><span class="line">        .map &#123; toCommonDenominatorExp(it, lcm) &#125;</span><br><span class="line">        .reduce(::calculateExp)</span><br><span class="line">        .reducedFraction()</span><br><span class="line">        .toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码，我们从上读到下，就跟读英语文本一样：</p><ul><li>首先，使用“+-”替代“-”；</li><li>接着，将其用“+”分割；之后，过滤无效的字符；</li><li>然后，将字符串解析成 Expression；</li><li>这时候，我们根据所有的分母，计算出所有分母的最小公倍数；</li><li>接着，我们就可以对所有的分数进行通分；</li><li>然后，就可以将所有的分子相加，得到计算结果；</li><li>最后，就是将结果化为“最简分数”，再返回 toString() 的结果。</li></ul><p>那么，要写出上面这样的代码，我们仍然是需要一些辅助函数的，它们的逻辑跟解法一是一样的，只是换了种写法。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseExpression</span><span class="params">(expression: <span class="type">String</span>)</span></span> =</span><br><span class="line">    expression.trim()</span><br><span class="line">        .split(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">        .takeIf &#123; it.size == <span class="number">2</span> &#125;</span><br><span class="line">        ?.let &#123; Expression(it[<span class="number">0</span>].toInt(), it[<span class="number">1</span>].toInt()) &#125;</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCommonDenominator</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">Expression</span>&gt;)</span></span> =</span><br><span class="line">    list.map &#123; it.denominator &#125;.reduce(::lcm)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">toCommonDenominatorExp</span><span class="params">(expression: <span class="type">Expression</span>, lcm: <span class="type">Int</span>)</span></span>: Expression =</span><br><span class="line">    expression.let &#123;</span><br><span class="line">        Expression(numerator = it.numerator * lcm / it.denominator, denominator = lcm)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculateExp</span><span class="params">(acc: <span class="type">Expression</span>, expression: <span class="type">Expression</span>)</span></span>: Expression =</span><br><span class="line">    Expression(acc.numerator + expression.numerator, acc.denominator)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Expression.<span class="title">reducedFraction</span><span class="params">()</span></span>: Expression =</span><br><span class="line">    gcd(Math.abs(numerator), denominator)</span><br><span class="line">        .let &#123; Expression(numerator / it, denominator / it) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Least Common Multiple</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">lcm</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a * b / gcd(a, b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Greatest Common Divisor</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">gcd</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (big, small) = <span class="keyword">if</span> (a &gt; b) a to b <span class="keyword">else</span> b to a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (small != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> temp = small</span><br><span class="line">        small = big % small</span><br><span class="line">        big = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> big</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，对于复杂一些的方法来说，如果以函数式的思路来重构的话，可读性会有比较明显的提升。而对于原本就很简单的方法，重构之后，可读性反而会下降。所以，<strong>我们在写 Kotlin 的时候，不能一味追求所谓的范式正确，哪种范式更合适，我们就应该用哪个</strong>。</p><h2 id="解法三：稳定性优化"><a href="#解法三：稳定性优化" class="headerlink" title="解法三：稳定性优化"></a>解法三：稳定性优化</h2><p>好，前面的这两种解法的思路都是一样的，不过这两种解法其实还是会有一个问题，那就是当分数很多，并且分母很大的情况下，我们一次性计算所有分母的最小公倍数时，是可能导致溢出的（当然，我们前面已经明确讲过不需要考虑溢出）。</p><p>所以，前面两种解法的思路还可以再进一步优化，同时也可以避免溢出的问题。它整体的思路没有什么大的变化，只是在计算的时候不会采取一次性将所有分数通分的策略，而是选择一次计算两个相邻的分数，得到结果以后再计算下一个。</p><p>这里我制作了一个动图，方便你理解它的整体过程：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/8e/a7/8e30b6e8f7c196f0068f2835ec8e51a7.gif?wh=1080x608" alt="img" style="zoom:33%;" /><p>可以看到，这种思路的唯一区别就在于，它会先计算“1&#x2F;3-1&#x2F;2”的结果，将结果化为最简分数以后，再拿结果进行下一步计算“-1&#x2F;6+1&#x2F;4”，最终才会得到结果“1&#x2F;12”。</p><p>这样，我们在解法二的基础上，稍作改动就能实现：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fractionAddition</span><span class="params">(expression: <span class="type">String</span>)</span></span>: String =</span><br><span class="line">    expression</span><br><span class="line">        .replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;+-&quot;</span>)</span><br><span class="line">        .split(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">        .filter &#123; it.trim() != <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        .map(::parseExpression)</span><br><span class="line">        .reduce(::calculateExp)</span><br><span class="line">        .reducedFraction()</span><br><span class="line">        .toString()</span><br></pre></td></tr></table></figure><p>其实，我们也就是通过 reduce(::calculateExp) 这行代码，来计算相邻的分数的。</p><p>下面，我们具体来看看 calculateExp() 这个方法。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculateExp</span><span class="params">(acc: <span class="type">Expression</span>, expression: <span class="type">Expression</span>)</span></span>: Expression &#123;</span><br><span class="line">    <span class="keyword">val</span> lcm = lcm(acc.denominator, expression.denominator)</span><br><span class="line">    <span class="keyword">val</span> exp1 = toCommonDenominatorExp(acc, lcm)</span><br><span class="line">    <span class="keyword">val</span> exp2 = toCommonDenominatorExp(expression, lcm)</span><br><span class="line">    <span class="keyword">return</span> Expression(exp1.numerator + exp2.numerator, lcm).reducedFraction()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>calculateExp() 方法的实现也很简单，它的作用是计算两个分数的结果。总体流程就是：</p><ul><li>第一步，计算两个分数分母的最小公倍数 lcm；</li><li>第二步，根据 lcm，将两个分数都通分；</li><li>第三步，将分数的分子都相加，然后化简为“最简分数”。</li></ul><p>至此，解法三的代码就完成了，除了 calculateExp() 这个方法的实现之外，其他代码跟解法二是一样的。我们来看看它整体的代码吧。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fractionAddition</span><span class="params">(expression: <span class="type">String</span>)</span></span>: String =</span><br><span class="line">    expression</span><br><span class="line">        .replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;+-&quot;</span>)</span><br><span class="line">        .split(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">        .filter &#123; it.trim() != <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        .map(::parseExpression)</span><br><span class="line">        .reduce(::calculateExp)</span><br><span class="line">        .reducedFraction()</span><br><span class="line">        .toString()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseExpression</span><span class="params">(expression: <span class="type">String</span>)</span></span> =</span><br><span class="line">    expression.trim()</span><br><span class="line">        .split(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">        .takeIf &#123; it.size == <span class="number">2</span> &#125;</span><br><span class="line">        ?.let &#123; Expression(it[<span class="number">0</span>].toInt(), it[<span class="number">1</span>].toInt()) &#125;</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">toCommonDenominatorExp</span><span class="params">(expression: <span class="type">Expression</span>, lcm: <span class="type">Int</span>)</span></span>: Expression =</span><br><span class="line">    expression.let &#123;</span><br><span class="line">        Expression(numerator = it.numerator * lcm / it.denominator, denominator = lcm)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculateExp</span><span class="params">(acc: <span class="type">Expression</span>, expression: <span class="type">Expression</span>)</span></span>: Expression &#123;</span><br><span class="line">    <span class="keyword">val</span> lcm = lcm(acc.denominator, expression.denominator)</span><br><span class="line">    <span class="keyword">val</span> exp1 = toCommonDenominatorExp(acc, lcm)</span><br><span class="line">    <span class="keyword">val</span> exp2 = toCommonDenominatorExp(expression, lcm)</span><br><span class="line">    <span class="keyword">return</span> Expression(exp1.numerator + exp2.numerator, lcm).reducedFraction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Expression.<span class="title">reducedFraction</span><span class="params">()</span></span>: Expression =</span><br><span class="line">    gcd(Math.abs(numerator), denominator)</span><br><span class="line">        .let &#123; Expression(numerator / it, denominator / it) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Least Common Multiple</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">lcm</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a * b / gcd(a, b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Greatest Common Divisor</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">gcd</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (big, small) = <span class="keyword">if</span> (a &gt; b) a to b <span class="keyword">else</span> b to a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (small != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> temp = small</span><br><span class="line">        small = big % small</span><br><span class="line">        big = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> big</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课，我们一共用了三种解法来实现 LeetCode 的 592 号题《分数加减运算》这道题。解法一和二，它们的思路是一致的，只是前者是命令式，后者是函数式。而解法三，则是在解法二的基础上做的优化。我们可以来对比一下这三种解法。</p><ul><li>解法一，可读性差，时间复杂度、空间复杂度稍差，复杂的情况下可能会出现溢出。</li><li>解法二，类似解法一，只是可读性要好很多。</li><li>解法三，类似解法二，优势在于不容易出现溢出。</li></ul><p>不知不觉，春节假期就快要过去了。在这一周里，我们体验了一把用 Kotlin 刷题的感觉。总体来说，用 Kotlin 来刷算法题还是比较愉快的，对比起 Java，它能提供丰富 API 的同时，还能提供多样的编程范式。对于不同的问题，我们可以灵活选择编程范式来解决。</p><p>在这一周里，我故意在使用多种范式来刷题，目的就是让你可以体会到 Kotlin 在面对不同问题的时候，它在不同编程范式上的不同表现。</p><ul><li>比如，对于“版本号判断”这个题目来说，命令式的代码明显会更加的简洁，而函数式的代码则有些丑陋。</li><li>比如，对于“求解方程”这个题目来说，函数式与命令式之间各有优劣。</li><li>而对于今天这个“分数加减法”的题目来说，函数式的解法则是在各方面都要优于命令式的。</li></ul><p>那么，在最后，我希望你不要把这节课当作 Kotlin 刷题的终点，而是要把这节课当作一个起点。因为，用 Kotlin 刷算法题，真的是个一举多得的好办法！我们何乐而不为呢？</p><h2 id="小作业"><a href="#小作业" class="headerlink" title="小作业"></a>小作业</h2><p>好，还是给你留一个小作业吧，请你写出“解法三”对应的命令式代码吧。</p><p><code>提示：在解法一的基础上做一些修改就能轻松实现了。</code></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(春节特别放松)春节刷题计划（三） 一题双解， 方程</title>
      <link href="/posts/4b068051/"/>
      <url>/posts/4b068051/</url>
      
        <content type="html"><![CDATA[<p>在上节课里，我给你留了一个作业，那就是：用 Kotlin 来完成 LeetCode 的 640 号题《求解方程》。那么这节课，我就来讲讲我的解题思路，我们互相学习。</p><p>这道题也非常容易理解，程序的输入是一个“一元一次方程”，我们需要根据输入的方程，计算出正确的结果。根据输入方程的不同，结果可能有三种情况：</p><ul><li><strong>方程仅有一个解</strong>，这时，我们只需要按照格式返回结果即可，比如输入“2x&#x3D;4”，那么输出就应该是“x&#x3D;2”。</li><li><strong>方程有无数个解</strong>，比如输入“x&#x3D;x”，那么输出就应该是“Infinite solutions”。</li><li><strong>方程无解</strong>，比如输入“x&#x3D;x+5”，那么输出结果就应该是“No solution”。</li></ul><p>另外，对于程序的<strong>输入格式</strong>，其实我们还有几个问题需要弄清楚。只有弄清楚了这些问题，我们才能开始写代码：</p><ul><li>方程当中的未知数只会用 x 表示，不会是 y，也不会是大写的“X”。</li><li>方程当中不会出现空格，比如“2x&#x3D;4”，不会出现“2x &#x3D; 4 ”的情况。</li><li>方程当中只会有加减法，不会出现乘除法。</li><li>方程当中的数字，一定是整数，不会出现分数、小数。</li><li>输入的方程一定是一个正确的方程，不会出现“x&#x3D;…”之类的脏数据。</li></ul><p>好，问题的细节都弄清楚了，下面我们来分析一下解题的思路。</p><p>对于这种简单的一元一次方程的解法，其实我们在小学就学过了，概括起来，就是分为三个步骤。</p><ul><li>第一步，<strong>移项</strong>。将含有 x 的式子全部移到等式的左边，将数字全部都移到等式的右边。另外，移项的时候符号要变。比如“3x-4&#x3D;x+2”这个方程，移项以后，就会变成这样：“3x-x&#x3D;2+4”。</li><li>第二步，<strong>合并同类项</strong>。这里其实就是将等式的左边与右边合并起来，对于“3x-x&#x3D;2+4”这个式子，合并完以后，就会变成“2x&#x3D;6”。</li><li>第三步，<strong>系数化为一</strong>。这时候，我们就需要拿右边的数字，除以左边的系数。比如上面的式子“2x&#x3D;6”，系数化为一之后，就会变成“x&#x3D;3”，这就是我们想要的方程解。当然，这只是方程只有一个解的情况，其实在系数化为一之前，还存在其他的情况，比如“x&#x3D;x+5”最终会变成“0&#x3D;5”，这时候左边是零，右边不是零，这时候就代表方程无解；对于“2x&#x3D;2x”这样的方程，它最终会变成“0&#x3D;0”，这种两边都等于零的情况，就代表了方程有无数个解。</li></ul><p>好，如何求解方程的思路我们已经知道了，那么代码该如何写呢？这里，我们仍然有两种解法，这两种解法的思路是一致的，只是其中一种是偏命令式的，另一种是偏函数式的。</p><p>这里，我照样是制作了一张动图，给你展示下程序运行的整体思路：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/4b/91/4bbc7f1f21cd04e1b17f8032304a2691.gif?wh=1080x608" alt="img" style="zoom:50%;" /><p><strong>解法一：命令式</strong></p><p>首先，我们按照前面分析的思路，把待实现的程序分为以下几个步骤：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solveEquation</span><span class="params">(equation: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="comment">// ① 分割等号</span></span><br><span class="line">    <span class="comment">// ② 遍历左边的等式，移项，合并同类项</span></span><br><span class="line">    <span class="comment">// ③ 遍历右边的等式，移项，合并同类项</span></span><br><span class="line">    <span class="comment">// ④ 系数化为一，返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释，我们很容易就能完成其中①、④两个步骤的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solveEquation</span><span class="params">(equation: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="comment">// ① 分割等号</span></span><br><span class="line">        <span class="keyword">val</span> list = equation.split(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ② 遍历左边的等式，移项，合并同类项</span></span><br><span class="line">        <span class="comment">// ③ 遍历右边的等式，移项，合并同类项</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ④ 系数化为一,返回结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">            leftSum == <span class="number">0</span> &amp;&amp; rightSum == <span class="number">0</span> -&gt; <span class="string">&quot;Infinite solutions&quot;</span></span><br><span class="line">            leftSum == <span class="number">0</span> &amp;&amp; rightSum != <span class="number">0</span> -&gt; <span class="string">&quot;No solution&quot;</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="string">&quot;x=<span class="subst">$&#123;rightSum / leftSum&#125;</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在，关键还是在于②、③两个步骤的代码。这里，list[0]其实就代表了左边的式子，list[1]就代表了右边的式子。</p><p>按照之前的思路分析，我们其实用两个 for 循环，分别遍历它们，然后顺便完成移项与合并同类项就行了。具体的代码如下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> leftSum = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> rightSum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> leftList = splitByOperator(list[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">val</span> rightList = splitByOperator(list[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// ② 遍历左边的等式，移项，合并同类项</span></span><br><span class="line">leftList.forEach &#123;</span><br><span class="line">    <span class="keyword">if</span> (it.contains(<span class="string">&quot;x&quot;</span>)) &#123;</span><br><span class="line">        leftSum += xToInt(it)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rightSum -= it.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ③ 遍历右边的等式，移项，合并同类项</span></span><br><span class="line">rightList.forEach&#123;</span><br><span class="line">    <span class="keyword">if</span> (it.contains(<span class="string">&quot;x&quot;</span>)) &#123;</span><br><span class="line">        leftSum -= xToInt(it)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rightSum += it.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑其实也比较清晰了，leftList、rightList 是根据“+”、“-”分割出来的元素。在完成分割以后，我们再对它们进行了遍历，从而完成了移项与合并同类项。</p><p>并且，这里我们还用到了另外两个方法，分别是 splitByOperator()、xToInt()，它们具体的代码如下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">splitByOperator</span><span class="params">(list: <span class="type">String</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = mutableListOf&lt;String&gt;()</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="string">&quot;&quot;</span></span><br><span class="line">    list.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="string">&#x27;+&#x27;</span> || it == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.isNotEmpty()) &#123;</span><br><span class="line">                result.add(temp)</span><br><span class="line">            &#125;</span><br><span class="line">            temp = it.toString()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp += it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.add(temp)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">xToInt</span><span class="params">(x: <span class="type">String</span>)</span></span> =</span><br><span class="line">    <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>,</span><br><span class="line">        <span class="string">&quot;+x&quot;</span> -&gt; <span class="number">1</span></span><br><span class="line">        <span class="string">&quot;-x&quot;</span> -&gt; -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; x.replace(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;&quot;</span>).toInt()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从以上代码中，我们可以看到 splitByOperator() 就是使用“+”、“-”作为分隔符，将字符串类型的式子，分割成一个个的元素。而 xToInt() 的作用则是为了提取 x 的系数，比如“2x”，提取系数以后，就是“2”；而“-2x”的系数就是“-2”。</p><p>最后，我们再来看看整体的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solveEquation</span><span class="params">(equation: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="comment">// ① 分割等号</span></span><br><span class="line">    <span class="keyword">val</span> list = equation.split(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> leftSum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> rightSum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> leftList = splitByOperator(list[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">val</span> rightList = splitByOperator(list[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ② 遍历左边的等式，移项，合并同类项</span></span><br><span class="line">    leftList.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.contains(<span class="string">&quot;x&quot;</span>)) &#123;</span><br><span class="line">            leftSum += xToInt(it)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rightSum -= it.toInt()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③ 遍历右边的等式，移项，合并同类项</span></span><br><span class="line">    rightList.forEach&#123;</span><br><span class="line">        <span class="keyword">if</span> (it.contains(<span class="string">&quot;x&quot;</span>)) &#123;</span><br><span class="line">            leftSum -= xToInt(it)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rightSum += it.toInt()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ④ 系数化为一,返回结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        leftSum == <span class="number">0</span> &amp;&amp; rightSum == <span class="number">0</span> -&gt; <span class="string">&quot;Infinite solutions&quot;</span></span><br><span class="line">        leftSum == <span class="number">0</span> &amp;&amp; rightSum != <span class="number">0</span> -&gt; <span class="string">&quot;No solution&quot;</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="string">&quot;x=<span class="subst">$&#123;rightSum / leftSum&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据“+”、“-”分割式子</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">splitByOperator</span><span class="params">(list: <span class="type">String</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = mutableListOf&lt;String&gt;()</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="string">&quot;&quot;</span></span><br><span class="line">    list.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="string">&#x27;+&#x27;</span> || it == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.isNotEmpty()) &#123;</span><br><span class="line">                result.add(temp)</span><br><span class="line">            &#125;</span><br><span class="line">            temp = it.toString()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp += it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.add(temp)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取x的系数：“-2x” -&gt;“-2”</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">xToInt</span><span class="params">(x: <span class="type">String</span>)</span></span> =</span><br><span class="line">    <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>,</span><br><span class="line">        <span class="string">&quot;+x&quot;</span> -&gt; <span class="number">1</span></span><br><span class="line">        <span class="string">&quot;-x&quot;</span> -&gt; -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; x.replace(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;&quot;</span>).toInt()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>至此，偏命令式的代码就完成了，接下来我们看看偏函数式的代码该怎么写。</p><p><strong>解法二：函数式</strong></p><p>这里你要注意了，函数式的思路呢，和命令式的思路其实是<strong>一样</strong>的。解方程的步骤是不会变的，仍然是移项、合并同类项、系数化为一。只不过，对比前面的实现方式，我们这里会更多地<strong>借助 Kotlin 的标准库函数</strong>。</p><p>首先，我们来看看第一部分的代码怎么写：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solveEquation</span><span class="params">(equation: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> list = equation</span><br><span class="line">        .replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;+-&quot;</span>) <span class="comment">// 预处理逻辑</span></span><br><span class="line">        .split(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用“+”分割字符串</span></span><br><span class="line">    <span class="keyword">val</span> leftList = list[<span class="number">0</span>].split(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> rightList = list[<span class="number">1</span>].split(<span class="string">&quot;+&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，为了可以直接使用 Kotlin 的库函数 split 来实现算式的分割，我使用了一种<strong>数据预处理</strong>的办法。你可以看到，在上面代码的注释处，replace(“-“, “+-“) 的作用是将算式当中的所有“-”替换成“+-”，这就是预处理。经过这个预处理后，我们就可以直接使用 split(“+”) 来分割算式了。</p><p>为了体现这个细节，我这里也做了一个动图，你可以看看：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/b5/e9/b54e8c509be711cea6d3a0c1f22617e9.gif?wh=1080x425" alt="img" style="zoom:50%;" /><p>这样一来，我们得到的 leftList、rightList 其实就是干净的、独立的数字和 x 式子了。以“x+5-3+x&#x3D;6+x-2”为例，leftList&#x3D;[“x”,”5”,”-3”,”x”]，而rightList&#x3D;[“6”,”x”,”-2”]。</p><p>既然它们两者都是普通的集合，那么我们接下来，就完全可以借助 Kotlin 强大的库函数来做剩下的事情了。我们只需要将所有 x 的式子挪到左边，所有数字挪到右边，然后合并，最后系数化为一即可。大致代码如下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">leftList</span><br><span class="line">    .filter &#123; it.hasX() &#125;</span><br><span class="line">    .map &#123; xToInt(it) &#125; <span class="comment">// ①</span></span><br><span class="line">    .toMutableList() </span><br><span class="line">    .apply &#123;</span><br><span class="line">        rightList</span><br><span class="line">            .filter &#123; it.hasX() &#125;</span><br><span class="line">            .map &#123; xToInt(it).times(-<span class="number">1</span>) &#125; <span class="comment">// ②</span></span><br><span class="line">            .let &#123; addAll(it) &#125; </span><br><span class="line">    &#125;.sum() <span class="comment">// ③</span></span><br><span class="line">    .let &#123; leftSum = it &#125;</span><br><span class="line"></span><br><span class="line">rightList</span><br><span class="line">    .filter &#123; it.isNumber() &#125;</span><br><span class="line">    .map &#123; it.toInt() &#125; <span class="comment">// ④</span></span><br><span class="line">    .toMutableList()</span><br><span class="line">    .apply &#123;</span><br><span class="line">        leftList</span><br><span class="line">            .filter &#123; it.isNumber() &#125;</span><br><span class="line">            .map &#123; it.toInt().times(-<span class="number">1</span>) &#125; <span class="comment">// ⑤</span></span><br><span class="line">            .let &#123; addAll(it) &#125; </span><br><span class="line">    &#125;.sum() <span class="comment">// ⑥</span></span><br><span class="line">    .let &#123; rightSum = it &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回结果</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">    leftSum == <span class="number">0</span> &amp;&amp; rightSum == <span class="number">0</span> -&gt; <span class="string">&quot;Infinite solutions&quot;</span></span><br><span class="line">    leftSum == <span class="number">0</span> &amp;&amp; rightSum != <span class="number">0</span> -&gt; <span class="string">&quot;No solution&quot;</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">&quot;x=<span class="subst">$&#123;rightSum / leftSum&#125;</span>&quot;</span> <span class="comment">// ⑦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中，一共有 6 个注释，我们一个个看：</p><ul><li>注释①，我们提取出了左边式子里所有 x 的系数，这里不需要移项，因为它本来就在左边。</li><li>注释②，我们提取了右边式子里所有 x 的系数，由于这里涉及到移项，因此需要变号，这里我们通过乘以一个“-1”来实现的。</li><li>注释③，我们将所有 x 的系数合并到了一起，得到了左边 x 的系数之和。</li><li>注释④，我们收集了右边式子里所有的数字，这里也不需要移项，因为它本来就在右边。</li><li>注释⑤，我们收集了左边式子里所有的数字，这里要移项，所以要变号。</li><li>注释⑥，我们将所有数字求和了。</li><li>注释⑦，如果方程有解的话，我们通过“rightSum &#x2F; leftSum”就可以计算出来了。</li></ul><p>另外，以上代码其实还涉及到三个辅助的函数，需要我们自己实现，它们的逻辑都很简单：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">isNumber</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> =</span><br><span class="line">    <span class="keyword">this</span> != <span class="string">&quot;&quot;</span> &amp;&amp; !<span class="keyword">this</span>.contains(<span class="string">&quot;x&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">hasX</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> =</span><br><span class="line">    <span class="keyword">this</span> != <span class="string">&quot;&quot;</span> &amp;&amp; <span class="keyword">this</span>.contains(<span class="string">&quot;x&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取x的系数：“-2x” -&gt;“-2”</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">xToInt</span><span class="params">(x: <span class="type">String</span>)</span></span> =</span><br><span class="line">    <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span> -&gt; <span class="number">1</span></span><br><span class="line">        <span class="string">&quot;-x&quot;</span> -&gt; -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; x.replace(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;&quot;</span>).toInt()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>xToInt() 这个函数和之前的逻辑是相似的，isNumber() 和 hasX() 这两个扩展函数，它们是用来判断式子是纯数字、还是含有 x 的，这是因为我们要把 x 放到等式左边，而数字要放到等式右边。</p><p>最后，我们再来看看整体的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solveEquation</span><span class="params">(equation: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> leftSum: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">val</span> rightSum: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> list = equation</span><br><span class="line">        .replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;+-&quot;</span>) <span class="comment">// 预处理数据</span></span><br><span class="line">        .split(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> leftList = list[<span class="number">0</span>].split(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> rightList = list[<span class="number">1</span>].split(<span class="string">&quot;+&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求出所有x的系数之和</span></span><br><span class="line">    leftList</span><br><span class="line">        .filter &#123; it.hasX() &#125;</span><br><span class="line">        .map &#123; xToInt(it) &#125;</span><br><span class="line">        .toMutableList()</span><br><span class="line">        .apply &#123;</span><br><span class="line">            rightList</span><br><span class="line">                .filter &#123; it.hasX() &#125;</span><br><span class="line">                .map &#123; xToInt(it).times(-<span class="number">1</span>) &#125;</span><br><span class="line">                .let &#123; addAll(it) &#125;</span><br><span class="line">        &#125;.sum()</span><br><span class="line">        .let &#123; leftSum = it &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求出所有数字之和</span></span><br><span class="line">    rightList</span><br><span class="line">        .filter &#123; it.isNumber() &#125;</span><br><span class="line">        .map &#123; it.toInt() &#125;</span><br><span class="line">        .toMutableList()</span><br><span class="line">        .apply &#123;</span><br><span class="line">            leftList</span><br><span class="line">                .filter &#123; it.isNumber() &#125;</span><br><span class="line">                .map &#123; it.toInt().times(-<span class="number">1</span>) &#125;</span><br><span class="line">                .let &#123; addAll(it) &#125;</span><br><span class="line">        &#125;.sum()</span><br><span class="line">        .let &#123; rightSum = it &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        leftSum == <span class="number">0</span> &amp;&amp; rightSum == <span class="number">0</span> -&gt; <span class="string">&quot;Infinite solutions&quot;</span></span><br><span class="line">        leftSum == <span class="number">0</span> &amp;&amp; rightSum != <span class="number">0</span> -&gt; <span class="string">&quot;No solution&quot;</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="string">&quot;x=<span class="subst">$&#123;rightSum / leftSum&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">isNumber</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> =</span><br><span class="line">    <span class="keyword">this</span> != <span class="string">&quot;&quot;</span> &amp;&amp; !<span class="keyword">this</span>.contains(<span class="string">&quot;x&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">hasX</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> =</span><br><span class="line">    <span class="keyword">this</span> != <span class="string">&quot;&quot;</span> &amp;&amp; <span class="keyword">this</span>.contains(<span class="string">&quot;x&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取x的系数：“-2x” -&gt;“-2”</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">xToInt</span><span class="params">(x: <span class="type">String</span>)</span></span> =</span><br><span class="line">    <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span> -&gt; <span class="number">1</span></span><br><span class="line">        <span class="string">&quot;-x&quot;</span> -&gt; -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; x.replace(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;&quot;</span>).toInt()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课，我们用两种方式实现了LeetCode 的 640 号题《求解方程》。这两种解法的核心思路其实是一致的，不过前者是偏命令式的，后者是偏函数式的。而你要清楚，即使它们是用的一种思路，也仍然是各有优劣的。</p><ul><li>解法一，命令式的代码，它的时间复杂度和空间复杂度要稍微好一些，但总体差距不大，所以不一定能体现出运行时的差异。这种方式的劣势在于，逻辑相对复杂，可读性稍差，且编码过程中容易出错。</li><li>解法二，偏函数式的代码，它的优势在于，代码逻辑相对清晰，并且，由于运用了大量 Kotlin 库函数，没那么容易出错。</li></ul><h2 id="小作业"><a href="#小作业" class="headerlink" title="小作业"></a>小作业</h2><p>好，最后，我还是给你留一个小作业，请你用 Kotlin 来完成 LeetCode 的 592 号题《分数加减运算》，下节课我也会给出我的答案。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(特别放送)刷题计划（二） 一题三解，搞定版本号判断</title>
      <link href="/posts/b0ff92f3/"/>
      <url>/posts/b0ff92f3/</url>
      
        <content type="html"><![CDATA[<p>在上节刷题课中，我给你留了一个作业，那就是：用 Kotlin 来完成 LeetCode 的 165 号题《版本号判断》。那么今天这节课，我就来讲讲我的解题思路，希望能给你带来一些启发。</p><p>这道题目其实跟我们平时的工作息息相关。给你两个字符串代表的版本号，需要你判断哪个版本号是新的，哪个版本号是旧的。比如，2.0 与 1.0 对比的话，2.0 肯定是新版本，1.0 肯定是旧版本。对吧？</p><p>不过，这里面还有一些问题需要留意，这些都是我们在正式写代码之前要弄清楚的。</p><ul><li>首先，版本号是可能以 0 开头的。比如 0.1、1.01，这些都是合理的版本号。</li><li>另外，如果是以 0 开头的话，1 个 0 和多个 0，它们是等价的，比如 1.01、1.001、1.00001 之间就是等价的，也就是说这几个版本号其实是相等的。</li><li>还有，1.0、1.0.0、1.0.0.0 它们之间也是等价的，也就是说这几个版本号也是相等的。</li></ul><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>好了，理解了题意以后，我们就可以开始写代码了，LeetCode 上面给了我们一个待实现的方法，大致如下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compareVersion</span><span class="params">(version1: <span class="type">String</span>, version2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 待完善</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析完题目以后，也许你已经发现了，这道题目其实并不需要什么特殊的数据结构和算法基础，这是一道单纯的“模拟题”。我们脑子里是如何对比两个版本号的，我们的代码就可以怎么写。</p><p>下面我做了一个动图，展示了版本号对比的整体流程。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/25/ab/25a423b14908721aef1dd36082d345ab.gif?wh=1080x608" alt="img" style="zoom:50%;" /><p>我们可以看到，这个对比的流程，大致可以分为以下几个步骤。</p><ul><li>第一步，将版本号的字符串用“点号”进行分割，得到两个字符串的列表。</li><li>第二步，同时遍历这两个列表，将列表中的每一个元素转换成整数，比如，当遍历到第二位的时候，5、05 这两个字符串，都会转换成数字 5。这里有个细节，那就是当版本号的长度不一样的时候，比如，遍历到 7.05.002.2 的最后一位时，7.5.2 其实已经越界了，这时候我们需要进行补零，然后再转换成数字。</li><li>第三步，根据转换后的数字进行对比，如果两者相等的话，我们就继续遍历下一位。如果不相等的话，我们就能直接返回对比的结果了。</li><li>第四步，如果两个版本号都遍历到了末尾，仍然没有对比出大小的差异，那么我们就认为这两个版本号相等，返回 0 即可。</li></ul><p>所以，按照上面的思路，我们可以把 compareVersion() 这个函数分为以下几个部分：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compareVersion</span><span class="params">(version1: <span class="type">String</span>, version2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// ① 使用“.”，分割 version1 和 version2，得到list1、list2</span></span><br><span class="line">    <span class="comment">// ② 同时遍历list1、list2，取出的元素v1、v2，并将其转换成整数，这里注意补零操作</span></span><br><span class="line">    <span class="comment">// ③ 对比v1、v2的大小，如果它们两者不一样，我们就可以终止流程，直接返回结果。</span></span><br><span class="line">    <span class="comment">// ④ 当遍历完list1、list2后仍然没有判断出大小话，说明两个版本号其实是相等的，这时候应该返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来，其实就很简单了。我们只需要将注释里面的自然语言，用代码写出来就行了。具体代码如下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compareVersion</span><span class="params">(version1: <span class="type">String</span>, version2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// ① 分割</span></span><br><span class="line">    <span class="keyword">val</span> list1 = version1.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> list2 = version2.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; list1.size || i &lt; list2.size) &#123;</span><br><span class="line">        <span class="comment">// ② 遍历元素</span></span><br><span class="line">        <span class="keyword">val</span> v1 = list1.getOrNull(i)?.toInt()?:<span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> v2 = list2.getOrNull(i)?.toInt()?:<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③ 对比</span></span><br><span class="line">        <span class="keyword">if</span> (v1 != v2) &#123;</span><br><span class="line">            <span class="keyword">return</span> v1.compareTo(v2)</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ④ 相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，有两个地方需要格外注意。</p><p><strong>一个是 while 循环的条件</strong>。由于 list1、list2 的长度可能是不一样的，所以，我们的循环条件是：list1、list2 当中只要有一个没有遍历完的话，我们就要继续遍历。</p><p>还有一个需要注意的地方，<strong>getOrNull(i)，这是 Kotlin 独有的库函数</strong>。使用这个方法，我们不必担心越界问题，当 index 越界以后，这个方法会返回 null，在这里我们把它跟 Elvis 表达式结合起来，就实现了自动补零操作。这也体现出了 Kotlin 表达式语法的优势。</p><p>好，到这里，我们就用第一种思路实现了版本号对比的算法。下面我们再来看看第二种思路。</p><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>前面的思路，我们是使用的 Kotlin 的库函数 split() 进行分割，然后对列表进行遍历来判断的版本号。其实，这种思路还可以进一步优化，那就是我们自己遍历字符串，来模拟 split 的过程，然后在遍历过程中，我们顺便就把比对的工作一起做完了。</p><p>思路二的整体过程比较绕，我同样是制作了一个动图来描述这个算法的整体流程：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/dd/67/dd6a09c1428892c7dc5a52623842d067.gif?wh=1080x608" alt="img" style="zoom:33%;" /><p>以上的整体算法过程，是典型的“<strong>双指针</strong>”思想。运用这样的思想，我们大致可以写出下面这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compareVersion</span><span class="params">(version1: <span class="type">String</span>, version2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> length1 = version1.length</span><br><span class="line">    <span class="keyword">val</span> length2 = version2.length</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; length1 || j &lt; length2) &#123;</span><br><span class="line">        <span class="comment">// ③</span></span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; length1 &amp;&amp; version1[i] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            x = x * <span class="number">10</span> + version1[i].toInt() - <span class="string">&#x27;0&#x27;</span>.toInt()</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ④</span></span><br><span class="line">        <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; length2 &amp;&amp; version2[j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            y = y * <span class="number">10</span> + version2[j].toInt() - <span class="string">&#x27;0&#x27;</span>.toInt()</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        j++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⑤</span></span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x.compareTo(y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⑥</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码一共有 6 个注释，我们来一个个解释。</p><ul><li>注释①，代表的就是我们遍历两个版本号的 index，双指针，指的就是它们两个。</li><li>注释②，最外层的 while 循环，其实就是为了确保双指针可以遍历到两个字符串的末尾。你注意下这里的循环条件，只要 version1、version2 当中有一个没到末尾，就会继续遍历。</li><li>注释③，这里就是在遍历 version1，一直到字符串末尾，或者遇到“点号”。在同一个循环当中，我们会对 x 的值进行累加，这个做法其实就是把字符串的数字转换成十进制的数字。</li><li>注释④，这里和注释③的逻辑一样，只是遍历的对象是 version2。</li><li>注释⑤，这里会对累加出来的 x、y 进行对比，不相同的话，我们就可以返回结果了。</li><li>注释⑥，如果遍历到末尾还没有结果，这就说明 version1、version2 相等。</li></ul><p>现在，我们就已经用 Kotlin 写出了两个题解，使用的思路都是命令式的编程方式。也许你会好奇，<strong>这个问题能用函数式的思路来实现吗</strong>？</p><p>答案当然是可以的！</p><h2 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h2><p>我们在前面就提到过，Kotlin 是支持多范式的，我们可以根据实际场景来灵活选择编程范式。那么在这里，我们可以借鉴一下前面第一种解法的思路。</p><p>其实，想要解决这个问题，我们只要能把 version1、version2 转换成两个整数的列表，就可以很好地进行对比了。我制作了一个动图，方便你理解：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/ee/32/eea4765d618437d7145ae77c8e404a32.gif?wh=1080x608" alt="img" style="zoom:33%;" /><p>根据这个流程，我们可以大致写出下面这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compareVersion</span><span class="params">(version1: <span class="type">String</span>, version2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    version1.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        .zipLongest(version2.split(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;0&quot;</span>) <span class="comment">// ①</span></span><br><span class="line">        .onEach &#123; <span class="comment">// ②</span></span><br><span class="line">            with(it) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first != second) &#123;</span><br><span class="line">                    <span class="keyword">return</span> first.compareTo(second)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.run &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来很简洁，核心的逻辑在两个方法当中，我分别用注释标注了。</p><ul><li>注释①，zipLongest() 这个方法，它的作用是将 version1、version2 对应的列表合并到一起，它返回值的类型是 List&gt;。</li><li>注释②，onEach()，其实它是一个高阶函数，它的作用就是遍历 List 当中的每一个 Pair，将其中的整型版本号拿出来对比，如果不一样，就可以直接返回结果。</li></ul><p>现在，你可能会感慨，这代码看起来真香啊！这个嘛……别高兴得太早。虽然 Kotlin 支持基础的 zip 语法，但它目前还不支持 zipLongest() 这么高级的操作符。</p><p>那么这该怎么办呢？我们只能自己来实现 zipLongest() 了！为了让前面的代码通过编译，我们必须要自己动手实现下面三个扩展函数。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Iterable<span class="type">&lt;String&gt;</span>.<span class="title">zipLongest</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    other: <span class="type">Iterable</span>&lt;<span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    default: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> first = iterator()</span><br><span class="line">    <span class="keyword">val</span> second = other.iterator()</span><br><span class="line">    <span class="keyword">val</span> list = ArrayList&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt;(minOf(collectionSizeOrDefault(<span class="number">10</span>), other.collectionSizeOrDefault(<span class="number">10</span>)))</span><br><span class="line">    <span class="keyword">while</span> (first.hasNext() || second.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> v1 = (first.nextOrNull() ?: default).toInt()</span><br><span class="line">        <span class="keyword">val</span> v2 = (second.nextOrNull() ?: default).toInt()</span><br><span class="line">        list.add(Pair(v1, v2))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">collectionSizeOrDefault</span><span class="params">(default: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> Collection&lt;*&gt;) <span class="keyword">this</span>.size <span class="keyword">else</span> default</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterator<span class="type">&lt;T&gt;</span>.<span class="title">nextOrNull</span><span class="params">()</span></span>: T? = <span class="keyword">if</span> (hasNext()) next() <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pair 是Kotlin标准库提供的一个数据类</span></span><br><span class="line"><span class="comment">// 专门用于存储两个成员的数据</span></span><br><span class="line"><span class="comment">// 提交代码的时候，Pair不需要拷贝进去</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;<span class="type">out A, out B</span>&gt;(</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> first: A,</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> second: B</span><br><span class="line">) : Serializable &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">&quot;(<span class="variable">$first</span>, <span class="variable">$second</span>)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个扩展函数实现起来还是比较简单的，zipLongest() 其实就是合并了两个字符串列表，然后将它们按照 index 合并成 Pair，另外那两个扩展函数都只是起了辅助作用。</p><p>这样，我们把前面的代码一起粘贴到 LeetCode 当中，其实代码是可以通过的。不过呢，我们的代码当中其实还有一个<strong>比较深的嵌套</strong>，看起来不是很顺眼：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compareVersion</span><span class="params">(version1: <span class="type">String</span>, version2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    version1.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        .zipLongest(version2.split(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        .onEach &#123;</span><br><span class="line">            <span class="comment">// 这里的嵌套比较深</span></span><br><span class="line">            with(it) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first != second) &#123;</span><br><span class="line">                    <span class="keyword">return</span> first.compareTo(second)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.run &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><p>你可以注意到，在 onEach 当中，有一个代码块，它有两层嵌套，这看起来有点丑陋。那么，我们能不能对它进一步优化呢？</p><p>当然是可以的。</p><p>这里，我们只需要想办法让 onEach 当中的 Lambda，变成带接收者的函数类型即可。具体做法就是，我们自己实现一个新的 onEachWithReceiver() 的高阶函数。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                                                        注意这里</span></span><br><span class="line"><span class="comment">//                                                           ↓</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, C : Iterable&lt;T&gt;</span>&gt; C.<span class="title">onEachWithReceiver</span><span class="params">(action: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: C &#123;</span><br><span class="line">    <span class="keyword">return</span> apply &#123; <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) action(element) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                                                   注意这里</span></span><br><span class="line"><span class="comment">// Kotlin库函数当中的onEach                                ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, C : Iterable&lt;T&gt;</span>&gt; C.<span class="title">onEach</span><span class="params">(action: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: C &#123;</span><br><span class="line">    <span class="keyword">return</span> apply &#123; <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) action(element) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码展示了 onEach() 和 onEachWithReceiver() 之间的差别，可以看到，它们两个的函数体其实没有任何变化，区别只是 action 的函数类型而已。</p><p>所以在这里，借助 onEachWithReceiver()，就可以进一步简化我们的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compareVersion</span><span class="params">(version1: <span class="type">String</span>, version2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    version1.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        .zipLongest(version2.split(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        .onEachWithReceiver &#123;</span><br><span class="line">            <span class="comment">// 减少了一层嵌套</span></span><br><span class="line">            <span class="keyword">if</span> (first != second) &#123;</span><br><span class="line">                <span class="keyword">return</span> first.compareTo(second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.run &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们把 onEach() 改成了 onEachWithReceiver()，因为它里面的 Lambda 是带有接收者，原本的 Pair 对象变成了 this 对象，这样，我们就可以直接使用 first、second 来访问 Pair 当中的成员了。</p><p>现在，就让我们来看看整体的代码吧：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compareVersion</span><span class="params">(version1: <span class="type">String</span>, version2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    version1.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        .zipLongest(version2.split(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        .onEachWithReceiver &#123;</span><br><span class="line">            <span class="keyword">if</span> (first != second) &#123;</span><br><span class="line">                <span class="keyword">return</span> first.compareTo(second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.run &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, C : Iterable&lt;T&gt;</span>&gt; C.<span class="title">onEachWithReceiver</span><span class="params">(action: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: C &#123;</span><br><span class="line">    <span class="keyword">return</span> apply &#123; <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) action(element) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">collectionSizeOrDefault</span><span class="params">(default: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> Collection&lt;*&gt;) <span class="keyword">this</span>.size <span class="keyword">else</span> default</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterator<span class="type">&lt;T&gt;</span>.<span class="title">nextOrNull</span><span class="params">()</span></span>: T? = <span class="keyword">if</span> (hasNext()) next() <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Iterable<span class="type">&lt;String&gt;</span>.<span class="title">zipLongest</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    other: <span class="type">Iterable</span>&lt;<span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    default: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> first = iterator()</span><br><span class="line">    <span class="keyword">val</span> second = other.iterator()</span><br><span class="line">    <span class="keyword">val</span> list = ArrayList&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt;(minOf(collectionSizeOrDefault(<span class="number">10</span>), other.collectionSizeOrDefault(<span class="number">10</span>)))</span><br><span class="line">    <span class="keyword">while</span> (first.hasNext() || second.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> v1 = (first.nextOrNull() ?: default).toInt()</span><br><span class="line">        <span class="keyword">val</span> v2 = (second.nextOrNull() ?: default).toInt()</span><br><span class="line">        list.add(Pair(v1, v2))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这就是我们的第三种思路。看完这三种思路以后，你会更倾向于哪种思路呢？</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课，我们使用了三种思路，实现了LeetCode 的 165 号题《版本号判断》。其中，前两种思路，是命令式的编程方式，第三种是偏函数式的方式。在我看来呢，这三种方式各有优劣。</p><ul><li>思路一，代码逻辑比较清晰，代码量小，时间复杂度、空间复杂度较差。</li><li>思路二，代码逻辑比较复杂，代码量稍大，时间复杂度、空间复杂度非常好。</li><li>思路三，代码主逻辑非常清晰，代码量大，时间复杂度、空间复杂度较差。</li></ul><p>第三个思路其实还有一个额外的优势，那就是，我们自己实现的扩展函数，可以用于以后解决其他问题。这就相当于沉淀出了有用的工具。</p><h2 id="小作业"><a href="#小作业" class="headerlink" title="小作业"></a>小作业</h2><p>好，最后，我还是给你留一个小作业，请你用 Kotlin 来完成LeetCode 的 640 号题《求解方程》。这道题目我同样会在下节课给出答案解析。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(特别放送)刷题计划（一） 当Kotlin遇上LeetCode</title>
      <link href="/posts/a7227a95/"/>
      <url>/posts/a7227a95/</url>
      
        <content type="html"><![CDATA[<p>时光飞逝，不知不觉间，我们就已经完成了基础篇的学习，并且也已经完成了三个实战项目，但这终归是不够过瘾的。想要完全掌握 Kotlin 的基础语法，我们还需要更多的练习。我相信，你现在的心情就像是一个手握屠龙刀的勇士，热切希望找一些对手来验证自己的学习成果。</p><p>其实，我自己在学习一门新的编程语言的时候，有一个高效的方法，也分享给你。这里我以 Kotlin 为例，假设我现在是一个新手，想快速掌握 Kotlin 的话，我会这样做：</p><ul><li>第一步，我会去 Google 搜索一些语言特性对比的文章。比如，我熟悉 Java，想学 Kotlin，我就会去搜“from Java to Kotlin”，然后去看一些 Java、Kotlin 语法对比的文章。这时候，我大脑里就会建立起 Java 与 Kotlin 的语法联系。</li><li>第二步，我会打开Kotlin 官方文档，花几个小时的时间粗略看一遍，对 Kotlin 的语法有个大致印象。</li><li>最后一步，我会打开 LeetCode 之类的网站，开始用 Kotlin 刷题。在刷题的过程中，我也会先从模拟类的题目开始，之后再到数组、链表、Map、二叉树之类的数据结构。整个过程由易到难，刚开始的时候，我会选择“简单题”，等熟练以后，再选择“中等题”，心情好的时候，我偶尔会做个“困难题”挑战一下。</li></ul><p>当然，对于你来说，第一步和第二步都已经不是问题了，通过前面十几节课程的学习，你已经有了牢固的 Kotlin 基础。现在欠缺的，只是大量的练习而已。</p><p>说回来，其实我认为，我这种学习编程的方法是个一举多得的，比如它可以让我们：</p><ul><li><p><strong>快速掌握一门新的编程语言</strong>。</p></li><li><p><strong>夯实基本功</strong>。通过刷算法题，可以进一步巩固自己的数据结构与算法知识，这对于以后的工作也会有很大的帮助。所谓软件的架构，其实一定程度上就是在选择不同的数据结构与算法解决问题。而基本功的扎实程度，也决定了一名开发者的能力上限。</p></li><li><p><strong>面试加分</strong>。众所周知，顶级的 IT 公司面试的时候，都是要做算法题的。假如你是一名 Android 或 Java 工程师，如果你能用 Kotlin 写出漂亮的题解，那将会是大大加分项。</p></li></ul><p>另外，由于语法的简洁性，你会发现，用 Kotlin 做算法题，<strong>比 Java 要“爽”很多</strong>。同样的一道题目，用 Java 你可能要写很多代码，但 Kotlin 却只需要简单的几行。</p><p>所以接下来的春节假期呢，我就会带你来一起刷题，希望你在假期放松休息、陪伴家人之余，也不要停下学习的脚步。好，那么今天，我们就先来看几个简单的题目，就当作是热身了。</p><h2 id="热身-1：移除字符串当中的“元音字母”"><a href="#热身-1：移除字符串当中的“元音字母”" class="headerlink" title="热身 1：移除字符串当中的“元音字母”"></a>热身 1：移除字符串当中的“元音字母”</h2><p>这是 LeetCode 的 1119 号题。题意大致是这样的：程序的输入是一个字符串 s。题目要求我们移除当中的所有元音字母 a、e、i、o、u，然后返回。</p><p>这个问题，如果我们用 Java 来实现的话，大致会是这样的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String removeVowels(String s) &#123;</span><br><span class="line">    StringBuilder builder = new StringBuilder();</span><br><span class="line">    char[] array = s.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(char c: array) &#123;</span><br><span class="line">        <span class="comment">// 不是元音字母，才会拼接</span></span><br><span class="line">        <span class="keyword">if</span>(c != <span class="string">&#x27;a&#x27;</span> &amp;&amp; c != <span class="string">&#x27;e&#x27;</span> &amp;&amp; c != <span class="string">&#x27;i&#x27;</span> &amp;&amp; c !=<span class="string">&#x27;o&#x27;</span> &amp;&amp; c != <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">            builder.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果是用 Kotlin，我们一行代码就可以搞定：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeVowels</span><span class="params">(s: <span class="type">String</span>)</span></span>: String =</span><br><span class="line">        s.filter &#123; it !<span class="keyword">in</span> setOf(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>) &#125;</span><br></pre></td></tr></table></figure><p>这里，我们是使用了字符串的扩展函数 filter，轻松就实现了前面的功能。这个题目很简单，同时也比较极端，下面我们来看一个更复杂的例子。</p><h2 id="热身-2：最常见的单词"><a href="#热身-2：最常见的单词" class="headerlink" title="热身 2：最常见的单词"></a>热身 2：最常见的单词</h2><p>这是 LeetCode 的 819 号题。题意大致如下：程序的输入是一段英语文本（paragraph），一个禁用单词列表（banned）返回出现次数最多、同时不在禁用列表中的单词。</p><p>这个题目其实跟我们第 2 次的实战项目“英语词频统计”有点类似，我们之前实现的是完整的单词频率，并且降序。这个题目只需要我们找到频率最高的单词，不过就是多了一个<strong>单词黑名单</strong>而已。</p><p>那么，这个题目如果我们用 Java 来实现，肯定是要不少代码的，但如果用 Kotlin，简单的几行代码就可以搞定了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mostCommonWord1</span><span class="params">(paragraph: <span class="type">String</span>, banned: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> =</span><br><span class="line">            paragraph.toLowerCase()</span><br><span class="line">                .replace(<span class="string">&quot;[^a-zA-Z ]&quot;</span>.toRegex(), <span class="string">&quot; &quot;</span>)</span><br><span class="line">                .split(<span class="string">&quot;\\s+&quot;</span>.toRegex())</span><br><span class="line">                .filter &#123; it !<span class="keyword">in</span> banned.toSet() &#125;</span><br><span class="line">                .groupBy &#123; it &#125;</span><br><span class="line">                .mapValues &#123; it.value.size &#125;</span><br><span class="line">                .maxBy &#123; it.value &#125;</span><br><span class="line">                ?.key?:<span class="keyword">throw</span> IllegalArgumentException()</span><br></pre></td></tr></table></figure><h2 id="热身-3：用-Kotlin-实现冒泡排序"><a href="#热身-3：用-Kotlin-实现冒泡排序" class="headerlink" title="热身 3：用 Kotlin 实现冒泡排序"></a>热身 3：用 Kotlin 实现冒泡排序</h2><p>冒泡排序，是计算机里最基础的一种排序算法。如果你忘了它的实现方式，也没关系，我做了一个动图，让你可以清晰地看到算法的执行过程。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/89/14/896c2b92f5837fa05aa8e0d17d16e514.gif?wh=1080x608" alt="img" style="zoom:50%;" /><p>那么针对冒泡排序法，如果我们用 Kotlin 来实现，命令式的方式会更加直观一些，就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sort</span><span class="params">(array: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">for</span> (end <span class="keyword">in</span> (array.size - <span class="number">1</span>) downTo <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (begin <span class="keyword">in</span> <span class="number">1.</span>.end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[begin - <span class="number">1</span>] &gt; array[begin]) &#123;</span><br><span class="line">                <span class="keyword">val</span> temp = array[begin - <span class="number">1</span>]</span><br><span class="line">                array[begin - <span class="number">1</span>] = array[begin]</span><br><span class="line">                array[begin] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们需要格外注意的是，在逆序遍历数组的时候，我们是使用了<strong>逆序</strong>的 Range：“(array.size - 1) downTo 1”，而如果这里是用“1…(array.size - 1)”的话，其实是会出问题的。因为 Kotlin 当中的 Range 要求必须是右边不能小于左边，比如“1…3”是可以的，而“3…1”是不行的。</p><p>好了，到这里，相信你对用 Kotlin 刷算法题已经有了一定认识了。正如 Kotlin 官方所宣传的那样，Kotlin 是一门多范式的编程语言，对于不同的问题，我们完全可以选择不同范式来进行编程。说到底就是：<strong>怎么爽就怎么来</strong>。</p><h2 id="小作业"><a href="#小作业" class="headerlink" title="小作业"></a>小作业</h2><p>好，最后也再给你留一个小作业，请你用 Kotlin 来完成LeetCode 的 165 号题《版本号判断》。</p><p>注意：LeetCode 中文站使用的 Kotlin 版本，仍然停留在 1.3.10。如果你是使用 Kotlin 1.6 解题，代码在 IDE 当中编译通过了，而 LeetCode 显示编译出错，那么你就需要修改一下对应的实现。或者，你也可以将新版本的库函数一起拷贝到 Solution 当中去。</p><p>这道题目我会在下节课给出答案解析，我们下节课再见。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)加餐四  什么是“空安全思维”？</title>
      <link href="/posts/f0ec5bb9/"/>
      <url>/posts/f0ec5bb9/</url>
      
        <content type="html"><![CDATA[<p>这节加餐，我们来聊聊空安全思维。</p><p>空（null），是很多编程语言中都有的设计，不同的语言中名字也都不太一样，比如 Java 和 Kotlin 里叫 null，在 Swift 里叫做 nil，而 Objective-C 当中，根据情况的不同还细分了 NULL、nil、Nil 等等。</p><p>如果你有 Java 的经验，那你一定不会对 NullPointerException（NPE，代码中常见的逻辑错误）感到陌生。null 会引起 NPE，但是在很多场景下，你却不得不使用它。因为 null 用起来实在是太方便了。比如说，前面第 4 讲里，我提到的计算器程序当中的 calculate() 方法，它的返回值就是可为空的，当我们的输入不合法的时候，calculate() 就会返回 null。</p><p>一般来说，我们会习惯性地用 null 来解决以下这些场景的问题：</p><ul><li>当变量还没初始化的时候，用 null 赋值；</li><li>当变量的值不合法的时候，用 null 赋值；</li><li>当变量的值计算错误的时候，用 null 赋值。</li></ul><p>虽然这些场景，我们不借助 null 也可以漂亮地解决，但 null 其实才是最方便的解决方案。因为总的来说，null 代表了一切不正常的值。如果没有了 null，我们编程的时候将会面临很多困难。</p><p>所以，null 对于我们开发者来说，是一把双刃剑，我们既需要借助它提供的便利，还需要避开它引出的问题。这是一种取舍，我们要在 null 的利与弊当中找到一个平衡点。而且，这里的平衡点，在不同的场景中是不一样的。</p><p>那么，怎么才能把握好 null 的平衡点呢？这就体现出<strong>空安全思维</strong>的重要性了。</p><h2 id="Java-的空安全思维"><a href="#Java-的空安全思维" class="headerlink" title="Java 的空安全思维"></a>Java 的空安全思维</h2><p>在正式研究 Kotlin 的空安全思维之前，我们先来看看 Java 是否能给我们带来一些灵感。在 Java 当中，其实也有一些手段来规避 NPE，最常见的手段，当然就是<strong>判空</strong>，这是防御式编程的一种体现，应用范围也很广泛。</p><p>另外一种手段是 @Nullable、@NotNull 之类的<strong>注解</strong>，开发者可以使用这样的注解来告诉 IDE 哪些变量是可能为空的，哪些是不可能为空的，IDE 会借助这些注解信息来帮我们规避 NPE。</p><p>不过，注解这样的方式，实际效果并不好，主要有两个原因：一方面是注解很难在代码中大面积使用，这全依赖于开发者的习惯，很难在大型团队中推行，即使推行了也会影响开发效率；另一方面，即使在工程当中大面积推行可空注解，也无法完全解决 NPE 的问题。</p><p>想象一下，虽然我们可以在函数的参数以及返回值上面都标注可空性，但无法为每一个变量、每一种类型，都标注这些可空信息。因此，可空注解这样的方式，必然是会留下很多死角的。</p><p>还有一种手段，是 Java 1.8 当中引入的 Optional，这种手段的核心思路就是<strong>封装数据</strong>，不再直接使用 null。举个例子，从前我们直接使用 String 类，使用 Optional 以后，我们就得改成 Optional。如果我们要判断值是否为空，就用 optional.isPresent()。</p><p>但 Optional 有几个缺点：</p><ul><li>第一点，增加了代码的复杂度；</li><li>第二点，降低了代码的执行效率，Optional 的效率肯定比 String 更低；</li><li>最后，业界普及度不高。这其实也是由前面两者而决定的，即使我们在自己的工程中用了 Optional，而第三方 SDK 当中没有的话，它也很难与其交互。</li></ul><p>由此可见，Java 解决 NPE 的三种思路都无法令人满意。</p><p>那么，现在假设你自己就是 Kotlin 语言的设计者，在 Java 的三种思路的基础上，你能想到什么更好的思路吗？</p><p>前面我们曾提到了，使用 @NotNull 之类的注解，是存在死角的，因为我们无法为每一个变量、每一个类型都加上可空注解。一方面是注解的 Target 存在限制，另一方面是开发效率也会急剧下降。</p><p>所以，我们需要的其实是一种<strong>简洁，且能为每一种类型都标明可空性的方式</strong>。这样一来，我们自然而然就能想到一个更好的方案，那就是：从<strong>类型系统</strong>下手。</p><h2 id="Kotlin-的空安全思维"><a href="#Kotlin-的空安全思维" class="headerlink" title="Kotlin 的空安全思维"></a>Kotlin 的空安全思维</h2><p>Kotlin 虽然是与 Java 兼容的，但是它的类型系统与 Java 却有很大的不同。在 Java 当中，我们用 String 代表字符串类型。而在 Kotlin 当中，同样是字符串类型，它却有三种表示方法。</p><ul><li>String，不可为空的字符串；</li><li>String?，可能为空的字符串；</li><li>String!，不知道是不是可能为空。</li></ul><p>这有点像是电影里的分身术，Java 当中的一个概念，在 Kotlin 当中分化出了三种概念。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/70/82/706f679056d9074byycc66697a05dd82.jpg?wh=2000x740" alt="img" style="zoom:33%;" /><p>Kotlin 的可空（String?）、不可空（String），我们在第 1 讲就已经介绍过了。Kotlin 这样的类型系统，让开发者必须明确规定每一个变量类型是否可能为空，通过这样的方式，Kotlin 编译器就能帮我们规避 NPE 了。</p><p>可以说，在不与 Kotlin 以外的环境进行交互的情况下，仅仅只是纯 Kotlin 开发当中，Kotlin 编译器已经可以帮我们消灭 NPE 了。不过，现代商业化的软件当中，全栈使用 Kotlin 是不现实的，这也就意味着，我们将不得不与其他语言环境打交道，其中最常见的就是 Java。</p><h2 id="Kotlin、Java-混合编程的空安全"><a href="#Kotlin、Java-混合编程的空安全" class="headerlink" title="Kotlin、Java 混合编程的空安全"></a>Kotlin、Java 混合编程的空安全</h2><p>在 Java 当中，是不存在可空类型这个概念的。因此，在 Kotlin 当中，我们把 Java 未知可空性的类型叫做<strong>平台类型</strong>，比如：String!。所有 Java 当中的不确定可空性的类型，在 Kotlin 看来都是平台类型，用“!”来表示。</p><p>让我们来看一个实际的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Java 代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NullJava</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static String getMsg(String s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">&quot;Kotlin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> static String getNullableString(<span class="meta">@Nullable</span> String s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">&quot;Kotlin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> static String getNotNullString(<span class="meta">@NotNull</span> String s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们一共定义了三个 Java 方法，第一个 getMsg() 我们直接返回了一个字符串，但是没有用可空注解标注；第二个方法 getNullableString() 则使用了 @Nullable 修饰了，代表它的参数和返回值是可能为空的；第三个方法 getNotNullString() 则是用的 @NotNull 修饰的，代表它的参数和返回值是不可能为空的。</p><p>而以上三个 Java 方法在 Kotlin 调用的时候，就出现以下几种情况：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Kotlin代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testPlatformType</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nullableMsg: String? = NullJava.getNullableString(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">val</span> notNullMsg: String = NullJava.getNotNullString(<span class="string">&quot;Hey,&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> platformMsg1: String? = NullJava.getMsg(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">val</span> platformMsg2: String = NullJava.getMsg(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是，由于 Java 当中的 getNullableString() 是由 @Nullable 修饰的，因此 Kotlin 编译器会自动将其识别为可空类型“String?”；而 getNotNullString() 是由 @NotNull 修饰的，因此 Kotlin 编译器会自动将其识别为不可空类型“String”。</p><p>最后，是 getMsg()，由于这个 Java 方法没有任何可空注解，因此，它在 Kotlin 代码中会被认为是平台类型“String!”。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/24/9f/24516bc822c6187ca3be74c26a06859f.png?wh=1208x328" alt="img" style="zoom: 67%;" /><p>对于平台类型，Kotlin 会认为，它既能被当作可空类型“String?”，也可以被当作不可空类型“String”。Kotlin 没有强制开发者，而是将选择权交给了开发者。所以我们开发者，就需要在这中间寻找平衡点。</p><p>我们不能将平台类型一概认为是不可空的，因为这会引发 NPE；我们也不能一概认为平台类型是可空的，因为这会导致我们的代码出现过多的空安全检查。</p><p>在这里，结合我个人的一些实践经验来看，对于 Kotlin 与 Java 混合编程的情况，这几个建议你可以参考一下：</p><ul><li>对于工程中的 <strong>Java 源代码</strong>，当它与 Kotlin 交互的时候，我们应该尽量为它的参数与返回值加上可空的注解。注意，这里并不是说要一次性为所有 Java 代码都加上注解，而是当它与 Kotlin 交互的时候。这个需求其实可以通过一些静态代码检测方案来实现。</li><li>对于工程当中的 <strong>Java SDK</strong>，当它需要与 Kotlin 交互的时候，如果 SDK 没有完善的可空注解，我们可以在 SDK 与业务代码之间建立一个抽象层，对 Java SDK 进行封装。</li></ul><p>至此，我们就能总结出 Kotlin 空安全的第一条准则：<strong>警惕 Kotlin 以外的数据类型</strong>。</p><p>从<strong>语言角度</strong>上看，Kotlin 不仅只是和 Java 交互，它还可以与其他语言交互，而如果其他语言没有可空的类型系统，那么我们就一定要警惕起来。</p><p>另外，从<strong>环境角度</strong>上看，Kotlin 还可以与其他外界环境交互，比如发起网络请求、解析网络请求、读取数据库，等等。这些外界的环境当中的数据，往往也是没有可空类型系统的，这时候我们更要警惕。</p><p><code>举个例子：很多 Kotlin 开发者会在 JSON 解析的时候，遇到 NPE 的问题，这也是一个相当棘手的问题，这个问题我们会在后面的实战项目中进一步分析。</code></p><p>聊完了 Kotlin 与外界交互的空安全准则后，我们再来看看纯 Kotlin 开发的准则。</p><h2 id="纯-Kotlin-的空安全"><a href="#纯-Kotlin-的空安全" class="headerlink" title="纯 Kotlin 的空安全"></a>纯 Kotlin 的空安全</h2><p>正常情况下，我们使用纯 Kotlin 开发，编译器已经可以帮助解决大部分的空安全问题了。不过，纯 Kotlin 开发，仍然有<strong>三大准则</strong>需要严格遵守。接下来，我们就通过两个实际场景，来具体学习下这三个准则。</p><h3 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a><strong>非空断言</strong></h3><p>在前面，我们曾经学习过 Kotlin 的空安全调用语法“?.”，其实，Kotlin 还提供了一个<strong>非空安全</strong>的调用语法“!!.”。这样的语法，我们也叫做非空断言。让我们来看个具体的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testNPE</span><span class="params">(msg: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"><span class="comment">//            非空断言</span></span><br><span class="line"><span class="comment">//              ↓</span></span><br><span class="line">    <span class="keyword">val</span> i = msg!!.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    NullExample.testNPE(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，如果我们要调用“String?”类型的成员，需要使用空安全调用，而这里我们使用非空断言，强行调用了它的成员。毫无疑问，上面的代码就会产生空指针异常。</p><p>看到这里，相信你马上就能总结出第二条空安全准则了<strong>：绝不使用非空断言“!!.”。</strong></p><p>看到这条准则，也许很多人都会觉得：这不是废话吗？谁会喜欢用非空断言呢？但是啊，在我过去的几年经验当中，确实见到过不少 Kotlin 断言相关的代码，它们大致有两个原因。</p><p>第一个原因，是当我们借助 IDE 的“Convert Java File To Kotlin File”的时候，这个工具会自动帮我们生成带有非空断言的代码。而我们在转换完代码以后，却没有 review，进而将<strong>非空断言</strong>带到了生产环境当中。</p><p>就以下面这段代码为例：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Java 代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConvertExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    void <span class="keyword">init</span>() &#123;</span><br><span class="line">        name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void test()&#123;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">            int count = name.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是非常典型的 Java 代码，其中我们也已经使用了 if 来判断 name 是否为空，然后再调用它的 length。</p><p>那么，如果我们借助 IDE 的转换工具，它会变成什么样呢？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaConvertExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        name = <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        name = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//                        非空断言</span></span><br><span class="line"><span class="comment">//                           ↓</span></span><br><span class="line">            <span class="keyword">val</span> count = name!!.length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到转成 Kotlin 代码以后，我们 test() 方法当中出现了<strong>非空断言</strong>。</p><p>你也许会好奇，Kotlin 不是支持 Smart Cast 吗？既然我们已经在 if 当中判断了 name 不等于空，那么，它不是会被 Smart Cast 成为一个非空类型吗？毕竟，我们经常能写出这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> name: String? = getLocalName()</span><br><span class="line"><span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//   判断非空后，被转换成非空类型了</span></span><br><span class="line"><span class="comment">//      ↓</span></span><br><span class="line">    name.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，回到我们上面的例子当中，如果我们将转换出来的非空断言语法删除掉，会发生什么？</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/25/ae/253579d865aa407891025b809b8ebbae.gif?wh=1088x722" alt="img" style="zoom:67%;" /><p>可见，当我们删除掉非空断言以后，IDE 报错了，大致意思是，在这种场景下，Smart Cast 是不可能发生的。为什么呢？我们判空以后的代码明明就很安全了啊！为什么不能自动转换成非空类型？</p><p>这就是很多 Kotlin 开发者使用非空断言的第二个原因，在某些场景下，Smart Cast 失效了，<strong>即使我们判空了，也免不了还是要继续使用非空断言</strong>。</p><p>注意了，这种情况下，并不是 IDE 出现了 Bug。它在这种情况下不支持 Smart Cast 是有原因的。我给你举个例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaConvertExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        name = <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        name = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 几百行代码</span></span><br><span class="line">            foo()</span><br><span class="line">            <span class="comment">//几百行代码</span></span><br><span class="line">            <span class="keyword">val</span> count = name!!.length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们的程序逻辑变得复杂的时候，在判空后，我们可能又会不小心改变 name 的值，比如上面的 foo() 函数，这时候我们的非空断言就会产生 NPE。这也是 Kotlin 编译器无法帮我们做 Smart Cast 的原因。</p><p>那么，在这种情况下，我们到底该如何避免使用非空断言呢？主要有这么几种方法。</p><p><strong>第一种</strong>，避免直接访问成员变量或者全局变量，将其改为传参的形式：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//    改为函数参数</span></span><br><span class="line"><span class="comment">//        ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(name: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//             函数参数支持Smart Cast</span></span><br><span class="line"><span class="comment">//                      ↓</span></span><br><span class="line">        <span class="keyword">val</span> count = name.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Kotlin 当中，函数的参数是不可变的，因此，当我们将外部的成员变量或者全局变量以函数参数的形式传进来以后，它可以用于 Smart Cast 了。</p><p><strong>第二种</strong>，避免使用可变变量 var，改为 val 不可变变量：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaConvertExample</span> &#123;</span><br><span class="line"><span class="comment">//       不可变变量</span></span><br><span class="line"><span class="comment">//           ↓</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> name: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//               不可变变量支持Smart Cast</span></span><br><span class="line"><span class="comment">//                          ↓</span></span><br><span class="line">            <span class="keyword">val</span> count = name.length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式很好理解，既然引发问题的根本原因是可变性导致的，我们直接将其<strong>改为不可变</strong>的即可。从这里，我们也可以看到“空安全”与“不可变性”之间的关联。</p><p><strong>第三种</strong>，借助临时的不可变变量：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaConvertExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//        不可变变量</span></span><br><span class="line"><span class="comment">//            ↓</span></span><br><span class="line">        <span class="keyword">val</span> _name = name</span><br><span class="line">        <span class="keyword">if</span> (_name != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在if当中，只使用_name这个临时变量</span></span><br><span class="line">            <span class="keyword">val</span> count = _name.length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，本质上还是借助了不可变性。这种方式看起来有点丑陋，但如果稍微封装一下也是有用的，比如接下来要用到的 let。</p><p><strong>第四种</strong>，是借助 Kotlin 提供的标准函数 let：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaConvertExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//                      标准函数</span></span><br><span class="line"><span class="comment">//                         ↓</span></span><br><span class="line">        <span class="keyword">val</span> count = name?.let &#123; it.length &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式和第三种方式，从本质上来讲是相似的，但是我们通过 let 可以更加优雅地来实现同样的需求。</p><p><strong>第五种</strong>，是借助 Kotlin 提供的 lateinit 关键字:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaConvertExample</span> &#123;</span><br><span class="line"><span class="comment">//         稍后初始化             不可空</span></span><br><span class="line"><span class="comment">//            ↓                   ↓</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> name: String</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        name = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>::name.isInitialized) &#123;</span><br><span class="line">            <span class="keyword">val</span> count = name.length</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Please call init() first!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> example = JavaConvertExample()</span><br><span class="line">    example.<span class="keyword">init</span>()</span><br><span class="line">    example.test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你足够细心，你会发现这种思路其实是<strong>完全抛弃可空性</strong>的。我们直接用 lateinit var 定义了不可能为空的 String 类型，然后，当我们要用到这个变量的时候，再去判断这个变量是否已经完成了初始化。</p><p>由于它的类型是不可能为空的，因此我们初始化的时候，必须传入一个非空的值，这就能保证：只要 name 初始化了，它的值就一定不为空。在这种情况下，我们就将判空问题变成了一个判断是否初始化的问题。</p><p><strong>第六种</strong>，使用 by lazy 委托：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaConvertExample</span> &#123;</span><br><span class="line"><span class="comment">//         不可变        非空   懒加载委托</span></span><br><span class="line"><span class="comment">//           ↓           ↓        ↓</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> name: String <span class="keyword">by</span> lazy &#123; <span class="keyword">init</span>() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> count = name.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们将 name 这个变量改为了<strong>不可变的非空属性，</strong>并且，借助 Kotlin 的懒加载委托来完成初始化。借助这种方式，我们可以尽可能地延迟初始化，同时，也消灭了可变性、可空性。</p><p>到这里，相信你就可以总结出第三条准则了：<strong>尽可能使用非空类型</strong>。</p><p>下面我们再来看看另一个场景。</p><h3 id="泛型可空性"><a href="#泛型可空性" class="headerlink" title="泛型可空性"></a><strong>泛型可空性</strong></h3><p>在学习泛型的时候，我曾经介绍过：我们可以用字母（比如 T）来代表某种未知的类型，以此来提升程序的灵活性。比如，我们很容易就能写出下面这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 泛型定义处              泛型使用处</span></span><br><span class="line"><span class="comment">//   ↓                      ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">saveSomething</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">set</span> = sortedSetOf&lt;T&gt;() <span class="comment">// Java TreeSet</span></span><br><span class="line">    <span class="keyword">set</span>.add(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//                 泛型实参自动推导为String</span></span><br><span class="line"><span class="comment">//                        ↓</span></span><br><span class="line">    saveSomething(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码没有实际应用价值，它代表的是一种代码模式。我们重点来看看 saveSomething() 这个方法，请问你能找出它的问题在哪吗？说实话，如果不是实际踩过坑，我们是很难意识到这段代码的问题在何处的。</p><p>让我们来看看这段代码是怎么出问题的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 泛型定义处              泛型使用处</span></span><br><span class="line"><span class="comment">//   ↓                      ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">saveSomething</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">set</span> = sortedSetOf&lt;T&gt;()</span><br><span class="line"><span class="comment">//    空指针异常              </span></span><br><span class="line"><span class="comment">//       ↓</span></span><br><span class="line">    <span class="keyword">set</span>.add(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//               编译通过</span></span><br><span class="line"><span class="comment">//                  ↓</span></span><br><span class="line">    saveSomething(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，虽然我们定义的泛型参数是“T”，函数的参数是“data: T”，看起来 data 好像是不可为空的，但实际上，我们是可以将 null 作为参数传进去的。这时候，编译器也不会报错。紧接着，由于 TreeSet 内部无法存储 null，所以我们的代码在“set.add(data)”这里，会产生运行时的空指针异常。</p><p>出现这样的问题的原因，其实是因为泛型的参数 T 给了我们一种错觉，让我们觉得：T 是非空的，而“T?”才是可空的。实际上，我们的 T 是等价于 的，因为 Any? 才是 Kotlin 的<strong>根类型</strong>。这也就意味着，泛型的 T 是可以接收 null 作为实参的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">saveSomething</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">//   ↑ </span></span><br><span class="line"><span class="comment">//  等价              </span></span><br><span class="line"><span class="comment">//   ↓                      </span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any?&gt;</span> <span class="title">saveSomething</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么，saveSomething() 这个方法，正确的写法应该是怎样的呢？答案其实也很简单：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 增加泛型的边界限制              </span></span><br><span class="line"><span class="comment">//       ↓                      </span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">saveSomething</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">set</span> = sortedSetOf&lt;T&gt;()</span><br><span class="line">    <span class="keyword">set</span>.add(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//              编译无法通过</span></span><br><span class="line"><span class="comment">//                  ↓</span></span><br><span class="line">    saveSomething(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，我们为泛型 <strong>T 增加了上界“Any”</strong>，由于 Any 是所有非空类型的“根类型”，这样就能保证我们的 data 一定是非空的。这样一来，当我们尝试往 saveSomething() 这个方法里传入 null 的时候，编译器就会报错，让这个问题在编译期就能暴露出来。</p><p>看到这里，相信你也可以总结出 Kotlin 空安全的第四条准则了：<strong>明确泛型可空性</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>学完了这节课，相信现在你对 Kotlin 的空安全思维就已经有了一个全面的认识。最后，我也再给你总结一下，你需要重点关注 Kotlin 的空安全思维，主要有四大准则： </p><ul><li>第一个准则：<strong>警惕 Kotlin 与外界的交互</strong>。这里主要分为两大类，第一种是：Kotlin 与其他语言的交互，比如和 Java 交互；第二种是：Kotlin 与外界环境的交互，比如 JSON 解析。</li><li>第二个准则<strong>：绝不使用非空断言“!!.”</strong>。这里主要是两个场景需要注意，一个是：IDE 的“Convert Java File To Kotlin File”功能转换的 Kotlin 代码，一定要 review，消灭其中的非空断言；另一个是：当 Smart Cast 失效的时候，我们要用其他办法来解决，而不是使用非空断言。</li><li>第三个准则：<strong>尽可能使用非空类型。</strong>借助 lateinit、懒加载，我们可以做到灵活初始化的同时，还能消灭可空类型。</li><li>第四个准则：<strong>明确泛型的可空性</strong>。我们不能被泛型 T 的外表所迷惑，当我们定义 的时候，一定要记住，它是可空的。在非空的场景下，我们一定要明确它的可空性，这一点，通过增加泛型的边界就能做到 。</li></ul><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/39/94/39fc08c17f4a4f9fff42bdb536a4c494.jpg?wh=2000x1050" alt="img" style="zoom: 50%;" /><p>其实，Kotlin 的空安全思维，也并不是四个准则就可以完全概括的，不过这四个准则可以为我们指明方向，为我们后面的学习打下基础。Kotlin 的空安全，其实和 Kotlin 的每一个特性都息息相关。比如，我们在前面课程里就应用了不变性、lateinit、懒加载委托、泛型边界等特性，来解决空安全问题。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)加餐三  什么是“不变性思维”？</title>
      <link href="/posts/210fbe34/"/>
      <url>/posts/210fbe34/</url>
      
        <content type="html"><![CDATA[<p>在开篇词里，我提到过学习 Kotlin 的五种思维转变，包括前面加餐中讲过的函数思维、表达式思维，以及接下来要给你介绍的不变性思维、空安全思维以及协程思维。所以今天，我们就一起来聊聊 Kotlin 的不变性思维。</p><p>Kotlin 将不变性的思想发挥到了极致，并将其融入到了语法当中。当开发者想要定义一个变量的时候，必须明确规定这个变量是<strong>可变的</strong>（var），还是<strong>不可变的</strong>（val）。在定义集合变量的时候，也同样需要明确规定这个集合是可变的（比如 MutableList），还是不可变的（比如 List）。</p><p>不过，不变性其实会被很多 Kotlin 初学者所忽略。尤其是有 Java、C 经验的开发者，很容易将老一套思想照搬到 Kotlin 当中来，为了方便，写出来的变量全部都是 var 的，写出来的集合都是 MutableXXX。</p><p>事实上，不变性思维，对我们写出优雅且稳定的 Kotlin 代码很关键。要知道，我们代码中很多的 Bug 都是因为某个变量被多个调用方改来改去，最后导致状态错误才出问题的。毕竟，变动越多，就越容易出错！</p><p><strong>那么，既然可变性这么“可恶”，我们为何不干脆直接在语法层面消灭 var、MutableXXX 这样的概念呢？</strong></p><p>这当然是不行的，因为我们的程序本身就是“为了产生变化而生的”。你想想，如果你的程序在运行过程中不会改变任何数据，那程序运行还有什么意义呢？而且你可以再想象一下，如果没有可变性，你打游戏的时候，画面根本就不会动啊！游戏数据不变，画面自然也不会动了。</p><p>所以说，<strong>所谓不变性思维，是一种反直觉的思路</strong>。这也是 Kotlin 从函数式编程领域借鉴过来的思想。在 Kotlin 当中，所谓的不变性思维，其实就是在满足程序功能可变性需求的同时，尽可能地消灭可变性。</p><p>这颇有一种“戴着镣铐跳舞”的意味。其实换句话理解一下，就是说我们应该：尽可能消灭那些<strong>非必要</strong>可变性。</p><p>下面，我们就一起来看几个代码案例吧，在解读案例的过程中，我们来具体理解下究竟什么是不变性思维。</p><h2 id="表达式思维消灭-var"><a href="#表达式思维消灭-var" class="headerlink" title="表达式思维消灭 var"></a>表达式思维消灭 var</h2><p>那么现在，我们的目标就变成了<strong>尽可能消灭那些非必要可变性</strong>。沿着这个思路，我们很容易就可以想到一个方向：尽可能将 var 变成 val。就比如下面这段代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testExp</span><span class="params">(<span class="keyword">data</span>: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">data</span> <span class="keyword">is</span> Number) &#123;</span><br><span class="line">        i = <span class="keyword">data</span>.toInt()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">data</span> <span class="keyword">is</span> String) &#123;</span><br><span class="line">        i = <span class="keyword">data</span>.length</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们定义了一个可变的变量 i，它的初始值是 0，如果 data 是数字类型，我们就将其转换成整型，赋值给 i；如果 data 是 String 类型，我们就将字符串的长度赋值给 i，否则就用 0 赋值。</p><p>这段代码虽然没什么实际用途，但它代表了 Java、C 当中普遍存在的代码模式。这里的 i，就是我们需要消灭的<strong>非必要</strong>可变性。其实，在学了上节课“表达式思维”以后，这个问题我们不费吹灰之力就可以解决了，也就是把整体的赋值逻辑变成一个表达式，代码示例如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testExp</span><span class="params">(<span class="keyword">data</span>: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> i = <span class="keyword">when</span> (<span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="keyword">is</span> Number -&gt; &#123;</span><br><span class="line">            <span class="keyword">data</span>.toInt()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">is</span> String -&gt; &#123;</span><br><span class="line">            <span class="keyword">data</span>.length</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里你要注意，如果你把这个当做一道题目来做的话，它无疑是很容易的。但我想强调的是：在写 Kotlin 代码的时候，需要<strong>一步到位</strong>直接写出上面这样的代码。而想要做到这一点，你就一定要将不变性的思维铭记在心。因为要做到这一点其实不太容易，尤其是对 Java、C 开发者而言。</p><p>另外，如果你足够细心的话，相信你也发现了：我们上节课刚学的“表达式的思维”，对于我们的不变性思维，也是很有用的。</p><p>好，至此，我们就可以总结出不变性思维的第一条准则：<strong>尽可能使用条件表达式消灭 va</strong>r</p><h2 id="消灭数据类当中的可变性"><a href="#消灭数据类当中的可变性" class="headerlink" title="消灭数据类当中的可变性"></a>消灭数据类当中的可变性</h2><p>在第 2 讲里，我们曾经简单学习过数据类，它是专门用来存放数据的类。它与 Java 当中的“Java Bean”是类似的，它的优势在于简洁。</p><p>不过，我仍然见过有人在 Kotlin 当中写出类似这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> age: <span class="built_in">Int</span>? = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span>: String? &#123;</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setName</span><span class="params">(n: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        name = n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAge</span><span class="params">()</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setAge</span><span class="params">(a: <span class="type">Int</span>?)</span></span> &#123;</span><br><span class="line">        age = a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是明显在用 Java 思维写 Kotlin 代码，有时候，我还能看到这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span>? = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码呢，看起来问题要小一些，但实际上呢，开发者脑子里想的可能是类似 Java 这样的代码模式：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> int age = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，总的来说，大部分 Kotlin 开发者都能写出类似这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(</span><br><span class="line">    <span class="keyword">var</span> name: String?,</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span>?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>但这段代码其实还可以继续优化。我们可以将 var 都改为 val，就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// var -&gt; val</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(</span><br><span class="line">    <span class="keyword">val</span> name: String?, </span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span>?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>而到这里，你可能就会产生一个疑问：<strong>Person 的所有属性都改为 val 以后，万一想要修改它的值该怎么办呢？</strong></p><p>比如说，直接修改它的值的话，这段代码就会报错：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImmutableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 修改Person的name，然后返回Person对象</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">changeUserName</span><span class="params">(person: <span class="type">Person</span>, newName: <span class="type">String</span>)</span></span>: Person &#123;</span><br><span class="line">        person.name = newName <span class="comment">// 报错，val无法修改</span></span><br><span class="line">        <span class="keyword">return</span> person</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一点也是我们要尤为注意的：我们从 Java、C 那边带来的习惯，会促使我们第一时间想到上面这样的解决方案。但实际上，Kotlin 更加推崇我们用下面的方式来解决：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImmutableExample</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">changeUserName</span><span class="params">(person: <span class="type">Person</span>, newName: <span class="type">String</span>)</span></span>: Person =</span><br><span class="line">        person.copy(name = newName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们并没有直接修改参数 person 的值，而是返回了一个新的 person 对象。我们借助数据类的 copy 方法，快速创建了一份拷贝的同时，还完成了对 name 属性的修改。类似这样的代码模式，就可以极大地减少程序出 Bug 的可能。</p><p>那么到这里，我们也就能总结出 Kotlin 不变性思维的第二条准则了：<strong>使用数据类来存储数据，消灭数据类的可变性</strong>。</p><h2 id="集合的不变性"><a href="#集合的不变性" class="headerlink" title="集合的不变性"></a>集合的不变性</h2><p>在 Kotlin 当中，提到不变性，我们就不得不谈它的<strong>集合库</strong>。我们在学习数据结构的时候，都会学到：数组、列表、HashMap、HashSet、栈、队列。这些概念在大部分的编程语言里都会存在，不过 Kotlin 在这方面的设计，却与 Java 之类的语言不太一样。</p><p>以最常见的列表（List）为例：</p><ul><li>在 Java 当中，List 是一个接口，它代表了一个可变的列表，会包含 add()、remove() 方法；</li><li>在 Kotlin 当中，List 也是一个接口，但是它代表了一个不可变的列表，或者说是“只读的列表”。在它的接口当中，是没有 add()、remove() 方法的，当我们想要使用可变列表的时候，必须使用 MutableList。</li></ul><p>关于集合的不变性，我们其实在第 9 讲委托当中就提到了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: MutableList&lt;String&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 网络请求</span></span><br><span class="line">        <span class="keyword">data</span>.add(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> model = Model()</span><br><span class="line">    <span class="comment">// 类的外部仍然可以修改data</span></span><br><span class="line">    model.<span class="keyword">data</span>.add(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们将类内部的集合对象暴露给外部以后，我们其实没办法阻止外部对集合的修改。在第 9 讲当中，我们是通过<strong>属性之间的直接委托</strong>来解决这个问题的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: List&lt;String&gt; <span class="keyword">by</span> ::_data</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _data: MutableList&lt;String&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _data.add(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但其实，要解决这个问题，我们也可以借助其他的方法，比如像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: List&lt;String&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _data <span class="comment">// 自定义get</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _data: MutableList&lt;String&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _data.add(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们为 data 属性自定义了 get() 方法，然后返回了 _data 这个集合的值。这种方式也可以实现目的。</p><p>另外，我们其实还有其他的办法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> <span class="keyword">data</span>: MutableList&lt;String&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">data</span>.add(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">()</span></span>: List&lt;String&gt; = <span class="keyword">data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种解决方案也很简单，我们直接对外暴露了一个方法，把这个方法的返回值类型改成了 List 类型，这样一来，外部访问这个集合以后就无法直接修改了。</p><p>以上这三种方式，本质上都是对外暴露了一个“不可变的集合”，完成了可变性的封装，它们基本上可以满足大部分的使用需求。不过啊，这三种方式其实还是会<strong>存在一定的风险</strong>，那就是外部可以进行类型转换，就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> model = Model()</span><br><span class="line">    println(<span class="string">&quot;Before:<span class="subst">$&#123;model.getData()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = model.getData()</span><br><span class="line">    (<span class="keyword">data</span> <span class="keyword">as</span>? MutableList)?.add(<span class="string">&quot;Some data&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;After:<span class="subst">$&#123;model.getData()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Before:[]</span><br><span class="line">After:[Some <span class="keyword">data</span>]</span><br></pre></td></tr></table></figure><p>针对这种特殊情况，我们可以根据实际情况来决定是否要规避这个问题。其实要解决这个问题的话也很容易，我们只需要借助 Kotlin 提供的 toList 函数，让 data 变成真正的 List 类型即可。</p><p>比如像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> <span class="keyword">data</span>: MutableList&lt;String&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">data</span>.add(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//                                 变化在这里</span></span><br><span class="line">    <span class="comment">//                                    ↓</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">()</span></span>: List&lt;String&gt; = <span class="keyword">data</span>.toList()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改完以后的输出结果</span></span><br><span class="line">Before:[]</span><br><span class="line">After:[]</span><br></pre></td></tr></table></figure><p>这段代码基本上可以帮助我们完成集合可变性的封装，不过在这里，有一点我们需要格外<strong>注意</strong>：当 data 集合数据量很大的时候，toList() 操作可能会比较耗时。</p><p>好了，至此，相信你很快就能总结出第三条准则了：<strong>尽可能对外暴露只读集合</strong>。</p><h2 id="只读集合与-Java"><a href="#只读集合与-Java" class="headerlink" title="只读集合与 Java"></a>只读集合与 Java</h2><p>另外，还有一点需要注意，当只读集合在 Java 代码中被访问的时候，它的不变性将会被破坏，因为 Java 当中不存在“不可变的集合”的概念。比如说，你在 Java 当中，仍然可以调用这个集合的 set() 方法。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; test() &#123;</span><br><span class="line">    Model model = new Model();</span><br><span class="line">    List&lt;String&gt; <span class="keyword">data</span> = model.getData();</span><br><span class="line">    <span class="keyword">data</span>.<span class="keyword">set</span>(<span class="number">0</span>， <span class="string">&quot;Some Data&quot;</span>); <span class="comment">// 抛出异常 UnsupportedOperationException</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，当我们在与 Java 混合编程的时候，Java 里使用 Kotlin 集合的时候一定要足够小心，最好要有详细的文档。就比如说在上面的例子当中，虽然我们可以在 Java 当中调用 set() 方法，但是这行代码最终会抛出异常，引起崩溃。而引起崩溃的原因，是 Kotlin 的 List 最终会变成 Java 当中的“<strong>SingletonList</strong>”，它是 Java 当中的不可变 List，在它的 add()、remove() 方法被调用的时候，会抛出一个异常。</p><p>不得不说，Java 这样的实现方式真的很丑陋。我相信，可能很多 Java 开发者甚至都不知道 Java 居然还有 SingletonList 这个私有的类。并且，只读集合在和 Java 混编的时候，不仅仅只有这一个问题。</p><p>毕竟，当我们尝试修改只读集合的值的时候，Java 可以抛出一个异常的话，那也算是一个可以勉强接受的结局了。</p><p>但实际的情况还会更差，如果我们将代码改成这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model1</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list: List&lt;String&gt; = listOf(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableJava</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; test1() &#123;</span><br><span class="line">        Model1 model = new Model1();</span><br><span class="line">        List&lt;String&gt; <span class="keyword">data</span> = model.getList();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">data</span>.<span class="keyword">get</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">data</span>.<span class="keyword">set</span>(<span class="number">0</span>, <span class="string">&quot;some data&quot;</span>); <span class="comment">// 注意这里</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">data</span>.<span class="keyword">get</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">hello</span><br><span class="line">some <span class="keyword">data</span></span><br></pre></td></tr></table></figure><p>我们在 Java 代码当中调用 data.set() 方法，并没有引起异常，程序也正常执行完毕，并且结果也符合预期。在这种情况下，Kotlin 的 List 被编译器转换成了 java.util.Arrays$ArrayList 类型。因此，我们 Kotlin 当中的只读集合，在 Java 当中就变成了一个普通的可变集合了。</p><p>事实上，对于 Kotlin 的 List 类型来说，在它转换成 Java 字节码以后，可能会变成多种类型，比如前面我们看到的 SingletonList、java.util.Arrays$ArrayList，甚至还可能会变成 java.util.ArrayList。在这里，我们完全不必去深究编译器背后的翻译规则，我们只需要时刻记住，Kotlin 当中的只读集合，在 Java 看来和普通的可变集合是一样的。</p><p>至此，我们就能总结出第四条准则了：<strong>只读集合底层不一定是不可变的，要警惕 Java 代码中的只读集合访问行为</strong>。</p><h2 id="反思：val-一定不可变吗？"><a href="#反思：val-一定不可变吗？" class="headerlink" title="反思：val 一定不可变吗？"></a>反思：val 一定不可变吗？</h2><p>最后，我们再来反思一下 Kotlin 的不变性。通常来说，我们用 val 定义的临时变量，都会将其看做是不可变的，也就是只读变量。但是别忘了，<strong>val 还可以定义成员属性</strong>。而在这种情况下，它意味着：属性 + get 方法。而且，我们还可以自定义 get() 方法。</p><p>所以这时候，我们就要睁大眼睛看清楚它的本质了。比如我们可以来看看下面这段代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> TestVal &#123;</span><br><span class="line">    <span class="keyword">val</span> a: <span class="built_in">Double</span></span><br><span class="line">        <span class="keyword">get</span>() = Random.nextDouble()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testVal</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(a)</span><br><span class="line">        println(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">0.0071073054825220305</span></span><br><span class="line"><span class="number">0.6478886064282862</span></span><br></pre></td></tr></table></figure><p>很明显，在上面的代码中，我们通过自定义 get() 方法，打破了 val 的不变性。我们两次访问属性 a 所得到的值都不一样。对于 val 定义的成员属性，我们得到这样的结果并不会觉得奇怪，上面代码的运行结果也十分符合直觉。</p><p>那么你也许会这样想：我们用 val 定义的<strong>局部变量</strong>，那就一定是不可变的了吧？</p><p>答案仍然是<strong>否定</strong>的！</p><p>我们可以看看下面这个例子，这里我们同样是借助了委托相关的知识点：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomDelegate</span>() : ReadOnlyProperty&lt;Any?, <span class="built_in">Double</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Random.nextDouble()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testLocalVal</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> i: <span class="built_in">Double</span> <span class="keyword">by</span> RandomDelegate()</span><br><span class="line"></span><br><span class="line">    println(i)</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">0.1959507495773669</span></span><br><span class="line"><span class="number">0.5166803777645403</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们定义了一个委托 RandomDelegate，然后把局部变量委托给了这个 RandomDelegate，之后每次访问 i 这个变量，它的值都是不一样的。</p><p>那么，到这里，相信你马上就可以总结出第五条准则了：<strong>val 并不意味着绝对的不可变</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好了，我们来做一个简单的总结吧。所谓 Kotlin 的不变性思维，就是尽可能消灭代码中<strong>非必要</strong>的可变性。具体来说，一共有 5 大准则。</p><ul><li>第一，<strong>尽可能使用条件表达式消灭 var</strong>。由于 Kotlin 当中大部分语句都是表达式，我们可以借助这种思路减少 var 变量的定义。</li><li>第二，<strong>使用数据类来存储数据，消灭数据类的可变性</strong>。我们应该充分发挥 Kotlin 数据类的优势，借助它提供的 copy 方法，我们可以轻松实现不变性。</li><li>第三，<strong>尽可能对外暴露只读集合。根据开放封闭原则，我们的程序应该尽量对修改封闭</strong>。借助 Kotlin 的只读集合，我们在这方面可以做得比 Java 更好。</li><li>第四，<strong>只读集合底层不一定是不可变的，要警惕 Java 代码中的只读集合访问行为。</strong>Kotlin 为了兼容 Java，它的集合类型必须要与 Java 兼容，因此它不能创造出 Java 以外的集合类型，这也就决定了它只能是语法层面的不可变性。Kotlin 官方也在考虑进一步的优化，期待后续的版本能有更加优雅的处理方式。</li><li>第五，<strong>val 并不意味着绝对的不可变</strong>。在 Kotlin 当中定义的 val 变量与属性，它们并非绝对不可变的。由于 Kotlin 的语法十分灵活，我们完全可以用 val 写出可变的局部变量和成员属性。这一点，我们一定要小心。</li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>简单的五个准则，是不可能完全概括出 Kotlin 的不变性思维的。请问你还能想到其他的不变性准则吗？欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)加餐二  什么是“表达式思维”？</title>
      <link href="/posts/11b33035/"/>
      <url>/posts/11b33035/</url>
      
        <content type="html"><![CDATA[<p>在开篇词当中，我曾经说过，学好 Kotlin 的关键在于<code>思维的转变</code>。在上一次加餐课程当中，我给你介绍了 Kotlin 的函数式编程思想，相信你对 Kotlin 的“函数思维”已经有了一定的体会。那么今天这节课，我们就来聊聊 Kotlin 的<code>表达式思维</code>。</p><p>所谓编程思维，其实是一种非常抽象的概念，很多时候是只可意会不可言传的。不过，从某种程度上看，学习编程思维，比学习编程语法还要重要。因为<code>编程思维决定着我们的代码整体的架构与风格</code>，而具体的某个语法反而没那么大的影响力。当然，如果对 Kotlin 的语法没有一个全面的认识，编程思维也只会是空中楼阁。</p><p>所以，准确地来说，掌握 Kotlin 的编程思维，是在掌握了 Kotlin 语法基础上的一次升华。这就好比是，我们学会了基础的汉字以后开始写作文一样。学了汉字以后，如果不懂得写作的技巧，是写不出优美的文章的。同理，如果学了 Kotlin 语法，却没有掌握它的编程思维，也是写不出优雅的 Kotlin 代码的。</p><p>好，那么接下来，我们就来看看 Kotlin 的表达式思维。</p><h2 id="表达式思维"><a href="#表达式思维" class="headerlink" title="表达式思维"></a>表达式思维</h2><p>在正式开始学习表达式思维之前，我们先来看一段简单的 Kotlin 代码。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">data</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    i = <span class="keyword">data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">data</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    j = <span class="keyword">data</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    j = getDefault()</span><br><span class="line">    println(j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">data</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    k = <span class="keyword">data</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> NullPointerException()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line"><span class="keyword">when</span> (<span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; x = <span class="keyword">data</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; x = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    y = <span class="string">&quot;Kotlin&quot;</span>.toInt()</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">    println(e)</span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码，如果我们用 Java 的思维来分析的话，是挑不出太多毛病的。但是站在 Kotlin 的角度，就完全不一样了。</p><p>利用 Kotlin 的语法，我们完全可以将代码写得更加简洁，就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="keyword">data</span> ?: <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> j = <span class="keyword">data</span> ?: getDefault().also &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> k = <span class="keyword">data</span>?: <span class="keyword">throw</span> NullPointerException()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x = <span class="keyword">when</span> (<span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; <span class="keyword">data</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> y = <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="string">&quot;Kotlin&quot;</span>.toInt()</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">    println(e)</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来就简洁了不少，但如果你有 Java 经验，你在写代码的时候，脑子里第一时间想到的一定不是这样的代码模式。这个，也是我们需要格外注意培养表达式思维的原因。</p><p>不过，现在你心里可能已经出现了一个疑问：<code>Kotlin 凭什么就能用这样的方式写代码呢？其实这是因为：if、when、throw、try-catch 这些语法，在 Kotlin 当中都是表达式。</code></p><p>那么，这个“表达式”到底是什么呢？其实，与表达式（Expression）对应的，还有另一个概念，我们叫做语句（Statement）。这两者的准确定义其实很复杂，你可以点击我这里给出的链接去看看它们之间区别。</p><p>不过我们可以先简单来概括一下：<code>表达式，是一段可以产生值的代码；而语句，则是一句不产生值的代码</code>。这样解释还是有些抽象，我们来看一些例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">1</span>    <span class="comment">// statement</span></span><br><span class="line">println(a)   <span class="comment">// statement</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// statement</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">data</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    i = <span class="keyword">data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 + 2 是一个表达式，但是对b的赋值行为是statement</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">1</span> + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if else 整体是一个表达式</span></span><br><span class="line"><span class="comment">// a &gt; b是一个表达式</span></span><br><span class="line"><span class="comment">// a - b是一个表达式</span></span><br><span class="line"><span class="comment">// b - a是一个表达式。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (a &gt; b) a - b <span class="keyword">else</span> b - a</span><br><span class="line"></span><br><span class="line"><span class="comment">// throw NotImplementedError() 是一个表达式</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="keyword">throw</span> NotImplementedError()</span><br></pre></td></tr></table></figure><p>这段代码是描述了常见的 Kotlin 代码模式，从它的注释当中，我们其实可以总结出这样几个规律：</p><ul><li>赋值语句，就是典型的 statement；</li><li>if 语法，既可以作为语句，也可以作为表达式；</li><li>语句与表达式，它们可能会出现在同一行代码中，比如 val b &#x3D; 1 + 2；</li><li>表达式还可能包含“子表达式”，就比如这里的 minus 方法；</li><li>throw 语句，也可以作为表达式。</li></ul><p>但是看到这里，你的心中应该还是有一个疑问没有解开，那就是：<code>calculate() 这个函数难道不会引起编译器报错吗？</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//       函数返回值类型是Int，实际上却抛出了异常，没有返回Int</span></span><br><span class="line"><span class="comment">//                ↓       ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="keyword">throw</span> NotImplementedError()</span><br></pre></td></tr></table></figure><p>确实，在刚开始接触 Kotlin 的时候，我也无法理解这样的代码。直到我弄清楚 Kotlin 整个类型系统以后，我才真正找到答案。</p><p>所以，为了让你能真正理解 Kotlin 表达式背后的原理，接下来，我们就来系统学习一下 Kotlin 的类型系统吧。</p><h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>在课程的第 1 讲我们就学过，在 Kotlin 当中，Any 是所有类型的父类，我们可以称之为<code>根类型</code>。同时，我们也学过，Kotlin 的类型还分为**<code>可空类型</code>**和<code>不可空类型</code>。举个例子，对于字符串类型，就有 String、String?，它们两者分别代表了不为空的字符串、可能为空的字符串。</p><p>在这个基础上，我们很容易就能推测出，Kotlin 的类型体系应该是这样的：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/18/40/1873d04968cd8aca90381b9f84651f40.jpg?wh=2000x979" alt="img" style="zoom:50%;" /><p>也就是，Any 是所有非空类型的根类型；而 Any? 是所有可空类型的根类型。那么现在，你可能会想到这样的一个问题：<code>Any 与 Any? 之间是什么关系呢？</code></p><h2 id="Any-与-Any-与-Object"><a href="#Any-与-Any-与-Object" class="headerlink" title="Any 与 Any? 与 Object"></a>Any 与 Any? 与 Object</h2><p>从表面上看，这两个确实没有继承关系。不过，它们之间其实是存在一些微妙的联系的。</p><p>在 Kotlin 当中，我们可以把“子类型”赋值给“父类型”，就像下面的代码一样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> s: String = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">val</span> any: Any = s</span><br></pre></td></tr></table></figure><p>由于 String 是 Any 的子类型，因此，我们可以将 String 类型赋值给 Any 类型。而实际上，Any 和“Any?”之间也是类似的，我们可以将 Any 类型赋值给“Any？”类型，反之则不行。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a: Any = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">val</span> b: Any? = a <span class="comment">// 通过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c: Any = b  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>类似的，String 类型可以赋值给“String？”类型，反之也不行。你可能会想这是为什么呢？</p><p>其实，<code>任何类型，当它被“?”修饰，变成可空类型以后，它就变成原本类型的父类了。所以，从某种程度上讲，我们可以认为“Any？”是所有 Kotlin 类型的根类型</code>。它的具体关系如下图所示：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/d9/dd/d904d1ed5df67211058yya5098868cdd.jpg?wh=2000x1044" alt="img" style="zoom: 50%;" /><p>因此，我们可以说：虽然 Any 与 Any？之间没有继承的关系，但是我们可以将 Any 看作是 Any？的子类；String 类型可以看作是 String？的子类。</p><p>而由于 Any 与“Any？”之间并没有明确的继承关系，但它们又存在父子类型的关系，所以在上面的示意图中，我们用虚线来表示。</p><p>所以到这里，我们就弄明白了一个问题：<strong>Kotlin 的 Any 与 Java 的 Object 之间是什么关系</strong>？</p><p>那么，答案也是显而易见的，Java 当中的 Object 类型，对应 Kotlin 的“Any？”类型。但两者并<strong>不完全等价</strong>，因为 Kotlin 的 Any 可以没有 wait()、notify() 之类的方法。因此，我们只能说 Kotlin 的“Any？”与 Java 的 Object 是大致对应的。Intellij 有一个功能，可以将 Java 代码转换成 Kotlin 代码，我们可以借此印证。</p><p>这是一段 Java 代码，它有三个方法，分别是可为空的 Object 类型、不可为空的 Object 类型，以及无注解的 Object 类型。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestType</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span>  <span class="comment">// 可空注解</span></span><br><span class="line">    <span class="keyword">public</span> Object test() &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object test1() &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>  <span class="comment">// 不可空注解</span></span><br><span class="line">    <span class="keyword">public</span> Object test2() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码转换成 Kotlin 以后，会变成这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestType</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>: Any? &#123; <span class="keyword">return</span> <span class="literal">null</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">()</span></span>: Any? &#123; <span class="keyword">return</span> <span class="literal">null</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test2</span><span class="params">()</span></span>: Any &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，在没有注解标明可空信息的时候，Object 类型是会被当作“Any？”来看待的。而在有了注解修饰以后，Kotlin 就能够识别出到底是 Any，还是“Any？”。</p><h2 id="Unit-与-Void-与-void"><a href="#Unit-与-Void-与-void" class="headerlink" title="Unit 与 Void 与 void"></a>Unit 与 Void 与 void</h2><p>在 Kotlin 当中，除了普通的 Any、String 的类型之外，还有一个特殊的类型，叫做 <strong>Unit</strong>。而 Unit 这个类型，经常会被拿来和 Java 的 Void、void 来对比。</p><p>那么在这里，你首先需要知道的是：在 Java 当中，Void 和 void 不是一回事（注意大小写），前者是一个 Java 的类，后者是一个用于修饰方法的关键字。如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Void</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> Class&lt;<span class="built_in">Void</span>&gt; TYPE = (Class&lt;<span class="built_in">Void</span>&gt;) Class.getPrimitiveClass(<span class="string">&quot;void&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Void</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从语法含义上来讲，Kotlin 的 Unit 与 Java 的 void 更加接近，但 Unit 远不止于此。在 Kotlin 当中，Unit 也是一个类，这点跟 Void 又有点像。比如，在下面的代码中，Unit 是一个类型的同时，还是一个单例：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">&quot;kotlin.Unit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们就可以用 Unit 写出很灵活的代码。就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">funUnit</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">funUnit1</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123; <span class="keyword">return</span> <span class="built_in">Unit</span> &#125;</span><br></pre></td></tr></table></figure><p>可以看到，当返回值类型是 Unit 的时候，我们既可以选择不写 return，也可以选择 return 一个 Unit 的单例对象。</p><p>另外，在使用泛型编程的时候，当 T 类型作为返回值类型的时候，我们传入 Unit 以后，就不再需要写 return 了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Task</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">excute</span><span class="params">(any: <span class="type">Any</span>)</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintTask</span>: <span class="type">Task</span>&lt;<span class="type">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">excute</span><span class="params">(any: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        println(any)</span><br><span class="line">        <span class="comment">// 这里写不写return都可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更重要的是，Unit 还有助于我们实现函数类型。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> f: () -&gt; <span class="built_in">Unit</span> = &#123;&#125;</span><br></pre></td></tr></table></figure><p>所以，Kotlin 的 Unit 与 Java 的 Void 或者 void 并不存在等价的关系，但它们之间确实存在一些概念上的相似性。至此，我们也可以更新一下前面那个类型系统关系图了：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/74/7f/74e9ea7a804e30bc0e49982ce12f547f.jpg?wh=2000x1036" alt="img" style="zoom:50%;" /><p>可见，Unit 其实和 String 类型一样，就是一个普通的类。只是因为 Kotlin 编译器会特殊对待它，当 Unit 作为返回值类型的时候，可以不需要 return。</p><p>好了，接着，我们再来看看 Kotlin 当中经常被提到的 Nothing 类型。</p><h2 id="Nothing"><a href="#Nothing" class="headerlink" title="Nothing"></a>Nothing</h2><p>在有了前面的基础以后呢，Nothing 就很容易理解了。其实，<strong>Nothing 就是 Kotlin 所有类型的子类型</strong>。</p><p>Nothing 的概念与“Any?”恰好相反。“Any?”是所有的 Kotlin 类型的父类，Nothing 则是所有类型的子类。如果用一张图来概括，大概会是这样的：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/35/3a/35dd00d1acyyd43b7b72dc4cf84d3c3a.jpg?wh=2000x1125" alt="img" style="zoom:50%;" /><p>事实上，像 Nothing 这样的概念，在函数式编程当中，也被叫做<strong>底类型</strong>（Bottom Type），因为它位于整个类型体系的最底部。</p><p>而了解了 Kotlin 的 Nothing 类型以后，我们其实就可以尝试着来解答前面例子中留下来的疑问了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//       函数返回值类型是Int，实际上却抛出了异常，没有返回Int</span></span><br><span class="line"><span class="comment">//                ↓       ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="keyword">throw</span> NotImplementedError() <span class="comment">// 不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       函数返回值类型是Any，实际上却抛出了异常，没有返回Any</span></span><br><span class="line"><span class="comment">//                ↓       ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate1</span><span class="params">()</span></span>: Any = <span class="keyword">throw</span> Exception() <span class="comment">// 不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       函数返回值类型是Unit，实际上却抛出了异常，没有返回Unit</span></span><br><span class="line"><span class="comment">//                 ↓       ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate2</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = <span class="keyword">throw</span> Exception() <span class="comment">// 不会报错</span></span><br></pre></td></tr></table></figure><p>根据这段代码可以发现，不管函数的返回值类型是什么，我们都可以使用抛出异常的方式来实现它的功能。这样我们其实就可以推测出一个结论：<strong>throw 这个表达式的返回值是 Nothing 类型</strong>。而既然 Nothing 是所有类型的子类型，那么它当然是可以赋值给任意其他类型的。</p><p>可是，我们如何才能印证这个结论是否正确呢？很简单，我们可以把两个函数的返回值类型都改成 Nothing，然后看看编译器会不会报错：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">()</span></span>: <span class="built_in">Nothing</span> = <span class="keyword">throw</span> NotImplementedError() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate1</span><span class="params">()</span></span>: <span class="built_in">Nothing</span> = <span class="keyword">throw</span> Exception() </span><br><span class="line"></span><br><span class="line"><span class="comment">// Nothing构造函数是私有的，因此我们无法构造它的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Nothing</span> <span class="keyword">private</span> <span class="keyword">constructor</span>()</span><br></pre></td></tr></table></figure><p>可见，编译器仍然不会报错。这也就印证了我们前面的猜测：throw 表达式的返回值类型是 Nothing。</p><p>另外，我们应该也注意到了 Nothing 类的构造函数是私有的，因此我们无法构造出它的实例。而当 Nothing 类型作为函数参数的时候，一个有趣的现象就出现了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个无法调用的函数，因为找不到合适的参数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">(msg: <span class="type">Nothing</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show(<span class="literal">null</span>) <span class="comment">// 报错</span></span><br><span class="line">show(<span class="keyword">throw</span> Exception()) <span class="comment">// 虽然不报错，但方法仍然不会调用</span></span><br></pre></td></tr></table></figure><p>这里我们定义的这个 show 方法，它的参数类型是 Nothing，而由于 Nothing 的构造函数是私有的，这就导致我们将无法调用 show 这个函数，除非我们抛出异常，但这没有意义。这个概念在泛型星投影的时候是有应用的，具体你可以点击这个链接去<a href="https://kotlinlang.org/docs/generics.html#star-projections">查看详情</a>。</p><p>而除此之外，Nothing 还有助于编译器进行代码流程的推断。比如说，当一个表达式的返回值是 Nothing 的时候，就往往意味着它后面的语句不再有机会被执行。如下图所示：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/33/5a/3365f67ab5f828ef23af65484d317a5a.png?wh=676x371" alt="img" style="zoom: 67%;" /><p>在了解了 Unit 与 Nothing 这两个不可空的类型以后，我们再来看看它们对应的可空类型。</p><h2 id="Unit-与-Nothing"><a href="#Unit-与-Nothing" class="headerlink" title="Unit? 与 Nothing?"></a>Unit? 与 Nothing?</h2><p>也许你也注意到了，Unit 对应的还有一个“Unit?”类型，那么这个类型有什么意义吗？</p><p>我们可以看看下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span>: <span class="built_in">Unit</span>? &#123; <span class="keyword">return</span> <span class="literal">null</span> &#125; <span class="comment">// 通过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">f2</span><span class="params">()</span></span>: <span class="built_in">Unit</span>? &#123; <span class="keyword">return</span> <span class="built_in">Unit</span> &#125; <span class="comment">// 通过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">f3</span><span class="params">()</span></span>: <span class="built_in">Unit</span>? &#123; <span class="keyword">throw</span> Exception() &#125; <span class="comment">// 通过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">f4</span><span class="params">()</span></span>: <span class="built_in">Unit</span>? &#123; &#125; <span class="comment">// 报错，缺少return</span></span><br></pre></td></tr></table></figure><p>可见，Kotlin 编译器只会把 Unit 类型当作无需返回值的类型，而 Unit? 则不行。</p><p>所以，Unit? 这个类型其实没有什么广泛的应用场景，因为它失去了原本的编译器特权后，就只能有 3 种实现方式，即 null、Unit 单例、Nothing。也就是说，当 Unit? 作为返回值的时候，我们的函数必须要 return 一个值了，它返回值的类型可以是 null、Unit 单例、Nothing 这三种情况。</p><p>好，接下来我们再来看看“Nothing?”这个类型。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate1</span><span class="params">()</span></span>: <span class="built_in">Nothing</span>? = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate2</span><span class="params">()</span></span>: <span class="built_in">Nothing</span>? = <span class="keyword">throw</span> Exception()</span><br></pre></td></tr></table></figure><p>由以上代码示例可知，当 Nothing? 作为返回值类型的时候，我们可以返回 null，或者是抛出异常。这一切都符合预期，而当它作为函数参数的时候，也会有一些有趣的变化。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//               变化在这里</span></span><br><span class="line"><span class="comment">//                   ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">(msg: <span class="type">Nothing</span>?)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show(<span class="literal">null</span>) <span class="comment">// 通过</span></span><br><span class="line">show(<span class="keyword">throw</span> Exception()) <span class="comment">// 虽然不报错，但方法仍然不会调用</span></span><br></pre></td></tr></table></figure><p>可以看到，当参数类型是 Nothing? 的时候，我们的函数仍然是可以调用的。这其实就能进一步说明一个问题：<strong>Nothing 才是底类型，而“Nothing?”则不是底类型</strong>。</p><p>这一点其实在前面的类型关系图中就有体现，现在你就可以真正理解了：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/35/3a/35dd00d1acyyd43b7b72dc4cf84d3c3a.jpg?wh=2000x1125" alt="img" style="zoom: 50%;" /><p>到这里相信你也明白了，“Unit?”“Nothing?”这两个类型，其实并没有太多实际的应用场景，不过由于它们是 Kotlin 类型系统当中特殊的类型，因此我们也应该对它们有个清晰的认识。</p><p>这样，在系统学习了 Kotlin 的类型系统以后，我们对表达式理解就可以更上一层楼了。</p><h2 id="表达式的本质"><a href="#表达式的本质" class="headerlink" title="表达式的本质"></a>表达式的本质</h2><p>我们再来看看表达式的定义：<strong>表达式，是一段可以产生值的代码；而语句，则是一句不产生值的代码</strong>。</p><p>也许你听说过这样一句话：在 Kotlin 当中，一切都是表达式。<strong>注意！这句话其实是错的</strong>。因为 Kotlin 当中还是存在语句的，比如 while 循环、for 循环，等等。</p><p>不过，如果我们换个说法：<strong>在 Kotlin 当中，大部分代码都是表达式</strong>。这句话就对了。Kotlin 的类型系统当中的 Unit 和 Nothing，让很多原本无法产生返回值的语句，变成了表达式。</p><p>我们来举个例子:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// statement</span></span><br><span class="line">println(<span class="string">&quot;Hello World.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// println(&quot;Hello World.&quot;) 变成了表达式</span></span><br><span class="line"><span class="keyword">val</span> a = println(<span class="string">&quot;Hello World.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// statement</span></span><br><span class="line"><span class="keyword">throw</span> Exception()</span><br><span class="line"></span><br><span class="line"><span class="comment">// throw 变成了表达式</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">()</span></span> = <span class="keyword">throw</span> Exception() </span><br></pre></td></tr></table></figure><p>从上面的代码案例中，我们可以总结出两个规律。</p><ul><li>由于 Kotlin 存在 Unit 这个类型，因此 println(“Hello World.”) 这行代码也可以变成表达式，它所产生的值就是 Unit 这个单例。</li><li>由于 Kotlin 存在 Nothing 这个类型，因此 throw 也可以作为表达式，它所产生的值就是 Nothing 类型。</li></ul><p>注意，因为 Java 当中不存在 Unit、Nothing 这样的类型，所以 Java 里返回值为 void 的函数是无法成为表达式的，另外，throw 这样的语句也是无法成为表达式的。而也正是因为 Kotlin 这样的类型系统，才让大部分的语句都摇身一变成为了表达式。因为 Unit、Nothing 在 Kotlin 编译器看来，也是所有类型当中的一种。</p><p>可以说，Unit 和 Nothing 填补了原本 Java 当中的类型系统，让 Kotlin 的类型系统更加全面。也正因为如此，Kotlin 才可以拥有真正的函数类型，比如：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> f: (String) -&gt; <span class="built_in">Unit</span> = ::println</span><br></pre></td></tr></table></figure><p>可以看到，如果不存在 Unit 这个类型，我们是无法描述 println 这个函数的类型的。正因为 println 函数的返回值类型为 Unit，我们才可以用“(String) -&gt; Unit”来描述它。</p><p>换句话说就是：<strong>Kotlin 的类型系统让大部分的语句都变成了表达式，同时也让无返回值的函数有了类型</strong>。</p><p>而所谓的表达式思维，其实就是要求我们开发者在编程的时候，<strong>时刻记住 Kotlin 大部分的语句都是可以作为表达式的</strong>，并且由于表达式都是有返回值的，这也就让我们可以用一种全新的思维来写代码。这在很多时候，都可以大大简化我们的代码逻辑。</p><p>那么现在，我们再回过头看之前的代码，就会觉得很顺眼了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> i = <span class="keyword">data</span> ?: <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> j = <span class="keyword">data</span> ?: getDefault().also &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> k = <span class="keyword">data</span>?: <span class="keyword">throw</span> NullPointerException()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x = <span class="keyword">when</span> (<span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; <span class="keyword">data</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> y = <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="string">&quot;Kotlin&quot;</span>.toInt()</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好，今天这节加餐，到这里就接近尾声了，我们来做个简单的总结。</p><ul><li>所谓的表达式思维，就是要时刻记住：Kotlin 大部分的语句都是表达式，它是可以产生返回值的。利用这种思维，往往可以大大简化代码逻辑。</li><li>Any 是所有非空类型的根类型，而“Any?”才是所有类型的<strong>根类型</strong>。</li><li>Unit 与 Java 的 void 类型，代表一个函数不需要返回值；而“Unit?”这个类型则没有太多实际的意义。</li><li>当 Nothing 作为函数返回值的时候，意味着这个函数永远不会返回结果，而且还会截断程序的后续流程。Kotlin 编译器也会根据这一点，进行流程分析。</li><li>当 Nothing 作为函数参数的时候，就意味着这个函数永远无法被正常调用。这在泛型星投影的时候是有一定应用的。</li><li>另外，Nothing 可以看作是“Nothing?”子类型，因此，Nothing 可以看作是 Kotlin 所有类型的<strong>底类型</strong>。</li><li>正是因为 Kotlin 在类型系统当中，加入了 Unit、Nothing 这两个类型，才让大部分无法产生值的语句摇身一变，成为了表达式。这也是“Kotlin 大部分的语句都是表达式”的根本原因。</li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>这节课，我们学习了表达式思维，请问，你觉得它和我们前面学到的“函数式编程”有联系吗？为什么？欢迎在留言区分享你的答案和思考，也欢迎你把今天的内容分享给更多的朋友。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)12  实战：用Kotlin实现一个网络请求框架KtHttp</title>
      <link href="/posts/e45ff726/"/>
      <url>/posts/e45ff726/</url>
      
        <content type="html"><![CDATA[<p>在前面几节课当中，我们一起学习了 Kotlin 的委托、泛型、注解、反射这几个高级特性。那么今天这节课，我们将会运用这些特性，来写一个 <strong>Kotlin 版本的 HTTP 网络请求框架</strong>。由于它是纯 Kotlin 开发的，我们就把它叫做是 KtHttp 吧。</p><p>事实上，在 Java 和 Kotlin 领域，有许多出色的网络请求框架，比如 <a href="https://github.com/square/okhttp">OkHttp</a>、<a href="https://github.com/square/Retrofit">Retrofit</a>、<a href="https://github.com/kittinunf/fuel">Fuel</a>。而我们今天要实现的 KtHttp，它的灵感来自于 Retrofit。之所以选择 Retrofit 作为借鉴的对象，是因为它的底层使用了大量的泛型、注解和反射的技术。如果你能跟着我一起用泛型、注解、反射来实现一个简单的网络请求框架，相信你对这几个知识点的认识也会更加透彻。</p><p>在这节课当中，我会带你从 0 开始实现这个网络请求框架。和往常一样，为了方便你理解，我们的代码会分为两个版本：</p><ul><li>1.0 版本，我们会用 Java 思维，以最简单直白的方式来实现 KtHttp 的基础功能——同步式的 GET 网络请求；</li><li>2.0 版本，我们会用函数式思维来重构代码。</li></ul><p>另外，在正式开始学习之前，我也建议你去 clone 我 GitHub 上面的 KtHttp 工程：<a href="https://github.com/chaxiu/KtHttp.git%EF%BC%8C%E7%84%B6%E5%90%8E%E7%94%A8">https://github.com/chaxiu/KtHttp.git，然后用</a> IntelliJ 打开，并切换到 start 分支跟着课程一步步敲代码。</p><h2 id="1-0：Java-思维"><a href="#1-0：Java-思维" class="headerlink" title="1.0：Java 思维"></a>1.0：Java 思维</h2><p>在正式开始之前，我们还是先来看看程序的运行效果：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/32/bc/321d151db077766997ed8d8b911f1fbc.gif?wh=1294x862" alt="img" style="zoom:50%;" /><p>在上面的动图中，我们通过 KtHttp 请求了一个服务器的 API，然后在控制台输出了结果。这其实是我们在开发工作当中十分常见的需求。通过这个 KtHttp，我们就可以在程序当中访问任何服务器的 API，比如<a href="https://docs.github.com/en">GitHub 的 API</a>。</p><p>那么，为了描述服务器返回的内容，我们定义了两个数据类：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这种写法是有问题的，但这节课我们先不管。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">RepoList</span>(</span><br><span class="line">    <span class="keyword">var</span> count: <span class="built_in">Int</span>?,</span><br><span class="line">    <span class="keyword">var</span> items: List&lt;Repo&gt;?,</span><br><span class="line">    <span class="keyword">var</span> msg: String?</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Repo</span>(</span><br><span class="line">    <span class="keyword">var</span> added_stars: String?,</span><br><span class="line">    <span class="keyword">var</span> avatars: List&lt;String&gt;?,</span><br><span class="line">    <span class="keyword">var</span> desc: String?,</span><br><span class="line">    <span class="keyword">var</span> forks: String?,</span><br><span class="line">    <span class="keyword">var</span> lang: String?,</span><br><span class="line">    <span class="keyword">var</span> repo: String?,</span><br><span class="line">    <span class="keyword">var</span> repo_link: String?,</span><br><span class="line">    <span class="keyword">var</span> stars: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>除了数据类以外，我们还要定义一个用于网络请求的接口：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: RepoList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个接口当中，有两个注解，我们一个个分析：</p><ul><li><strong>GET 注解</strong>，代表了这个网络请求应该是 GET 请求，这是HTTP请求的一种方式。GET 注解当中的“&#x2F;repo”，代表了 API 的 path，它是和 baseURL 拼接的；</li><li><strong>Field 注解</strong>，代表了 GET 请求的参数。Field 注解当中的值也会和 URL 拼接在一起。</li></ul><p>也许你会好奇，<strong>GET、Field 这两个注解是从哪里来的呢？</strong>这其实也是需要我们自己定义的。根据上节课学过的内容，我们很容易就能写出下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.FUNCTION)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">GET</span>(<span class="keyword">val</span> value: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.VALUE_PARAMETER)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Field</span>(<span class="keyword">val</span> value: String)</span><br></pre></td></tr></table></figure><p>从这段代码里我们可以看出，GET 注解只能用于修饰函数，Field 注解只能用于修饰参数。另外，这两个注解的 Retention 都是 AnnotationRetention.RUNTIME，这意味着这两个注解都是运行时可访问的。而这，也正好是我们后面要使用的反射的前提。</p><p>最后，我们再来看看 KtHttp 是如何使用的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">val</span> api: ApiService = KtHttpV1.create(ApiService::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: RepoList = api.repos(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码有两个注释，我们分别来看。</p><ul><li>注释①：我们调用 KtHttpV1.create() 方法，传入了 ApiService::class.java，参数的类型是Class，返回值类型是 ApiService。这就相当于创建了 ApiService 这个接口的实现类的对象。</li><li>注释②：我们调用 api.repos() 这个方法，传入了 Kotlin、weekly 这两个参数，代表我们想查询最近一周最热门的 Kotlin 开源项目。</li></ul><p>看到这里，你也许会好奇，KtHttpV1.create() 是如何创建 ApiService 的实例的呢？要知道 ApiService 可是一个接口，我们要创建它的对象，必须要先定义一个类实现它的接口方法，然后再用这个类来创建对象才行。</p><p>不过在这里，我们不会使用这种传统的方式，而是会用动态代理，也就是 JDK 的<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html">Proxy</a>。Proxy 的底层，其实也用到了反射。</p><p>不过，由于这个案例涉及到的知识点都很抽象，在正式开始编写逻辑代码之前，我们先来看看下面这个动图，对整体的程序有一个粗略的认识。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/cf/95/cf441d3df1bb4b49432319e160cd3c95.gif?wh=1080x608" alt="img" style="zoom:67%;" /><p>现在，相信你大概就知道这个程序是如何实现的了。下面，我再带你来看看具体的代码是怎么写的。</p><p>这里我要先说明一点，为了不偏离这次实战课的主题，我们不会去深究 Proxy 的底层原理。在这里，<strong>你只需要知道，我们通过 Proxy，就可以动态地创建 ApiService 接口的实例化对象</strong>。具体的做法如下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">create</span><span class="params">(service: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Proxy.newProxyInstance 就可以创建接口的实例化对象</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">        service.classLoader,</span><br><span class="line">        arrayOf&lt;Class&lt;*&gt;&gt;(service),</span><br><span class="line">        <span class="keyword">object</span> : InvocationHandler&#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(proxy: <span class="type">Any</span>?, method: <span class="type">Method</span>?, args: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;?)</span></span>: Any &#123;</span><br><span class="line">                <span class="comment">// 省略</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ) <span class="keyword">as</span> T</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>在上面的代码当中，我们在 create() 方法当中，直接返回了 Proxy.newProxyInstance() 这个方法的返回值，最后再将其转换成了 T 类型。</p><p>那么，newProxyInstance() 这个方法又是如何定义的呢？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                          InvocationHandler h)&#123; </span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">        throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码当中，我们可以看到，最后一个参数，InvocationHandler 其实是符合 SAM 转换要求的，所以我们的 create() 方法可以进一步简化成这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">create</span><span class="params">(service: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">        service.classLoader,</span><br><span class="line">        arrayOf&lt;Class&lt;*&gt;&gt;(service)</span><br><span class="line">    ) &#123; proxy, method, args -&gt;</span><br><span class="line">        <span class="comment">// 待完成</span></span><br><span class="line">    &#125; <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么到这里，我们程序的基本框架也就搭建好了。</p><p>细心的你一定发现了，我们<strong>程序的主要逻辑还没实现</strong>，所以接下来，我们就一起看看上面那个“待完成”的 InvocationHandler，这个 Lambda 表达式应该怎么写。这个换句话说，也就是 Proxy.newProxyInstance()，会帮我们创建 ApiService 的实例对象，而 ApiService 当中的接口方法的具体逻辑，我们需要在 Lambda 表达式当中实现。</p><p>好了，让我们回过头来看看 ApiService 当中的代码细节：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiService</span> &#123;</span><br><span class="line"><span class="comment">// 假设我们的baseurl是：https://baseurl.com</span></span><br><span class="line"><span class="comment">// 这里拼接结果会是这样：https://baseurl.com/repo</span></span><br><span class="line"><span class="comment">//          ↓</span></span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//                Field注解当中的lang，最终会拼接到url当中去</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//            ↓                                                 ↓</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,  <span class="comment">// https://baseurl.com/repo?lang=Kotlin</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span> <span class="comment">// https://baseurl.com/repo?lang=Kotlin&amp;since=weekly</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: RepoList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码注释中可以看出来，其实我们真正需要实现的逻辑，就是想办法把注解当中的值 &#x2F;repo、lang、since 取出来，然后拼接到 URL 当中去。那么，我们如何才能得到注解当中的值呢？</p><p>答案自然就是我们在上节课学过的：<strong>反射</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> KtHttpV1 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底层使用 OkHttp</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> okHttpClient: OkHttpClient = OkHttpClient()</span><br><span class="line">    <span class="comment">// 使用 Gson 解析 JSON</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> gson: Gson = Gson()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里以baseurl.com为例，实际上我们的KtHttpV1可以请求任意API</span></span><br><span class="line">    <span class="keyword">var</span> baseUrl = <span class="string">&quot;https://baseurl.com&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">create</span><span class="params">(service: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            service.classLoader,</span><br><span class="line">            arrayOf&lt;Class&lt;*&gt;&gt;(service)</span><br><span class="line">        <span class="comment">//           ①     ②</span></span><br><span class="line">        <span class="comment">//           ↓      ↓</span></span><br><span class="line">        ) &#123; proxy, method, args -&gt;</span><br><span class="line">            <span class="comment">// ③</span></span><br><span class="line">            <span class="keyword">val</span> annotations = method.annotations</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">annotation</span> <span class="keyword">in</span> annotations) &#123;</span><br><span class="line">                <span class="comment">// ④</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">annotation</span> <span class="keyword">is</span> GET) &#123;</span><br><span class="line">                    <span class="comment">// ⑤</span></span><br><span class="line">                    <span class="keyword">val</span> url = baseUrl + <span class="keyword">annotation</span>.value</span><br><span class="line">                    <span class="comment">// ⑥</span></span><br><span class="line">                    <span class="keyword">return</span><span class="symbol">@newProxyInstance</span> invoke(url, method, args!!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@newProxyInstance</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(url: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">// 待完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，一共有 6 个注释，我们一个个看。</p><ul><li>注释①：method 的类型是反射后的 Method，在我们这个例子当中，它最终会代表被调用的方法，也就是 ApiService 接口里面的 repos() 这个方法。</li><li>注释②：args 的类型是对象的数组，在我们的例子当中，它最终会代表方法的参数的值，也就是“api.repos(“Kotlin”, “weekly”)”当中的”Kotlin”和”weekly”。</li><li>注释③：method.annotations，代表了我们会取出 repos() 这个方法上面的所有注解，由于 repos() 这个方法上面可能会有多个注解，因此它是数组类型。</li><li>注释④：我们使用 for 循环，遍历所有的注解，找到 GET 注解。</li><li>注释⑤：我们找到 GET 注解以后，要取出 @GET(“&#x2F;repo”) 当中的”&#x2F;repo”，也就是“annotation.value”。这时候我们只需要用它与 baseURL 进行拼接，就可以得到完整的 URL；</li><li>注释⑥：return@newProxyInstance，用的是 Lambda 表达式当中的返回语法，在得到完整的 URL 以后，我们将剩下的逻辑都交给了 invoke() 这个方法。</li></ul><p>接下来，我们再来看看 invoke() 当中的“待完成代码”应该怎么写。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(url: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// ① 根据url拼接参数，也就是：url + ?lang=Kotlin&amp;since=weekly</span></span><br><span class="line">    <span class="comment">// ② 使用okHttpClient进行网络请求</span></span><br><span class="line">    <span class="comment">// ③ 使用gson进行JSON解析</span></span><br><span class="line">    <span class="comment">// ④ 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们的 invoke() 方法一共分成了四个步骤，其中的③、④两个步骤其实很容易实现：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(url: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// ① 根据url拼接参数，也就是：url + ?lang=Kotlin&amp;since=weekly</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用okHttpClient进行网络请求</span></span><br><span class="line">    <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">            .url(url)</span><br><span class="line">            .build()</span><br><span class="line">    <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ② 获取repos()的返回值类型 genericReturnType</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用gson进行JSON解析</span></span><br><span class="line">    <span class="keyword">val</span> body = response.body</span><br><span class="line">    <span class="keyword">val</span> json = body?.string()</span><br><span class="line">    <span class="comment">//                              根据repos()的返回值类型解析JSON</span></span><br><span class="line">    <span class="comment">//                                            ↓</span></span><br><span class="line">    <span class="keyword">val</span> result = gson.fromJson&lt;Any?&gt;(json, genericReturnType)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看，经过我们的分解，现在的问题变成了下面这样：</p><ul><li>注释①，利用反射，解析出“api.repos(“Kotlin”, “weekly”)”这个方法当中的”Kotlin”和”weekly”，将其与 URL 进行拼接得到：url + ?lang&#x3D;Kotlin&amp;since&#x3D;weekly</li><li>注释②，利用反射，解析出 repos() 的返回值类型，用于 JSON 解析。</li></ul><p>我们来看看最终的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// 条件判断</span></span><br><span class="line">    <span class="keyword">if</span> (method.parameterAnnotations.size != args.size) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析完整的url</span></span><br><span class="line">    <span class="keyword">var</span> url = path</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">val</span> parameterAnnotations = method.parameterAnnotations</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> parameterAnnotations.indices) &#123;</span><br><span class="line">        <span class="keyword">for</span> (parameterAnnotation <span class="keyword">in</span> parameterAnnotations[i]) &#123;</span><br><span class="line">            <span class="comment">// ②</span></span><br><span class="line">            <span class="keyword">if</span> (parameterAnnotation <span class="keyword">is</span> Field) &#123;</span><br><span class="line">                <span class="keyword">val</span> key = parameterAnnotation.value</span><br><span class="line">                <span class="keyword">val</span> value = args[i].toString()</span><br><span class="line">                <span class="keyword">if</span> (!url.contains(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// ③</span></span><br><span class="line">                    url += <span class="string">&quot;?<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// ④</span></span><br><span class="line">                    url += <span class="string">&quot;&amp;<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终的url会是这样：</span></span><br><span class="line">    <span class="comment">// https://baseurl.com/repo?lang=Kotlin&amp;since=weekly</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行网络请求</span></span><br><span class="line">    <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">        .url(url)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⑤</span></span><br><span class="line">    <span class="keyword">val</span> genericReturnType = method.genericReturnType</span><br><span class="line">    <span class="keyword">val</span> body = response.body</span><br><span class="line">    <span class="keyword">val</span> json = body?.string()</span><br><span class="line">    <span class="comment">// JSON解析</span></span><br><span class="line">    <span class="keyword">val</span> result = gson.fromJson&lt;Any?&gt;(json, genericReturnType)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码一共涉及五个注释，它们都是跟注解与反射这两个知识点相关的。</p><ul><li>注释①，method.parameterAnnotations，它的作用是取出方法参数当中的所有注解，在我们这个案例当中，repos() 这个方法当中涉及到两个注解，它们分别是@Field(“lang”)、@Field(“since”)。</li><li>注释②，由于方法当中可能存在其他注解，因此要筛选出我们想要的 Field 注解。</li><li>注释③，这里是取出注解当中的值“lang”，以及参数当中对应的值“Kotlin”进行拼接，URL 第一次拼接参数的时候，要用“?”分隔。</li><li>注释④，这里是取出注解当中的值“since”，以及参数当中对应的值“weekly”进行拼接，后面的参数拼接格式，是用“&amp;”分隔。</li><li>注释⑤，method.genericReturnType 取出 repos() 的返回值类型，也就是 RepoList，最终，我们用它来解析 JSON。</li></ul><p>说实话，动态代理的这种模式，由于它大量应用了反射，加之我们的代码当中还牵涉到了泛型和注解，导致这个案例的代码不是那么容易理解。不过，我们其实可以利用<strong>调试</strong>的手段，去查看代码当中每一步执行的结果，这样就能对注解、反射、动态代理有一个更具体的认识。</p><p>前面带你看过的这个动图，其实就是在向你展示代码在调试过程中的关键节点，我们可以再来回顾一下整个代码的执行流程：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/cf/95/cf441d3df1bb4b49432319e160cd3c95.gif?wh=1080x608" alt="img" style="zoom:50%;" /><p>相信现在，你已经能够体会我们使用 <strong>动态代理 + 注解 + 反射</strong> 实现这个网络请求框架的原因了。通过这样的方式，我们就不必在代码当中去实现每一个接口，而是只要是符合这样的代码模式，任意的接口和方法，我们都可以直接传进去。在这个例子当中，我们用的是 ApiService 这个接口，如果下次我们定义了另一个接口，比如说：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GitHubService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/search&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">search</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;id&quot;</span>)</span> id: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，我们的 KtHttp 根本不需要做任何的改动，直接这样调用即可：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    KtHttpV1.baseUrl = <span class="string">&quot;https://api.github.com&quot;</span></span><br><span class="line">    <span class="comment">//       换一个接口名即可                  换一个接口名即可</span></span><br><span class="line">    <span class="comment">//              ↓                             ↓                </span></span><br><span class="line">    <span class="keyword">val</span> api: GitHubService = KtHttpV1.create(GitHubService::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: User = api.search(id = <span class="string">&quot;JetBrains&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，使用动态代理实现网络请求的优势，它的<strong>灵活性</strong>是非常好的。只要我们定义的 Service 接口拥有对应的注解 GET、Field，我们就可以通过注解与反射，将这些信息拼凑在一起。下面这个动图就展示了它们整体的流程：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/8b/31/8b5997dc2f036020dc16a1a5efb8c531.gif?wh=1080x608" alt="img" style="zoom:50%;" /><p>实际上，我们的 KtHttp，就是将 URL 的信息存储在了注解当中（比如 lang 和 since），而实际的参数值，是在函数调用的时候传进来的（比如 Kotlin 和 weekly）。我们通过泛型、注解、反射的结合，将这些信息集到一起，完成整个 URL 的拼接，最后才通过 OkHttp 完成的网络请求、Gson 完成的解析。</p><p>好，到这里，我们 1.0 版本的开发就算是完成了。这里的单元测试代码很容易写，我就不贴出来了，<strong>单元测试是个好习惯</strong>，我们不能忘。</p><p>接下来，我们正式进入 2.0 版本的开发。</p><h2 id="2-0：函数式思维"><a href="#2-0：函数式思维" class="headerlink" title="2.0：函数式思维"></a>2.0：函数式思维</h2><p>其实，如果你理解了 1.0 版本的代码，2.0 版本的程序也就不难实现了。因为这个程序的主要功能都已经完成了，现在要做的只是：<strong>换一种思路重构代码</strong>。</p><p>我们先来看看 KtHttpV1 这个单例的成员变量：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> KtHttpV1 &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> okHttpClient: OkHttpClient = OkHttpClient()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> gson: Gson = Gson()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">create</span><span class="params">(service: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(url: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>okHttpClient、gson 这两个成员是不支持懒加载的，因此我们首先应该让它们<strong>支持懒加载</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> KtHttpV2 &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> okHttpClient <span class="keyword">by</span> lazy &#123; OkHttpClient() &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> gson <span class="keyword">by</span> lazy &#123; Gson() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">create</span><span class="params">(service: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(url: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们直接使用了 by lazy 委托的方式，它简洁的语法可以让我们快速实现懒加载。</p><p>接下来，我们再来看看 create() 这个方法的定义：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                      注意这里</span></span><br><span class="line"><span class="comment">//                         ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">create</span><span class="params">(service: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">        service.classLoader,</span><br><span class="line">        arrayOf&lt;Class&lt;*&gt;&gt;(service)</span><br><span class="line">    ) &#123; proxy, method, args -&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，create() 会接收一个Class类型的参数。其实，针对这样的情况，我们完全可以省略掉这个参数。具体做法，是使用我们前面学过的inline，来实现<strong>类型实化</strong>（Reified Type）。我们常说，Java 的泛型是伪泛型，而这里我们要实现的就是真泛型。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  注意这两个关键字</span></span><br><span class="line"><span class="comment">//  ↓          ↓</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">create</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">        T::<span class="keyword">class</span>.java.classLoader, <span class="comment">// ① 变化在这里</span></span><br><span class="line">        arrayOf(T::<span class="keyword">class</span>.java) <span class="comment">// ② 变化在这里</span></span><br><span class="line">    ) &#123; proxy, method, args -&gt;</span><br><span class="line">        <span class="comment">// 待重构</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，泛型参数<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">类型会被擦除</a>，这就是 Java 的泛型被称为“伪泛型”的原因。而通过使用 <strong>inline</strong> 和 <strong>reified</strong> 这两个关键字，我们就能实现类型实化，也就是“真泛型”，进一步，我们就可以在代码注释①、②的地方，使用“T::class.java”来得到 Class 对象。</p><p>下面，我们来看看 KtHttp 的主要逻辑该如何重构。</p><p>为了方便理解，我们会使用 Kotlin 标准库当中已有的高阶函数，尽量不去涉及函数式编程里的高级概念。在这里我强烈建议你打开 <strong>IDE 一边敲代码一边阅读</strong>，这样一来，当你遇到不熟悉的标准函数时，就可以随时去看它的实现源码了。相信在学习过第 7 讲的高阶函数以后，这些库函数都不会难倒你。</p><p>首先，我们来看看 create() 里面“待重构”的代码该如何写。在这个方法当中，我们需要读取 method 当中的 GET 注解，解析出它的值，然后与 baseURL 拼接。这里我们完全可以<strong>借助 Kotlin 的标准库函数</strong>来实现：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">create</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">        T::<span class="keyword">class</span>.java.classLoader,</span><br><span class="line">        arrayOf(T::<span class="keyword">class</span>.java)</span><br><span class="line">    ) &#123; proxy, method, args -&gt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@newProxyInstance</span> method.annotations</span><br><span class="line">            .filterIsInstance&lt;GET&gt;()</span><br><span class="line">            .takeIf &#123; it.size == <span class="number">1</span> &#125;</span><br><span class="line">            ?.let &#123; invoke(<span class="string">&quot;<span class="variable">$baseUrl</span><span class="subst">$&#123;it[<span class="number">0</span>].value&#125;</span>&quot;</span>, method, args) &#125;</span><br><span class="line">    &#125; <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的可读性很好，我们可以像读英语文本一样来阅读：</p><ul><li>首先，我们通过 method.annotations，来获取 method 的所有注解；</li><li>接着，我们用filterIsInstance()，来筛选出我们想要找的 GET 注解。这里的 filterIsInstance 其实是 filter 的升级版，也就是过滤的意思；</li><li>之后，我们判断 GET 注解的数量，它的数量必须是 1，其他的都不行，这里的 takeIf 其实相当于我们的 if；</li><li>最后，我们通过拼接出 URL，然后将程序执行流程交给 invoke() 方法。这里的”?.let{}”相当于判空。</li></ul><p>好了，create() 方法的重构已经完成，接下来我们来看看 invoke() 方法该如何重构。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(url: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? =</span><br><span class="line">    method.parameterAnnotations</span><br><span class="line">        .takeIf &#123; method.parameterAnnotations.size == args.size &#125;</span><br><span class="line">        ?.mapIndexed &#123; index, it -&gt; Pair(it, args[index]) &#125;</span><br><span class="line">        ?.fold(url, ::parseUrl)</span><br><span class="line">        ?.let &#123; Request.Builder().url(it).build() &#125;</span><br><span class="line">        ?.let &#123; okHttpClient.newCall(it).execute().body?.string() &#125;</span><br><span class="line">        ?.let &#123; gson.fromJson(it, method.genericReturnType) &#125;</span><br></pre></td></tr></table></figure><p>这段代码读起来也不难，我们一行一行来分析。</p><ul><li>第一步，我们通过 method.parameterAnnotations，获取方法当中所有的参数注解，在这里也就是@Field(“lang”)、@Field(“since”)。</li><li>第二步，我们通过 takeIf 来判断，参数注解数组的数量与参数的数量相等，也就是说@Field(“lang”)、@Field(“since”)的数量是 2，那么[“Kotlin”, “weekly”]的 size 也应该是 2，它必须是一一对应的关系。</li><li>第三步，我们将@Field(“lang”)与”Kotlin”进行配对，将@Field(“since”)与”weekly”进行配对。这里的 mapIndexed，其实就是 map 的升级版，它本质还是一种映射的语法，“注解数组类型”映射成了“Pair 数组”，只是多了一个 index 而已。</li><li>第四步，我们使用 fold 与 parseUrl() 这个方法，拼接出完整的 URL，也就是：<a href="https://baseurl.com/repo?lang=Kotlin&since=weekly%E3%80%82">https://baseurl.com/repo?lang=Kotlin&amp;since=weekly。</a> 这里我们使用了函数引用的语法“::parseUrl”。而 fold 这个操作符，其实就是高阶函数版的 for 循环。</li><li>第五步，我们构建出 OkHttp 的 Request 对象，并且将 URL 传入了进去，准备做网络请求。</li><li>第六步，我们通过 okHttpClient 发起了网络请求，并且拿到了 String 类型的 JSON 数据。最后，我们通过 Gson 解析出 JSON 的内容，并且返回 RepoList 对象。</li></ul><p>到目前为止，我们的 invoke() 方法的主要流程就分析完了，接下来我们再来看看用于实现 URL 拼接的 parseUrl() 是如何实现的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseUrl</span><span class="params">(acc: <span class="type">String</span>, pair: <span class="type">Pair</span>&lt;<span class="type">Array</span>&lt;<span class="type">Annotation</span>&gt;, Any&gt;)</span></span> =</span><br><span class="line">    pair.first.filterIsInstance&lt;Field&gt;()</span><br><span class="line">        .first()</span><br><span class="line">        .let &#123; field -&gt;</span><br><span class="line">            <span class="keyword">if</span> (acc.contains(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">                <span class="string">&quot;<span class="variable">$acc</span>&amp;<span class="subst">$&#123;field.value&#125;</span>=<span class="subst">$&#123;pair.second&#125;</span>&quot;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="string">&quot;<span class="variable">$acc</span>?<span class="subst">$&#123;field.value&#125;</span>=<span class="subst">$&#123;pair.second&#125;</span>&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里我们只是把从前的 for 循环代码，换成了 <strong>Kotlin 的集合操作符</strong>而已。大致流程如下：</p><ul><li>首先，我们从注解的数组里筛选出 Field 类型的注解；</li><li>接着，通过 first() 取出第一个 Field 注解，这里它也应该是唯一的；</li><li>最后，我们判断当前的 acc 是否已经拼接过参数，如果没有拼接过，就用“?”分隔，如果已经拼接过参数，我们就用“&amp;”分隔。</li></ul><p>至此，我们 2.0 版本的代码就完成了，完整的代码如下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> KtHttpV2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> okHttpClient <span class="keyword">by</span> lazy &#123; OkHttpClient() &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> gson <span class="keyword">by</span> lazy &#123; Gson() &#125;</span><br><span class="line">    <span class="keyword">var</span> baseUrl = <span class="string">&quot;https://baseurl.com&quot;</span> <span class="comment">// 可改成任意url</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">create</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            T::<span class="keyword">class</span>.java.classLoader,</span><br><span class="line">            arrayOf(T::<span class="keyword">class</span>.java)</span><br><span class="line">        ) &#123; proxy, method, args -&gt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@newProxyInstance</span> method.annotations</span><br><span class="line">                .filterIsInstance&lt;GET&gt;()</span><br><span class="line">                .takeIf &#123; it.size == <span class="number">1</span> &#125;</span><br><span class="line">                ?.let &#123; invoke(<span class="string">&quot;<span class="variable">$baseUrl</span><span class="subst">$&#123;it[<span class="number">0</span>].value&#125;</span>&quot;</span>, method, args) &#125;</span><br><span class="line">        &#125; <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(url: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? =</span><br><span class="line">        method.parameterAnnotations</span><br><span class="line">            .takeIf &#123; method.parameterAnnotations.size == args.size &#125;</span><br><span class="line">            ?.mapIndexed &#123; index, it -&gt; Pair(it, args[index]) &#125;</span><br><span class="line">            ?.fold(url, ::parseUrl)</span><br><span class="line">            ?.let &#123; Request.Builder().url(it).build() &#125;</span><br><span class="line">            ?.let &#123; okHttpClient.newCall(it).execute().body?.string() &#125;</span><br><span class="line">            ?.let &#123; gson.fromJson(it, method.genericReturnType) &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseUrl</span><span class="params">(acc: <span class="type">String</span>, pair: <span class="type">Pair</span>&lt;<span class="type">Array</span>&lt;<span class="type">Annotation</span>&gt;, Any&gt;)</span></span> =</span><br><span class="line">        pair.first.filterIsInstance&lt;Field&gt;()</span><br><span class="line">            .first()</span><br><span class="line">            .let &#123; field -&gt;</span><br><span class="line">                <span class="keyword">if</span> (acc.contains(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">                    <span class="string">&quot;<span class="variable">$acc</span>&amp;<span class="subst">$&#123;field.value&#125;</span>=<span class="subst">$&#123;pair.second&#125;</span>&quot;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="string">&quot;<span class="variable">$acc</span>?<span class="subst">$&#123;field.value&#125;</span>=<span class="subst">$&#123;pair.second&#125;</span>&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的，我们可以再看看 1.0 版本的完整代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> KtHttpV1 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> okHttpClient: OkHttpClient = OkHttpClient()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> gson: Gson = Gson()</span><br><span class="line">    <span class="keyword">var</span> baseUrl = <span class="string">&quot;https://baseurl.com&quot;</span> <span class="comment">// 可改成任意url</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">create</span><span class="params">(service: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            service.classLoader,</span><br><span class="line">            arrayOf&lt;Class&lt;*&gt;&gt;(service)</span><br><span class="line">        ) &#123; proxy, method, args -&gt;</span><br><span class="line">            <span class="keyword">val</span> annotations = method.annotations</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">annotation</span> <span class="keyword">in</span> annotations) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">annotation</span> <span class="keyword">is</span> GET) &#123;</span><br><span class="line">                    <span class="keyword">val</span> url = baseUrl + <span class="keyword">annotation</span>.value</span><br><span class="line">                    <span class="keyword">return</span><span class="symbol">@newProxyInstance</span> invoke(url, method, args!!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@newProxyInstance</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.parameterAnnotations.size != args.size) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> url = path</span><br><span class="line">        <span class="keyword">val</span> parameterAnnotations = method.parameterAnnotations</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> parameterAnnotations.indices) &#123;</span><br><span class="line">            <span class="keyword">for</span> (parameterAnnotation <span class="keyword">in</span> parameterAnnotations[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parameterAnnotation <span class="keyword">is</span> Field) &#123;</span><br><span class="line">                    <span class="keyword">val</span> key = parameterAnnotation.value</span><br><span class="line">                    <span class="keyword">val</span> value = args[i].toString()</span><br><span class="line">                    <span class="keyword">if</span> (!url.contains(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">                        url += <span class="string">&quot;?<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        url += <span class="string">&quot;&amp;<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">            .url(url)</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> genericReturnType = method.genericReturnType</span><br><span class="line">        <span class="keyword">val</span> body = response.body</span><br><span class="line">        <span class="keyword">val</span> json = body?.string()</span><br><span class="line">        <span class="keyword">val</span> result = gson.fromJson&lt;Any?&gt;(json, genericReturnType)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，1.0 版本、2.0 版本，它们之间可以说是天壤之别。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好了，这节实战就到这里。接下来我们来简单总结一下：</p><ul><li><p>在 1.0 版本的代码中，我们灵活利用了<strong>动态代理、泛型、注解、反射</strong>这几个技术，实现了 KtHttp 的基础功能。</p></li><li><p><strong>动态代理</strong>，由于它的底层原理比较复杂，课程当中我是通过 ApiImpl 这个类，来模拟了它动态生成的 Proxy 类。用这种直观的方式来帮助你理解它存在的意义。</p></li><li><p>泛型方面，我们将其用在了动态代理的 create() 方法上，后面我们还使用了“类型实化”的技术，也就是 inline + reified 关键字。</p></li><li><p><strong>注解方面</strong>，我们首先自定义了两个注解，分别是 GET、Field。其中，@GET 用于标记接口的方法，它的值是 URL 的 path；@Field 用于标记参数，它的值是参数的 key。</p></li><li><p><strong>反射方面</strong>，这个技术点，几乎是贯穿于整个代码实现流程的。我们通过反射的自省能力，去分析 repos() 方法，从 GET 注解当中取出了“&#x2F;repo”这个 path，从注解 Field 当中取出了 lang、since，还取出了 repos() 方法的返回值 RepoList，用于 JSON 数据的解析。</p></li><li><p>在 2.0 版本的代码中，我们几乎删除了之前所有的代码，以<strong>函数式的思维</strong>重写了 KtHttp 的内部逻辑。在这个版本当中，我们大量地使用了 Kotlin 标准库里的高阶函数，进一步提升了代码的可读性。</p></li></ul><p>在前面的加餐课程当中，我们也讨论过 Kotlin 的编程范式问题。<strong>命令式还是函数式，这完全取决于我们开发者自身</strong>。</p><p>相比起前面实战课中的单词频率统计程序，这一次我们的函数式范式的代码，实现起来就没有那么得流畅了。原因其实也很简单，Kotlin 提供了强大的集合操作符，这就让 Kotlin 十分擅长“集合操作”的场景，因此词频统计程序，我们不到 10 行代码就解决了。而对于注解、反射相关的场景，函数式的编程范式就没那么擅长了。</p><p>在这节课里，我之所以费尽心思地用函数式风格，重构出 KtHttp 2.0 版本，主要还是想让你看到函数式编程在它不那么擅长的领域表现会如何。毕竟，我们在工作中什么问题都可能会遇到。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)11  注解与反射：进阶必备技能</title>
      <link href="/posts/f3ad1558/"/>
      <url>/posts/f3ad1558/</url>
      
        <content type="html"><![CDATA[<p>今天这节课，我们来学习一下 Kotlin 的<strong>注解</strong>（Annotation）和<strong>反射</strong>（Reflection）。</p><p>注解和反射，是 Kotlin 当中比较难理解的内容了。和前面我们学习的泛型一样，注解与反射都是比较抽象的概念。我们现在已经知道，Kotlin 的泛型，就是在代码架构的层面进行的一种抽象，从而达到代码逻辑尽可能复用的目的。那么，注解与反射，它们存在的意义是什么呢？</p><p>答案是：提高代码的<strong>灵活性</strong>。</p><p>灵活性，就让注解与反射同样有着举足轻重的地位，借助这两种技术，我们可以做许多有趣的事情。Kotlin 与 Java 领域，有许多著名的开源库，比如大名鼎鼎的<a href="https://spring.io/projects/spring-boot">Spring Boot</a>、Retrofit、Gson等，都会用到这两种技术。</p><p>所以，只有深刻理解了注解和反射，我们才可能理解那些著名开源库的设计思路，也才可能读懂这些世界顶级开发者的代码。</p><p>当然，课程进行到这里，学习的难度也越来越高了，不过你也不要因此产生畏难的情绪，只要你能多思考、多练习，把对知识点的理解都落实到代码上，那我相信你对 Kotlin 的掌握情况、代码能力甚至架构能力，都会有一个质的飞跃。并且，在课程中我也会尽量用通俗易懂的语言、例子来给你介绍这些陌生的概念知识，让你在学习的过程中可以轻松一些。</p><p>好，下面我们就正式开始吧。</p><h2 id="认识注解"><a href="#认识注解" class="headerlink" title="认识注解"></a>认识注解</h2><p>注解，可能是我们眼里<strong>最熟悉的陌生人</strong>。虽然经常见面，但我们并不真的认识它。</p><p>实际上，注解几乎无处不在，比如说，我们经常能在 Kotlin 标准库当中看见“@Deprecated”这样的注解，它代表了被标注的代码“已废弃”。如果你有 Java 的编程经验，你一定见过“@Override”这个注解，它代表了重写。</p><p>而就算你没有任何编程经验，你也已经在前面的课程中见到过注解了。比如我们在第 4 讲的单元测试代码当中，就用到了 @Test 这个注解；在第 8 讲的性能测试代码中，我们用到了 @Benchmark 这个注解。</p><p>其实，要理解 Kotlin 的注解也并不困难，因为在我们的生活当中也有类似的概念，那就是<strong>便利贴</strong>。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/CtvZ9EerRDTlbq5.png" alt="img" style="zoom: 33%;" /><p>比如在学习的时候，你看到书本里的某个知识点有了新的感悟，就会拿起便利贴，写下来你当时的想法，然后贴到书本当中去。</p><p>另一个例子就是，我们经常会在论文或者维基百科当中看到的“注解”。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/3FCaw82V7gfZXxG.png" alt="img" style="zoom: 50%;" /><p>所以，从这个角度来看，我们很容易就能想清楚注解到底是什么。其实，它就是“对已有数据进行补充的一种数据”。这话读起来有点绕，让我用更通俗的语言来解释一下：</p><ul><li>我们学习的时候，写下来的便利贴注解，其实就是对知识点的补充。</li><li>维基百科当中的注解，其实就是对它描述内容的一种补充。</li></ul><p>因此<strong>，Kotlin 当中的注解，其实就是“程序代码的一种补充”</strong>。</p><p>现在我们就拿第 4 讲中的单元测试代码为例，来看看它的作用。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestCalculatorV3</span> &#123;</span><br><span class="line"><span class="comment">//   注解</span></span><br><span class="line"><span class="comment">//    ↓</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testCalculate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> calculator = CalculatorV3()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> res1 = calculator.calculate(<span class="string">&quot;2333333333333332+1&quot;</span>)</span><br><span class="line">        assertEquals(<span class="string">&quot;2333333333333333&quot;</span>, res1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中的“@Test”，它的作用是告诉我们的 IDE，testCalculate() 这个方法是一个测试方法。IDE 检测到这个注解以后，就会在旁边的工具栏展示出一个绿色的三角形按钮，方便我们直接运行这个测试方法。</p><p>如果我们删掉“@Test”这个注解，这段代码就会变成一段普通的 Kotlin 代码，而旁边工具栏的绿色三角形按钮也会消失。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/eiY3K5aygnlLRfs.gif" alt="img" style="zoom:67%;" /><p>从这个例子里，我们其实就能体会到注解的灵活性。我们开发者只需要用 Kotlin 的语法写代码即可，至于代码是不是用来做单元测试，我们用一个简单的“@Test”注解就可以搞定。这中间有<strong>解耦</strong>的思想在里面。</p><p>认识到注解是什么以后，我们后面的学习就很简单了。接下来，我们就来看看注解的定义还有使用。</p><h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><p>首先，让我们来看看注解是如何定义的。Kotlin 的源代码当中，提供了很多内置的注解，比如 @Deprecated、@JvmStatic、@JvmOverloads 等等。除了 Kotlin 默认就有的注解以外，我们也可以定义自己的注解。</p><p>比如说，如果我们想定义一个 @Deprecated 注解，应该怎么做呢？其实非常简单，总体结构和定义一个普通的 Kotlin 类差不多，只是多了一些额外的东西。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target(CLASS, FUNCTION, PROPERTY, ANNOTATION_CLASS, CONSTRUCTOR, PROPERTY_SETTER, PROPERTY_GETTER, TYPEALIAS)</span></span><br><span class="line"><span class="meta">@MustBeDocumented</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Deprecated</span>(</span><br><span class="line">    <span class="keyword">val</span> message: String,</span><br><span class="line">    <span class="keyword">val</span> replaceWith: ReplaceWith = ReplaceWith(<span class="string">&quot;&quot;</span>),</span><br><span class="line">    <span class="keyword">val</span> level: DeprecationLevel = DeprecationLevel.WARNING</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>从上面的代码里，我们可以看到，@Deprecated 这个注解的定义上面，还有其他的注解 @Target、@MustBeDocumented。这样的注解，我们叫做<strong>元注解</strong>，即它本身是注解的同时，还可以用来修饰其他注解。</p><p>Kotlin 常见的元注解有四个：</p><ul><li><strong>@Target</strong>，这个注解是指定了被修饰的注解都可以用在什么地方，也就是目标；</li><li><strong>@Retention</strong>，这个注解是指定了被修饰的注解是不是编译后可见、是不是运行时可见，也就是保留位置；</li><li><strong>@Repeatable</strong>，这个注解是允许我们在同一个地方，多次使用相同的被修饰的注解，使用场景比较少；</li><li><strong>@MustBeDocumented</strong>，指定被修饰的注解应该包含在生成的 API 文档中显示，这个注解一般用于 SDK 当中。</li></ul><p>这里，你需要注意的是 Target 和 Retention 的取值：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">AnnotationTarget</span> &#123;</span><br><span class="line">    <span class="comment">// 类、接口、object、注解类</span></span><br><span class="line">    CLASS,</span><br><span class="line">    <span class="comment">// 注解类</span></span><br><span class="line">    ANNOTATION_CLASS,</span><br><span class="line">    <span class="comment">// 泛型参数</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    PROPERTY,</span><br><span class="line">    <span class="comment">// 字段、幕后字段</span></span><br><span class="line">    FIELD,</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    <span class="comment">// 函数参数</span></span><br><span class="line">    VALUE_PARAMETER,</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    <span class="comment">// 函数</span></span><br><span class="line">    FUNCTION,</span><br><span class="line">    <span class="comment">// 属性的getter</span></span><br><span class="line">    PROPERTY_GETTER,</span><br><span class="line">    <span class="comment">// 属性的setter</span></span><br><span class="line">    PROPERTY_SETTER,</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    TYPE,</span><br><span class="line">    <span class="comment">// 表达式</span></span><br><span class="line">    EXPRESSION,</span><br><span class="line">    <span class="comment">// 文件</span></span><br><span class="line">    FILE,</span><br><span class="line">    <span class="comment">// 类型别名</span></span><br><span class="line">    TYPEALIAS</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">AnnotationRetention</span> &#123;</span><br><span class="line">    <span class="comment">// 注解只存在于源代码，编译后不可见</span></span><br><span class="line">    SOURCE,</span><br><span class="line">    <span class="comment">// 注解编译后可见，运行时不可见</span></span><br><span class="line">    BINARY,</span><br><span class="line">    <span class="comment">// 编译后可见，运行时可见</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码的注释当中，我详细解释了 Target 和 Retention 的取值，以及它们各自代表的意义。现在我们就可以回过头，来看看我们定义的“@Deprecated”到底是什么含义。</p><p>通过 @Target 的取值，我们可以看到，@Deprecated 只能作用于这些地方：类、 函数、 属性、注解类、构造器、属性 getter、属性 setter、类型别名。此外，@Deprecated 这个类当中还包含了几个成员：message 代表了废弃的提示信息；replaceWith 代表了应该用什么来替代废弃的部分；level 代表警告的程度，分别是 WARNING、ERROR、HIDDEN。</p><p>OK，现在我们已经知道如何定义注解了，接下来看看如何用它。我们仍然以 @Deprecated 注解为例。</p><h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><p>假设现在我们要开发一个计算器，第一个版本的 Calculator 代码出现了问题，然后这个问题在 CalculatorV3 当中修复了。这时候，我们希望所有的调用方都将 Calculator 改为 CalculatorV3。这种情况，@Deprecated 这个注解就恰好符合我们的需求。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Deprecated(</span></span><br><span class="line"><span class="meta">    message = <span class="string">&quot;Use CalculatorV3 instead.&quot;</span>,</span></span><br><span class="line"><span class="meta">    replaceWith = ReplaceWith(<span class="string">&quot;CalculatorV3&quot;</span>),</span></span><br><span class="line"><span class="meta">    level = DeprecationLevel.ERROR</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="comment">// 错误逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalculatorV3</span> &#123;</span><br><span class="line">    <span class="comment">// 正确逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用 @Deprecated 修饰了 Calculator 这个类。message 代表了报错的提示信息；replaceWith 代表了正确的解决方案；DeprecationLevel.ERROR 则代表了 IDE 会把这个问题当作是错误的来看待。</p><p>现在，我们再来看看 @Deprecated 的实际效果：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/62/89/6212fddyy950855b67c6f267c5351e89.gif?wh=2102x1754" alt="img" style="zoom: 33%;" /><p>可以看到，当我们在代码当中使用了 Calculator 的时候，IDE 会报错，鼠标挪到报错处后，IDE 会显示 message 当中的内容“Use CalculatorV3 instead.”。另外，IDE 还会提供一个快速修复的选项“Replace with CalculatorV3”，只要我们点击那个选项，我们的 Calculator 就会被直接替换成 CalculatorV3，从而达到修复错误的目的。</p><p>还有，由于我们使用的 level 是 DeprecationLevel.ERROR，所以 IDE 会直接报错。而如果我们使用的是 DeprecationLevel.WARNING，IDE 就只会提示一个警告，而不是错误了。</p><p>好了，到这里，我们就了解了注解要如何定义和使用。其实啊，只要我们真正理解了 Kotlin 的注解到底是什么东西，前面的这些注解的语法是很容易就能记住的。不过，Kotlin 注解在使用的时候，还有一个细节需要注意，那就是注解的<strong>精确使用目标</strong>。</p><p>我们看一个具体的例子，比如Dagger当中的 @Inject 注解：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line"><span class="comment">//    ①</span></span><br><span class="line"><span class="comment">//    ↓</span></span><br><span class="line">    <span class="meta">@set:Inject</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> person: Person</span><br><span class="line"><span class="comment">//     ↑</span></span><br><span class="line"><span class="comment">//     ②</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码，是一个简单的 Dagger 使用场景。如果你不熟悉 Dagger，那也没关系，你只需要关注一下上面的两个注释。</p><ul><li><strong>注释①</strong>：如果去掉 set 这个标记，直接使用 @Inject 这个注解，我们的程序将无法正常工作。这是因为 Kotlin 当中的一个 var 修饰的属性，它会有多种含义：这个属性背后的字段（field）、这个属性对应的 setter、还有这个属性对应的 getter，在没有明确标注出来要用哪个的时候，@Inject 根本不知道该如何决定。因此，这里的“@set:Inject”的作用，就是明确标记出注解的精确使用目标（Use-site targets）。</li><li><strong>注释②</strong>：如果没有 lateinit 这个关键字，person 这个属性是必须要有初始值的，要么直接赋值，要么在构造函数当中被赋值。因为如果它不被初始化，person 这个属性将为空，而这个就和它的类型“不可为空的 Person 类型”冲突了。而加上 lateinit 修饰的属性，即使它是不可为空的，编译器也会允许它无初始值。但当我们需要依赖注入的时候，常常需要与 lateinit 结合使用。</li></ul><p>实际上，注解的精确使用目标，一般是和注解一起使用的，在上面的例子当中，set 就是和 @Inject 一起使用的。而除了 set 以外，Kotlin 当中还有其他的使用目标：</p><ul><li>file，作用于文件；</li><li>property，作用于属性；</li><li>field，作用于字段；</li><li>get，作用于属性 getter；</li><li>set，作用于属性 setter；</li><li>receiver，作用于扩展的接受者参数；</li><li>param，作用于构造函数参数；</li><li>setparam，作用于函数参数；</li><li>delegate，作用于委托字段。</li></ul><p>好，理解了注解这个特性之后，我们再来看看 Kotlin 的反射。</p><h2 id="认识反射"><a href="#认识反射" class="headerlink" title="认识反射"></a>认识反射</h2><p>反射，是 Kotlin 当中另一个比较抽象的概念。如果说注解是<strong>最熟悉的陌生人</strong>，那反射就<strong>单纯只是个陌生人</strong>了。因为，我们很少会在平时的业务开发当中直接用到反射。但是，在架构设计的时候，反射却可以极大地提升架构的灵活性。很多热门的开源库，也都喜欢用反射来做一些不同寻常的事情。因此，反射也是极其重要的一个语法特性。</p><p>所有的计算机程序其实都是服务于真实世界，用来解决实际问题的。所以，其实我们也通过一些真实世界的例子来理解反射的本质。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/tOfu6y2Q5gTEWBN.png" alt="img" style="zoom:33%;" /><p>古人云：吾日三省吾身，指的是人的自我反省能力<strong>。反射，则是程序自我反省的能力</strong>。人的自我反省的能力，跟程序的反射，它们之间有许多相似之处。</p><ul><li>人类可以<strong>反省自己当前的状态</strong>，比如说，我们随时可以知道自己是不是困了。而在 Kotlin 当中，程序可以通过反射来检查代码自身的状态，比如说，判断某个变量，它是不是可变的。</li><li>另外，人类反省自己的状态以后，还可以<strong>主动改变自己的状态</strong>。比如说，困了就休息一会儿、饿了就吃饭、渴了就喝点水。而在 Kotlin 当中，我们可以在运行时，用反射来查看变量的值是否符合预期，如果不符合预期，我们就可以动态修改这个变量的值，即使这个变量是 private 的甚至是 final 的。</li><li>还有，人类可以<strong>根据状态作出不同的决策</strong>。比如说，上班的路上，如果快迟到了，我们就会走快点，如果时间很充足，就可以走慢一点。而在程序世界里，JSON 解析经常会用到 @SerializedName 这个注解，如果属性有 @SerializedName 修饰的话，它就以指定的名称为准，如果没有，那就直接使用属性的名称来解析。</li></ul><p>所以，总的来看，Kotlin 反射具备这三个特质：</p><ul><li><strong>感知</strong>程序的状态，包含程序的运行状态，还有源代码结构；</li><li><strong>修改</strong>程序的状态；</li><li>根据程序的状态，<strong>调整</strong>自身的决策行为。</li></ul><h3 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h3><p>在 Kotlin 当中，反射库并没有直接集成到标准库当中。这是为了方便一些对程序安装包敏感的应用，可以根据实际需求来选择是否要用 Kotlin 反射。比如，在 Android 开发当中，我们对安装包体积就十分敏感，如果没有反射的需求，就完全不需要多引入这个依赖。</p><p>而对应的，如果我们需要用到反射，就必须要引入这个依赖：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;org.jetbrains.kotlin:kotlin-reflect&quot;</span></span><br></pre></td></tr></table></figure><p>前面我们刚了解过 Kotlin 反射的三个特质，那么在这里，我们就用代码来探索下这三种特质。</p><p>在正常情况下，我们写出来的程序，其实也可以感知自身部分的状态。比如，我们前面课程中写的计算器程序，还有词频统计程序，本质上都是对输入数据状态的感知。不过，它们感知的状态十分有限。</p><p>假设，现在有一个待实现的函数 readMembers。这个函数的参数 obj 可能是任何的类型，我们需要读取 obj 当中所有的成员属性的名称和值，那么具体该怎么做呢？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">99.5</span>, <span class="number">170</span>)</span><br><span class="line">    <span class="keyword">val</span> school = School(<span class="string">&quot;PKU&quot;</span>, <span class="string">&quot;Beijing...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    readMembers(student)</span><br><span class="line">    readMembers(school)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readMembers</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 读取obj的所有成员属性的名称和值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Student</span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> score: <span class="built_in">Double</span>,</span><br><span class="line">    <span class="keyword">val</span> height: <span class="built_in">Int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">School</span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">var</span> address: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求readMembers函数能够输出以下内容：</span></span><br><span class="line"></span><br><span class="line">Student.height=<span class="number">170</span></span><br><span class="line">Student.name=Tom</span><br><span class="line">Student.score=<span class="number">99.5</span></span><br><span class="line">School.address=Beijing...</span><br><span class="line">School.name=PKU</span><br></pre></td></tr></table></figure><p>从上面的代码，我们可以看到，readMembers() 这个函数无法提前知道参数是什么类型，但是，在这个函数当中，我们还是要能够准确找到 obj 的所有成员属性，然后输出它们的名称和值。</p><p>对于这样的问题，也许你会第一时间想到用 when 表达式，写出类似这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readMembers</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span>(obj) &#123;</span><br><span class="line">        <span class="keyword">is</span> Student -&gt; &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">        <span class="keyword">is</span> School -&gt; &#123; <span class="comment">/*...*/</span>&#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123; <span class="comment">/*...*/</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，在这个例子里，我们是只有 Student、School 这两种情况，而在实际情况下，obj 可能的类型是成千上万的，我们根本无法用 when 的方式提前硬编码进行预测。比如你可以再看看下面这段示例：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readMembers</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span>(obj) &#123;</span><br><span class="line">        <span class="keyword">is</span> Student -&gt; &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">        <span class="keyword">is</span> School -&gt; &#123; <span class="comment">/*...*/</span>&#125;</span><br><span class="line">        <span class="comment">// 硬编码的话，这里要写成千上万个逻辑分支，根本不可能做到</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123; <span class="comment">/*...*/</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，即使我们有心想要写上万个逻辑分支，那当中的代码量也是不可想象的。因此，对于类似这样的问题，我们就可以考虑使用反射了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readMembers</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    obj::<span class="keyword">class</span>.memberProperties.forEach &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;obj::class.simpleName&#125;</span>.<span class="subst">$&#123;it.name&#125;</span>=<span class="subst">$&#123;it.getter.call(obj)&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看，通过反射，简单的几行代码就搞定了这个需求。如果你是第一次接触反射，可能会觉得上面的代码有点难懂，我来带你分析一下。</p><p>首先，是 <strong>obj::class</strong>，这是 Kotlin 反射的语法，我们叫做<strong>类引用</strong>，通过这样的语法，我们就可以读取一个变量的“类型信息”，并且就能拿到这个变量的类型，它的类型是 KClass。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">interface</span> <span class="title class_">KClass</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">KDeclarationContainer</span>, <span class="type">KAnnotatedElement</span>, <span class="type">KClassifier</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> simpleName: String?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> qualifiedName: String?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> members: Collection&lt;KCallable&lt;*&gt;&gt;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 KClass 其实就代表了一个 Kotlin 类，通过 obj::class，我们就可以拿到这个类型的所有信息，比如说，类的名称“obj::class.simpleName”。而如果要获取类的所有成员属性，我们访问它的扩展属性 memberProperties 就可以了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> &lt;T : Any&gt; KClass&lt;T&gt;.memberProperties: Collection&lt;KProperty1&lt;T, *&gt;&gt;</span><br><span class="line">    <span class="keyword">get</span>() = (<span class="keyword">this</span> <span class="keyword">as</span> KClassImpl&lt;T&gt;).<span class="keyword">data</span>().allNonStaticMembers.filter &#123; it.isNotExtension &amp;&amp; it <span class="keyword">is</span> KProperty1&lt;*, *&gt; &#125; <span class="keyword">as</span> Collection&lt;KProperty1&lt;T, *&gt;&gt;</span><br></pre></td></tr></table></figure><p>在拿到所有的成员属性以后，我们可以通过 <strong>forEach</strong> 遍历所有的属性，它的类型是 KProperty1，同时也是 KCallable 的子类，我们通过调用属性的 getter.call()，就可以拿到 obj 属性的值了。</p><p>这样，到目前为止，我们的程序就已经可以感知到自身的状态了，接下来我们来尝试修改自身的状态，这是反射的第二个特质。</p><p>具体需求是这样的：如果传入的参数当中，存在 String 类型的 address 变量，我们就将其改为 China。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">99.5</span>, <span class="number">170</span>)</span><br><span class="line">    <span class="keyword">val</span> school = School(<span class="string">&quot;PKU&quot;</span>, <span class="string">&quot;Beijing...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    readMembers(student)</span><br><span class="line">    readMembers(school)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改其中的address属性</span></span><br><span class="line">    modifyAddressMember(school)</span><br><span class="line"></span><br><span class="line">    readMembers(school)</span><br><span class="line">    readMembers(student)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">modifyAddressMember</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    obj::<span class="keyword">class</span>.memberProperties.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.name == <span class="string">&quot;address&quot;</span> &amp;&amp; <span class="comment">// ①</span></span><br><span class="line">            it <span class="keyword">is</span> KMutableProperty1 &amp;&amp; <span class="comment">// ②</span></span><br><span class="line">            it.setter.parameters.size == <span class="number">2</span> &amp;&amp; <span class="comment">// ③</span></span><br><span class="line">            it.getter.returnType.classifier == String::<span class="keyword">class</span> <span class="comment">// ④</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// ⑤</span></span><br><span class="line">            it.setter.call(obj, <span class="string">&quot;China&quot;</span>)</span><br><span class="line">            println(<span class="string">&quot;====Address changed.====&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">Student.height=<span class="number">170</span></span><br><span class="line">Student.name=Tom</span><br><span class="line">Student.score=<span class="number">99.5</span></span><br><span class="line"><span class="comment">// 注意这里</span></span><br><span class="line">School.address=Beijing...</span><br><span class="line">School.name=PKU</span><br><span class="line">====Address changed.====</span><br><span class="line"><span class="comment">// 注意这里</span></span><br><span class="line">School.address=China</span><br><span class="line">School.name=PKU</span><br><span class="line">Student.height=<span class="number">170</span></span><br><span class="line">Student.name=Tom</span><br><span class="line">Student.score=<span class="number">99.5</span></span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以看到，当我们运行了 modifyAddressMember(school) 这行代码以后，反射代码就会检查传入的变量当中，是否存在 String 类型的 address，如果存在，就会将它的值修改为“China”。</p><p>这里你可以关注下我在其中标出来的四个注释，它们就代表了关键的逻辑：</p><ul><li>注释①，判断属性的名称是否为 address，如果不是，则跳过；</li><li>注释②，判断属性是否可变，在我们的例子当中 address 是用 var 修饰的，因此它的类型是 KMutableProperty1；</li><li>注释③，我们在后面要调用属性的 setter，所以我们要先判断 setter 的参数是否符合预期，这里 setter 的参数个数应该是 2，第一个参数是 obj 自身，第二个是实际的值；</li><li>注释④，根据属性的 getter 的返回值类型 returnType，来判断属性的类型是不是 String 类型；</li><li>注释⑤，调用属性的 setter 方法，传入 obj，还有“China”，来完成属性的赋值。</li></ul><p>好，到这里，我们就已经了解了反射的两种特质，分别是感知程序的状态和修改程序的状态。现在只剩下第三种，根据程序状态作出不同决策。这个其实非常容易做到。</p><p>假如在前面的例子的基础上，我们想要增加一个功能：如果传入的参数没有符合需求的 address 属性，我们就输出一行错误日志。这其实也就代表了根据程序的状态，作出不同的行为。比如，我们可以看看下面这段示例，其中的 else 分支就是我们的决策行为“输出错误日志”：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">modifyAddressMember</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    obj::<span class="keyword">class</span>.memberProperties.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.name == <span class="string">&quot;address&quot;</span> &amp;&amp;</span><br><span class="line">            it <span class="keyword">is</span> KMutableProperty1 &amp;&amp;</span><br><span class="line">            it.getter.returnType.classifier == String::<span class="keyword">class</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            it.setter.call(obj, <span class="string">&quot;China&quot;</span>)</span><br><span class="line">            println(<span class="string">&quot;====Address changed.====&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 差别在这里</span></span><br><span class="line">            println(<span class="string">&quot;====Wrong type.====&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line">Student.height=<span class="number">170</span></span><br><span class="line">Student.name=Tom</span><br><span class="line">Student.score=<span class="number">99.5</span></span><br><span class="line">School.address=Beijing...</span><br><span class="line">School.name=PKU</span><br><span class="line">====Address changed.====</span><br><span class="line">====Wrong type.====  <span class="comment">// 差别在这里</span></span><br><span class="line">School.address=China</span><br><span class="line">School.name=PKU</span><br><span class="line">Student.height=<span class="number">170</span></span><br><span class="line">Student.name=Tom</span><br><span class="line">Student.score=<span class="number">99.5</span></span><br></pre></td></tr></table></figure><p>在前面的几个案例当中，我们用到了 Kotlin 反射的几个关键的反射 Api 和类：KClass、KCallable、KParameter、KType。现在，我们来进一步看看它们的关键成员。</p><p><strong>KClass 代表了一个 Kotlin 的类，下面是它的重要成员：</strong></p><ul><li>simpleName，类的名称，对于匿名内部类，则为 null；</li><li>qualifiedName，完整的类名；</li><li>members，所有成员属性和方法，类型是Collection&gt;；</li><li>constructors，类的所有构造函数，类型是Collection&gt;&gt;；</li><li>nestedClasses，类的所有嵌套类，类型是Collection&gt;；</li><li>visibility，类的可见性，类型是KVisibility?，分别是这几种情况，PUBLIC、PROTECTED、INTERNAL、PRIVATE；</li><li>isFinal，是不是 final；</li><li>isOpen，是不是 open；</li><li>isAbstract，是不是抽象的；</li><li>isSealed，是不是密封的；</li><li>isData，是不是数据类；</li><li>isInner，是不是内部类；</li><li>isCompanion，是不是伴生对象；</li><li>isFun，是不是函数式接口；</li><li>isValue，是不是 Value Class。</li></ul><p><strong>KCallable 代表了 Kotlin 当中的所有可调用的元素，比如函数、属性、甚至是构造函数。下面是 KCallable 的重要成员：</strong></p><ul><li><p>name，名称，这个很好理解，属性和函数都有名称；</p></li><li><p>parameters，所有的参数，类型是List，指的是调用这个元素所需的所有参数；</p></li><li><p>returnType，返回值类型，类型是 KType；</p></li><li><p>typeParameters，所有的类型参数 (比如泛型)，类型是List；</p></li><li><p>call()，KCallable 对应的调用方法，在前面的例子中，我们就调用过 setter、getter 的 call() 方法。</p></li><li><p>visibility，可见性；</p></li><li><p>isSuspend，是不是挂起函数。</p></li></ul><p><strong>KParameter，代表了KCallable当中的参数，它的重要成员如下：</strong></p><ul><li>index，参数的位置，下标从 0 开始；</li><li>name，参数的名称，源码当中参数的名称；</li><li>type，参数的类型，类型是 KType；</li><li>kind，参数的种类，对应三种情况：INSTANCE 是对象实例、EXTENSION_RECEIVER 是扩展接受者、VALUE 是实际的参数值。</li></ul><p><strong>KType，代表了 Kotlin 当中的类型，它重要的成员如下：</strong></p><ul><li>classifier，类型对应的 Kotlin 类，即 KClass，我们前面的例子中，就是用的 classifier &#x3D;&#x3D; String::class 来判断它是不是 String 类型的；</li><li>arguments，类型的类型参数，看起来好像有点绕，其实它就是这个类型的泛型参数；</li><li>isMarkedNullable，是否在源代码中标记为可空类型，即这个类型的后面有没有“?”修饰。</li></ul><p>所以，归根结底，<strong>反射，其实就是 Kotlin 为我们开发者提供的一个工具</strong>，通过这个工具，我们可以让程序在运行的时候“自我反省”。这里的“自我反省”一共有三种情况，其实跟我们的现实生活类似。</p><ul><li>第一种情况，程序在运行的时候，可以通过反射来查看自身的状态。</li><li>第一种情况，程序在运行的时候，可以通过反射来查看自身的状态。</li><li>第一种情况，程序在运行的时候，可以通过反射来查看自身的状态。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好了，让我们来做个简单的总结吧。</p><p>注解和反射，是 Kotlin 当中十分重要的特性，它们可以极大地提升程序的灵活性。那么，在使用注解和反射的时候，你要知道，<strong>注解，其实就是“程序代码的一种补充”，而反射，其实就是“程序代码自我反省的一种方式”。</strong></p><p>在这节课当中，我们已经分别见识了注解与反射的威力。那么，如果我们将它们两者结合起来使用会产生什么样的反应呢？我们将在下节课当中揭晓！</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>这节课，我们学习了 Kotlin 的注解、反射，其实 Java 当中也是有注解与反射的。那么你知道 Kotlin 和 Java 之间有哪些异同点吗？欢迎给我留言，我们一起交流探讨。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)10  泛型：逆变or协变，傻傻分不清？</title>
      <link href="/posts/91ec5a6c/"/>
      <url>/posts/91ec5a6c/</url>
      
        <content type="html"><![CDATA[<p><audio src="http://rpheez113.hn-bkt.clouddn.com/course/kotlin/kotlin-first-lesson/audio10%20_%20%E6%B3%9B%E5%9E%8B%EF%BC%9A%E9%80%86%E5%8F%98or%E5%8D%8F%E5%8F%98%EF%BC%8C%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%EF%BC%9F.m4a"></audio></p><p>这节课我们来学习 Kotlin 的泛型（Generics），包括泛型基础、使用处型变、声明处型变以及星投影。</p><p>泛型，这个概念在很多编程语言里面都存在。在中大型软件开发当中，我们对泛型的使用也十分频繁，因为它可以让我们<strong>在不同类型之间复用相似的逻辑代码。</strong></p><p>不管是 Android 领域，还是后端领域，泛型在软件的架构当中都有着举足轻重的地位。只有透彻理解了泛型，我们才能理解各种设计模式，进而才可能设计出合理的软件架构。</p><p>然而，想要学好泛型却不是一件容易的事情。这是因为，泛型实在太抽象了。</p><p>我们都知道，程序其实是对真实世界的抽象，比如我们在前面实战课里写的计算器程序，现实生活当中就有计算器这个东西，我们想要在电脑里写一个抽象的计算器程序，也不会那么难理解，因为它和现实生活相关。可是泛型，它是对<strong>程序的抽象</strong>。程序本来就已经够抽象了，我们还要在它的基础上再做一次抽象。</p><p>这样一来，泛型和我们真实的物理世界差了两层抽象，因此，泛型对于我们人类来说，会显得尤为虚无缥缈。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/14/d0/14f371f5352321cb32d085d7ab25dbd0.jpg?wh=2000x797" alt="img" style="zoom:50%;" /><p>不过，程序其实也是源自于生活的。所以在这节课里，我会尽量用生活中的例子来给你解释下 Kotlin 的泛型概念，让你能更直观、更立体地感知到泛型与现实生活的联系，然后，你也能够从这些生活的场景中，更深刻地理解并掌握 Kotlin 的泛型，从而为你将来构建大型软件打好基础。</p><p>好，那么下面，我们就拿“遥控器”这个生活中常见的物件儿，来聊聊它跟“泛型”之间，都能产生哪些联系。</p><h2 id="掌握泛型基础"><a href="#掌握泛型基础" class="headerlink" title="掌握泛型基础"></a>掌握泛型基础</h2><p>在现实生活中，我们能看到各式各样的电视机遥控器，比如小米就有 1S、2S、3S、4S 电视遥控器。</p><p>那么，如果我们将遥控器的概念迁移到程序的世界，我们就需要定义各种各样的“遥控器类”，比如说：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小米1S电视机遥控</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TvMi1SController</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOff</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小米2S电视机遥控</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TvMi2SController</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOff</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小米3S电视机遥控</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TvMi3SController</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOff</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小米4S电视机遥控</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TvMi4SController</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOff</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">省略几千种不同的遥控器</span><br></pre></td></tr></table></figure><p>从上面的代码我们可以看到，如果我们为每一个型号的电视机都创建一个对应的遥控器类，然后在里面重复编写“开机”“关机”的方法，我们的工作量会很大，而且没有意义。</p><p>这个时候，我们其实需要一个<strong>万能遥控器</strong>，而借助 Kotlin 的泛型，我们就可以很容易地实现了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//          T代表泛型的形参</span></span><br><span class="line"><span class="comment">//               ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">(tv: <span class="type">T</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOff</span><span class="params">(tv: <span class="type">T</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//                                泛型的实参</span></span><br><span class="line"><span class="comment">//                                   ↓</span></span><br><span class="line">    <span class="keyword">val</span> mi1Controller = Controller&lt;XiaoMiTV1&gt;()</span><br><span class="line">    mi1Controller.turnOn()</span><br><span class="line"></span><br><span class="line"><span class="comment">//                                  泛型的实参</span></span><br><span class="line"><span class="comment">//                                     ↓</span></span><br><span class="line">    <span class="keyword">val</span> mi2Controller = Controller&lt;XiaoMiTV2&gt;()</span><br><span class="line">    mi2Controller.turnOn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码里，我们定义了一个“万能遥控器类”Controller，它当中的字母 T 代表了，这个遥控器可以控制很多种型号的电视，至于我们到底想要控制哪种型号，在使用的时候，只需要把 T 替换成实际的电视机型号即可。在上面的 main 函数当中，我们是传入了“XiaoMi1S”“XiaoMi2S”这两个型号。</p><p>可见，使用泛型的好处就在于，我们可以复用程序代码的逻辑，借助这个特性，我们可以在程序的基础上再做一次抽象。这样，通过这个Controller，<strong>不管将来有多少型号的电视机，我们都可以用这一个类来搞定</strong>。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/c1/e7/c1248f3042f62b3ddb74618bb43e38e7.jpg?wh=2000x856" alt="img"></p><p>另外，我们在定义泛型的时候，其实还可以为它的泛型参数增加一些<strong>边界限制</strong>，比如说，强制要求传入的泛型参数，必须是 TV 或者是它的子类。这叫做泛型的<strong>上界</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//               差别在这里</span></span><br><span class="line"><span class="comment">//                   ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span>&lt;<span class="type">T: TV</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">(tv: <span class="type">T</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOff</span><span class="params">(tv: <span class="type">T</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 Kotlin 的继承语法一样，我们是使用冒号来表示泛型的边界。注意，当我们定义了边界之后，如果我们传入 Controller 的类型不是 TV 的子类，那么编译器是会报错的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 报错，因为Car不是TV的子类</span></span><br><span class="line">    <span class="keyword">val</span> controller = Controller&lt;Car&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一点你也需要注意，由于函数是 Kotlin 当中的一等公民，所以你也可以用两个简单的函数 turnOn() 和 turnOff()，来解决前面所说的“遥控器的问题”：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//     函数的泛型参数</span></span><br><span class="line"><span class="comment">//   ↓             ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">turnOn</span><span class="params">(tv: <span class="type">T</span>)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">turnOff</span><span class="params">(tv: <span class="type">T</span>)</span></span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">turnOnAll</span><span class="params">(mi1: <span class="type">XiaoMiTV1</span>, mi2: <span class="type">XiaoMiTV2</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//      泛型实参自动推导</span></span><br><span class="line"><span class="comment">//          ↓</span></span><br><span class="line">    turnOn(mi1)</span><br><span class="line">    turnOn(mi2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码里我们可以看到，我们直接在 fun 关键字的后面加上用尖括号包起来的 T，就可以为函数增加泛型支持。这里我们选择用字母“T”，完全是因为约定俗成，你将 T 改为其他英文字母也是不会影响编译的。</p><p>好了，泛型是什么、使用的好处、如何表示等问题，现在我们就都搞清楚了。下面我们再来看看学习泛型的一大难点：型变。</p><h2 id="型变（Variance）"><a href="#型变（Variance）" class="headerlink" title="型变（Variance）"></a>型变（Variance）</h2><p>首先，型变是什么呢？</p><p>简单来说，它就是为了解决泛型的<strong>不变性</strong>问题。事实上，型变讨论的是：在已知 Cat 是 Animal 的子类的情况下，MutableList与MutableList之间是什么关系。</p><p>在正常情况下，编译器会认为它们两者是没有任何关系的。换句话，也就是说，<strong>泛型是不变的</strong>。Kotlin 编译器会这样处理的原因也很简单，这里我们可以先来假设一下：如果编译器不阻止我们用MutableList来替代MutableList，代码会出什么问题呢？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 需要父类集合，传入子类集合</span></span><br><span class="line"></span><br><span class="line">foo(list: MutableList&lt;Animal&gt;) &#123;</span><br><span class="line">    <span class="comment">// 出错，Cat集合不能存Dog对象</span></span><br><span class="line">    list.add(Dog())</span><br><span class="line">    <span class="comment">// 通过</span></span><br><span class="line">    <span class="keyword">val</span> animal: Animal = list[<span class="number">0</span>] <span class="comment">// 取出的Cat对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需要MutableList&lt;Animal&gt;，实际传MutableList&lt;Cat&gt;</span></span><br><span class="line">    foo(mutableListOf&lt;Cat&gt;(Cat()))</span><br><span class="line">    <span class="comment">// 实际上，编译器在这里就会提示错误，我们现在假设编译器不阻止我们，会出什么问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码的注释中，我们能看到，当程序需要 Animal 的集合时，如果我们传入的是 Cat 的集合，<strong>我们就可以往 list 里添加其他类型的动物</strong>，比如 Dog。然而，Dog 是无法存入 Cat 的集合的。</p><p>那么如果我们反过来呢？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 需要子类集合，传入父类集合</span></span><br><span class="line"></span><br><span class="line">foo(list: MutableList&lt;Cat&gt;) &#123;</span><br><span class="line">    <span class="comment">// 通过</span></span><br><span class="line">    list.add(Cat())</span><br><span class="line">    <span class="comment">// 出错</span></span><br><span class="line">    <span class="keyword">val</span> cat: Cat = list[<span class="number">0</span>] <span class="comment">// 实际取出来的是Animal对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需要MutableList&lt;Cat&gt;，实际传MutableList&lt;Animal&gt;</span></span><br><span class="line">    foo(mutableListOf(Animal()))</span><br><span class="line">    <span class="comment">// 实际上，编译器在这里就会提示错误，我们现在假设编译器不阻止我们，会出什么问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现，反过来之后，当需要子类集合传入父类集合的时候，我们在函数体内部存储的行为是不会受到影响的，存储 Cat、Animal 类型都没问题。可是，一旦我们想从集合当中取出 Cat 对象的时候，会发现取出来的是 Animal 对象，这时候又错了。</p><p>所以，在默认情况下，编译器会认为MutableList与MutableList之间不存在任何继承关系，它们也无法互相替代，这样就不会出现前面提到的两种问题。这就是泛型的<strong>不变性</strong>。</p><p>但是啊，在某些特定场景下，编译器这种行为还是会给我们带来麻烦的。而这个时候，就需要<strong>泛型的逆变与协变</strong>了。具体是什么特定场景呢？别着急，下面我带你来看个例子。</p><h2 id="逆变（Contravariant）"><a href="#逆变（Contravariant）" class="headerlink" title="逆变（Contravariant）"></a>逆变（Contravariant）</h2><p>让我们继续以前面的遥控器为例：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoMiTV1</span>: <span class="type">TV</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">(tv: <span class="type">T</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们有一个电视机的父类，叫做 TV，另外还有一个子类，叫做 XiaoMiTV1。它们两者是继承关系。由于它们是父子的关系，当函数的参数需要 TV 这个父类的时候，我们是可以传入子类作为参数的。这很好理解，我们接着往下看：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(tv: <span class="type">TV</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 要求父类，可以传入子类</span></span><br><span class="line">    foo(XiaoMiTV1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在问题来了，Controller和Controller之间是什么关系呢？让我们来设想一个<strong>买遥控器的场景</strong>：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                      需要一个小米电视1的遥控器</span></span><br><span class="line"><span class="comment">//                                ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buy</span><span class="params">(controller: <span class="type">Controller</span>&lt;<span class="type">XiaoMiTV1</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> xiaoMiTV1 = XiaoMiTV1()</span><br><span class="line">    <span class="comment">// 打开小米电视1</span></span><br><span class="line">    controller.turnOn(xiaoMiTV1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们的函数需要一个“小米电视 1 的遥控器”，在函数的内部，我们需要打开一台小米电视机。那么，当我们需要打开一台小米电视机的时候，我们是否可以用一个“万能的遥控器”呢？当然可以！所以，我们可以写出下面这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//                             实参</span></span><br><span class="line"><span class="comment">//                              ↓</span></span><br><span class="line">    <span class="keyword">val</span> controller = Controller&lt;TV&gt;()</span><br><span class="line">    <span class="comment">// 传入万能遥控器，报错</span></span><br><span class="line">    buy(controller)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，由于我们传入的泛型实参是 TV，它是所有电视机的父类。因此，Controller 内部将会处理所有电视机型号的开机、关机。这时候，<strong>它就相当于一个万能遥控器</strong>，万能遥控器当然也可以打开小米电视 1。</p><p>从道理上来讲，我们的推理是没有错的，不过 Kotlin 编译器会报错，报错的内容是说“类型不匹配”，需要的是小米遥控器Controller，你却买了个万能遥控器Controller。在默认情况下，Kotlin 编译器就是这么认死理。</p><p>所以，为了让我们的代码通过编译，我们需要主动告诉编译器一些额外的信息，具体的做法有两种。</p><p><strong>第一种做法</strong>，是修改泛型参数的使用处代码，它叫做使用处型变。具体做法就是修改 buy 函数的声明，在 XiaoMiTV1 的前面增加一个 in 关键字：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                         变化在这里</span></span><br><span class="line"><span class="comment">//                             ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buy</span><span class="params">(controller: <span class="type">Controller</span>&lt;<span class="type">in</span> <span class="type">XiaoMiTV1</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> xiaoMiTV1 = XiaoMiTV1()</span><br><span class="line">    <span class="comment">// 打开小米电视1</span></span><br><span class="line">    controller.turnOn(xiaoMiTV1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种做法</strong>，是修改 Controller 的源代码，这叫声明处型变。具体做法就是，在泛型形参 T 的前面增加一个关键字 in：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//            变化在这里</span></span><br><span class="line"><span class="comment">//               ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">(tv: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用以上任意一种方式修改后，代码就能够通过 Kotlin 编译了。这样修改之后，我们就可以使用Controller来替代Controller，也就是说，Controller是Controller的子类。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/6a/22/6acd7ea7c06df0fd2f25626965ac6022.jpg?wh=2000x517" alt="img"></p><p>如果你足够细心，你会发现：在这个场景下，遥控器与电视机之间的父子关系颠倒了。“小米电视”是“电视”的子类，但是，“万能遥控”成了“小米遥控”的子类。这种父子关系颠倒的现象，我们就叫做“<strong>泛型的逆变</strong>”。上面这两种修改方式，就分别叫做<strong>使用处逆变和声明处逆变</strong>。</p><p>而除了父子关系颠倒的现象，泛型当中还存在一种父子关系一致的现象，也就是<strong>泛型的协变</strong>。</p><h2 id="协变（Covariant）"><a href="#协变（Covariant）" class="headerlink" title="协变（Covariant）"></a>协变（Covariant）</h2><p>这次，我们仍然以一个生活中的场景来做分析。现在，请你想象一个点外卖的场景。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/37/68/37fd3346e8de26327b0e09768378fa68.png?wh=1280x765" alt="img" style="zoom:67%;" /><p>为了模拟这个场景，我们需要用代码来描述其中的几个角色：普通的食物、肯德基的食物，它们两者之间是父子关系。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Food</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KFC</span>: <span class="type">Food</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>除此之外呢，我们还有一个饭店的角色：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">orderFood</span><span class="params">()</span></span>: T &#123; <span class="comment">/*..*/</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的 Restaurant 泛型参数处，我们传入不同的食物类型，就代表了不同类型的饭店。接下来，就是我们的点外卖方法了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//                      这里需要一家普通的饭店，随便什么饭店都行</span></span><br><span class="line"><span class="comment">//                                     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">orderFood</span><span class="params">(restaurant: <span class="type">Restaurant</span>&lt;<span class="type">Food</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从这家饭店，点一份外卖</span></span><br><span class="line">    <span class="keyword">val</span> food = restaurant.orderFood()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//                  找到一家肯德基</span></span><br><span class="line"><span class="comment">//                        ↓</span></span><br><span class="line">    <span class="keyword">val</span> kfc = Restaurant&lt;KFC&gt;()</span><br><span class="line"><span class="comment">// 需要普通饭店，传入了肯德基，编译器报错</span></span><br><span class="line">    orderFood(kfc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们直接运行上面的代码，会发现编译器提示最后一行代码报错，报错的原因同样是：“类型不匹配”，我们需要的是一家随便类型的饭店Restaurant，而传入的是肯德基Restaurant，不匹配。</p><p>是不是觉得很荒谬？既然随便找一家饭店就能点外卖，为什么肯德基不可以呢？</p><p>不过，有了上次的经验，这次我们就轻车熟路了，由于编译器认死理，我们必须额外提供一些信息给编译器，让它知道我们是在特殊场景使用泛型。具体的做法呢，还是有两种。</p><p><strong>第一种做法</strong>，还是修改泛型参数的使用处，也就是使用处型变。具体的做法就是修改 orderFood() 函数的声明，在 Food 的前面增加一个 out 关键字：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//                                变化在这里</span></span><br><span class="line"><span class="comment">//                                    ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">orderFood</span><span class="params">(restaurant: <span class="type">Restaurant</span>&lt;<span class="type">out</span> <span class="type">Food</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从这家饭店，点一份外卖</span></span><br><span class="line">    <span class="keyword">val</span> food = restaurant.orderFood()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种做法</strong>，是修改 Restaurant 的源代码，也就是声明处型变。具体做法就是，在它泛型形参 T 的前面增加一个关键字 out：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//            变化在这里</span></span><br><span class="line"><span class="comment">//                ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">orderFood</span><span class="params">()</span></span>: T &#123; <span class="comment">/*..*/</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在做完以上任意一种修改以后，代码就可以通过编译了。这也就意味着，在这种情况下，我们可以使用Restaurant替代Restaurant，也就意味着Restaurant可以看作是Restaurant的子类。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/8f/c0/8f9yyb56537bf5f5248b9a484e26b6c0.jpg?wh=2000x533" alt="img" style="zoom:50%;" /><p>到了这时候，你会发现，食物与饭店它们之间的父子关系一致了。这种现象，我们称之为“<strong>泛型的协变</strong>”。上面两种修改的方式，就分别叫做<strong>使用处协变</strong>和<strong>声明处协变</strong>。</p><p>需要特别注意的是，虽然 Java 当中也有型变的概念，但是呢，Java 当中是没有声明处型变的。Java 里面只有使用处型变，下面是它们的语法对比：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/3d/ca/3d3a24ffff462a6019c42e43b7e4f3ca.jpg?wh=2000x622" alt="img" style="zoom:50%;" /><p>而通过对比，你也会发现，Java 的型变语法十分抽象，远不如 Kotlin 来得简洁。</p><p>好了，到这里，我们就差不多把 Kotlin 的泛型这个特性理解清楚了，那么是不是就说明，我们可以开始实战了呢？其实还不行，我们还需要了解另一个跟泛型相关的概念，也就是星投影。</p><h2 id="星投影（Star-Projections）"><a href="#星投影（Star-Projections）" class="headerlink" title="星投影（Star-Projections）"></a>星投影（Star-Projections）</h2><p>Kotlin 当中还有一个概念叫做“星投影”。虽然你听起来可能会觉得这个词很吓人，但其实它的概念很简单。所谓的星投影，其实就是<strong>用“星号”作为泛型的实参</strong>。</p><p>那么，什么情况下，我们需要用星号作为泛型实参呢？答案其实也很简单，<strong>当我们不关心实参到底是什么的时候</strong>。</p><p>举个例子，我们现在需要开发一个“找饭店”的功能，借助泛型，我们可以写出这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">findRestaurant</span><span class="params">()</span></span>: Restaurant&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>不过，如果我们并不关心找到的饭店到底是什么类型，不管它是肯德基还是麦当劳的话，那么，我们就完全可以把“星号”作为泛型的实参，比如这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">orderFood</span><span class="params">()</span></span>: T &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                        把星号作为泛型实参</span></span><br><span class="line"><span class="comment">//                               ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findRestaurant</span><span class="params">()</span></span>: Restaurant&lt;*&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> restaurant = findRestaurant()</span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    <span class="keyword">val</span> food: Any? = restaurant.orderFood() <span class="comment">// 返回值可能是：任意类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码当中，我们没有传递任何具体的类型给 Restaurant，而是使用了“星号”作为 Restaurant 的泛型实参，因此，我们就无法知道饭店到底是什么类型。</p><p>相应的，当我们调用 restaurant.orderFood() 的时候，就无法确定它返回的值到底是什么类型。这时候，变量 food 的实际类型可能是任意的，比如 String、Int、Food、KFC，甚至可能是 null，因此，在这里我们只能将其看作是“Any?”类型。</p><p>那么，对于上面的这种 food 可能是任意类型的情况，我们有没有办法让 food 的类型更加精确一些呢？当然是有的。如果我们为 Restaurant 的泛型类型加上边界的话，food 的类型就可以更精确一些。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                   区别在这里</span></span><br><span class="line"><span class="comment">//                       ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span>&lt;<span class="type">out T: Food</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">orderFood</span><span class="params">()</span></span>: T &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findRestaurant</span><span class="params">()</span></span>: Restaurant&lt;*&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> restaurant = findRestaurant()</span><br><span class="line">    <span class="comment">//       注意这里</span></span><br><span class="line">    <span class="comment">//          ↓</span></span><br><span class="line">    <span class="keyword">val</span> food: Food = restaurant.orderFood() <span class="comment">// 返回值是：Food或其子类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子我们能看到，当我们为 Restaurant 泛型类型增加了上界 Food 以后，即使我们使用了“星投影”，也仍然可以通过调用 restaurant.orderFood()，来拿到 Food 类型的变量。在这里，food 的实际类型肯定是 Food 或者是 Food 的子类，因此我们可以将其看作是 Food 类型。</p><p>泛型虽然很抽象，但它存在的目的，仍然是为了解决我们生活的实际问题。所以，当我们将泛型应用到实际的生活场景时，它就显得不是那么抽象了。</p><h2 id="实战与思考"><a href="#实战与思考" class="headerlink" title="实战与思考"></a>实战与思考</h2><p>在学完型变以后，也许你会有点迷惑：<strong>到底什么时候用逆变，什么时候用协变</strong>？如果你看过 Kotlin 的官方文档，你会看到一句这样的话：</p><p><code>Consumer in, Producer out !</code></p><p>直译的话，大概意思就是：消费者 in，生产者 out。不过，这个对我们中国人的说话语境而言，不是那么好理解。让我们继续根据前面的遥控器、点外卖两个场景，来做个说明。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//              逆变</span></span><br><span class="line"><span class="comment">//               ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                 ①</span></span><br><span class="line"><span class="comment">//                 ↓</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">(tv: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//               协变</span></span><br><span class="line"><span class="comment">//                ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                   ②</span></span><br><span class="line"><span class="comment">//                   ↓</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">orderFood</span><span class="params">()</span></span>: T &#123; <span class="comment">/*..*/</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，分别是我们前面提到的逆变、协变的例子。把它们两个放到一起后，你应该就能很容易地发现它们两个的差别了。需要特别留意的地方，我都在注释当中标记出来了，让我来解释给你听：</p><ul><li>对于逆变的情况，我们模拟的是买遥控器的场景。请注意注释①的地方，我们的泛型 T，它最终会以函数的参数的形式，被<strong>传入</strong>函数的<strong>里面</strong>，这往往是一种<strong>写入</strong>行为，这时候，我们使用关键字 <strong>in</strong>。</li><li>对于协变的情况，我们模拟的是点外卖的场景。请注意注释②的地方，我们的泛型 T，它最终会以返回值的形式，被<strong>传出</strong>函数的<strong>外面</strong>，这往往是一种<strong>读取</strong>行为，这时候，我们使用关键字 out。</li></ul><p>所以，如果要以更加通俗的语言来解释逆变与协变的使用场景的话，我们可以将其总结为：<strong>传入 in，传出 out</strong>。或者，我们也可以说：泛型作为参数的时候，用 in，泛型作为<strong>返回值</strong>的时候，用 out。</p><p>我们再来看一下 Kotlin 源码当中型变的应用。首先，是逆变的应用。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                          逆变</span></span><br><span class="line"><span class="comment">//                           ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                                   泛型作为参数</span></span><br><span class="line"><span class="comment">//                                       ↓</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，由于泛型是作为了 compareTo 方法的<strong>参数</strong>传入的，因此，对于 Comparable 的泛型 T，我们应该使用 <strong>in</strong> 来修饰，这就是<strong>逆变</strong>的实际应用。</p><p>我们再来看看协变在 Kotlin 源码当中的应用。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                        协变</span></span><br><span class="line"><span class="comment">//                         ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                         泛型作为返回值</span></span><br><span class="line"><span class="comment">//                              ↓    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: T</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码里我们可以看到，由于泛型是作为 next 方法的<strong>返回值</strong>的，因此，对于 Iterator 的泛型 T，我们应该使用 <strong>out</strong> 来修饰，这就是<strong>协变</strong>的应用。</p><p>我们再来看看第 2 讲当中密封类的代码案例，一起回顾下当中的泛型细节：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;<span class="type">out R</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                     协变    ①</span></span><br><span class="line"><span class="comment">//                      ↓      ↓</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Success</span>&lt;<span class="type">out T</span>&gt;(<span class="keyword">val</span> <span class="keyword">data</span>: T, <span class="keyword">val</span> message: String = <span class="string">&quot;&quot;</span>) : Result&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> exception: Exception) : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Loading</span>(<span class="keyword">val</span> time: <span class="built_in">Long</span> = System.currentTimeMillis()) : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码里，我们对 Success 这个数据类的泛型参数使用了 out 来修饰，这就代表了协变。看到这里，如果你足够细心，就会觉得奇怪：这里为什么可以使用协变呢？前面我们不是说过：“泛型作为参数，用 in；泛型作为返回值，用 out”吗？<strong>这里并没有任何函数参数或者返回值啊</strong>？</p><p>其实，这里就又体现出了我们<strong>对 Kotlin 底层理解的重要性了</strong>。请注意我在上面标记的注释①，val 在 Kotlin 当中，代表不可变的变量，当它修饰类成员属性的时候，代表它只有 getter，没有 setter。当我们看到这样的代码时，我们要能自动脑补出 Success 反编译后的 Java 结构：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Success</span> <span class="title">extends</span> <span class="title">Result</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object <span class="keyword">data</span>;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// Success 这个类当中，是会有getter方法的</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Object getData() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">data</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们可以用 out 修饰 Success 泛型的原因，是因为 data 的 getter 方法，它本质上是一个返回 T 类型的方法。这时候，如果我们将注释①处的 val 改为 var，那么代码就会立马报错。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;<span class="type">out R</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                 改为var后，编译器就会立马报错</span></span><br><span class="line"><span class="comment">//                             ↓</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Success</span>&lt;<span class="type">out T</span>&gt;(<span class="keyword">var</span> <span class="keyword">data</span>: T, <span class="keyword">val</span> message: String = <span class="string">&quot;&quot;</span>) : Result&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> exception: Exception) : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Loading</span>(<span class="keyword">val</span> time: <span class="built_in">Long</span> = System.currentTimeMillis()) : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，有了前面的铺垫，我想你应该很快就能反应过来，编译器报错的原因是由于 var 修饰的成员属性，Kotlin 编译器会在背后生成对应 getter 和 setter，这个时候泛型参数<strong>既是“参数”也是“返回值”</strong>。所以，如果此时我们还用 out 修饰泛型 T，编译器就会报错了。</p><p>也就是说，如果泛型的 T，既是函数的参数类型，又是函数的返回值类型，那么，我们就无法直接使用 in 或者 out 来修饰泛型 T。</p><p>不过，<strong>函数传入参数的时候，并不一定就意味着写入</strong>，这时候，即使泛型 T 是作为参数类型，我们也仍然要想一些办法来用 out 修饰泛型。让我们拿一段官方源码来举例说明一下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                   协变    </span></span><br><span class="line"><span class="comment">//                    ↓      </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;<span class="type">out E</span>&gt; : <span class="type">Collection</span>&lt;<span class="type">E</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                                泛型作为返回值</span></span><br><span class="line"><span class="comment">//                                       ↓    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: E</span><br><span class="line"><span class="comment">//                                           泛型作为参数</span></span><br><span class="line"><span class="comment">//                                                 ↓    </span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"><span class="comment">//                                        泛型作为参数</span></span><br><span class="line"><span class="comment">//                                              ↓   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">indexOf</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 官方源码当中的 List，也就是这里的泛型 E，它既作为了返回值类型，又作为了参数类型。在正常情况下，如果我们用 out 修饰 E，那编译器是会报错的。但我们其实很清楚，对于 contains、indexOf 这样的方法，它们虽然以 E 作为参数类型，但本质上并没有产生写入的行为。所以，我们用 out 修饰 E 并不会带来实际的问题。</p><p>所以这个时候，我们就可以通过 @UnsafeVariance 这样的注解，来让编译器忽略这个型变冲突的问题。</p><p>另外，让我们再来看看第 5 讲当中提到过的单例抽象模板，一起回顾下当中的泛型细节：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                           逆变   协变</span></span><br><span class="line"><span class="comment">//                            ↓     ↓</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseSingleton</span>&lt;<span class="type">in P, out T</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                        ①</span></span><br><span class="line">    <span class="meta">@Volatile</span><span class="comment">//           ↓</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> instance: T? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//                              参数  返回值</span></span><br><span class="line">    <span class="comment">//                               ↓    ↓</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">val</span> creator: (P)-&gt; T</span><br><span class="line"></span><br><span class="line">    <span class="comment">//                    参数 返回值</span></span><br><span class="line">    <span class="comment">//                     ↓   ↓</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(param: <span class="type">P</span>)</span></span>: T =</span><br><span class="line">        instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            instance ?: creator(param).also &#123; instance = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个单例模板的例子当中，P 一直作为参数，而 T 则是作为返回值。因此我们用 in 来修饰 P，这就是逆变；对应的我们用 out 修饰 T，这就是协变。</p><p>不过，如果你足够细心的话，会发现注释①处还有一个 instance 是用泛型 T 修饰的。而它是 var 定义的成员变量，这就意味着，它既有 getter，又有 setter。那它为什么可以用协变的泛型 T 呢？其实，<strong>这是因为它是 private 的</strong>，如果你把 private 关键字删掉的话，上面的代码就会报错了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后，让我们来做一个总结吧。</p><ul><li><strong>泛型，是对程序的一种抽象</strong>。通过泛型，我们可以实现代码逻辑复用的目的，Kotlin 标准库当中很多源代码也都是借助泛型来实现的。</li><li>从<strong>型变的位置</strong>来分类的话，分为使用处型变和声明处型变。</li><li>从<strong>型变的父子关系</strong>来分类的话，分为逆变和协变。逆变表示父子关系颠倒了，而协变表示父子关系和原来一致。</li><li>型变的口诀：<strong>泛型作为参数，用 in；泛型作为返回值，用 out</strong>。在特殊场景下，同时作为参数和返回值的泛型参数，我们可以用 @UnsafeVariance 来解决型变冲突。</li><li><strong>星投影</strong>，就是当我们对泛型的具体类型不感兴趣的时候，直接传入一个“星号”作为泛型的实参。</li></ul><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/0e/2c/0e115b3b553ddf6c0bb3yyf7827fe42c.jpg?wh=2000x1528" alt="img" style="zoom:50%;" /><p>最后，我还想和你分享一下我学习 Kotlin 泛型的方法论。正如开头我提到的：程序是对真实世界的抽象，而泛型是对程序的抽象。由于泛型与我们真实世界差了两层抽象，这就导致我们很难理解泛型的本质。</p><p>所以，为了让泛型更加易懂，我的思路就是让泛型与我们的真实世界建立一种关联：<strong>直接拿泛型来模拟真实世界的场景</strong>，建立类比的关系。就比如我们今天所讲的：</p><ul><li>用万能遥控器，类比泛型；</li><li>用买遥控器的场景，类比逆变；</li><li>用点外卖的场景，类比协变、星投影。</li></ul><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/10/7a/102062dfdc96a48ae4f8c4671ff42e7a.jpg?wh=2000x808" alt="img" style="zoom:50%;" /><p>希望我的学习方法可以对你有所启发。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)09  委托：你为何总是被低估？</title>
      <link href="/posts/5db0fd8d/"/>
      <url>/posts/5db0fd8d/</url>
      
        <content type="html"><![CDATA[<p>今天我们来学习 Kotlin 的委托特性。</p><p>Kotlin 的委托主要有两个应用场景，一个是委托类，另一个是委托属性。对比第 6 讲我们学过的扩展来看的话，Kotlin 委托这个特性就没有那么“神奇”了。</p><p>因为扩展可以从类的外部，为一个类“添加”成员方法和属性，因此 Kotlin 扩展的应用场景也十分明确，而 Kotlin 委托的应用场景就没那么清晰了。这也是很多人会“重视扩展”，而“轻视委托”的原因。</p><p>然而，我要告诉你的是，Kotlin“委托”的重要性一点也不比“扩展”低。Kotlin 委托在软件架构中可以发挥巨大的作用，在掌握了 Kotlin 委托特性后，你不仅可以改善应用的架构，还可以大大提升开发效率。</p><p>另外，如果你是 Android 工程师，你会发现 Jetpack Compose 当中大量使用了 Kotlin 委托特性。可以说，如果你不理解委托，你就无法真正理解 Jetpack Compose。</p><p>看到这里，想必你也已经知道 Kotlin 委托的重要性了，接下来就来开启我们的学习之旅吧！</p><h2 id="委托类"><a href="#委托类" class="headerlink" title="委托类"></a>委托类</h2><p>我们先从委托类开始，它的使用场景非常简单易懂：它常常用于实现类的“委托模式”。我们来看个简单例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">DB</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlDB</span>() : DB &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">save</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;save to sql&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreenDaoDB</span>() : DB &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">save</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;save to GreenDao&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//               参数  通过 by 将接口实现委托给 db </span></span><br><span class="line"><span class="comment">//                ↓            ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UniversalDB</span>(db: DB) : DB <span class="keyword">by</span> db</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    UniversalDB(SqlDB()).save()</span><br><span class="line">    UniversalDB(GreenDaoDB()).save()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">save to sql</span></span><br><span class="line"><span class="comment">save to GreenDao</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上的代码当中，我们定义了一个 DB 接口，它的 save() 方法用于数据库存储，SqlDB 和 GreenDaoDB 都实现了这个接口。接着，我们的 UniversalDB 也实现了这个接口，同时通过 by 这个关键字，将接口的实现委托给了它的参数 db。</p><p>这种委托模式在我们的实际编程中十分常见，UniversalDB 相当于一个壳，它虽然实现了 DB 这个接口，但并不关心它怎么实现。具体是用 SQL 还是 GreenDao，传不同的委托对象进去，它就会有不同的行为。</p><p>另外，以上委托类的写法，等价于以下 Java 代码，我们可以再进一步来看下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UniversalDB</span> <span class="title">implements</span> <span class="title">DB</span> &#123;</span><br><span class="line">    DB db;</span><br><span class="line">    <span class="keyword">public</span> UniversalDB(DB db) &#123; <span class="keyword">this</span>.db = db; &#125;</span><br><span class="line">             <span class="comment">//  手动重写接口，将 save 委托给 db.save()</span></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//            ↓</span></span><br><span class="line">    <span class="keyword">public</span> void save() &#123; db.save(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码显示，save() 将执行流程委托给了传入的 db 对象。所以说，Kotlin 的委托类提供了<strong>语法层面的委托模式</strong>。通过这个 by 关键字，就可以自动将接口里的方法委托给一个对象，从而可以帮我们省略很多接口方法适配的模板代码。</p><p>委托类很好理解，下面让我们重点来看看 Kotlin 的委托属性。</p><h2 id="委托属性"><a href="#委托属性" class="headerlink" title="委托属性"></a>委托属性</h2><p>正如我们前面所讲的<strong>，Kotlin“委托类”委托的是接口方法，而“委托属性”委托的，则是属性的 getter、setter</strong>。在第 1 讲中，我们知道 val 定义的属性，它只有 get() 方法；而 var 定义的属性，既有 get() 方法，也有 set() 方法。</p><p>那么，属性的 getter、setter 委托出去以后，能有什么用呢？我们可以从 Kotlin 官方提供的标准委托那里找到答案。</p><h3 id="标准委托"><a href="#标准委托" class="headerlink" title="标准委托"></a>标准委托</h3><p>Kotlin 提供了好几种标准委托，其中包括两个属性之间的直接委托、by lazy 懒加载委托、Delegates.observable 观察者委托，以及 by map 映射委托。前面两个的使用频率比较高，后面两个频率比较低。这里，我们就主要来了解下前两种委托属性。</p><h3 id="将属性-A-委托给属性-B"><a href="#将属性-A-委托给属性-B" class="headerlink" title="将属性 A 委托给属性 B"></a>将属性 A 委托给属性 B</h3><p>从 Kotlin 1.4 开始，我们可以直接在语法层面将“属性 A”委托给“属性 B”，就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">//              ①  ②</span></span><br><span class="line">    <span class="comment">//              ↓   ↓</span></span><br><span class="line">    <span class="keyword">var</span> total: <span class="built_in">Int</span> <span class="keyword">by</span> ::count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码定义了两个变量，count 和 total，其中 total 的值与 count 完全一致，因为我们把 total 这个属性的 getter 和 setter 都委托给了 count。</p><p>注意，代码中的两处注释是关键：注释①，代表 total 属性的 getter、setter 会被委托出去；注释②，::count，代表 total 被委托给了 count。这里的“::count”是属性的引用，它跟我们前面学过的函数引用是一样的概念。</p><p>total 和 count 两者之间的委托关系一旦建立，就代表了它们两者的 getter 和 setter 会完全绑定在一起，如果要用代码来解释它们背后的逻辑，它们之间的关系会是这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 近似逻辑，实际上，底层会生成一个Item$total$2类型的delegate来实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> total: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = count</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span>(value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">            count = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是，当 total 的 get() 方法被调用时，它会直接返回 count 的值，也就意味着会调用 count 的 get() 方法；而当 total 的 set() 方法被调用时，它会将 value 传递给 count，也就意味着会调用 count 的 set() 方法。</p><p>也许你会好奇：Kotlin 1.4 提供的这个特性有啥用？为什么要分别定义 count 和 total？我们直接用 count 不好吗？</p><p>这个特性，其实对我们<strong>软件版本之间的兼容</strong>很有帮助。假设 Item 是服务端接口的返回数据，1.0 版本的时候，我们的 Item 当中只 count 这一个变量：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.0 版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而到了 2.0 版本的时候，我们需要将 count 修改成 total，这时候问题就出现了，如果我们直接将 count 修改成 total，我们的老用户就无法正常使用了。但如果我们借助委托，就可以很方便地实现这种兼容。我们可以定义一个新的变量 total，然后将其委托给 count，这样的话，2.0 的用户访问 total，而 1.0 的用户访问原来的 count，由于它们是委托关系，也不必担心数值不一致的问题。</p><p>好了，除了属性之间的直接委托以外，还有一种委托是我们经常会用到的，那就是懒加载委托。</p><h3 id="懒加载委托"><a href="#懒加载委托" class="headerlink" title="懒加载委托"></a>懒加载委托</h3><p>懒加载，顾名思义，就是对于一些需要消耗计算机资源的操作，我们希望它在被访问的时候才去触发，从而避免不必要的资源开销。前面第 5 讲学习单例的时候，我们就用到了 by lazy 的懒加载。其实，这也是软件设计里十分常见的模式，我们来看一个例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//            定义懒加载委托</span></span><br><span class="line"><span class="comment">//               ↓   ↓</span></span><br><span class="line"><span class="keyword">val</span> <span class="keyword">data</span>: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    request()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    println(<span class="string">&quot;执行网络请求&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;网络数据&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">开始</span><br><span class="line">执行网络请求</span><br><span class="line">网络数据</span><br><span class="line">网络数据</span><br></pre></td></tr></table></figure><p>通过“**by lazy{}**”，我们就可以实现属性的懒加载了。这样，通过上面的执行结果我们会发现：main() 函数的第一行代码，由于没有用到 data，所以 request() 函数也不会被调用。到了第二行代码，我们要用到 data 的时候，request() 才会被触发执行。到了第三行代码，由于前面我们已经知道了 data 的值，因此也不必重复计算，直接返回结果即可。</p><p>并且，如果你去看懒加载委托的源代码，你会发现，它其实是一个<strong>高阶函数</strong>：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(initializer: () -&gt; <span class="type">T</span>)</span></span>: Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(mode: <span class="type">LazyThreadSafetyMode</span>, initializer: () -&gt; <span class="type">T</span>)</span></span>: Lazy&lt;T&gt; =</span><br><span class="line">    <span class="keyword">when</span> (mode) &#123;</span><br><span class="line">        LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)</span><br><span class="line">        LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)</span><br><span class="line">        LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，lazy() 函数可以接收一个 LazyThreadSafetyMode 类型的参数，如果我们不传这个参数，它就会直接使用 SynchronizedLazyImpl 的方式。而且通过它的名字我们也能猜出来，它是为了多线程同步的。而剩下的 SafePublicationLazyImpl、UnsafeLazyImpl，则不是多线程安全的。</p><p>好了，除了这两种标准委托以外，Kotlin 也还提供了<a href="https://kotlinlang.org/docs/delegated-properties.html#observable-properties">Delegates.observable 观察者委</a>托、<a href="https://kotlinlang.org/docs/delegated-properties.html#storing-properties-in-a-map">by map 映射委托</a>，这两种委托比较简单，你可以点击这里给出的链接去了解它们的定义与用法。</p><h2 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h2><p>在学完 Kotlin 的标准委托以后，你也许会好奇<strong>：是否可以根据需求实现自己的属性委托呢</strong>？答案当然是可以的。</p><p>不过，为了自定义委托，我们必须遵循 Kotlin 制定的规则。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringDelegate</span>(<span class="keyword">private</span> <span class="keyword">var</span> s: String = <span class="string">&quot;Hello&quot;</span>) &#123;</span><br><span class="line"><span class="comment">//     ①                           ②                              ③</span></span><br><span class="line"><span class="comment">//     ↓                            ↓                               ↓</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Owner</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//      ①                          ②                                     ③ </span></span><br><span class="line"><span class="comment">//      ↓                           ↓                                      ↓</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Owner</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            s = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      ②</span></span><br><span class="line"><span class="comment">//      ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Owner</span> &#123;</span><br><span class="line"><span class="comment">//               ③</span></span><br><span class="line"><span class="comment">//               ↓     </span></span><br><span class="line">    <span class="keyword">var</span> text: String <span class="keyword">by</span> StringDelegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码一共有三套注释，我分别标注了①、②、③，其中注释①有两处，注释②有三处，注释③也有三处，相同注释标注出来的地方，它们之间存在密切的关联。</p><p>首先，看到两处注释①对应的代码，对于 var 修饰的属性，我们必须要有 getValue、setValue 这两个方法，同时，这两个方法必须有 <strong>operator</strong> 关键字修饰。</p><p>其次，看到三处注释②对应的代码，我们的 text 属性是处于 Owner 这个类当中的，因此 getValue、setValue 这两个方法中的 thisRef 的类型，必须要是 Owner，或者是 Owner 的父类。也就是说，我们将 thisRef 的类型改为 <strong>Any</strong> 也是可以的。一般来说，这三处的类型是一致的，当我们不确定委托属性会处于哪个类的时候，就可以将 thisRef 的类型定义为“Any?”。</p><p>最后，看到三处注释③对应的代码，由于我们的 text 属性是 String 类型的，为了实现对它的委托，getValue 的返回值类型，以及 setValue 的参数类型，<strong>都必须是 String 类型或者是它的父类</strong>。大部分情况下，这三处的类型都应该是一致的。</p><p>不过上面这段代码看起来还挺吓人的，刚开始的时候你也许会不太适应。但没关系，<strong>你只需要把它当作一个固定格式就行了</strong>。你在自定义委托的时候，只需要关心 3 个注释标注出来的地方即可。</p><p>而如果你觉得这样的写法实在很繁琐，也可以借助 Kotlin 提供的 ReadWriteProperty、ReadOnlyProperty 这两个接口，来自定义委托。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> ReadOnlyProperty<span class="type">&lt;in T, out V&gt;</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteProperty</span>&lt;<span class="type">in T, V</span>&gt; : <span class="type">ReadOnlyProperty</span>&lt;<span class="type">T, V</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">V</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要为 val 属性定义委托，我们就去实现 ReadOnlyProperty 这个接口；如果我们需要为 var 属性定义委托，我们就去实现 ReadWriteProperty 这个接口。这样做的好处是，通过实现接口的方式，IntelliJ 可以帮我们自动生成 override 的 getValue、setValue 方法。</p><p>以前面的代码为例，我们的 StringDelegate，也可以通过实现 ReadWriteProperty 接口来编写：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringDelegate</span>(<span class="keyword">private</span> <span class="keyword">var</span> s: String = <span class="string">&quot;Hello&quot;</span>): ReadWriteProperty&lt;Owner, String&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Owner</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Owner</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        s = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提供委托（provideDelegate）"><a href="#提供委托（provideDelegate）" class="headerlink" title="提供委托（provideDelegate）"></a>提供委托（provideDelegate）</h2><p>接着前面的例子，假设我们现在有一个这样的需求：我们希望 StringDelegate(s: String) 传入的初始值 s，可以根据委托属性的名字的变化而变化。我们应该怎么做？</p><p>实际上，要想在属性委托之前再做一些额外的判断工作，我们可以使用 <strong>provideDelegate</strong> 来实现。</p><p>看看下面的 SmartDelegator 你就会明白：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartDelegator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">provideDelegate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        thisRef: <span class="type">Owner</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        prop: <span class="type">KProperty</span>&lt;*&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: ReadWriteProperty&lt;Owner, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (prop.name.contains(<span class="string">&quot;log&quot;</span>)) &#123;</span><br><span class="line">            StringDelegate(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            StringDelegate(<span class="string">&quot;normal&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Owner</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> normalText: String <span class="keyword">by</span> SmartDelegator()</span><br><span class="line">    <span class="keyword">var</span> logText: String <span class="keyword">by</span> SmartDelegator()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> owner = Owner()</span><br><span class="line">    println(owner.normalText)</span><br><span class="line">    println(owner.logText)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">normal</span><br><span class="line">log</span><br></pre></td></tr></table></figure><p>可以看到，为了在委托属性的同时进行一些额外的逻辑判断，我们使用创建了一个新的 SmartDelegator，通过它的成员方法 provideDelegate 嵌套了一层，在这个方法当中，我们进行了一些逻辑判断，然后再把属性委托给 StringDelegate。</p><p>如此一来，通过 provideDelegate 这样的方式，我们不仅可以嵌套 Delegator，还可以根据不同的逻辑派发不同的 Delegator。</p><h2 id="实战与思考"><a href="#实战与思考" class="headerlink" title="实战与思考"></a>实战与思考</h2><p>至此，我们就算是完成了 Kotlin 委托的学习，包括委托类、委托属性，还有 4 种标准委托模式。除了这些之外，我们还学习了如何自定义委托属性，其中包括我们自己实现 getValue、setValue 两个方法，还有通过实现 ReadOnlyProperty、ReadWriteProperty 这两个接口。而对于更复杂的委托逻辑，我们还需要采用 provideDelegate 的方式，来嵌套 Delegator。这里，为了让你对 Kotlin 委托的应用场景有一个更清晰的认识，我再带你一起来看看几个 Android 的代码案例。</p><h3 id="案例-1：属性可见性封装"><a href="#案例-1：属性可见性封装" class="headerlink" title="案例 1：属性可见性封装"></a>案例 1：属性可见性封装</h3><p>在软件设计当中，我们会遇到这样的需求：对于某个成员变量 data，我们希望类的外部可以访问它的值，但不允许类的外部修改它的值。因此我们经常会写出类似这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span>: String = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment">// ①</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 网络请求</span></span><br><span class="line">        <span class="keyword">data</span> = <span class="string">&quot;请求结果&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请留意代码注释①处，我们将 data 属性的 set 方法声明为 private 的，这时候，data 属性的 set 方法只能从类的内部访问，这就意味着类的外部无法修改 data 的值了，但类的外部仍然可以访问 data 的值。</p><p>这样的代码模式很常见，我们在 Java&#x2F;C 当中也经常使用，不过当我们的 data 类型从 String 变成集合以后，问题就不一样了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: MutableList&lt;String&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 网络请求</span></span><br><span class="line">        <span class="keyword">data</span>.add(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> model = Model()</span><br><span class="line">    <span class="comment">// 类的外部仍然可以修改data</span></span><br><span class="line">    model.<span class="keyword">data</span>.add(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于集合而言，即使我们将其定义为只读变量 val，类的外部一旦获取到 data 的实例，它仍然可以调用集合的 add() 方法修改它的值。这个问题在 Java 当中几乎没有优雅的解法。只要你暴露了集合的实例给外部，外部就可以随意修改集合的值。这往往也是 Bug 的来源，这样的 Bug 还非常难排查。</p><p>而在这个场景下，我们前面学习的“两个属性之间的委托”这个语法，就可以派上用场了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: List&lt;String&gt; <span class="keyword">by</span> ::_data</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _data: MutableList&lt;String&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _data.add(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了两个变量，一个变量是公开的“data”，它的类型是 List，这是 Kotlin 当中不可修改的 List，它是没有 add、remove 等方法的。</p><p>接着，我们通过委托语法，将 data 的 getter 委托给了 _data 这个属性。而 _data 这个属性的类型是 MutableList，这是 Kotlin 当中的可变集合，它是有 add、remove 方法的。由于它是 private 修饰的，类的外部无法直接访问，通过这种方式，我们就成功地将修改权保留在了类的内部，而类的外部访问是不可变的 List，因此类的外部只能访问数据。</p><h3 id="案例-2：数据与-View-的绑定"><a href="#案例-2：数据与-View-的绑定" class="headerlink" title="案例 2：数据与 View 的绑定"></a>案例 2：数据与 View 的绑定</h3><p>在 Android 当中，如果我们要对“数据”与“View”进行绑定，我们可以用 DataBinding，不过 DataBinding 太重了，也会影响编译速度。其实，除了 DataBinding 以外，我们还可以借助 Kotlin 的自定义委托属性来实现类似的功能。这种方式不一定完美，但也是一个有趣的思路。</p><p>这里我们以 TextView 为例：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> TextView.<span class="title">provideDelegate</span><span class="params">(value: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span> = <span class="keyword">object</span> : ReadWriteProperty&lt;Any?, String?&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String? = text</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        text = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码，我们为 TextView 定义了一个扩展函数 TextView.provideDelegate，而这个扩展函数的返回值类型是 ReadWriteProperty。通过这样的方式，我们的 TextView 就相当于支持了 String 属性的委托了。</p><p>它的使用方式也很简单：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> textView = findViewById&lt;textView&gt;(R.id.textView)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ①</span></span><br><span class="line"><span class="keyword">var</span> message: String? <span class="keyword">by</span> textView</span><br><span class="line"></span><br><span class="line"><span class="comment">// ②</span></span><br><span class="line">textView.text = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">println(message)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ③</span></span><br><span class="line">message = <span class="string">&quot;World&quot;</span></span><br><span class="line">println(textView.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure><p>在注释①处的代码，我们通过委托的方式，将 message 委托给了 textView。这意味着，message 的 getter 和 setter 都将与 TextView 关联到一起。</p><p>在注释②处，我们修改了 textView 的 text 属性，由于我们的 message 也委托给了 textView，因此这时候，println(message) 的结果也会变成“Hello”。</p><p>在注释③处，我们改为修改 message 的值，由于 message 的 setter 也委托给了 textView，因此这时候，println(textView.text) 的结果会跟着变成“World”。</p><h3 id="案例-3：ViewModel-委托"><a href="#案例-3：ViewModel-委托" class="headerlink" title="案例 3：ViewModel 委托"></a>案例 3：ViewModel 委托</h3><p>在 Android 当中，我们会经常用到 ViewModel 来存储界面数据。同时，我们不会直接创建 ViewModel 的实例，而对应的，我们会使用委托的方式来实现。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// MainActivity.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mainViewModel: MainViewModel <span class="keyword">by</span> viewModels()</span><br></pre></td></tr></table></figure><p>这一行代码虽然看起来很简单，但它背后隐藏了 ViewModel 复杂的实现原理。为了不偏离本节课的主题，我们先抛开 ViewModel 的实现原理不谈。在这里，我们专注于研究 ViewModel 的委托是如何实现的。</p><p>我们先来看看 viewModels() 是如何实现的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> VM : ViewModel&gt;</span> ComponentActivity.<span class="title">viewModels</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">noinline</span> factoryProducer: (() -&gt; <span class="type">Factory</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Lazy&lt;VM&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> factoryPromise = factoryProducer ?: &#123;</span><br><span class="line">        defaultViewModelProviderFactory</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ViewModelLazy(VM::<span class="keyword">class</span>, &#123; viewModelStore &#125;, factoryPromise)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lazy</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> value: T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来，viewModels() 是 Activity 的一个扩展函数。也是因为这个原因，我们才可以直接在 Activity 当中直接调用 viewModels() 这个方法。</p><p>另外，我们注意到，viewModels() 这个方法的返回值类型是 Lazy，那么，它是如何实现委托功能的呢？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Lazy<span class="type">&lt;T&gt;</span>.<span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T = value</span><br></pre></td></tr></table></figure><p>实际上，<strong>Lazy</strong> 类在外部还定义了一个扩展函数 getValue()，这样，我们的只读属性的委托就实现了。而 Android 官方这样的代码设计，就再一次体现了<strong>职责划分、关注点分离</strong>的原则。Lazy 类只包含核心的成员，其他附属功能，以扩展的形式在 Lazy 外部提供。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后，让我们来做一个总结吧。</p><ul><li>委托类，委托的是<strong>接口的方法</strong>，它在语法层面支持了“委托模式”。</li><li>委托属性，委托的是属<strong>性的 getter、setter</strong>。虽然它的核心理念很简单，但我们借助这个特性可以设计出非常复杂的代码。</li><li>另外，Kotlin 官方还提供了几种标准的属性委托，它们分别是：两个属性之间的直接委托、by lazy 懒加载委托、Delegates.observable 观察者委托，以及 by map 映射委托；</li><li>两个属性之间的直接委托，它是 Kotlin 1.4 提供的新特性，它在<strong>属性版本更新、可变性封装上</strong>，有着很大的用处；</li><li>by lazy 懒加载委托，可以让我们灵活地使用<strong>懒加载</strong>，它一共有三种线程同步模式，默认情况下，它就是线程安全的；Android 当中的 viewModels() 这个扩展函数在它的内部实现的懒加载委托，从而实现了功能强大的 ViewModel；</li><li>除了标准委托以外，Kotlin 可以让我们开发者<strong>自定义委托</strong>。自定义委托，我们需要<strong>遵循 Kotlin 提供的一套语法规范</strong>，只要符合这套语法规范，就没问题；</li><li>在自定义委托的时候，如果我们有灵活的需求时，可以使用 <strong>provideDelegate</strong> 来动态调整委托逻辑。</li></ul><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/bd/2c/bd5668ecfb84e324f6239e7f24ddcf2c.jpg?wh=2000x1160" alt="img"></p><p>看到这里，相信你也发现了，Kotlin 当中看起来毫不起眼的委托，实际上它的功能是极其强大的，甚至可以说它比起<strong>扩展</strong>毫不逊色。其实，只是因为 Kotlin 的委托语法要比扩展更难一些，所以它的价值才更难被挖掘出来，进而也就容易被开发者所低估。</p><p>希望这节课的内容可以对你有所启发，也希望你可以将 Kotlin 强大的委托语法，应用到自己的工作当中去。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>这节课我们学习了 Kotlin 的委托语法，也研究了几个委托语法的使用场景，请问你还能想到哪些 Kotlin 委托的使用场景呢？欢迎在评论区分享你的思路，我们下节课再见。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)加餐一  初识Kotlin函数式编程</title>
      <link href="/posts/e851a3a2/"/>
      <url>/posts/e851a3a2/</url>
      
        <content type="html"><![CDATA[<p>在上一节实战课当中，我们算是用 Kotlin 实践了一把函数式编程的思想。不过，上节课我们其实只是浅尝辄止，也不完全算是函数式编程，咱们只是借鉴了它的思想。</p><p>函数式编程（Functional Programming），是一个跟“面向对象”类似的概念，它也是软件工程中的一种编程范式，它是声明式编程（Declarative Programming）的一种，而与它相反的，我们叫做命令式编程（Imperative Programming）。</p><p>虽然说，Kotlin 的函数式编程还不属于主流，但近几年它的关注度也越来越高了，所以今天我们就借着这节加餐，一起来简单聊聊 Kotlin 的函数式编程，也为上一节实战课做一个延伸。这样，等将来你想深入研究 Kotlin 函数式编程的时候，有了这节课的认知基础，也会更加轻松。</p><h2 id="函数式与命令式的区别"><a href="#函数式与命令式的区别" class="headerlink" title="函数式与命令式的区别"></a>函数式与命令式的区别</h2><p>那么，在介绍函数式编程之前，我们首先要来看几个编程范式的概念：声明式、命令式，还有四个常见的编程范式：函数式、逻辑式、面向过程、面向对象。它们之间的关系大致如下图所示：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/12/6a/12fe0504cd5329b2634a6b3746c0yy6a.jpg?wh=1920x1013" alt="img" style="zoom: 50%;" /><p>我们的校园里学习编程的时候，一般都是学的 C、Java，它们分别是面向过程语言、面向对象语言的代表，它们都属于“命令式”的范畴。</p><p>那么，想要理解“函数式”，我们首先就要理解什么是“命令式编程”，这是两种截然相反的编程范式。</p><p>所谓命令式编程，其实就是最常见的编程方式：<strong>在编程的时候，我们需要告诉计算机每一步具体都要干什么</strong>。比如说，我们要过滤集合当中所有的偶数，那么使用命令式编程的话，会需要以下几个步骤：</p><ul><li>使用 for 循环遍历集合；</li><li>在 for 循环当中，取出集合元素，并且判断它是否能够被 2 整除；</li><li>对于能被 2 整除的元素，我们将它们添加到新的集合当中；</li><li>最后，返回新的集合。</li></ul><p>具体来说，命令式的代码是这样的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> result = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如果是函数式，或者说“声明式”的代码呢？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fp</span><span class="params">()</span></span> = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><p>这段代码，我们是使用了 Kotlin 标准库当中的 filter 方法，它是一个高阶函数，作用就是过滤符合要求的集合元素并且返回。而具体的过滤要求呢，我们会在 Lambda 表达式里传进来。</p><p>由此我们也可以感受到，函数式风格的代码，它对比命令式的代码主要是有两个区别：</p><ul><li>第一个区别是：它只需要声明我们想要什么，而不必关心底层如何实现。</li><li>第二个区别是：代码更加简洁，可读性更高。</li></ul><p>在上节课的实战案例当中，我们 3.0 版本的词频统计程序，其实并没有完全发挥出 Kotlin 函数式编程的优势，因为其中的“getWordCount()”“mapToList()”都是我们自己实现的。事实上，我们完全可以借助 Kotlin 标准库函数来实现。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processText</span><span class="params">(text: <span class="type">String</span>)</span></span>: List&lt;WordFreq&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line">        .clean()</span><br><span class="line">        .split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        .filter &#123; it != <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        .groupBy &#123; it &#125;</span><br><span class="line">        .map &#123; WordFreq(it.key, it.value.size) &#125;</span><br><span class="line">        .sortedByDescending &#123; it.frequency &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这段代码我们可以看到，借助 Kotlin 库函数，我们用简单的几行代码，就成功实现了单词频率统计功能。这就是函数式编程的魅力。</p><p>要知道，我们 1.0 版本命令式的代码，足足有五十多行代码！这中间的差距是非常大的。</p><h2 id="到底什么是函数式编程？"><a href="#到底什么是函数式编程？" class="headerlink" title="到底什么是函数式编程？"></a>到底什么是函数式编程？</h2><p>那么，到底什么是函数式编程呢？函数式编程在数学理论上的定义很复杂，而对于我们初次接触 Kotlin 函数式编程来说，其实我们需要记住两个重点：</p><ul><li>函数是一等公民；</li><li>纯函数。</li></ul><p>而以这两个点作为延伸，我们就可以扩展出很多函数式编程的其他概念。比如说<strong>，函数是一等公民</strong>，这就意味着：</p><ul><li>函数可以独立于类之外，这就是 Kotlin 的顶层函数；</li><li>函数可以作为参数和返回值，这就是高阶函数和 Lambda；</li><li>函数可以像变量一样，这就是函数的引用；</li><li>当函数的功能更加强大以后，我们就可以几乎可以做到：只使用函数来解决所有编程的问题。</li></ul><p>再比如，对于<strong>纯函数</strong>的理解，这就意味着：</p><ul><li><p>函数不应该有副作用。所谓副作用，就是“对函数作用域以外的数据进行修改”，而这就引出了函数式的<strong>不变性</strong>。在函数式编程当中，我们不应该修改任何变量，当我们需要修改变量的时候，我们要创建一份新的拷贝再做修改，然后再使用它（这里，你是不是马上就想到了数据类的 copy 方法呢？）。</p></li><li><p>无副作用的函数，它具有<strong>幂等性</strong>，换句话说就是：函数调用一次和调用 N 次，它们的效果是等价的。</p></li><li><p>无副作用的函数，它具有引用透明的特性。</p></li><li><p>无副作用的函数，它具有<strong>无状态</strong>的特性。</p></li></ul><p>当然，函数式编程还有很多其他的特点，但是，在 Kotlin 当中，我们把握好“函数是一等公民”和“纯函数”这两个核心概念，就算初步理解了。</p><p>好，前面我们提到过，我们可以使用函数来解决所有编程问题，那么接下来，我们就来试试如何用函数来实现循环的功能吧。</p><h2 id="实战：函数式的循环"><a href="#实战：函数式的循环" class="headerlink" title="实战：函数式的循环"></a>实战：函数式的循环</h2><p>for 循环，是命令式编程当中最典型的语句。举个例子，我们想要计算从 1 到 10 的总和，使用 for 循环，我们很容易就可以写出这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">        result += i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很简单，我们定义了一个 result 变量，然后在 for 循环当中，将每一个数字与其相加，最后返回 result 这个变量作为结果。这很明显就是在告诉计算机每一步应该做什么，这其实也是它叫做命令式风格的原因。</p><p>那么，如果不使用 for 循环，仅仅只使用函数，我们该如何实现这样的功能呢？答案其实很简单，那就是递归。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recursionLoop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">go</span><span class="params">(i: <span class="type">Int</span>, sum: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>) sum <span class="keyword">else</span> go(i + <span class="number">1</span>, sum + i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> go(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码当中，我们可以看到，在 recursionLoop() 这个函数当中，我们定义了一个内部的函数 go()，它才是我们实现递归的核心函数。</p><p>在函数式编程当中，请不要觉得这种代码很奇怪，<strong>毕竟咱们函数都是一等公民了，类的内部可以继续嵌套内部类，那函数里面为什么就不可以嵌套一个内部的函数呢？</strong></p><p>实际上，在函数式编程当中，我们有时候也会<strong>使用递归来替代循环</strong>。我们知道，递归都是有调用栈开销的，所以我们应该尽量使用尾递归。对于这种类型的递归，在经过栈复用优化以后，它的开销就可以忽略不计了，我们可以认为它的空间复杂度是 O(1)。</p><p>实际上，在函数式编程当中，我们有时候也会使用<strong>递归来替代循环</strong>。我们知道，递归都是有调用栈开销的，所以我们应该尽量使用<a href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8#%E5%B0%BE%E9%80%92%E5%BD%92">尾递归</a>。对于这种类型的递归，在经过栈复用优化以后，它的开销就可以忽略不计了，我们可以认为它的空间复杂度是 O(1)。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recursionLoop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">// 变化在这里</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line">    <span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">go</span><span class="params">(i: <span class="type">Int</span>, sum: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>) sum <span class="keyword">else</span> go(i + <span class="number">1</span>, sum + i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> go(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上面的递归思路只是为了说明我们可以用它替代循环。在实际的开发工作中，这种方式是不推荐的，毕竟它太绕了，对吧？如果要在工作中实现类似的需求，我们使用 Kotlin 集合操作符一行代码就能搞定：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reduce</span><span class="params">()</span></span> = (<span class="number">1.</span><span class="number">.10</span>).reduce &#123; acc, i -&gt; acc + i &#125; <span class="comment">// 结果 55</span></span><br></pre></td></tr></table></figure><p>这里的 reduce 操作符也许你会觉得难以理解，没关系，Kotlin 还为我们提供了另一个更简单的操作符，也就是 sum：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">()</span></span> = (<span class="number">1.</span><span class="number">.10</span>).sum() <span class="comment">// 结果 55</span></span><br></pre></td></tr></table></figure><p>在这里，我们也能发现一些问题：<strong>使用 Kotlin，我们运用不同的思维，可以写出截然不同的 4 种代码</strong>。而即使同样都是函数式的思想的 3 种代码，它们之间的可读性也有很大的差异。</p><p>otlin 官方一直宣扬自己是支持多种编程范式的语言，它不像某些语言，会强制你使用某种编程范式（比如 C、Haskell 等）。这样一来，面对不同的问题，我们开发者就可以灵活选择不同的范式进行编程。</p><p>而且，Kotlin 也没有完全拥抱函数式编程，它只是在一些语法设计上，借鉴了函数式编程的思想，而且这种借鉴的行为也十分克制，比如<a href="https://zh.wikipedia.org/zh-hans/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">模式匹配</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B1%BB">类型类</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)">单子</a>。另外，函数式编程领域的很多高级概念，Kotlin 也都没有天然支持，需要我们开发者自己去实现。对比起其他 JVM 的现代语言（如Scala），<strong>Kotlin 也显得更加务实，有点“博采众长”的意味。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Kotlin 作为一门刚出生不久的语言，它融合了很多现代化语言的特性，它在支持命令式编程的同时呢，也对“函数式编程”有着天然的亲和力。</p><p>命令式编程与函数式编程，它们之间本来就各有优劣。</p><p>函数式编程的优点在于，在部分场景下，它的开发效率高、可读性强，以及由于不变性、无状态等特点，更适合并发编程。而函数式编程的劣势也很明显，它的学习曲线十分陡峭、反直觉，由于自身特性的限制，往往会导致性能更差。所以，Kotlin 函数式编程目前仍未成为主流，这是有一定道理的。</p><p>不过，随着 2021 年 Android 推出 Jetpack Compose 声明式 UI 框架，以及 Kotlin 官方推出的 Compose Multiplatform 以后，Kotlin 函数式编程的关注度也被推向了一个前所未有的高度。总的来说，Kotlin 函数式编程是一个非常大的话题，它自身就足够写一个完整的专栏了。如果有机会的话，我们在课程后面，还会再来详细聊聊 Kotlin 函数式编程在 Compose 当中的体现。</p><p>我相信，在不久的将来，Kotlin 函数式编程的方式，一定会被更多的人认可和接受。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>今天，咱们从“编程范式”聊到了 Kotlin 函数式编程，也请你说说你对“编程范式”以及“函数式编程”的理解吧。这个问题没有标准答案，请畅所欲言吧！</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)08  实战：用Kotlin写一个英语词频统计程序</title>
      <link href="/posts/90cef85a/"/>
      <url>/posts/90cef85a/</url>
      
        <content type="html"><![CDATA[<p>前面几节课，我们学了一些 Kotlin 独有的特性，包括扩展、高阶函数等等。虽然我在前面的几节课当中都分别介绍了这些特性的实际应用场景，但那终归不够过瘾。因此，这节课我们来尝试将这些知识点串联起来，一起来写一个“单词词频统计程序”。</p><p>英语单词的频率统计，有很多实际应用场景，比如高考、研究生考试、雅思考试，都有对应的“高频词清单”，考生优先突破这些高频词，可以大大提升备考效率。那么这个高频词是如何统计出来的呢？当然是通过计算机统计出来的。只是，我们的操作系统并没有提供这样的程序，想要用这样的功能，我们必须自己动手写。</p><p>而这节课，我将带你用 Kotlin 写一个单词频率统计程序。为了让你更容易理解，我们的程序同样会分为三个版本。</p><ul><li><strong>1.0 版本</strong>：实现频率统计基本功能，使用“命令式风格”的代码。</li><li><strong>2.0 版本</strong>：利用扩展函数、高阶函数来优化代码，实现“函数式风格”的代码。</li><li><strong>3.0 版本</strong>：使用 inline 进一步提升软件的性能，并分析高阶函数的实现原理，以及 inline 到底能带来多大的性能提升。</li></ul><p>在正式开始学习之前，我也建议你去 clone 我 GitHub 上面的 TextProcessor 工程：<a href="https://github.com/chaxiu/TextProcessor.git%EF%BC%8C%E7%84%B6%E5%90%8E%E7%94%A8">https://github.com/chaxiu/TextProcessor.git，然后用</a> IntelliJ 打开，并切换到 start 分支跟着课程一步步敲代码。</p><h2 id="1-0-版本：命令式风格"><a href="#1-0-版本：命令式风格" class="headerlink" title="1.0 版本：命令式风格"></a>1.0 版本：命令式风格</h2><p>在正式开始写代码之前，我们先看看程序运行之后是什么样的，一起来分析一下整体的编程思路：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/57/66/5757bb50b199c4e3faafd8ba8791e866.gif?wh=2182x1362" alt="img"></p><p>首先，我们的词频统计程序是一个类，“TextProcessorV1”，这是第一个版本的类名称。text 是需要被统计的一段测试文本。</p><p>所以，我们很容易就能写出这样的代码结构：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextProcessorV1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">processText</span><span class="params">(text: <span class="type">String</span>)</span></span>: List&lt;WordFreq&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">WordFreq</span>(<span class="keyword">val</span> word: String, <span class="keyword">val</span> frequency: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>这段代码中，我们定义了一个方法 processText，它接收的参数类型是 String，返回值类型是 List。与此同时，我们还定义了一个数据类 WordFreq，它里面有两个属性，分别是 word 和对应的频率 frequency。</p><p>所以，这个程序最关键的逻辑都在 <strong>processText</strong> 这个方法当中。</p><p>接下来我们以一段简短的英语作为例子，看看整体的统计步骤是怎样的。我用一张图来表示：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/95/0c/950672a2d7629a47b313aa77636afd0c.jpg?wh=900x1212" alt="img" style="zoom:50%;" /><p>上面的流程图一共分为 4 个步骤：</p><ul><li>步骤 1，<strong>文本清洗</strong>。正常的英语文本当中是会有很多标点符号的，比如“.”“！”，而标点符号是不需要被统计进来的。所以，在进行词频统计之前，我们还需要对文本数据进行清洗。这里的做法是将标点符号替换成空格。</li><li>步骤 2，<strong>文本分割</strong>。有了步骤 1 作为基础，我们的英语文本当中除了单词之外，就都是空格了。所以，为了分割出一个个单词，我们只需要以空格作为分隔符，对整个文本进行分割即可。在这个过程中，我们的文本数据就会变成一个个单词组成的列表，也就是 List 类型。</li><li>步骤 3，<strong>统计单词频率</strong>。在上个步骤中，我们已经得到了单词组成的 List，但这个数据结构并不适合做频率统计。为了统计单词频率，我们要借助 Map 这个数据结构。我们可以通过遍历 List 的方式，将所有单词都统计一遍，并将“单词”与“频率”以成对的方式存储在 Map 当中。</li><li>步骤 4，<strong>词频排序</strong>。在步骤 3 中，我们得到的词频数据是无序的，但实际场景中，频率越高的单词越重要，因此我们希望高频词可以放在前面，低频词则放在后面。</li></ul><p>经过以上分析，我们就能进一步完善 processText() 方法当中的结构了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextProcessorV1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">processText</span><span class="params">(text: <span class="type">String</span>)</span></span>: List&lt;WordFreq&gt; &#123;</span><br><span class="line">        <span class="comment">// 步骤1</span></span><br><span class="line">        <span class="keyword">val</span> cleaned = clean(text)</span><br><span class="line">        <span class="comment">// 步骤2</span></span><br><span class="line">        <span class="keyword">val</span> words = cleaned.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="comment">// 步骤3</span></span><br><span class="line">        <span class="keyword">val</span> map = getWordCount(words)</span><br><span class="line">        <span class="comment">// 步骤4</span></span><br><span class="line">        <span class="keyword">val</span> list = sortByFrequency(map)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，步骤 2 的逻辑很简单，我们直接使用 Kotlin 标准库提供的 <strong>split()</strong> 就可以实现空格分割。其余的几个步骤 1、3、4，则是由单独的函数来实现。所以下面，我们就来分析下 clean()、getWordCount()、sortByFrequency() 这几个方法该如何实现。</p><h3 id="文本清洗"><a href="#文本清洗" class="headerlink" title="文本清洗"></a>文本清洗</h3><p>首先，是文本清洗的方法 clean() 方法。</p><p>经过分析，现在我们知道针对一段文本数据，我们需要将其中的标点符号替换成空格：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                            标点            标点</span></span><br><span class="line"><span class="comment">// 清洗前                       ↓              ↓</span></span><br><span class="line"><span class="string">&quot;Kotlin is my favorite language. I love Kotlin!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                            空格            空格</span></span><br><span class="line"><span class="comment">// 清洗后                       ↓              ↓</span></span><br><span class="line"><span class="string">&quot;Kotlin is my favorite language  I love Kotlin &quot;</span></span><br></pre></td></tr></table></figure><p>那么对于这样的逻辑，我们很容易就能写出以下代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">clean</span><span class="params">(text: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;!&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .trim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码对于前面这种简单文本是没问题的，但这样的方式存在几个明显的问题。</p><p>第一个问题是<strong>普适性差</strong>。在复杂的文本当中，标点符号的类型很多，比如“,”“?”等标点符号。为了应对这样的问题，我们不得不尝试去枚举所有的标点符号：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">clean</span><span class="params">(text: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;!&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;,&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;?&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;*&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;#&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;@&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .trim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么随之而来的第二个问题，就是<strong>很容易出错</strong>，因为我们可能会遗漏枚举的标点符号。第三个问题则是<strong>性能差</strong>，随着枚举情况的增加，replace 执行的次数也会增多。</p><p>因此这个时候，我们必须要换一种思路，正则表达式就是一个不错的选择：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">clean</span><span class="params">(text: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="string">&quot;[^A-Za-z]&quot;</span>.toRegex(), <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .trim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的正则表达式的含义就是，<strong>将所有不是英文字母的字符都统一替换成空格</strong>（为了不偏离主题，这里我们不去深究正则表达式的细节）。</p><p>这样，数据清洗的功能完成以后，我们就可以对文本进行切割了，这个步骤通过 split() 就能实现。在经过分割以后，我们就得到了单词的列表。接下来，我们就需要进行词频统计 getWordCount() 了。</p><h3 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h3><p>在 getWordCount() 这个方法当中，我们需要用到 Map 这个数据结构。如果你不了解这个数据结构也不必紧张，我制作了一张动图，描述 getWordCount() 的工作流程。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/43/46/43598fd9f2d476f9ffa717dba38cd846.gif?wh=720x405" alt="img"></p><p>看过上面的 Gif 动图以后，相信你对词频统计的实现流程已经心中有数了。其实它就是跟我们生活中做统计一样，遇到一个单词，就把这个单词的频率加一就行。只是我们生活中是用本子和笔来统计，而这里，我们用程序来做统计。</p><p>那么，根据这个流程，我们就可以写出以下这样的频率统计的代码了，这里面主要用了一个 Map 来存储单词和它对应频率：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getWordCount</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: Map&lt;String, <span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> map = hashMapOf&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (word <span class="keyword">in</span> list) &#123;</span><br><span class="line">        <span class="comment">// ①</span></span><br><span class="line">        <span class="keyword">if</span> (word == <span class="string">&quot;&quot;</span>) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">val</span> trim = word.trim()</span><br><span class="line">        <span class="comment">// ②</span></span><br><span class="line">        <span class="keyword">val</span> count = map.getOrDefault(trim, <span class="number">0</span>)</span><br><span class="line">        map[trim] = count + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码一共有两处需要注意，我们一个个看：</p><ul><li>注释①，当我们将标点符号替换成空格以后，两个连续的空格进行分割后会出现空字符””，这是脏数据，我们需要将其过滤掉。</li><li>注释②，map.getOrDefault 是 Map 提供的一个方法，如果当前 map 中没有对应的 Key，则返回一个默认值。这里我们设置的默认值为 0，方便后面的代码计数。</li></ul><p>这样，通过 Map 这个数据结构，我们的词频统计就实现了。而因为 Map 是无序的，所以我们还需要对统计结果进行排序。</p><h2 id="词频排序"><a href="#词频排序" class="headerlink" title="词频排序"></a>词频排序</h2><p>那么到这里，我们就又要将无序的数据结构换成有序的。这里我们选择 List，因为 List 是有序的集合。但由于 List 每次只能存储单个元素，为了同时存储“单词”与“频率”这两个数据，我们需要用上前面定义的<strong>数据类 WordFreq</strong>：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sortByFrequency</span><span class="params">(map: <span class="type">Map</span>&lt;<span class="type">String</span>, <span class="built_in">Int</span>&gt;)</span></span>: MutableList&lt;WordFreq&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableListOf&lt;WordFreq&gt;()</span><br><span class="line">    <span class="keyword">for</span> (entry <span class="keyword">in</span> map) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.key == <span class="string">&quot;&quot;</span>) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">val</span> freq = WordFreq(entry.key, entry.value)</span><br><span class="line">        <span class="comment">// ①</span></span><br><span class="line">        list.add(freq)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    list.sortByDescending &#123;</span><br><span class="line">        it.frequency</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分的排序代码其实思路很简单：</p><ul><li>注释①处，我们将 Map 当中的词频数据，封装到 WordFreq 数据类当中，并且添加到了 List 当中，这样就将所有的信息都放到了一个有序的集合当中来了；</li><li>注释②处，我们调用了 Kotlin 标准库提供的排序方法“sortByDescending”，它代表了以词频降序排序。</li></ul><p>到这里，我们的 1.0 版本就算是完成了，按照惯例，我们可以写一个单元测试来看看代码运行结果是否符合预期。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/a4/yy/a4d2e9c146517e984bf17a6dfbc403yy.gif?wh=2182x1362" alt="img" style="zoom: 50%;" /><p>由于我们的测试文本很简单，我们一眼就能分析出正确的结果。其中单词“Kotlin”出现的频率最高，是 2 次，它会排在 result 的第一位。所以，我们可以通过断言来编写以上的测试代码。最终单元测试的结果，也显示我们的代码运行结果符合预期。</p><p>这时候，你也许会想：测试的文本数据太短了，<strong>如果数据量再大一些，程序是否还能正常运行呢</strong>？</p><p>其实，我们可以让程序支持统计文件当中的单词词频，要实现这个功能也非常简单，就是利用我们在第 6 讲学过的扩展方法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processFile</span><span class="params">(file: <span class="type">File</span>)</span></span>: List&lt;WordFreq&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> text = file.readText(Charsets.UTF_8)</span><br><span class="line">    <span class="keyword">return</span> processText(text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以看到，readText() 就是 Kotlin 标准库里提供的一个扩展函数，它可以让我们非常方便地从文件里读取文本。增加这样一行代码，我们的程序就能够统计文件当中的单词频率了。</p><h2 id="2-0-版本：函数式风格"><a href="#2-0-版本：函数式风格" class="headerlink" title="2.0 版本：函数式风格"></a>2.0 版本：函数式风格</h2><p>好，下面我们就一起来实现下第二个版本的词频统计程序。这里，我想先带你回过头来看看咱们 1.0 版本当中的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextProcessorV1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">processText</span><span class="params">(text: <span class="type">String</span>)</span></span>: List&lt;WordFreq&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> cleaned = clean(text)</span><br><span class="line">        <span class="keyword">val</span> words = cleaned.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> map = getWordCount(words)</span><br><span class="line">        <span class="keyword">val</span> list = sortByFrequency(map)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是觉得咱们的代码实在太整齐了？甚至整齐得有点怪怪的？而且，我们定义的临时变量 cleaned、words、map、list 都只会被用到一次。</p><p>其实上面的代码，就是很明显地在用 Java 思维写 Kotlin 代码。这种情况下，我们甚至可以省略掉中间所有的临时变量，将代码缩减成这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processText</span><span class="params">(text: <span class="type">String</span>)</span></span>: List&lt;WordFreq&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> sortByFrequency(getWordCount(clean(text).split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，很明显的是，以上代码的可读性并不好。在开篇词当中，我曾提到过，Kotlin 既有<strong>命令式</strong>的一面，也有函数式的一面，它们有着各自擅长的领域。而在这里，我们就完全可以借助<a href="https://zh.wikipedia.org/zh/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a>的思想来优化代码，就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processText</span><span class="params">(text: <span class="type">String</span>)</span></span>: List&lt;WordFreq&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line">        .clean()</span><br><span class="line">        .split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        .getWordCount()</span><br><span class="line">        .sortByFrequency &#123; WordFreq(it.key, it.value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这段代码从上读到下，可读性非常高，它也非常接近我们说话的习惯：我们拿到参数 text，接着对它进行清洗 clean()，然后对单词频率进行统计，最后根据词频进行排序。</p><p>那么，我们要如何修改 1.0 版本的代码，才能实现这样的代码风格呢？<strong>问题的关键还是在于 clean()、getWordCount()、sortByFrequency() 这几个方法。</strong></p><p>我们一个个来分析。首先是 text.clean()，为了让 String 能够直接调用 clean() 方法，我们必须将 clean() 定义成<strong>扩展函数</strong>：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 原函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">clean</span><span class="params">(text: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="string">&quot;[^A-Za-z]&quot;</span>.toRegex(), <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .trim()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">clean</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="string">&quot;[^A-Za-z]&quot;</span>.toRegex(), <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .trim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以清晰地看到普通函数转换为扩展函数之间的差异：</p><ul><li>原本的参数类型 String，在转换成扩展函数后，就变成了“接收者类型”；</li><li>原本的参数 text，变成了扩展函数的 this。</li></ul><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/d2/59/d27f98fe4234c10a14bd18c7770b8f59.gif?wh=720x405" alt="img"></p><p>对应的，我们的 getWordCount() 方法也同样可以修改成扩展函数的形式。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> List<span class="type">&lt;String&gt;</span>.<span class="title">getWordCount</span><span class="params">()</span></span>: Map&lt;String, <span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> map = HashMap&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element == <span class="string">&quot;&quot;</span>) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">val</span> trim = element.trim()</span><br><span class="line">        <span class="keyword">val</span> count = map.getOrDefault(trim, <span class="number">0</span>)</span><br><span class="line">        map[trim] = count + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你能看到，原本是作为参数的 List，现在同样变成了接收者类型，原本的参数 list 集合变成了 this。</p><p>最后是 sortByFrequency()，我们很容易就能写出类似下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Map<span class="type">&lt;String, Int&gt;</span>.<span class="title">sortByFrequency</span><span class="params">()</span></span>: MutableList&lt;WordFreq&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableListOf&lt;WordFreq&gt;()</span><br><span class="line">    <span class="keyword">for</span> (entry <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> freq = WordFreq(entry.key, entry.value)</span><br><span class="line">        list.add(freq)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list.sortByDescending &#123;</span><br><span class="line">        it.frequency</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的步骤，将参数类型变成“接收者类型”，将参数变成 this。不过，这里的做法并不符合函数式编程的习惯，因为这个方法明显包含两个功能：</p><ul><li>功能 1，将 Map 转换成 List；</li><li>功能 2，使用 sort 对 List 进行排序。</li></ul><p>因此针对这样的情况，我们应该再对这个方法进行拆分：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Map<span class="type">&lt;String, Int&gt;</span>.<span class="title">mapToList</span><span class="params">(transform: (<span class="type">Map</span>.<span class="type">Entry</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;) -&gt; <span class="type">T</span>)</span></span>: MutableList&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableListOf&lt;T&gt;()</span><br><span class="line">    <span class="keyword">for</span> (entry <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> freq = transform(entry)</span><br><span class="line">        list.add(freq)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码当中，为了让 Map 到 List 的转换更加得灵活，我们引入了高阶函数，它的参数 transform 是函数类型的参数。那么相应的，我们的调用处代码也需要做出改变，也就是传入一个 Lambda 表达式：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processText</span><span class="params">(text: <span class="type">String</span>)</span></span>: List&lt;WordFreq&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line">        .clean()</span><br><span class="line">        .split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        .getWordCount()</span><br><span class="line">        .mapToList &#123; WordFreq(it.key, it.value) &#125;</span><br><span class="line">        .sortedByDescending &#123; it.frequency &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看着上面的代码，我们几乎可以像读普通的英语文本一般地阅读上面的代码：首先是对 text 进行清理；然后使用 split 以空格形式进行分割；接着计算出单词的频率，然后再将无序的 Map 转换成 List；最后对 List 进行排序，排序的依据就是词频降序。</p><p>至此，我们的 2.0 版本就算完成了。让我们再次执行一次单元测试，看看我们的代码逻辑是否正确：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/7c/y3/7cb66e38089f63b82a136316233a3yy3.gif?wh=2182x1362" alt="img" style="zoom: 50%;" /><p>单元测试的结果告诉我们，代码运行结果符合预期。接下来，我们就可以进行 3.0 版本的开发工作了。</p><h2 id="3-0-版本：inline-优化"><a href="#3-0-版本：inline-优化" class="headerlink" title="3.0 版本：inline 优化"></a>3.0 版本：inline 优化</h2><p>在上一个版本当中，我们的 mapToList 被改造成了一个高阶函数。那到了这个版本，我们实际的代码量其实很少，只需要为 mapToList 这个高阶函数增加一个 inline 关键字即可。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  增加inline关键字</span></span><br><span class="line"><span class="comment">//        ↓</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Map<span class="type">&lt;String, Int&gt;</span>.<span class="title">mapToList</span><span class="params">(transform: (<span class="type">Map</span>.<span class="type">Entry</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;) -&gt; <span class="type">T</span>)</span></span>: MutableList&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableListOf&lt;T&gt;()</span><br><span class="line">    <span class="keyword">for</span> (entry <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> freq = transform(entry)</span><br><span class="line">        list.add(freq)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们 3.0 版本的开发工作其实就完成了。</p><p>但是你要清楚，虽然我们只花几秒钟就能增加这个 inline 关键字，可我们这么做的原因却比较复杂。这涉及到 <strong>inline 关键字的实现原理</strong>。</p><p>不过，在正式研究 inline 之前，我们要先来了解下高阶函数的实现原理。由于 Kotlin 兼容 Java 1.6，因此 JVM 是不懂什么是高阶函数的，我们的高阶函数最终一定会被编译器转换成 JVM 能够理解的格式。</p><p>而又因为，我们的词频统计代码略微有些复杂，所以为了更好地研究高阶函数的原理，这里我们可以先写一个简单的高阶函数，然后看看它反编译后的代码长什么样。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// HigherOrderExample.kt</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    foo&#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码经过反编译成 Java 后，会变成这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HigherOrderExampleKt</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Function0 block)</span> &#123;</span><br><span class="line">      block.invoke();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">      foo((Function0)(<span class="keyword">new</span> <span class="title class_">Function0</span>() &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">()</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Kotlin 高阶函数当中的函数类型参数，变成了 Function0，而 main() 函数当中的高阶函数调用，也变成了“匿名内部类”的调用方式。那么，Function0 又是个什么东西？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function0</span>&lt;<span class="type">out R</span>&gt; : <span class="type">Function</span>&lt;<span class="type">R</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span>: R</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Function0 其实是 Kotlin 标准库当中定义的接口，它代表没有参数的函数类型。在<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/functions/Functions.kt">Functions.kt</a>这个文件当中，Kotlin 一共定义了 23 个类似的接口，从 Function0 一直到 Function22，分别代表了“无参数的函数类型”到“22 个参数的函数类型”。</p><p>好，现在，我们已经知道 Kotlin 高阶函数是如何实现的了，接下来我们看看使用 inline 优化过的高阶函数会是什么样的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// HigherOrderInlineExample.kt</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多了一个关键字</span></span><br><span class="line"><span class="comment">   ↓                                    */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">fooInline</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    fooInline&#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面的例子唯一的不同点在于，我们在 foo() 函数的定义处增加了一个 inline 关键字，同时，为了区分，我们也改了一下函数的名称。这个时候，我们再来看看它反编译后的 Java 长什么样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HigherOrderInlineExampleKt</span> &#123;</span><br><span class="line">   <span class="comment">// 没有变化</span></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> void fooInline(Function0 block) &#123;</span><br><span class="line">      block.invoke();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">      <span class="comment">// 差别在这里</span></span><br><span class="line">      int i = <span class="number">0</span>;</span><br><span class="line">      int i = i + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了看得更加清晰，我们将有无 inline 的 main() 放到一起来对比下：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/de/c8/de4c7c3ee9b93c60ca93ab4074db78c8.png?wh=1920x1080" alt="img"></p><p>所以你能发现，<strong>inline 的作用其实就是将 inline 函数当中的代码拷贝到调用处</strong>。</p><p>而是否使用 inline，main() 函数会有以下两个区别：</p><ul><li>在不使用 inline 的情况下，我们的 main() 方法当中，需要调用 foo() 这个函数，这里多了一次函数调用的开销。</li><li>在不使用 inline 的情况下，调用 foo() 函数时，还创建了“Function0”的匿名内部类对象，这也是额外的开销。</li></ul><p>为了验证这一猜测，我们可以使用<a href="https://github.com/openjdk/jmh">JMH</a>（Java Microbenchmark Harness）对这两组代码进行性能测试。JMH 这个框架可以最大程度地排除外界因素的干扰（比如内存抖动、虚拟机预热），从而判断出我们这两组代码执行效率的差异。它的结果不一定非常精确，但足以说明一些问题。</p><p>不过，为了不偏离本节课的主题，在这里我们不去深究 JMH 的使用技巧，而是只以两组测试代码为例，来探究下 inline 到底能为我们带来多少性能上的提升：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 不用inline的高阶函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123; </span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用inline的高阶函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">fooInline</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123; </span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试无inline的代码</span></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testNonInlined</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    foo &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试无inline的代码</span></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testInlined</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    fooInline &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的测试结果如下，分数越高性能越好：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Benchmark       Mode         Score       Error   Units</span><br><span class="line">testInlined     thrpt   <span class="number">3272062.466</span> ± <span class="number">67403.033</span>  ops/ms</span><br><span class="line">testNonInlined  thrpt    <span class="number">355450.945</span> ± <span class="number">12647.220</span>  ops/ms</span><br></pre></td></tr></table></figure><p>从上面的测试结果我们能看出来，是否使用 inline，它们之间的效率几乎相差 10 倍。而这还仅仅只是最简单的情况，如果在一些复杂的代码场景下，多个高阶函数嵌套执行，它们之间的执行效率会相差上百倍。</p><p>为了模拟复杂的代码结构，我们可以简单地将这两个函数分别嵌套 10 个层级，然后看看它们之间的性能差异：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 模拟复杂的代码结构，这是错误示范，请不要在其他地方写这样的代码。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testNonInlined</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    foo &#123;</span><br><span class="line">        foo &#123;</span><br><span class="line">            foo &#123;</span><br><span class="line">                foo &#123;</span><br><span class="line">                    foo &#123;</span><br><span class="line">                        foo &#123;</span><br><span class="line">                            foo &#123;</span><br><span class="line">                                foo &#123;</span><br><span class="line">                                    foo &#123;</span><br><span class="line">                                        foo &#123;</span><br><span class="line">                                            i++</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testInlined</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    fooInline &#123;</span><br><span class="line">        fooInline &#123;</span><br><span class="line">            fooInline &#123;</span><br><span class="line">                fooInline &#123;</span><br><span class="line">                    fooInline &#123;</span><br><span class="line">                        fooInline &#123;</span><br><span class="line">                            fooInline &#123;</span><br><span class="line">                                fooInline &#123;</span><br><span class="line">                                    fooInline &#123;</span><br><span class="line">                                        fooInline &#123;</span><br><span class="line">                                            i++</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：以上的代码仅仅只是为了做测试，请不要在其他地方写类似这样的代码。</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Benchmark        Mode         Score       Error   Units</span><br><span class="line">testInlined     thrpt   <span class="number">3266143.092</span> ± <span class="number">85861.453</span>  ops/ms</span><br><span class="line">testNonInlined  thrpt     <span class="number">31404.262</span> ±   <span class="number">804.615</span>  ops/ms</span><br></pre></td></tr></table></figure><p>从上面的性能测试数据我们可以看到，在嵌套了 10 个层级以后，我们 testInlined 的性能几乎没有什么变化；而当 testNonInlined 嵌套了 10 层以后，性能也比 1 层嵌套差了 10 倍。</p><p>在这种情况下，testInlined() 与 testNonInlined() 之间的性能差异就达到了 100 倍，那么随着代码复杂度的进一步上升，它们之间的性能差异会更大。</p><p>我在下面这张 Gif 动图里展示了它们反编译成 Java 的代码：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/f7/a1/f7b342a7ecf56c100ec6b2bb488yyaa1.gif?wh=480x253" alt="img"></p><p>我们能看到，对于 testNonInlined()，由于 foo() 嵌套了 10 层，它反编译后的代码也嵌套了 10 层函数调用，中间还伴随了 10 次匿名内部类的创建。而 testInlined() 则只有简单的两行代码，完全没有任何嵌套的痕迹。难怪它们之间的性能相差 100 倍！</p><p><strong>inline 的局限性</strong></p><p>看到这，你也许会有这样的想法：<strong>既然 inline 这么神奇，那我们是不是可以将“词频统计程序”里的所有函数都用 inline 来修饰？</strong></p><p>答案当然是<strong>否定</strong>的。事实上，Kotlin 官方只建议我们将 inline 用于<strong>修饰高阶函数</strong>。对于普通的 Kotlin 函数，如果我们用 inline 去修饰它，IntelliJ 会对我们发出警告。而且，也不是所有高阶函数都可以用 inline，它在使用上有一些局限性。</p><p>举个例子，如果我们在 processText() 的前面增加 inline 关键字，IntelliJ 会提示一个警告：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/ba/ff/ba3175a460470887c852cfd14778f0ff.png?wh=1624x672" alt="img"></p><p>这个警告的意思是：“对于普通的函数，inline 带来的性能提升并不显著，inline 用在高阶函数上的时候，才会有显著的性能提升”。</p><p>另外，在 processText() 方法的内部，getWordCount() 和 mapToList() 这两个方法还会报错：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/31/4c/3113667bb87e2fe9929a704a0a14a24c.png?wh=1708x736" alt="img"></p><p>出现这个报错的原因是：getWordCount() 和 mapToList() 这两个函数是私有的，无法 inline。为什么呢？</p><p>前面我们提到过：<strong>inline 的作用其实就是将 inline 函数当中的代码拷贝到调用处</strong>。由于 processText() 是公开的，因此它会从外部被调用，这意味着它的代码会被拷贝到外部去执行，而 getWordCount() 和 mapToList() 这两个函数却无法在外部被访问。这就是导致编译器报错的原因。</p><p>所以，inline 虽然可以为我们带来极大的性能提升，但我们不能滥用。在使用 inline 的时候，我们还需要时刻注意它的实现机制，有时候，稍有不慎就会引发问题。</p><p>除此之外，在第 3 讲中我们曾提到：Kotlin 编译器一直在幕后帮忙做着翻译的好事，那它有没有可能“好心办坏事”？</p><p>这个问题，现在我们就能够回答了：K<strong>otlin 编译器是有可能好心办坏事的。如果我们不够了解 Kotlin 的底层细节，不够了解 Kotlin 的语法实现原理，我们就可能会用错某些 Kotlin 语法，比如 inline，当我们用错这些语法后，Kotlin 在背后做的这些好事，就可能变成一件坏事。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后，让我们来做个简单的总结。</p><ul><li>通过 1.0 版本的开发，我们初步实现了单词频率统计的功能，同时也使用了面向对象的思想，也使用了单元测试；</li><li>在 2.0 版本的开发中，我们初步尝试了函数式编程的风格，在这个过程中，我们灵活运用了我们前面学习的扩展、高阶函数知识。</li><li>在 3.0 版本中，我们使用 inline 优化了高阶函数。随后我们着重研究了高阶函数的原理，以及 inline 背后的细节。在这个过程中，我们发现 inline 可以为高阶函数带来超过 100 倍的性能提升，同时我们也了解到 inline 并不是万能的，它也存在一定的局限性。</li></ul><p>经过这节课的实战演练之后，相信你一定感受到了 Kotlin 函数式风格的魅力。在日后不断地学习、实操中，我也希望，你可以把 Kotlin 函数式的代码应用到自己的开发工作当中，并且充分发挥出 Kotlin 简洁、优雅、可读性强的优势。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>咱们的词频统计程序其实还有很多可以优化和提升的地方，请问你能想到哪些改进之处？欢迎你在评论区分享你的思路，我们下节课再见。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)07  高阶函数：为什么说函数是Kotlin的“一等公民”？</title>
      <link href="/posts/15c1fa4b/"/>
      <url>/posts/15c1fa4b/</url>
      
        <content type="html"><![CDATA[<p>高阶函数在 Kotlin 里有着举足轻重的地位。<strong>它是 Kotlin 函数式编程的基石，是各种框架的关键元素</strong>。高阶函数掌握好了，我们理解协程的 launch、async 函数就会轻松一些，阅读协程的源代码也会不那么吃力；高阶函数理解透彻了，我们学习 Jetpack Compose 也会得心应手，在特定业务场景下，我们甚至可以用它来实现自己的 DSL（Domain Specific Language）。</p><p>不过，如果你没有函数式编程的相关经验，在初次接触高阶函数的时候，很可能会被绕晕。因为它是一个全新的概念，你很难从经典的 C&#x2F;Java 里找到同等的概念迁移过来（Java 从 1.8 开始才引入相关概念）。然而，对于高阶函数这么重要的概念，Kotlin 官方文档又惜字如金。</p><p>文档里只是突兀地介绍了高阶函数、函数类型、Lambda 表达式的简单用法，接着就丢出一段复杂的代码案例，然后丢出一个更复杂的概念，“带接收者的函数类型”（Function Types With Receiver），接着又丢出了一段更复杂的代码案例。说实话，这真的让人难以理解。</p><p>所以今天这节课，我会采用 Java 和 Kotlin 对照的方式，来给你讲解 Kotlin 高阶函数的核心概念。并且我会通过一个实际案例，来帮助你理解其中最晦涩难懂的“带接收者的函数类型”，为你今后的 Kotlin 学习之路打下坚实的基础。</p><h2 id="Kotlin-为什么要引入高阶函数？"><a href="#Kotlin-为什么要引入高阶函数？" class="headerlink" title="Kotlin 为什么要引入高阶函数？"></a>Kotlin 为什么要引入高阶函数？</h2><p>想要掌握好高阶函数，我们首先要知道，Kotlin 为什么要引入这一全新的概念。这个问题，Kotlin 官方并没有给出解释，但是我们很容易在它的使用上找到蛛丝马迹。</p><p>我们来看个实际的例子，这是 Android 中的 View 定义，这里我省略了大部分代码，主要是想带你来看看 Kotlin 高阶函数的一个典型使用场景。</p><p><code>补充：如果你不了解 Android 开发也没关系，Java Swing 中也有类似的代码模式。如果两者你都不熟悉，借助我提供的注释，也不难理解。</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// View.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员变量</span></span><br><span class="line"><span class="keyword">private</span> OnClickListener mOnClickListener;</span><br><span class="line"><span class="keyword">private</span> OnContextClickListener mOnContextClickListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听手指点击事件</span></span><br><span class="line"><span class="keyword">public</span> void setOnClickListener(OnClickListener l) &#123;</span><br><span class="line">    mOnClickListener = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为传递这个点击事件，专门定义了一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnClickListener</span> &#123;</span><br><span class="line">    void onClick(View v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听鼠标点击事件</span></span><br><span class="line"><span class="keyword">public</span> void setOnContextClickListener(OnContextClickListener l) &#123;</span><br><span class="line">    getListenerInfo().mOnContextClickListener = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为传递这个鼠标点击事件，专门定义了一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnContextClickListener</span> &#123;</span><br><span class="line">    boolean onContextClick(View v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码，其实是一个典型的“可以用高阶函数来优化”的例子。让我们来看看它都做了什么：</p><ul><li>首先，为了设置点击事件的监听，代码里特地定义了一个 OnClickListener 接口；</li><li>接着，为了设置鼠标点击事件的监听，又专门定义了一个 OnContextClickListener 接口。</li></ul><p>乍一看，我们貌似是可以复用同一个接口就行了，对吧？但事实上，<strong>借助高阶函数，我们一个接口都不必定义</strong>。</p><p>当然了，上面的代码是 Android 团队十几年前用 Java 写的，在那个场景下，这么写代码是完全没问题的。可是这段代码在使用的时候，问题更大。比如，我们可以来看看如下所示的 Android 里设置点击监听的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 设置手指点击事件</span></span><br><span class="line">image.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onClick(View v) &#123;</span><br><span class="line">        gotoPreview();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置鼠标点击事件</span></span><br><span class="line">image.setOnContextClickListener(new View.OnContextClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onContextClick(View v) &#123;</span><br><span class="line">        gotoPreview();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看完了这两段代码之后，你有没有觉得这样的代码会很啰嗦？因为，真正逻辑只有一行代码：gotoPreview()，而实际上我们却写了 6 行代码。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/18/ac/1876d635751fd11662fbfcc3285a0eac.jpg?wh=1852x494" alt="img"></p><p>如果我们将其中的核心逻辑提取出来，会发现这样才是最简单明了的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                      &#123; gotoPreview() &#125; 就是 Lambda</span></span><br><span class="line"><span class="comment">//                             ↑</span></span><br><span class="line">image.setOnClickListener(&#123; gotoPreview() &#125;)</span><br><span class="line">image.setOnContextClickListener(&#123; gotoPreview() &#125;)</span><br></pre></td></tr></table></figure><p>那么，Kotlin 语言的设计者是怎么做的呢？实际上他们是分成了两个部分：</p><ul><li>用函数类型替代接口定义；</li><li>用 Lambda 表达式作为函数参数。</li></ul><p>这里我们再来看看与前面 View.java 的等价 Kotlin 代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//View.kt</span></span><br><span class="line"><span class="comment">//                     (View) -&gt; Unit 就是「函数类型 」</span></span><br><span class="line"><span class="comment">//                       ↑        ↑ </span></span><br><span class="line"><span class="keyword">var</span> mOnClickListener: ((View) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> mOnContextClickListener: ((View) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: (<span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    mOnClickListener = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnContextClickListener</span><span class="params">(l: (<span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    mOnContextClickListener = l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么通过对比，我们能看到，Kotlin 中引入高阶函数会带来几个<strong>好处</strong>：一个是针对定义方，代码中减少了两个接口类的定义；另一个是对于调用方来说，代码也会更加简洁。这样一来，就大大减少了代码量，提高了代码可读性，并通过减少类的数量，提高了代码的性能。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/a7/eb/a7yy974d95cd3938f0f36781afb425eb.jpg?wh=1531x699" alt="img" style="zoom:33%;" /><p><code>注：关于“inline”，我会在下节课中详细介绍。</code></p><p>通过上面的例子，我们已经清楚高阶函数存在的意义和价值了。不过，前面出现的一些新的概念我们还没来得及详细解释，比如，<strong>函数类型、Lambda，它们到底是什么呢？还有高阶函数的具体定义是什么呢？</strong></p><p>接下来，我会通过一个具体的代码案例，来给你一一解读与高阶函数关系密切的概念及使用定义，让你能进一步夯实函数式编程的基础知识。</p><h2 id="理解高阶函数的相关概念"><a href="#理解高阶函数的相关概念" class="headerlink" title="理解高阶函数的相关概念"></a>理解高阶函数的相关概念</h2><p>首先，我们来了解下什么是函数类型。</p><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>顾名思义，函数类型（Function Type）就是<strong>函数的类型</strong>。如果你之前没有函数式编程的经验，刚接触这个概念的话也许会觉得奇怪：函数也有类型吗？</p><p>是的，既然变量可以有类型，函数也可以有。在 Kotlin 的世界里<a href="https://kotlinlang.org/docs/lambdas.html">，函数是一等公民</a>。你可以将其理解为 Kotlin 里的 VIP，普通人有的东西，VIP 当然也有。比如，我们可以仔细看看下面的函数：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//         (Int,  Int) -&gt;Float 这就是 add 函数的类型</span></span><br><span class="line"><span class="comment">//           ↑     ↑      ↑</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Float</span> &#123; <span class="keyword">return</span> (a+b).toFloat() &#125;</span><br></pre></td></tr></table></figure><p>请注意这里我给出代码注释，第二行注释里面的“↑”代表的是一种映射关系。其实，将第三行代码里的“Int Int Float”抽出来，就代表了该函数的类型。</p><p>我们可以用更精练的语言来描述函数类型的规律：<strong>将函数的“参数类型”和“返回值类型”抽象出来后，就得到了“函数类型</strong>”。(Int, Int) -&gt;Float 就代表了参数类型是两个 Int，返回值类型为 Float 的函数类型。</p><p>理解了函数类型以后，我们再来看<strong>函数的引用</strong>。普通的变量也有引用的概念，我们可以将一个变量赋值给另一个变量。而这一点，在函数上也是同样适用的，函数也有引用，并且也可以赋值给变量。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 函数赋值给变量                    函数引用</span></span><br><span class="line"><span class="comment">//    ↑                              ↑</span></span><br><span class="line"><span class="keyword">val</span> function: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Float</span> = ::add</span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>好，接着我们再来看看高阶函数的具体定义。当然，前面解释了这么多，现在我们对高阶函数应该已经有了比较清晰的认识了，我们用 Kotlin 实现的 View 点击事件函数，它就是一个高阶函数</p><p>而它明确的定义其实是这样的：<strong>高阶函数是将函数用作参数或返回值的函数。</strong></p><p>这句话有点绕，我们还是直接看例子吧。如果我们将 Android 里点击事件的监听用 Kotlin 来实现的话，它其实就是一个典型的高阶函数。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//                      函数作为参数的高阶函数</span></span><br><span class="line"><span class="comment">//                              ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: (<span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>换句话说，一个函数的参数或是返回值，它们当中有一个是函数的情况下，这个函数就是高阶函数。</p><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>而前面我们还提到过，Kotlin 语言的设计者是用 Lambda 表达式作为函数参数的，那么这里的 Lambda，就可以理解为是<strong>函数的简写</strong>：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>)</span></span>: <span class="built_in">Unit</span> &#123; ... &#125;</span><br><span class="line">setOnClickListener(::onClick)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 Lambda 表达式来替代函数引用</span></span><br><span class="line">setOnClickListener(&#123;v: View -&gt; ...&#125;)</span><br></pre></td></tr></table></figure><p>那么，如果你够细心的话，可能已经发现了一个问题：Android 并没有提供 View.java 的 Kotlin 实现，那么为什么我们的 Demo 里面可以用 Lambda 来简化事件监听呢？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在实际开发中，我们经常使用这种简化方式</span></span><br><span class="line">setOnClickListener(&#123; gotoPreview() &#125;</span><br></pre></td></tr></table></figure><p>原因是这样的，由于 OnClickListener 符合 SAM 转换的要求，因此编译器自动帮我们做了一层转换，让我们可以用 Lambda 表达式来简化我们的函数调用。</p><p>那么，SAM 又是个什么鬼？</p><h2 id="SAM-转换"><a href="#SAM-转换" class="headerlink" title="SAM 转换"></a>SAM 转换</h2><p>SAM 是 Single Abstract Method 的缩写，意思就是只有一个抽象方法的类或者接口。但在 Kotlin 和 Java 8 里，<strong>SAM 代表着只有一个抽象方法的接口</strong>。只要是符合 SAM 要求的接口，编译器就能进行 SAM 转换，也就是我们可以使用 Lambda 表达式，来简写接口类的参数。</p><p>注意，Java 8 中的 SAM 有明确的名称，叫做<strong>函数式接口（FunctionalInterface</strong>）。FunctionalInterface 的限制如下，缺一不可：</p><ul><li>必须是接口，抽象类不行；</li><li>该接口有且仅有一个抽象的方法，抽象方法个数必须是 1，默认实现的方法可以有多个。</li></ul><p>也就是说，对于 View.java 来说，它虽然是 Java 代码，但 Kotlin 编译器知道它的参数 OnClickListener 符合 SAM 转换的条件，所以会自动做以下转换。</p><p>转换前：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> void setOnClickListener(OnClickListener l)</span><br></pre></td></tr></table></figure><p>转换后：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: (<span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="comment">// 实际上是这样：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: ((<span class="type">View</span>!) -&gt; <span class="type">Unit</span>)?)</span></span></span><br></pre></td></tr></table></figure><p>其中，((View!) -&gt; Unit)? 代表的是这个参数可能为空。</p><h3 id="Lambda-表达式引发的-8-种写法"><a href="#Lambda-表达式引发的-8-种写法" class="headerlink" title="Lambda 表达式引发的 8 种写法"></a>Lambda 表达式引发的 8 种写法</h3><p>当一个函数的参数是 SAM 的情况下，我们同样也可以使用 Lambda 作为参数。所以，我<strong>们既可以用匿名内部类的方式传参，也可以使用 Lambda 的方式传参</strong>。这两种方式在我们前面都已经提到过了。然而，在这两种写法的中间，还有 6 种“过渡状态”的写法。这对大部分初学者简直是噩梦：同样的代码，能有 8 种不同的写法，确实也挺懵的。</p><p>而要理解 Lambda 表达式的简写逻辑，其实很简单，那就是：<strong>多写</strong>。你也可以跟着我接下来的流程来一起写一写。</p><h4 id="第-1-种写法"><a href="#第-1-种写法" class="headerlink" title="第 1 种写法"></a>第 1 种写法</h4><p>这是原始代码，它的本质是用 object 关键字定义了一个匿名内部类：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">image.setOnClickListener(<span class="keyword">object</span>: View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        gotoPreview(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="第-2-种写法"><a href="#第-2-种写法" class="headerlink" title="第 2 种写法"></a>第 2 种写法</h4><p>在这种情况下，object 关键字可以被省略。这时候它在语法层面就不再是匿名内部类了，它更像是 Lambda 表达式了，因此它里面 override 的方法也要跟着删掉：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">image.setOnClickListener(View.OnClickListener &#123; v: View? -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的View.OnClickListener被称为 SAM Constructor（SAM 构造器），它是编译器为我们生成的。</p><h4 id="第-3-种写法"><a href="#第-3-种写法" class="headerlink" title="第 3 种写法"></a>第 3 种写法</h4><p>由于 Kotlin 的 Lambda 表达式是不需要 SAM Constructor 的，所以它也可以被删掉：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">image.setOnClickListener(&#123; v: View? -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="第-4-种写法"><a href="#第-4-种写法" class="headerlink" title="第 4 种写法"></a>第 4 种写法</h4><p>由于 Kotlin 支持类型推导，所以 View 可以被删掉</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">image.setOnClickListener(&#123; v -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="第-5-种写法"><a href="#第-5-种写法" class="headerlink" title="第 5 种写法"></a>第 5 种写法</h4><p>当 Kotlin Lambda 表达式只有一个参数的时候，它可以被写成 it：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">image.setOnClickListener(&#123; it -&gt;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="第-6-种写法"><a href="#第-6-种写法" class="headerlink" title="第 6 种写法"></a>第 6 种写法</h4><p>Kotlin Lambda 的 it 是可以被省略的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">image.setOnClickListener(&#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="第-7-种写法"><a href="#第-7-种写法" class="headerlink" title="第 7 种写法"></a>第 7 种写法</h4><p>当 Kotlin Lambda 作为函数的最后一个参数时，Lambda 可以被挪到外面：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">image.setOnClickListener() &#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第-8-种写法"><a href="#第-8-种写法" class="headerlink" title="第 8 种写法"></a>第 8 种写法</h4><p>当 Kotlin 只有一个 Lambda 作为函数参数时，() 可以被省略：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">image.setOnClickListener &#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我把这 8 种写法的演进过程以动图的形式展现了出来，让你对 Lambda 这几种写法的差异有一个更加直观的认识。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/e4/bf/e441323968c0c061898257fd06db37bf.gif?wh=1080x608" alt="img" style="zoom:67%;" /><p>按照这个流程，在 IDE 里多写几遍，你自然就会理解了。一定要写，光看是记不住的。</p><p>好了，到这里，你就搞明白这些概念是什么意思了。下面我们来做一个小的总结，在后续的 Kotlin 学习当中，这些都是要铭记在心的。</p><ul><li>将函数的参数类型和返回值类型抽象出来后，我们就得到了函数类型。比如(View) -&gt; Unit 就代表了参数类型是 View，返回值类型为 Unit 的函数类型。</li><li>如果一个函数的“参数”或者“返回值”的类型是函数类型，那这个函数就是高阶函数。很明显，我们刚刚就写了一个高阶函数，只是它比较简单而已。</li><li>Lambda 就是函数的一种简写。</li></ul><p>然后，你也可以再通过一张图来回顾下函数类型、高阶函数以及 Lambda 表达式三者之间的关系：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/ec/71/ecf85d05f6fdc5ea2d015a61d7e64771.png?wh=1920x914" alt="img" style="zoom:67%;" /><p>你也可以再回过头来看看官方文档提供的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">fold</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    initial: <span class="type">R</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    combine: (<span class="type">acc</span>: <span class="type">R</span>, <span class="type">nextElement</span>: <span class="type">T</span>) -&gt; <span class="type">R</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">var</span> accumulator: R = initial</span><br><span class="line">    <span class="keyword">for</span> (element: T <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        accumulator = combine(accumulator, element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看到这个函数类型：(acc: R, nextElement: T) -&gt; R，是不是瞬间就懂了呢？这个函数接收了两个参数，第一个参数类型是 R，第二个参数是 T，函数的返回类型是 R。</p><h2 id="难点：带接收者的函数类型"><a href="#难点：带接收者的函数类型" class="headerlink" title="难点：带接收者的函数类型"></a>难点：带接收者的函数类型</h2><p>那么现在，我们就把高阶函数这个知识点理解得有 80% 了。而在这节课一开始，我还提到，在 Kotlin 的函数类型这个知识点当中，还有一个特殊的概念，叫做<strong>带接收者的函数类型</strong>，它尤其晦涩难懂。</p><p>说实话，这个名字也对初学者不太友好，“带接收者的函数类型”，这里面的每一个字我都认识，可放到一块我就懵了。所以我们其实还是绕不开一个问题：为什么？</p><p><em><strong>为什么要引入带接收者的函数类型？</strong></em></p><p>这里，让我们先来看一下 Kotlin 的标准函数 apply 的使用场景。</p><p>不用 apply：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    username.text = user.name</span><br><span class="line">    website.text = user.blog</span><br><span class="line">    image.setOnClickListener &#123; gotoImagePreviewActivity(user) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 apply</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">user?.apply &#123;</span><br><span class="line">    ...</span><br><span class="line">    username.text = name</span><br><span class="line">    website.text = blog</span><br><span class="line">    image.setOnClickListener &#123; gotoImagePreviewActivity(<span class="keyword">this</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问这个 apply 方法应该怎么实现呢？</p><p>上面的写法其实是简化后的 Lambda 表达式，让我们来反推一下，看看它简化前是什么样的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// apply 肯定是个函数，所以有 ()，只是被省略了</span></span><br><span class="line">user?.apply() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 肯定是在 () 里面</span></span><br><span class="line">user?.apply(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 gotoImagePreviewActivity(this) 里的 this 代表了 user</span></span><br><span class="line"><span class="comment">// 所以 user 应该是 apply 函数的一个参数，而且参数名为：this</span></span><br><span class="line">user?.apply(&#123; <span class="keyword">this</span>: User -&gt; ... &#125;)</span><br></pre></td></tr></table></figure><p>所以，现在问题非常明确了，apply 其实是接收了一个 Lambda 表达式：{ this: User -&gt; … }。那么现在，我们就尝试来实现这个 apply 方法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">apply</span><span class="params">(self: <span class="type">User</span>, block: (<span class="type">self</span>: <span class="type">User</span>) -&gt; <span class="type">Unit</span>)</span></span>: User&#123;</span><br><span class="line">    block(self)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user?.apply(self = user) &#123; self: User -&gt;</span><br><span class="line">            username.text = self.name</span><br><span class="line">            website.text = self.blog</span><br><span class="line">            image.setOnClickListener &#123; gotoImagePreviewActivity(<span class="keyword">this</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Kotlin 里面的函数形参是不允许被命名为 this 的，因此我这里用的是 self。另外，这里我们自己写出来的 apply，仍然还要通过 self.name 这样的方式来访问成员变量，但 Kotlin 的语言设计者能做到这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//           改为this             改为this</span></span><br><span class="line"><span class="comment">//               ↓                    ↓ </span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">apply</span><span class="params">(this: <span class="type">User</span>, block: (<span class="type">this</span>: <span class="type">User</span>) -&gt; <span class="type">Unit</span>)</span></span>: User&#123;</span><br><span class="line"><span class="comment">//    这里还要传参数</span></span><br><span class="line"><span class="comment">//         ↓ </span></span><br><span class="line">    block(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user?.apply(<span class="keyword">this</span> = user) &#123; <span class="keyword">this</span>: User -&gt;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//               this 可以省略</span></span><br><span class="line"><span class="comment">//                   ↓ </span></span><br><span class="line">    username.text = <span class="keyword">this</span>.name</span><br><span class="line">    website.text = blog</span><br><span class="line">    image.setOnClickListener &#123; gotoImagePreviewActivity(<span class="keyword">this</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子能看到，我们反推的 apply 实现会比较繁琐：</p><ul><li>需要我们传入 this：user?.apply(this &#x3D; user)</li><li>需要我们自己调用：block(this)。</li></ul><p>因此，Kotlin 就引入了带接收者的函数类型，可以简化 apply 的定义：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//              带接收者的函数类型</span></span><br><span class="line"><span class="comment">//                     ↓  </span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">apply</span><span class="params">(block: <span class="type">User</span>.() -&gt; <span class="type">Unit</span>)</span></span>: User&#123;</span><br><span class="line"><span class="comment">//  不用再传this</span></span><br><span class="line"><span class="comment">//       ↓ </span></span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user?.apply &#123; <span class="keyword">this</span>: User -&gt;</span><br><span class="line"><span class="comment">//               this 可以省略</span></span><br><span class="line"><span class="comment">//                   ↓</span></span><br><span class="line">    username.text = <span class="keyword">this</span>.name</span><br><span class="line">    website.text = <span class="keyword">this</span>.blog</span><br><span class="line">    image.setOnClickListener &#123; gotoImagePreviewActivity(<span class="keyword">this</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，关键来了。上面的 apply 方法是不是看起来就像是在 User 里，增加了一个成员方法 apply()？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">val</span> blog: String = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 成员方法可以通过 this 访问成员变量</span></span><br><span class="line">        username.text = <span class="keyword">this</span>.name</span><br><span class="line">        website.text = <span class="keyword">this</span>.blog</span><br><span class="line">        image.setOnClickListener &#123; gotoImagePreviewActivity(<span class="keyword">this</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，从外表上看，带接收者的函数类型，就等价于成员方法<strong>。但从本质上讲，它仍是通过编译器注入 this 来实现的</strong>。</p><p>我们可以再通过一张图，来理解下什么是带接收者的函数类型：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/9a/04/9acd54ac08d88c94ca52336a576b3304.png?wh=1890x1156" alt="img" style="zoom: 50%;" /><p>看到这里，也许你会想起前面我们讲过的“扩展函数”。那么，带接收者的函数类型，是否也能代表扩展函数呢？</p><p>答案是肯定的。毕竟，从语法层面讲<strong>，扩展函数就相当于成员函数</strong>。</p><h2 id="实战与思考"><a href="#实战与思考" class="headerlink" title="实战与思考"></a>实战与思考</h2><p>在第 5 讲当中，我们实现了“单例的抽象类模板”，在课程的最后，我还给你留了一个思考题：</p><p><code>我们的抽象类模板 BaseSingleton 是否还有改进的空间？</code></p><p>这里，让我们先回顾一下 BaseSingleton 的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">                     </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseSingleton</span>&lt;<span class="type">in P, out T</span>&gt; &#123;</span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> instance: T? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//                       ①</span></span><br><span class="line">    <span class="comment">//                       ↓</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">P</span>)</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(param: <span class="type">P</span>)</span></span>: T =</span><br><span class="line">        instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            instance ?: creator(param).also &#123; instance = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : BaseSingleton&lt;String, PersonManager&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">String</span>)</span></span>: PersonManager = PersonManager(param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们可以看到，BaseSingleton 是单例抽象模板，而 PersonManager 则是实际的单例类。</p><p>在前面的第 2 讲里，我们就讨论过 Person 的 isAdult 应该是属性，而 walk 则应该是方法。那么现在，请看注释①，它是我们定义的一个抽象方法，名字叫做 creator。这时候，相信你马上就能反应过来：creator 应该定义成属性。</p><p>可是，<strong>如何才能将一个方法改成属性呢</strong>？答案当然就是刚学过的：<strong>高阶函数</strong>。</p><p>运用这节课学到的知识，我们很容易就能将 creator 改成一个类型为：(P)-&gt;T的属性，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseSingleton</span>&lt;<span class="type">in P, out T</span>&gt; &#123;</span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> instance: T? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//               变化在这里，函数类型的属性</span></span><br><span class="line">    <span class="comment">//                  ↓              ↓</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">val</span> creator: (P)-&gt; T</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(param: <span class="type">P</span>)</span></span>: T =</span><br><span class="line">        instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            instance ?: creator(param).also &#123; instance = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们将 creator 改成了一个抽象的属性，如果其他的单例类继承了 BaseSingleton 这个类，就必须实现这个 creator 属性。不过，这时候一个问题就出现了：<strong>PersonManager 该怎么写呢？</strong></p><p>如果我们依葫芦画瓢，在实现 creator 的时候传入 PersonManager 的构造函数，会发现代码报错：类型不匹配。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : BaseSingleton&lt;String, PersonManager&gt;() &#123;</span><br><span class="line">    <span class="comment">//             报错，类型不匹配</span></span><br><span class="line">    <span class="comment">//                  ↓ </span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> creator = PersonManager(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码报错的原因其实也很简单，creator 的类型是一个 (String)-&gt; PersonManager，而 PersonManager 构造函数这个表达式的值类型，是 PersonManager 类型。<strong>前者是函数类型，后者是普通对象类型</strong>。那么，如何才能正确实现 creator 这个函数类型的属性呢？</p><p>答案就是我们前面刚学的：<strong>函数引用</strong>！</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : BaseSingleton&lt;String, PersonManager&gt;() &#123;</span><br><span class="line">    <span class="comment">//                             函数引用</span></span><br><span class="line">    <span class="comment">//                                ↓ </span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> creator = ::PersonManager</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以看到，我们直接将 PersonManager 的构造函数，以函数引用的方式传给了 creator 这个属性，这样就成功地实现了这个函数类型的属性。</p><p>在这个案例里，我们将函数引用以及高阶函数应用到了单例抽象类模板当中，而在这个过程当中，我们也就能更加透彻地理解这两个特性的使用场景了。</p><p>这里我制作了一个代码的转换动图，帮你建立一个更加直观的认识。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/49/5c/49b134d723c11c7d50762497b44afa5c.gif?wh=1080x608" alt="img" style="zoom: 67%;" /><p>从这个动图里，我们可以清晰地看到某些元素的转移过程。比如泛型 P、T，还有 PersonManager 的构造函数，这些都是代码中的关键元素。这些关键元素只是换了一种语法排列规则：<strong>从函数的语法变成了属性的语法，语法从复杂变得简洁，其中的关键元素并未丢失。</strong></p><p>因此，这两种代码是完全等价的，但后者更加简洁易懂。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到现在为止，咱们高阶函数部分的内容就进入尾声了。让我们再来做一次总结：</p><ul><li><strong>为什么引入高阶函数？</strong>答：为了简化。</li><li><strong>高阶函数是什么？</strong>答：函数作为参数 or 返回值。</li><li><strong>函数类型是什么？</strong>答：函数的类型。</li><li><strong>函数引用是什么？</strong>答：类比变量的引用。</li><li><strong>Lambda 是什么？</strong>答：可以简单理解为“函数的简写”（官方定义我们以后再讨论）。</li><li><strong>带接收者的函数类型是什么？</strong>答：可以简单理解为“成员函数的类型”。</li></ul><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/45/3e/45e23ce48a64711943366fec784af23e.jpg?wh=1920x1171" alt="img" style="zoom:50%;" /><p>事实上，对于初学者来说，要一下子理解并掌握 Kotlin“高阶函数”不是一件容易的事情。在掌握好这节课内容的基础上，我们可以尝试去读一些优秀的代码。</p><p>比如 Kotlin 官方的源代码<a href="https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/src/kotlin/util/Standard.kt">StandardKt</a>，你可以去分析其中的 with、let、also、takeIf、repeat、apply，来进一步加深对高阶函数的理解。还有就是<a href="https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/common/src/generated/_Collections.kt">CollectionsKt</a>，你可以去分析其中的 map、flatMap、fold、groupBy 等操作符，从而对高阶函数的应用场景有一个更具体的认知。</p><p>另外，在第2 讲的时候，我们曾经提到过：理论上讲，Kotlin 与 Java 是完全兼容的。那么问题来了，<strong>Kotlin 引入全新的高阶函数，最终变成 JVM 字节码后是怎么执行呢</strong>？毕竟，JVM 可不知道什么是高阶函数啊。</p><p>答案其实也很简单：<strong>匿名内部类</strong>。</p><p>而这样又引出了另一个问题：所以 Kotlin 弄了个这么高端的高阶函数，最终还是以匿名内部类的形式在运行呗？那它们两者的性能差不多？这不是多此一举吗？</p><p>答案当然是否定的，Kotlin 高阶函数的性能，在极端情况下可以达到匿名内部类的 100 倍！具体是怎么回事儿呢？别着急，下节课讲“inline”时，我们就会来详细探讨。</p><h2 id="小作业"><a href="#小作业" class="headerlink" title="小作业"></a>小作业</h2><p>请你去阅读一下 Kotlin 官方的标准函数库<a href="https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/src/kotlin/util/Standard.kt">StandardKt</a> 的源代码，尝试去解析其中任意一个高阶函数的原理和意义，并分享出来，我们一起探讨。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">run</span><span class="params">(block: () -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receiver.block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeIf</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeUnless</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (!predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">repeat</span><span class="params">(times: <span class="type">Int</span>, action: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    contract &#123; callsInPlace(action) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until times) &#123;</span><br><span class="line">        action(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这节课就到这里，如果觉得有收获，非常欢迎你把今天的内容分享给更多的朋友，咱们下节课再见。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)06  扩展：你的能力边界到底在哪里？</title>
      <link href="/posts/85d82fa8/"/>
      <url>/posts/85d82fa8/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 的扩展（Extension），主要分为两种语法：第一个是扩展函数，第二个是扩展属性。从语法上看，扩展看起来就像是我们从类的外部为它扩展了新的成员。</p><p>这在实际编程当中是非常有用的功能。我们可以来想象一个场景：我们想修改 JDK 当中的 String，想在它的基础上增加一个方法“lastElement()”来获取末尾元素，如果使用 Java，我们是无法通过常规手段实现的，因为我们没办法修改 JDK 的源代码。<strong>任何第三方提供的 SDK，我们都无权修改</strong>。</p><p>不过，借助 Kotlin 的扩展函数，我们就完全可以在语义层面，来为第三方 SDK 的类扩展新的成员方法和成员属性。不管是为 JDK 的 String 增加新的成员方法，还是为 Android SDK 的 View 增加新成员属性，我们都可以实现。</p><p>Kotlin 的这个“扩展”功能看起来很神奇，它会不会很难学？其实不然，它的语法非常简洁。今天这节课，我们就一起来学习下 Kotlin 当中的扩展。通过研究它的原理，来探索它的能力边界，并在理解和掌握核心知识点之后，去思考它的实战应用场景。</p><h2 id="什么是扩展函数和扩展属性？"><a href="#什么是扩展函数和扩展属性？" class="headerlink" title="什么是扩展函数和扩展属性？"></a>什么是扩展函数和扩展属性？</h2><p>扩展函数，就是从类的外部扩展出来的一个函数，这个函数看起来就像是类的成员函数一样。这里，我们就以 JDK 当中的 String 为例，来看看如何通过 Kotlin 的扩展特性，为它新增一个 lastElement() 方法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// Ext.kt</span><br><span class="line">package com.boycoder.chapter06</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> ①    ②      ③            ④</span><br><span class="line"> ↓     ↓       ↓            ↓      */</span><br><span class="line">fun String.lastElement(): Char? &#123;</span><br><span class="line">    //    ⑤</span><br><span class="line">    //    ↓</span><br><span class="line">    if (this.isEmpty()) &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this[length - 1]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用扩展函数</span><br><span class="line">fun main() &#123;</span><br><span class="line">    val msg = &quot;Hello Wolrd&quot;</span><br><span class="line">    // lastElement就像String的成员方法一样可以直接调用</span><br><span class="line">    val last = msg.lastElement() // last = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先是定义了一个 String 的扩展函数“lastElement()”，然后在 main 函数当中调用了这个函数。并且，这个扩展函数是直接定义在 Kotlin 文件里的，而不是定义在某个类当中的。这种扩展函数，我们称之为“<strong>顶层扩展</strong>”，这么叫它是因为它并没有嵌套在任何的类当中，它自身就在最外层。</p><p>现在，我们依次来看看上面的五处注释。</p><ul><li>注释①，fun关键字，代表我们要定义一个函数。也就是说，不管是定义普通 Kotlin 函数，还是定义扩展函数，我们都需要 fun 关键字。</li><li>注释②，“String.”，代表我们的扩展函数是为 String 这个类定义的。在 Kotlin 当中，它有一个名字，叫做接收者（Receiver），也就是扩展函数的接收方。</li><li>注释③，lastElement()，是我们定义的扩展函数的名称。</li><li>注释④，“Char?”，代表扩展函数的返回值是可能为空的 Char 类型。</li><li>注释⑤，“this.”，代表“具体的 String 对象”，当我们调用 msg.lastElement() 的时候，this 就代表了 msg。</li></ul><p>需要注意的是，<strong>在整个扩展函数的方法体当中，this 都是可以省略的</strong>。这一点，Kotlin 和 Java 是一样的，this 代表当前作用域，它可写可不写。</p><p>另外，如果你足够细心的话，你会发现如果去掉注释②处的“String.”，这段代码就会变成一个普通的函数定义:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;&#125;</span><br><span class="line"><span class="comment">// 普通函数与扩展函数之间的差别</span></span><br></pre></td></tr></table></figure><p>换句话说，就是如果我们在普通函数的名称前面加上一个“接收者类型”，比如“String.”，Kotlin 的“普通函数”就变成了“扩展函数”。</p><p>可见，Kotlin 扩展语法设计得非常巧妙，只要你记住了普通函数的语法，那么，只需要再记住一点点细微的区别，你就能记住扩展函数的语法。而通过这个细微的语法差异，你也可以体会到，所谓的扩展函数，就是多了个“扩展接收者”的函数。</p><h2 id="扩展函数的实现原理"><a href="#扩展函数的实现原理" class="headerlink" title="扩展函数的实现原理"></a>扩展函数的实现原理</h2><p>在第 3 讲中，我们学习了如何研究 Kotlin 的原理，也就是通过 Java 字节码来做反编译。那么在这里，我们就以刚才写的 lastElement() 为例，一起来看看它反编译后的 Java 代码是什么样的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ExtKt</span> &#123;</span><br><span class="line">   <span class="comment">// ①</span></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> Character lastElement(String $<span class="keyword">this</span>) &#123;</span><br><span class="line">      CharSequence var1 = (CharSequence)$<span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (var1.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>  var1.charAt(var1.length() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">  String msg = <span class="string">&quot;Hello Wolrd&quot;</span>;</span><br><span class="line">  <span class="comment">//                        ②</span></span><br><span class="line">  <span class="comment">//                        ↓</span></span><br><span class="line">  Character last = ExtKt.lastElement(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码有两个地方需要注意，我分别用两个注释标记出来了。</p><p>通过第一个注释，我们可以看到，原本定义在 String 类型上面的扩展函数 lastElement()，变成了一个<strong>普通的静态方法</strong>。另外，之前定义的扩展函数 lastElement() 是没有参数的，但反编译后的 Java 代码中，lastElement(String $this) <strong>多了一个 String 类型的参数</strong>。</p><p>还有第二个注释，这是扩展函数的调用处，原本 msg.lastElement() 的地方，变成了 ExtKt.lastElement(msg)。这说明，<strong>Kotlin 编写的扩展函数调用代码，最终会变成静态方法的调用。</strong></p><p>看到这里，也许你一下就能反应过来：Kotlin 的扩展函数只是从表面上将 lastElement() 变成 String 的成员，但它实际上并没有修改 String 这个类的源代码，lastElement() 也并没有真正变成 String 的成员方法。</p><p>也就是说，<strong>由于 JVM 不理解 Kotlin 的扩展语法，所以 Kotlin 编译器会将扩展函数转换成对应的静态方法，而扩展函数调用处的代码也会被转换成静态方法的调用。</strong></p><p>而如果我们将上面的 ExtKt 修改成 StringUtils，它就变成了典型的 Java 工具类。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringUtils</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> Character lastElement(String $<span class="keyword">this</span>) &#123;</span><br><span class="line">     <span class="comment">// 省略</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">  Character last = StringUtils.lastElement(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何理解扩展属性？"><a href="#如何理解扩展属性？" class="headerlink" title="如何理解扩展属性？"></a>如何理解扩展属性？</h2><p>在学习了 Kotlin 的扩展函数以后，扩展属性就很好理解了。扩展函数，是在类的外部为它定义一个<strong>新的成员方法</strong>；而扩展属性，则是在类的外部为它定义一个<strong>新的成员属性</strong>。</p><p>那么，在研究了扩展的实现原理后，我们知道，我们从外部定义的成员方法和属性，都只是语法层面的，并没有实际修改那个类的源代码。</p><p>还是以 lastElement 为例，在之前的案例当中，我们是通过扩展函数来实现的，这次我们以扩展属性的方式来实现。扩展函数的定义对比普通函数，其实就只是多了一个“接收者类型”。类似的，扩展属性，也就是在普通属性定义的时候多加一个“接收者类型”即可。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="keyword">val</span> String.lastElement: <span class="built_in">Char</span>?</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = <span class="string">&quot;Hello Wolrd&quot;</span></span><br><span class="line">    <span class="comment">// lastElement就像String的成员属性一样可以直接调用</span></span><br><span class="line">    <span class="keyword">val</span> last = msg.lastElement <span class="comment">// last = d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段的代码中，我们为 String 类型扩展了一个新的成员属性“lastElement”。然后在 main 函数当中，我们直接通过“msg.lastElement”方式使用了这个扩展属性，就好像它是一个成员一样。而如果你将以上的代码进行反编译，你会发现它反编译后的 Java 代码几乎和我们前面扩展函数的一模一样。</p><p>为了让你看得更加清晰，我们用一张图来描述它们之间的关系。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/2a/ed/2a38487b61ec06e437c1425b2a69ffed.png?wh=1920x752" alt="img"></p><p>上面的两个箭头，说明了扩展函数与扩展属性，它们最终会被 Kotlin 编译器转换成静态方法；下面两个箭头，说明了扩展函数和扩展属性的调用代码，最终会被 Kotlin 编译器转换成静态方法的调用。</p><p>所以也就是说，Kotlin 的扩展表面上看起来是为一个类扩展了新的成员，但是<strong>本质上，它还是静态方法</strong>。而且，不管是扩展函数还是扩展属性，它本质上都会变成一个静态的方法。那么，到底什么时候该用扩展函数，什么时候该用扩展属性呢？</p><p>其实，我们只需要看扩展在语义上更适合作为函数还是属性就够了。比如这里的 lastElement，它更适合作为一个扩展属性。这样设计的话，在语义上，lastElement 就像是 String 类当中的属性一样，它代表了字符串里的最后一个字符。</p><h2 id="扩展的能力边界"><a href="#扩展的能力边界" class="headerlink" title="扩展的能力边界"></a>扩展的能力边界</h2><p>在理解了扩展的使用与原理后，我们再来探讨一下扩展的能力边界：扩展能做什么，不能做什么。Kotlin 的扩展看起来很神奇，但它并不是无所不能的，通过探索它的能力边界，我们就能对它有一个更加深入的认识。</p><h2 id="扩展能做什么？"><a href="#扩展能做什么？" class="headerlink" title="扩展能做什么？"></a>扩展能做什么？</h2><p>我们先从“扩展能做什么”说起。</p><p>当我们想要从外部为一个类扩展一些方法和属性的时候，我们就可以通过扩展来实现了。<strong>在 Kotlin 当中，几乎所有的类都可以被扩展</strong>，包括普通类、单例类、密封类、枚举类、伴生对象，甚至还包括第三方提供的 Java 类。唯有匿名内部类，由于它本身不存在名称，我们无法指定“接收者类型”，所以不能被扩展，当然了，它也没必要被扩展。</p><p>可以说，Kotlin 扩展的应用范围还是非常广的。它最主要的用途，<strong>就是用来取代 Java 当中的各种工具类</strong>，比如 StringUtils、DateUtils 等等。</p><p>所有 Java 工具类能做的事情，Kotlin 扩展函数都可以做，并且可以做得更好。扩展函数的优势在于，开发工具可以在编写代码的时候智能提示。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/23/9c/239e540b768560c6cd119b1bb9e1eb9c.gif?wh=1210x682" alt="img" style="zoom:50%;" /><h2 id="扩展不能做什么？"><a href="#扩展不能做什么？" class="headerlink" title="扩展不能做什么？"></a>扩展不能做什么？</h2><p>我们再聊聊扩展不能做什么。</p><p>Kotlin 的扩展，由于它本质上并没有修改接收类型的源代码，所以它的行为是无法与“类成员”完全一致的。那么它对比普通的类成员，就会有以下几个限制。</p><p><strong>第一个限制</strong>，Kotlin 扩展不是真正的类成员，因此它无法被它的子类重写。举个例子，我们定义一个这样的 Person 类，并且分别为它扩展了一个 isAdult 属性和 walk() 方法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> Person.isAdult: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;walk&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Person 类有 open 关键字修饰，所以我们可以继承这个 Person 类。不过，当我们尝试去重写它的成员时，会发现 isAdult 和 walk() 是无法被重写的，因为它们压根就不属于 Person 这个类。这个很好理解，让我们看下一个。</p><p><strong>第二个限制</strong>，扩展属性无法存储状态。就如前面代码当中的 isAdult 属性一般，它的值是由 age 这个成员属性决定的，它本身没有状态，也无法存储状态。这一点，和我们在第 2 讲学习的“接口成员属性”一样，背后的根本原因，还是因为它们都是静态方法。</p><p><strong>第三个限制</strong>，扩展的访问作用域仅限于两个地方。第一，定义处的成员；第二，接收者类型的公开成员。我们以前面的代码为例：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Ext.kt</span></span><br><span class="line"><span class="keyword">package</span> com.boycoder.chapter06</span><br><span class="line"></span><br><span class="line"><span class="comment">// ①</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> msg: String = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//       ②</span></span><br><span class="line">        <span class="comment">//       ↓</span></span><br><span class="line">        println(msg)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//            ③</span></span><br><span class="line">    <span class="comment">//            ↓</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码一共有三处注释，我们一个个看：</p><ul><li>在注释①的地方，我们在 Ext 这个 Kotlin 文件里定义了一个私有的变量 msg。</li><li>由于 lastElement() 与 msg 是定义在同一个文件当中的，因此，在注释②处我们可以直接访问 msg，即使它是私有的。</li><li>最后，是注释③，由于 length 是 String 类的公开属性，因此我们可以在扩展函数当中直接访问它。对应的，如果 length 是 String 的 private、protected 成员，那我们将无法在扩展函数当中访问它。归根结底，还是因为扩展函数并非真正的类成员。</li></ul><p>看到这里，也许你会冒出一个有趣的想法：<strong>如果将扩展定义在某个类的内部，它能够访问这个类的私有属性吗？</strong></p><p>让我们来试试看：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Helper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">walkOnFoot</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;用脚走路&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> Person.isAdult: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Person.<span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 调用了Helper的私有方法</span></span><br><span class="line">        walkOnFoot()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> person = Person()</span><br><span class="line">        <span class="comment">// 仅可以在Helper类当中使用此扩展</span></span><br><span class="line">        person.walk()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建了一个 Helper 类，它内部有一个私有的成员方法，同时，我们在这个类的内部定义了一个扩展属性和一个扩展函数。可以看到，我们在扩展函数 walk() 方法当中，能直接调用 Helper 类的私有成员方法 walkOnFoot()，这体现了类的内部定义扩展的优势。</p><p>但是与此同时，这种方式定义的扩展也存在一个劣势，那就是无法在 Helper 类的外部作为扩展被调用。如果你将上面的代码反编译成 Java，你会发现，我们定义的内部扩展，最终都变成了 Helper 类的普通成员函数和成员属性。</p><p>所以，针对扩展的第三个限制来说：</p><ul><li>如果扩展是<strong>顶层的扩展</strong>，那么扩展的访问域仅限于该 Kotlin 文件当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展是可以被全局使用的。</li><li>如果扩展是<strong>被定义在某个类</strong>当中的，那么该扩展的访问域仅限于该类当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展仅能在该类当中使用。</li></ul><h2 id="实战与思考"><a href="#实战与思考" class="headerlink" title="实战与思考"></a>实战与思考</h2><p>到这里，我们就了解了 Kotlin 的扩展，包括扩展函数、扩展属性以及扩展的实现原理，同时我们也在了解它原理的基础上分析了它的能力边界。</p><p>不过，即使在学习完上面所有的知识点后，你也许还是不太清楚 Kotlin 扩展的实际使用场景。所以下面，我再带你来看两个案例，这两个工业界的实际案例，可以完美地向你展示 Kotlin 扩展的两个核心使用场景。你可以通过学习这两种思路，将其运用在实际的工作当中。</p><p>第一个案例，是来自 Kotlin 标准库当中的源代码。我们先看看在 Kotlin 当中，<a href="https://github.com/JetBrains/kotlin/blob/master/core/builtins/native/kotlin/String.kt">String.kt</a>的源代码是什么样的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// String.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> : <span class="type">Comparable</span>&lt;<span class="type">String</span>&gt;, <span class="type">CharSequence</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> length: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Char</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">subSequence</span><span class="params">(startIndex: <span class="type">Int</span>, endIndex: <span class="type">Int</span>)</span></span>: CharSequence</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你一定会很惊讶，Kotlin 里面的 String 类竟然只有不到十行代码。那么，String 类的那些字符操作的方法到哪里去了？比如，String.trim()、String.lowercase() 它们定义在什么地方？</p><p>实际上，String 相关的操作方法全都放到了Strings.kt当中去了。而这些字符操作方法全部都是以扩展函数的方式定义的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Strings.kt 部分代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">trim</span><span class="params">()</span></span>: CharSequence = trim(<span class="built_in">Char</span>::isWhitespace)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">expect</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">lowercase</span><span class="params">()</span></span>: String</span><br></pre></td></tr></table></figure><p>那么，Kotlin 官方能不能将“字符操作方法”放到 String 类当中合并到一起呢？源代码是 Kotlin 官方写的，他们当然能将所有的代码都合并到一个类当中去，形成一个几千行的 String 类，但他们却没有这么做。这是为啥呢？</p><p>这就是 Kotlin 扩展的<strong>第一个典型使用场景</strong>：<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">关注点分离</a>。所谓关注点分离，就是将我们程序的逻辑划分成不同的部分，每一个部分，都只关注自己那部分的职责。以上面的 String 类为例，String.kt这个类，只关注 String 的核心逻辑；而Strings.kt则只关注 String 的操作符逻辑。</p><p>需要注意的是，只有借助 Kotlin 的扩展，我们才能实现这样的关注点分离设计。如果你去看 Java 的 String 类，你会发现它的源代码有三千多行。这是因为，Java 的 String 核心属性跟它的操作方法全都混合在了一起。</p><p>第二个代码案例，是我工作当中用到的一段 Android 扩展函数代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : ViewGroup.LayoutParams&gt;</span> View.<span class="title">updateLayoutParams</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> params = layoutParams <span class="keyword">as</span> T</span><br><span class="line">    block(params)</span><br><span class="line">    layoutParams = params</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">updateMargin</span><span class="params">(left: <span class="type">Int</span>? = <span class="literal">null</span>, top: <span class="type">Int</span>? = <span class="literal">null</span>, right: <span class="type">Int</span>? = <span class="literal">null</span>, bottom: <span class="type">Int</span>? = <span class="literal">null</span>)</span></span> &#123;</span><br><span class="line">    (layoutParams <span class="keyword">as</span>? ViewGroup.MarginLayoutParams)?.let &#123; param -&gt;</span><br><span class="line">        updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; &#123;</span><br><span class="line">            left?.let &#123;</span><br><span class="line">                marginStart = left</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            right?.let &#123;</span><br><span class="line">                marginEnd = right</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            top?.let &#123;</span><br><span class="line">                topMargin = top</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bottom?.let &#123;</span><br><span class="line">                bottomMargin = bottom</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了两个扩展函数，updateLayoutParams()、updateMargin()，后者的方法体当中用到了前者。通过 updateMargin() 这个扩展函数，可以大大简化 Android 当中的 margin 更新。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">iew.updateMargin(top = <span class="number">100</span>, bottom = <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>而如果不借助扩展函数，我们将不得不写一堆的模板代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> params = view.layoutParams</span><br><span class="line"><span class="keyword">if</span> (params <span class="keyword">is</span> ViewGroup.MarginLayoutParams) &#123;</span><br><span class="line">    params.marginTop = <span class="number">100</span></span><br><span class="line">    params.marginBottom = <span class="number">100</span></span><br><span class="line">    view.layoutParams = params</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，借助扩展函数，我们不仅提升了代码的可读性，还提升了编码效率，而这种效率可以说是<strong>成倍</strong>的提升：借助扩展函数，我们只需要写一行代码，IntelliJ 还会智能提示，帮我们补全代码；不借助扩展函数的话，我们需要写 5 行代码，这样的代码模式不仅枯燥繁琐，IntelliJ 也无法智能提示，也更容易出错。</p><p>我们来小结一下，Kotlin 扩展主要有两个核心使用场景。</p><ul><li><strong>主动使用扩展，通过它来优化软件架构。</strong></li></ul><p>对复杂的类进行职责划分，关注点分离。让类的核心尽量简单易懂，而让类的功能性属性与方法以扩展的形式存在于类的外部。比如我们的<a href="https://github.com/JetBrains/kotlin/blob/master/core/builtins/native/kotlin/String.kt">String.kt</a>与<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/text/Strings.kt">Strings.kt</a>。</p><ul><li><strong>被动使用扩展，提升可读性与开发效率。</strong></li></ul><p>当我们无法修改外部的 SDK 时，对于重复的代码模式，我们将其以扩展的方式封装起来，提供给对应的接收者类型，比如 view.updateMargin()。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好，让我们来做个简单的总结吧。</p><ul><li>Kotlin 的扩展，从<strong>语法角度</strong>来看，分为扩展函数和扩展属性。定义扩展的方式，只是比普通函数、属性多了一个“扩展接收者”而已。</li><li>从<strong>作用域角度</strong>来看，分为顶层扩展和类内扩展。</li><li>从<strong>本质</strong>上来看，扩展函数和扩展属性，它们都是 Java 静态方法，与 Java 当中的工具类别无二致。对比 Java 工具类，扩展最大的优势就在于，IDE 可以为我们提供代码补全功能。</li><li>从<strong>能力</strong>的角度来看，Kotlin 扩展一共有三个限制，分别是：扩展无法被重写；扩展属性无法存储状态；扩展的作用域有限，无法访问私有成员。</li><li>从<strong>使用场景</strong>的角度来看，Kotlin 扩展主要有两个使用场景，分别是：关注点分离，优化代码架构；消灭模板代码，提高可读性和开发效率。</li></ul><p>最后在这里，我还想和你分享一下我在学 Kotlin 扩展的思考过程，希望这种思考的方式可以给你带来一些启发。</p><p>刚开始，我学习扩展的时候，脑子里其实是一片混乱的，就像下面这张图一样：扩展的每一个知识点都是散乱的。</p><p>这时候，我们就要将这些知识点做一个分类整理，同时，在学习扩展语法的时候，还要与前面的普通函数、普通属性的语法进行关联记忆。这样一来，我们零散的知识点就连接到一起，形成体系化的知识面。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/3d/5c/3d0715ee9ba1461bcee1bea99de8e25c.jpg?wh=1920x1080" alt="img"></p><p>当我们的知识形成一个体系之后，记忆起来就很容易了，这样，一个简单的<strong>浅层知识结构</strong>就形成了。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/5b/ac/5b2f0b9560d9198a9166f5e9016c83ac.jpg?wh=1920x1080" alt="img"></p><p>接着，在这个基础上，我们再进行深度的思考，去探索扩展的底层原理，还有它的能力边界，从而形成一个更加<strong>深层次的知识结构</strong>。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/3e/18/3e42099e82472869f87e33e9202c1218.jpg?wh=1999x1273" alt="img"></p><p>到目前为止，这些都是理论层面的一些知识，我们还需要进一步探索 Kotlin 扩展的实际应用场景。这时候，就会发现它的两个主要使用场景，<strong>一个是主动的，一个是被动的。</strong></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/b4/10/b4a3ce7c3e0b2228161faa4769618a10.jpg?wh=1999x1333" alt="img"></p><p>其实，学习就是一个不断向下挖掘探索的过程。学习 Kotlin 是这样，学习其他计算机知识也是这样，甚至学习其他领域的知识也是这个道理。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>在这节课中的所有案例中，我们的“扩展接收者”都是不为空的类型。但实际上，Kotlin 的扩展是允许我们为“可为空的类型”进行扩展的。比如说：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 不为空的接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可为空的接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String?.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;&#125;</span><br></pre></td></tr></table></figure><p>那么，请问这两种扩展有什么不同？欢迎在评论区分享你的思路，我们下节课再见。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)05  object关键字：你到底有多少种用法？</title>
      <link href="/posts/38dca859/"/>
      <url>/posts/38dca859/</url>
      
        <content type="html"><![CDATA[<p>这节课我们来学习 Kotlin 当中 object 关键字的三种语义，以及它的具体使用场景。</p><p>在前面课程中，我们学习了 Kotlin 语言的基础语法和面向对象相关的语法，其中涵盖了很多不同类型的关键字。比如说，fun 关键字代表了定义函数，class 关键字代表了定义类，这些都是一成不变的。但是今天我们要学习的 object 关键字，却有三种迥然不同的语义，分别可以定义：</p><ul><li>匿名内部类；</li><li>单例模式；</li><li>伴生对象。</li></ul><p>之所以会出现这样的情况，是因为 Kotlin 的设计者认为，这三种语义本质上都是在<strong>定义一个类的同时还创建了对象</strong>。在这样的情况下，与其分别定义三种不同的关键字，还不如将它们统一成 object 关键字。</p><p>那么，理解 object 关键字背后的统一语义，对我们学习这个语法是极其关键的，因为它才是这三种不同语义背后的共同点。通过这个统一语义，我们可以在这三种语义之间建立联系，形成知识体系。这样，我们在后面的学习中才不会那么容易迷失，也不会那么容易遗忘。</p><p>接下来，我们就一起来逐一探讨这三种情况吧。</p><h2 id="object：匿名内部类"><a href="#object：匿名内部类" class="headerlink" title="object：匿名内部类"></a>object：匿名内部类</h2><p>首先是 object 定义的匿名内部类。</p><p>Java 当中其实也有匿名内部类的概念，这里我们可以通过跟 Java 的对比，来具体理解下 Kotlin 中对匿名内部类的定义。</p><p>在 Java 开发当中，我们经常需要写类似这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnClickListener</span> &#123;</span><br><span class="line">    void onClick(View v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">image.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onClick(View v) &#123;</span><br><span class="line">        gotoPreview();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这就是典型的匿名内部类的写法，View.OnClickListener 是一个接口，因此我们在创建它的时候，<strong>必须实现它内部没有实现的方法</strong>。</p><p>类似地，在 Kotlin 当中，我们会使用 object 关键字来创建匿名内部类。同样，在它的内部，我们也必须要实现它内部未实现的方法。这种方式不仅可以用于创建接口的匿名内部类，也可以创建抽象类的匿名内部类。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">image.setOnClickListener(<span class="keyword">object</span>: View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        gotoPreview()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要特殊说明的是，当 Kotlin 的匿名内部类只有一个需要实现的方法时，我们可以使用 SAM 转换，最终使用 Lambda 表达式来简化它的写法。这个话题我们会留到第 7 讲再详细分析。</p><p>所以也就是说，Java 和 Kotlin 相同的地方就在于，它们的接口与抽象类，都不能直接创建实例。想要创建接口和抽象类的实例，我们必须通过匿名内部类的方式。</p><p>不过，在 Kotlin 中，匿名内部类还有一个特殊之处，就是我们在使用 object 定义匿名内部类的时候，其实还可以在<strong>继承一个抽象类的同时，来实现多个接口</strong>。</p><p>我们看个具体的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">funA</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">funB</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Man</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">findMan</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这个匿名内部类，在继承了Man类的同时，还实现了A、B两个接口</span></span><br><span class="line">    <span class="keyword">val</span> item = <span class="keyword">object</span> : Man(), A, B&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">funA</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">funB</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findMan</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们分析一下这段代码。接口 A，它内部有一个 funA() 方法，接口 B，它内部有一个 funB() 方法，抽象类 Man，它内部有一个抽象方法 findMan()。</p><p>接着，在 main() 函数当中，我们使用 object 定义了一个匿名内部类。这个匿名内部类，不仅继承了抽象类 Man，还同时实现了接口 A、接口 B。而这种写法，在 Java 当中其实是不被支持的。</p><p>在日常的开发工作当中，我们有时会遇到这种情况：我们需要继承某个类，同时还要实现某些接口，为了达到这个目的，我们不得不定义一个内部类，然后给它取个名字。但这样的类，往往只会被用一次就再也没有其他作用了。</p><p>所以针对这种情况，使用 object 的这种语法就正好合适。我们既不用再定义内部类，也不用想着该怎么给这个类取名字，因为用过一次后就不用再管了。</p><h2 id="object：单例模式"><a href="#object：单例模式" class="headerlink" title="object：单例模式"></a>object：单例模式</h2><p>接着，我们再来了解下 object 定义的第二种语义，也就是单例模式。</p><p>在 Kotlin 当中，要实现<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a>其实非常简单，我们直接用 object 修饰类即可：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> UserManager &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码中我们可以发现，当使用 object 以后，就不必再写 class 关键字了。<strong>我们只需要关注业务逻辑</strong>，至于这个单例模式到底是如何实现的，我们交给 Kotlin 编译器就行了。这种便捷性，在 Java 当中是不可想象的。要知道，单例模式的实现，在 Java 当中是会被当做面试题来考的！而在 Kotlin 当中，它已变得无比简单。</p><p>在第 3 讲里，我带你学习过如何研究 Kotlin 的原理，那么如果你想看看 Kotlin 编译器到底是如何实现单例模式的，你也可以反编译看看对应的 Java 代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">UserManager</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> UserManager INSTANCE; </span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      UserManager var0 = new UserManager();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> UserManager() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> void login() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们使用 object 关键字定义单例类的时候，Kotlin 编译器会将其<strong>转换成静态代码块的单例模式</strong>。因为static{}代码块当中的代码，由虚拟机保证它只会被执行一次，因此，它在保证了线程安全的前提下，同时也保证我们的 INSTANCE 只会被初始化一次。</p><p>不过到这里，你或许就会发现，这种方式定义的单例模式，虽然具有简洁的优点，但同时也存在两个缺点。</p><ul><li><strong>不支持懒加载</strong>。这个问题很容易解决，我们在后面会提到。</li><li><strong>不支持传参构造单例</strong>。举个例子，在 Android 开发当中，很多情况下我们都需要用到 Context 作为上下文。另外有的时候，在单例创建时可能也需要 Context 才可以创建，那么如果这时候单纯只有 object 创建的单例，就无法满足需求了。</li></ul><p>那么，Kotlin 当中有没有其他方式来实现单例模式呢？答案当然是有的，不过，我们要先掌握 object 的第三种用法：伴生对象。</p><h2 id="object：伴生对象"><a href="#object：伴生对象" class="headerlink" title="object：伴生对象"></a>object：伴生对象</h2><p>我们都知道，Kotlin 当中没有 static 关键字，所以我们没有办法直接定义静态方法和静态变量。不过，Kotlin 还是为我们提供了伴生对象，来帮助实现静态方法和变量。</p><p>在正式讲解伴生对象之前，我们先来看看 object 定义单例的一种特殊情况，看看它是如何演变成“伴生对象”的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">object</span> InnerSingleton &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们可以将单例定义到一个类的内部。这样，单例就跟外部类形成了一种嵌套的关系，而我们要使用它的话，可以直接这样写：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Person.InnerSingleton.foo()</span><br></pre></td></tr></table></figure><p>以上的代码看起来，foo() 就像是静态方法一样。不过，为了一探究竟，我们可以看看 Person 类反编译成 Java 后是怎样的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InnerSingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> static <span class="keyword">final</span> Person.InnerSingleton INSTANCE;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> void foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> InnerSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">      static &#123;</span><br><span class="line">         Person.InnerSingleton var0 = new Person.InnerSingleton();</span><br><span class="line">         INSTANCE = var0;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，foo() 并不是静态方法，它实际上是通过调用单例 InnerSingleton 的实例上的方法实现的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Kotlin当中这样调用</span></span><br><span class="line">Person.InnerSingleton.foo()</span><br><span class="line"><span class="comment">//      等价</span></span><br><span class="line"><span class="comment">//       ↓  java 当中这样调用</span></span><br><span class="line">Person.InnerSingleton.INSTANCE.foo()</span><br></pre></td></tr></table></figure><p>这时候，你可能就会想：<strong>要如何才能实现类似 Java 静态方法的代码呢？</strong></p><p>其实很简单，我们可以使用“**@JvmStatic**”这个注解，如以下代码所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">object</span> InnerSingleton &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这个时候，如果你再反编译 Person 类，你会发现，foo() 这个方法就变成了 InnerSingleton 类当中的一个静态方法了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InnerSingleton</span> &#123;</span><br><span class="line">      <span class="comment">// 省略其他相同代码</span></span><br><span class="line">      <span class="keyword">public</span> static <span class="keyword">final</span> void foo() &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，对于 foo() 方法的调用，不管是 Kotlin 还是 Java，它们的调用方式都会变成一样的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Person.InnerSingleton.foo()</span><br></pre></td></tr></table></figure><p>看到这里，如果你足够细心，你一定会产生一个疑问：上面的静态内部类“InnerSingleton”看起来有点多余，我们平时在 Java 当中写的静态方法，不应该是只有一个层级吗？比如：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static void foo() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用的时候，只有一个层级</span></span><br><span class="line">Person.foo()</span><br></pre></td></tr></table></figure><p>答案当然是有的，我们只需要在前面例子当中的 object 关键字前面，加一个 <strong>companion 关键字</strong>即可。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="comment">//  改动在这里</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> InnerSingleton &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>companion object，在 Kotlin 当中就被称作伴生对象，它其实是我们嵌套单例的一种特殊情况。也就是，<strong>在伴生对象的内部，如果存在“@JvmStatic”修饰的方法或属性，它会被挪到伴生对象外部的类当中，变成静态成员。</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> Person.InnerSingleton InnerSingleton = new Person.InnerSingleton((DefaultConstructorMarker)<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注意这里</span></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> void foo() &#123;</span><br><span class="line">      InnerSingleton.foo();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InnerSingleton</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> void foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> InnerSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> InnerSingleton(DefaultConstructorMarker $constructor_marker) &#123;</span><br><span class="line">         <span class="keyword">this</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面反编译后的代码，我们可以看出来，被挪到外部的静态方法 foo()，它最终还是调用了单例 InnerSingleton 的成员方法 foo()，所以它只是做了一层转接而已。</p><p>到这里，也许你已经明白 object 单例、伴生对象中间的演变关系了：普通的 object 单例，演变出了嵌套的单例；嵌套的单例，演变出了伴生对象。</p><p>你也可以换个说法<strong>：嵌套单例，是 object 单例的一种特殊情况；伴生对象，是嵌套单例的一种特殊情况。</strong></p><h2 id="伴生对象的实战应用"><a href="#伴生对象的实战应用" class="headerlink" title="伴生对象的实战应用"></a>伴生对象的实战应用</h2><p>前面我们已经使用 object 关键字实现了最简单的单例模式，这种方式的缺点是不支持懒加载、不支持“getInstance() 传递参数”。而借助 Kotlin 的伴生对象，我们可以实现功能更加全面的单例模式。</p><p>不过，在使用伴生对象实现单例模式之前，我们需要先热热身，用它来实现工厂模式。下面，我就给你详细介绍一下。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>所谓的<a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">工厂模式</a>，就是指当我们想要统一管理一个类的创建时，我们可以将这个类的构造函数声明成 private，然后用工厂模式来暴露一个统一的方法，以供外部使用。Kotlin 的伴生对象非常符合这样的使用场景：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  私有的构造函数，外部无法调用</span></span><br><span class="line"><span class="comment">//            ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(name: <span class="type">String</span>)</span></span>: User? &#123;</span><br><span class="line">            <span class="comment">// 统一检查，比如敏感词过滤</span></span><br><span class="line">            <span class="keyword">return</span> User(name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子当中，我们将 User 的构造函数声明成了 private 的，这样，外部的类就无法直接使用它的构造函数来创建实例了。与此同时，我们通过伴生对象，暴露出了一个 create() 方法。在这个 create() 方法当中，我们可以做一些统一的判断，比如敏感词过滤、判断用户的名称是否合法。</p><p>另外，由于“伴生对象”本质上还是属于 User 的嵌套类，伴生对象仍然还算是在 User 类的内部，所以，我们是可以在 create() 方法内部调用 User 的构造函数的。</p><p>这样，我们就通过“伴生对象”巧妙地实现了工厂模式。接下来，我们继续看看如何使用“伴生对象”来实现更加复杂的单例设计模式。</p><h2 id="另外-4-种单例模式的写法"><a href="#另外-4-种单例模式的写法" class="headerlink" title="另外 4 种单例模式的写法"></a>另外 4 种单例模式的写法</h2><p>在前面，我们已经学习了 Kotlin 当中最简单的单例模式，也就是 object 关键字。同时，我们也提到了，这种方式虽然简洁，但它也存在两大问题：第一，无法懒加载；第二，不支持传参。</p><p>那么，Kotlin 当中有没有既支持懒加载又支持传参的单例模式呢？</p><p>答案当然是有的。接下来，我们就来了解下 Kotlin 里功能更加全面的 4 种单例模式，分别是懒加载委托单例模式、Double Check 单例模式、抽象类模板单例，以及接口单例模板。</p><h3 id="第一种写法：借助懒加载委托"><a href="#第一种写法：借助懒加载委托" class="headerlink" title="第一种写法：借助懒加载委托"></a>第一种写法：借助懒加载委托</h3><p>其实，针对懒加载的问题，我们在原有的代码基础上做一个非常小的改动就能优化，也就是借助 Kotlin 提供的“委托”语法。</p><p>比如，针对前面的单例代码，我们在它内部的属性上使用 by lazy 将其包裹起来，这样我们的单例就能得到一部分的懒加载效果。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> UserManager &#123;</span><br><span class="line">    <span class="comment">// 对外暴露的 user</span></span><br><span class="line">    <span class="keyword">val</span> user <span class="keyword">by</span> lazy &#123; loadUser() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line">        <span class="comment">// 从网络或者数据库加载数据</span></span><br><span class="line">        <span class="keyword">return</span> User.create(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，UserManager 内部的 user 变量变成了懒加载，只要 user 变量没有被使用过，它就不会触发 loadUser() 的逻辑。</p><p>这其实是一种<strong>简洁与性能的折中方案</strong>。一个对象所占用的内存资源毕竟不大，绝大多数情况我们都可以接受。而从服务器去请求用户信息所消耗的资源更大，我们能够保证这个部分是懒加载的，就算是不错的结果了。</p><p><code>注意：这里我们用到了 by lazy，它是 Kotlin 当中的“懒加载委托”语法。我们会在第 9 讲里详细介绍它。目前你只需要知道，它可以保证懒加载的同时，还能保证线程安全即可。</code></p><h3 id="第二种写法：伴生对象-Double-Check"><a href="#第二种写法：伴生对象-Double-Check" class="headerlink" title="第二种写法：伴生对象 Double Check"></a>第二种写法：伴生对象 Double Check</h3><p>我们直接看代码吧：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: UserManager? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(name: <span class="type">String</span>)</span></span>: UserManager =</span><br><span class="line">            <span class="comment">// 第一次判空</span></span><br><span class="line">            INSTANCE?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 第二次判空</span></span><br><span class="line">                INSTANCE?:UserManager(name).also &#123; INSTANCE = it &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">UserManager.getInstance(<span class="string">&quot;Tom&quot;</span>)</span><br></pre></td></tr></table></figure><p>这种写法，其实是借鉴于 GitHub 上的<a href="https://github.com/android/architecture-components-samples/blob/master/BasicRxJavaSampleKotlin/app/src/main/java/com/example/android/observability/persistence/UsersDatabase.kt">Google 官方 Demo</a>，它本质上就是 Java 的 Double Check。</p><p>首先，我们定义了一个伴生对象，然后在它的内部，定义了一个 INSTANCE，它是 private 的，这样就保证了它无法直接被外部访问。同时它还被注解“@Volatile”修饰了，这可以保证 INSTANCE 的可见性，而 getInstance() 方法当中的 synchronized，保证了 INSTANCE 的原子性。因此，这种方案还是线程安全的。</p><p>时，我们也能注意到，初始化情况下，INSTANCE 是等于 null 的。这也就意味着，只有在 getInstance() 方法被使用的情况下，我们才会真正去加载用户数据。这样，我们就实现了整个 UserManager 的懒加载，而不是它内部的某个参数的懒加载。</p><p>另外，由于我们可以在调用 getInstance(name) 方法的时候传入初始化参数，因此，这种方案也是支持传参的。</p><p>不过，以上的实现方式仍然存在一个问题，在实现了 UserManager 以后，假设我们又有一个新的需求，要实现 PersonManager 的单例，这时候我们就需要重新写一次 Double Check 的逻辑。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: PersonManager? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(name: <span class="type">String</span>)</span></span>: PersonManager =</span><br><span class="line">            INSTANCE?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">                INSTANCE?:PersonManager(name).also &#123; INSTANCE = it &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，不同的单例当中，我们必须反复写 Double Check 的逻辑，这是典型的坏代码。这种方式不仅很容易出错，同时也不符合编程规则（Don’t Repeat Yourself）。</p><p>那么，有没有一种办法可以让我们复用这部分逻辑呢？答案当然是肯定的。</p><h3 id="第三种写法：抽象类模板"><a href="#第三种写法：抽象类模板" class="headerlink" title="第三种写法：抽象类模板"></a>第三种写法：抽象类模板</h3><p>我们来仔细分析下第二种写法的单例。其实很快就能发现，它主要由两个部分组成：第一部分是 INSTANCE 实例，第二部分是 getInstance() 函数。</p><p>现在，我们要尝试对这种模式进行抽象。在面向对象的编程当中，我们主要有两种抽象手段，第一种是<strong>类抽象模板</strong>，第二种是接口抽象模板。</p><p>这两种思路都是可以实现的，我们先来试试<strong>抽象类</strong>的方式，将单例当中通用的“INSTANCE 实例”和“getInstance() 函数”，抽象到 BaseSingleton 当中来。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  ①                          ②                      </span></span><br><span class="line"><span class="comment">//  ↓                           ↓                       </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseSingleton</span>&lt;<span class="type">in P, out T</span>&gt; &#123;</span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> instance: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//                       ③</span></span><br><span class="line">    <span class="comment">//                       ↓</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">P</span>)</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(param: <span class="type">P</span>)</span></span>: T =</span><br><span class="line">        instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//            ④</span></span><br><span class="line">            <span class="comment">//            ↓</span></span><br><span class="line">            instance ?: creator(param).also &#123; instance = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在仔细分析每一处注释之前，我们先来整体看一下上面的代码：我们定义了一个抽象类 BaseSingleton，在这个抽象类当中，我们把单例当中通用的“INSTANCE 实例”和“getInstance() 函数”放了进去。也就是说，我们把单例类当中的核心逻辑放到了抽象类当中去了。</p><p>现在，我们再来看看上面的 4 处注释。</p><ul><li>注释①：abstract 关键字，代表了我们定义的 BaseSingleton 是一个抽象类。我们以后要实现单例类，就只需要继承这个 BaseSingleton 即可。</li><li>注释②：in P, out T 是 Kotlin 当中的泛型，P 和 T 分别代表了 getInstance() 的参数类型和返回值类型。注意，这里的 P 和 T，是在具体的单例子类当中才需要去实现的。如果你完全不知道泛型是什么东西，可以先看看<a href="https://zh.wikipedia.org/zh/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B">泛型的介绍</a>，我们在第 10 讲会详细介绍 Kotlin 泛型。</li><li>注释③：creator(param: P): T 是 instance 构造器，它是一个抽象方法，需要我们在具体的单例子类当中实现此方法。</li><li>注释④：creator(param) 是对 instance 构造器的调用。</li></ul><p>这里，我们就以前面的 UserManager、PersonManager 为例，用抽象类模板的方式来实现单例，看看代码会发生什么样的变化。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="comment">//               ①                  ②</span></span><br><span class="line">    <span class="comment">//               ↓                   ↓</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : BaseSingleton&lt;String, PersonManager&gt;() &#123;</span><br><span class="line">    <span class="comment">//                  ③</span></span><br><span class="line">    <span class="comment">//                  ↓ </span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">String</span>)</span></span>: PersonManager = PersonManager(param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : BaseSingleton&lt;String, UserManager&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">String</span>)</span></span>: UserManager = UserManager(param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在仔细分析注释之前，我们可以看到：UserManager、PersonManager 的代码已经很简洁了，我们不必重复去写“INSTANCE 实例”和“Double Check”这样的模板代码，只需要简单继承 BaseSingleton 这个抽象类，按照要求传入泛型参数、实现 creator 这个抽象方法即可。</p><p>下面我们来分析上面的 3 处注释。</p><ul><li>注释①：companion object : BaseSingleton，由于伴生对象本质上还是嵌套类，也就是说，它仍然是一个类，那么它就具备类的特性“继承其他的类”。因此，我们让伴生对象继承 BaseSingleton 这个抽象类。</li><li>注释②：String, PersonManager，这是我们传入泛型的参数 P、T 对应的实际类型，分别代表了 creator() 的“参数类型”和“返回值类型”。</li><li>注释③：override fun creator，我们在子类当中实现了 creator() 这个抽象方法</li></ul><p>至此，我们就完成了单例的“抽象类模板”。通过这样的方式，我们不仅将重复的代码都统一封装到了抽象类“BaseSingleton”当中，还大大简化了单例的实现难度。</p><p>接下来，让我们对比着看看单例的“接口模板”。</p><h3 id="第四种写法：接口模板"><a href="#第四种写法：接口模板" class="headerlink" title="第四种写法：接口模板"></a>第四种写法：接口模板</h3><p>首先我需要重点强调，<strong>这种方式是不被推荐的</strong>，这里提出这种写法是为了让你熟悉 Kotlin 接口的特性，并且明白 Kotlin 接口虽然能做到这件事，但它做得并不够好。</p><p>如果你理解了上面的“抽象类模板”，那么，接口的这种方式你应该也很容易就能想到：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ISingleton</span>&lt;<span class="type">P, T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">var</span> instance: T?</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">P</span>)</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(p: <span class="type">P</span>)</span></span>: T =</span><br><span class="line">        instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            instance ?: creator(p).also &#123; instance = it &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，接口模板的代码结构和抽象类的方式如出一辙。而我们之所以可以这么做，也是因为 Kotlin 接口的两个特性：<strong>接口属性、接口方法默认实现</strong>。在第 1 讲的时候，我们提到过，Kotlin 当中的接口被增强了，让它与抽象类越来越接近，这个例子正好就可以说明这一点。抽象类能实现单例模板，我们的接口也可以。</p><p>说实话，上面的接口单例模板看起来还是比较干净的，好像也挑不出什么大的毛病。但实际上，如果你看注释①的地方，你会发现：</p><ul><li><strong>instance 无法使用 private 修饰</strong>。这是接口特性规定的，而这并不符合单例的规范。正常情况下的单例模式，我们内部的 instance 必须是 private 的，这是为了防止它被外部直接修改。</li><li><strong>instance 无法使用 @Volatile 修饰</strong>。这也是受限于接口的特性，这会引发多线程同步的问题。</li></ul><p>除了 ISingleton 接口有这样的问题，我们在实现 ISingleton 接口的类当中，也会有类似的问题。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>: ISingleton&lt;String, Singleton&gt; &#123;</span><br><span class="line">        <span class="comment">//  ①      ②</span></span><br><span class="line">        <span class="comment">//  ↓       ↓</span></span><br><span class="line">        <span class="meta">@Volatile</span> <span class="keyword">override</span> <span class="keyword">var</span> instance: Singleton? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">String</span>)</span></span>: Singleton = Singleton(param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注释①：@Volatile，这个注解虽然可以在实现的时候添加，但<strong>实现方</strong>可能会忘记，这会导致隐患。</li><li>注释②：我们在实现 instance 的时候，仍然无法使用 private 来修饰。</li></ul><p>因此综合来看，单例“接口模板”并不是一种合格的实现方式。</p><p>不过，在研究这个接口模板的过程中，我们又重温了 Kotlin 接口属性、接口方法默认实现这两个特性，并且对这两个特性进行一次应用。与此同时，我们也理解了接口模板存在的缺陷，以及不被推荐的原因。</p><p>实际上，从一个知识锚点着手，我们用类似的方式，也可以帮助自己理解 Kotlin 其他的新特性。而在这个时候，我们会发现，Kotlin 语法之间并不是一些孤立的知识点，而是存在一些关联的，通过这种学习方式，能帮助我们快速建立起知识体系，这其实也是保持学习与思考连贯性的好办法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这节课，我们学习了 object 的三种语义，分别是匿名内部类、单例、伴生对象。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/cc/67/cc75cc62f08d1b4f2e604630499f8b67.jpg?wh=1920x1260" alt="img"></p><p>Kotlin 的匿名内部类和 Java 的类似，只不过它多了一个功能：匿名内部类可以在继承一个抽象类的同时还实现多个接口。</p><p>另外，object 的单例和伴生对象，这两种语义从表面上看是没有任何联系的。但通过这节课的学习我们发现了，单例与伴生对象之间是存在某种演变关系的。<strong>“单例”演变出了“嵌套单例”，而“嵌套单例”演变出了“伴生对象”。</strong></p><p>然后，我们也借助 Kotlin 伴生对象这个语法，研究了伴生对象的实战应用，比如可以实现工厂模式、懒加载 + 带参数的单例模式。</p><p>尤其是单例模式，这节课中，我们一共提出了 Kotlin 当中 5 种单例模式的写法。除了最后一种“接口模板”的方式，是为了学习研究不被推荐使用以外，其他 4 种单例模式都是有一定使用场景的。这 4 种单例之间各有优劣，我们可以在工作中根据实际需求，来选择对应的实现方式：</p><ul><li>如果我们的单例占用内存很小，并且对内存不敏感，不需要传参，直接使用 object 定义的单例即可。</li><li>如果我们的单例占用内存很小，不需要传参，但它内部的属性会触发消耗资源的网络请求和数据库查询，我们可以使用 object 搭配 by lazy 懒加载。</li><li>果我们的工程很简单，只有一两个单例场景，同时我们有懒加载需求，并且 getInstance() 需要传参，我们可以直接手写 Double Check。</li><li>如果我们的工程规模大，对内存敏感，单例场景比较多，那我们就很有必要使用抽象类模板 BaseSingleton 了。</li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>这节课当中，我们提到的 BaseSingleton 是否还有改进的空间？这个问题会在第 7 讲“高阶函数”里做出解答。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)04 | 实战：构建一个Kotlin版本的四则运算计算器</title>
      <link href="/posts/9850cd08/"/>
      <url>/posts/9850cd08/</url>
      
        <content type="html"><![CDATA[<p>前面几节课，我们学了不少 Kotlin 的语法，也算是对 Kotlin 有了一个基本认识。不过，单纯只认识 Kotlin 是远远不够的，我们还要<strong>会用 Kotlin</strong>。当遇到一个具体问题的时候，我们得能用 Kotlin 来解决这个问题。换句话说，就是要实战。在实战的过程中，我们对 Kotlin 的理解也会进一步加深。</p><p>那么这节课，我们就把前面的知识点串联起来，一起做一个 Kotlin 版本的计算器。为了便于理解，我会以<strong>循序渐进</strong>的方式来编写这个计算器程序，由简单到复杂。你在这个由易到难的实操过程中，可以实际体会到 Kotlin 的代码实现思路以及编码方式的变化，进而也就能更好地掌握和运用前面所学的基础语法，以及与面向对象相关的知识点。</p><p>这个计算器程序大致会分为三个版本：</p><ul><li>计算器 1.0，实现两个整数的“加减乘除”，对输入数据有严格要求。</li><li>计算器 2.0，对输入数据无严格要求，融入面向对象的编程思想。</li><li>计算器 3.0，支持“大数的加法”，增加单元测试。</li></ul><p>现在，我们就开始实战吧。</p><h2 id="创建-Kotlin-工程"><a href="#创建-Kotlin-工程" class="headerlink" title="创建 Kotlin 工程"></a>创建 Kotlin 工程</h2><p>如果你之前没有使用过 IntelliJ 或 Android Studio，你可能还不知道怎么创建一个工程。别担心，这个过程其实很简单，它分为以下几个步骤。</p><ul><li>第一步：选择菜单“File -&gt; New -&gt; Project”。</li><li>第二步：选中菜单左边的“Gradle”，然后在右边勾选“Java 和 Kotlin&#x2F;JVM”，最后点击右下角的“Next”。</li><li>第三步：给工程取一个你喜欢的名字，我们这里就用 Calculator。GroupId 这个地方一般使用倒过来的域名，这里根据你的实际情况填写即可。默认情况下，IDE 会自动帮你设置成“org.example”，所以你不去改动它也没问题。最后，我们点击 Finish，工程就创建成功了！</li><li>第四步：等待工程配置完成。<strong>如果你是第一次创建 Kotlin 工程，点击 Finish 以后，你可能需要等待一段时间，IDE 需要下载 Gradle，然后用 Gradle 下载工程所需的依赖</strong>。当你在 IDE 当中能看到这样的工程结构时，这个工程就算配置完成了。</li></ul><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/89/9f/89cyycca9830e62538528df5e62fbc9f.gif?wh=1000x750" alt="img" style="zoom:67%;" /><h2 id="导入初始化工程"><a href="#导入初始化工程" class="headerlink" title="导入初始化工程"></a>导入初始化工程</h2><p>其实，你只需要知道如何创建一个 Kotlin 工程就行了，也没必要真的跟着我一步步操作。课程配套的源代码已经在GitHub开源，你可以将其下载下来并切换到 start 分支，这样就可以跟着课程一步步实现计算器的三个版本了。</p><p><strong>具体做法是这样的</strong>：打开 IntelliJ，点击“Get from VCS”按钮，接着在弹出的窗口中，填入我们的 GitHub URL“<a href="https://github.com/chaxiu/Calculator.git%E2%80%9D%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB%E5%8F%B3%E4%B8%8B%E8%A7%92%E7%9A%84">https://github.com/chaxiu/Calculator.git”，然后点击右下角的</a> Clone 按钮即可。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/sNFVr93gcuP2YpO.gif" alt="img" style="zoom: 67%;" /><p>等代码下载完成以后，IDE 会问你是否要打开此工程，我们选择打开。这样，我们的计算器工程就算导入进来了。</p><p>最后，我们还需要将工程改为初始化状态，借助 Git 我们可以非常方便地实现：</p><ul><li>在 IntelliJ 的右下角，找到 main 按钮并且点击；</li><li>在弹出的菜单中，点击 start 分支；</li><li>最后，点击 Checkout，代表将当前代码切换到初始状态。</li></ul><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/FfEcZlIjLa5YdGb.png" alt="img"></p><p>这样，我们就完成了整个工程的初始化配置了。为了测试我们的开发环境是否已经配置好，我们可以打开工程里的 HelloWorld 文件，运行一下，看看程序是否正常执行。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/db/1f/db316ef784abb04cd3fc87fcd9b0a31f.gif?wh=976x544" alt="img" style="zoom: 67%;" /><p>如果你也能在工程当中看见控制台输出“Hello world.”，说明你的开发环境已经完全没问题了。接下来，就让我们一起用 Kotlin 完成计算器的 1.0 版本吧！</p><h2 id="计算器-1-0"><a href="#计算器-1-0" class="headerlink" title="计算器 1.0"></a>计算器 1.0</h2><p>第一个版本的计算器，它的功能非常简单，你可以看看下面的动图演示。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/PTlj4VWfORg3s5A.gif" alt="img"></p><p>我们大致列举一下这个计算器的功能需求：</p><ul><li>交互式界面，输入算式，按下回车，程序就会帮我们计算出结果；</li><li>数字与字符之间要求有空格，“1 + 1”是可以的，“1+1”则不行；</li><li>输入 exit，按下回车，程序就会退出；</li><li>支持“加减乘除”，四种运算，仅支持两个数的运算。</li></ul><p>搞清楚功能需求以后，我们就可以开始写代码了。</p><p>首先，我们要创建一个 Kotlin 源代码文件：在 Kotlin 文件夹下，点击右键，选择“New -&gt; Kotlin Class&#x2F;File”，然后填写文件名字即可，这里我们创建一个名为 Calculator 的 Kotlin 文件。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/J8hnkxLSrPiyQeI.png" alt="img"></p><p>由于我们的程序要和命令进行交互，根据不同的命令来做出不同的行为，因此，我们的程序需要有一个 <strong>while 循环</strong>的逻辑，在循环当中，还要读取命令行的输入，然后根据输入的结果来判断执行逻辑。我们可以将整个程序分为以下几个步骤：</p><ul><li>初始化，打印提示信息；</li><li>第一步，读取输入命令；</li><li>第二步，判断命令是不是 exit，如果用户输入的是“exit”则直接退出程序；</li><li>第三步，解析算式，分解出“数字”与“操作符”：“1”“+”“2”；</li><li>第四步，根据操作符类型，算出结果：3；</li><li>第五步，输出结果：1 + 2 &#x3D; 3；</li><li>第六步，进入下一个 while 循环。</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化，打印提示信息</span></span><br><span class="line">        println(<span class="string">&quot;请输入标准的算式，并且按回车; \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;比如：1 + 1，注意符合与数字之间要有空格。\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;输入exit，退出程序。&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一步，读取输入命令；</span></span><br><span class="line">        <span class="keyword">var</span> input = readLine()</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="literal">null</span>) <span class="keyword">continue</span></span><br><span class="line">        <span class="comment">// 第二步，判断命令是不是exit，如果是则直接退出程序；</span></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="string">&quot;exit&quot;</span>) exitProcess(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三步，解析算式，分解出“数字”与“操作符”：“1”“+”“2”；</span></span><br><span class="line">        <span class="keyword">var</span> inputList = input.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="comment">// 第四步，根据操作符类型，算出结果：3；</span></span><br><span class="line">        <span class="keyword">var</span> result = calculate(inputList)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第五步，输出结果：1 + 2 = 3；</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;输入格式不对&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$input</span> = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第六步，进入下一个while循环。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体计算逻辑</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(inputList: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputList.size != <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第七步，取出数字和操作符</span></span><br><span class="line">    <span class="keyword">var</span> left = inputList.<span class="keyword">get</span>(<span class="number">0</span>).toInt()</span><br><span class="line">    <span class="keyword">var</span> operation = inputList.<span class="keyword">get</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> right = inputList.<span class="keyword">get</span>(<span class="number">2</span>).toInt()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第八步，根据操作符的类型，执行计算</span></span><br><span class="line">    <span class="keyword">when</span>(operation) &#123;</span><br><span class="line">        <span class="string">&quot;+&quot;</span> -&gt; <span class="keyword">return</span> left + right</span><br><span class="line">        <span class="string">&quot;-&quot;</span> -&gt; <span class="keyword">return</span> left - right</span><br><span class="line">        <span class="string">&quot;*&quot;</span> -&gt; <span class="keyword">return</span> left * right</span><br><span class="line">        <span class="string">&quot;/&quot;</span> -&gt; <span class="keyword">return</span> left / right</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码非常简单直白，即使你没有任何编程经验，应该也能够理解。它也非常符合人的编程直觉。</p><p>不过，站在 Kotlin 的角度上看，以上的代码其实是有不少问题的，让我们通过一个图来对比着看：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/K7lLgMPDNtknQsw.png" alt="img"></p><ul><li>箭头①，表示程序中的“提示信息”应该使用 Kotlin 的“三引号”的原始字符串，这样的话，我们可以省去繁琐的“\n 和 +”，并且所见即所得；</li><li>箭头②，表示读取输入命令后，我们可以直接使用 Elvis 表达式，两行代码就会变成一行；</li><li>箭头③，表示程序中所有的 var 都应该改为 val，我在第 1 讲中说过，在 Kotlin 当中，我们应该优先使用 val，尽量避免使用可变的变量。</li><li>箭头④，表示 inputList.get(i) 可以改为 inputList[i]，这是因为 Kotlin 统一了数组和集合的元素访问操作，我们再也不用担心弄混了。</li><li>箭头⑤，表示了两点。首先，我们可以将 return 放到 when 表达式的前面，这样就省得我们每个分支都写一遍 return。另外，当我们使用 when 表达式的时候，应该尽量结合“枚举”或者“密封类”来使用。为此，我们可以为“加减乘除”四个操作符创建一个枚举类。这样，when 表达式的分支会自动判定完备，而不需要 else 分支了。</li></ul><p>那么经过调整，最终的源代码应该是这样的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> help = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">--------------------------------------</span></span><br><span class="line"><span class="string">使用说明：</span></span><br><span class="line"><span class="string">1. 输入 1 + 1，按回车，即可使用计算器；</span></span><br><span class="line"><span class="string">2. 注意：数字与符号之间要有空格；</span></span><br><span class="line"><span class="string">3. 想要退出程序，请输入：exit</span></span><br><span class="line"><span class="string">--------------------------------------&quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        println(help)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> input = readLine() ?: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="string">&quot;exit&quot;</span>) exitProcess(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> inputList = input.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> result = calculate(inputList)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;输入格式不对&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$input</span> = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(inputList: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputList.size != <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> left = inputList[<span class="number">0</span>].toInt()</span><br><span class="line">    <span class="comment">//                           ①</span></span><br><span class="line">    <span class="comment">//                           ↓</span></span><br><span class="line">    <span class="keyword">val</span> operation = Operation.valueOf(inputList[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">val</span> right = inputList[<span class="number">2</span>].toInt()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (operation) &#123;</span><br><span class="line">        Operation.ADD -&gt; left + right</span><br><span class="line">        Operation.MINUS -&gt; left - right</span><br><span class="line">        Operation.MULTI -&gt; left * right</span><br><span class="line">        Operation.DIVI -&gt; left / right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Operation</span>(<span class="keyword">val</span> value: String) &#123;</span><br><span class="line">    ADD(<span class="string">&quot;+&quot;</span>),</span><br><span class="line">    MINUS(<span class="string">&quot;-&quot;</span>),</span><br><span class="line">    MULTI(<span class="string">&quot;*&quot;</span>),</span><br><span class="line">    DIVI(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，我们的计算器 1.0 版本，到这里就算是完成了。</p><p>如果你跟随着我，一起来实现了这个简单的计算器，那么你在这个实操过程中就可以体会到，Kotlin 编程与传统的 Java&#x2F;C 之间确实是存在着一定的差别的。</p><p><strong>想要学会 Kotlin 语法其实不难，但要写出优雅的 Kotlin 代码，却不是一件容易的事情</strong>。我们唯一能做的，就是多写 Kotlin 代码，同时多看优秀的 Kotlin 代码，以及多思考改进自己已有的代码。</p><p>不过，代码中注释①处其实还有一些问题，接着让我们进入第二个版本的开发吧！</p><h2 id="计算器-2-0"><a href="#计算器-2-0" class="headerlink" title="计算器 2.0"></a>计算器 2.0</h2><p>在 2.0 版本中，我们会分成两个阶段：</p><ul><li>第一个阶段，<strong>融入面向对象的思想</strong>。1.0 版本中，我们只写了两个函数，一个是 main() 函数，另一个是 calculate() 函数。虽然这样的设计非常直观且便于理解，但却不太符合我们工程界的思维习惯。我们应该将程序封装到一个类当中，并且尽量让每个函数的功能划分清楚，保持每个函数尽量简单。</li><li>第二个阶段，<strong>兼容输入格式</strong>。1.0 版本中，我们对输入有严格的要求，数字和符号之间必须有空格，否则我们的算式解析会出错。在 2.0 版本中，我们尝试兼容不同的输入格式，不管数字和符号之间有没有空格，我们都要能成功执行。</li></ul><p>让我们一步步来，首先是融入面向对象的思想。</p><h3 id="第一阶段：融入面向对象思想"><a href="#第一阶段：融入面向对象思想" class="headerlink" title="第一阶段：融入面向对象思想"></a>第一阶段：融入面向对象思想</h3><p>具体做法其实也很简单，我们可以将前面定义的两个函数收拢到一个类当中去，比如“CalculatorV2”：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalculatorV2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(input: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span>? &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在这个 CalculatorV2 类当中有两个方法，<strong>start()</strong> 用于启动我们的计算器程序，监听控制台的文本输入；<strong>calculate(input)</strong> 用于接收输入文本，计算出算式的结果，然后返回一个可为空的整型，当输入不合法的时候会返回 null。</p><p>这样，我们的计算器作为一个整体已经是一个对象了，我们可以很方便地在 main() 函数当中，创建一个实例，并且调用它的 start() 函数。这样一来，我们的计算器也就可以充分发挥出面向对象的优势。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> calculator = CalculatorV2()</span><br><span class="line">    calculator.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了计算器本身需要面向对象，我们的输入表达式也可以抽象出一个具体模型出来。</p><p>我们知道，一个算式分为左边的数字、操作符和右边的数字。因此我们还可以定义一个类，来代表算式表达式。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Expression</span>(</span><br><span class="line">    <span class="keyword">val</span> left: String,</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">operator</span>: Operation,</span><br><span class="line">    <span class="keyword">val</span> right: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>比如，我们想要表达“1 + 2”这个式子的话，我们就可以用这样一个结构来表示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Expression(<span class="string">&quot;1&quot;</span>, Operation.ADD, <span class="string">&quot;2&quot;</span>)</span><br></pre></td></tr></table></figure><p>那么，在完成了面向对象的模型化以后，我们还需要进一步拆分函数的职责与颗粒度。其中，start() 方法，主要用于控制程序的流程、输入与输出：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        println(HELP)</span><br><span class="line">        <span class="keyword">val</span> input = readLine() ?: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">val</span> result = calculate(input)</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;输入格式不对&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$input</span> = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 calculate() 方法，则需要进一步地拆分：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(input: <span class="type">String</span>)</span></span>: String? &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldExit(input)) exitProcess(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> exp = parseExpression(input) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> left = exp.left</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">operator</span> = exp.<span class="keyword">operator</span></span><br><span class="line">    <span class="keyword">val</span> right = exp.right</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (<span class="keyword">operator</span>) &#123;</span><br><span class="line">        Operation.ADD -&gt; addString(left, right)</span><br><span class="line">        Operation.MINUS -&gt; minusString(left, right)</span><br><span class="line">        Operation.MULTI -&gt; multiString(left, right)</span><br><span class="line">        Operation.DIVI -&gt; diviString(left, right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addString</span><span class="params">(left: <span class="type">String</span>, right: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = left.toInt() + right.toInt()</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minusString</span><span class="params">(left: <span class="type">String</span>, right: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = left.toInt() - right.toInt()</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">multiString</span><span class="params">(left: <span class="type">String</span>, right: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = left.toInt() * right.toInt()</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">diviString</span><span class="params">(left: <span class="type">String</span>, right: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = left.toInt() / right.toInt()</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">shouldExit</span><span class="params">(input: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input == EXIT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseExpression</span><span class="params">(input: <span class="type">String</span>)</span></span>: Expression? &#123;</span><br><span class="line">    <span class="comment">// 待完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseOperator</span><span class="params">(input: <span class="type">String</span>)</span></span>: Operation? &#123;</span><br><span class="line">    <span class="comment">// 待完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码可以看到，我们拆分 calculate() 方法主要做了三件事：</p><ul><li>第一，<strong>将“是否退出”的逻辑封装到了 shouldExit() 方法当中</strong>，如果将来这部分逻辑变得更复杂，我们只改动这一个方法即可。</li><li>第二，<strong>将算式的解析，封装到了 parseExpression() 方法当中</strong>，而解析算式的时候也需要解析操作符，这时候我们也需要 parseOperator()。</li><li>第三，<strong>将具体的计算逻辑交给了对应的方法</strong>。这么做的原因，是可以让我们的程序变得更加灵活。比如，我们在下个版本当中会更改“加法”的计算逻辑，那么我们就只需要改动这一个方法就行了。</li></ul><p>同时，以上所有独立抽出来的方法，它们也都将变得<strong>可测试</strong>，这有利于提升程序的稳定性</p><p>到这里，我们对计算器 2.0 的第一阶段改造就差不多完成了，我们融入了面向对象的思想，也对 calculate() 方法进行了更细颗粒度的拆分。下一步，我们要做的就是兼容算式的格式，让它能够解析没有空格的算式。</p><h3 id="第二阶段：兼容输入格式"><a href="#第二阶段：兼容输入格式" class="headerlink" title="第二阶段：兼容输入格式"></a>第二阶段：兼容输入格式</h3><p>现在，假设我们的输入是“1+2”，数字与字符之间没有空格。那在这种情况下，我们就无法使用空格作为分隔符了。所以要换一种方式，想办法从算式当中，解析出操作符“加减乘除”中的一种，然后再用操作符作为我们的分隔符去找出数字。</p><p>其实，因为操作符只有这四种情况，所以我们很容易就能想到一种方案，一个个去尝试：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseOperator</span><span class="params">(input: <span class="type">String</span>)</span></span>: Operation? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        input.contains(Operation.ADD.value) -&gt; Operation.ADD</span><br><span class="line">        input.contains(Operation.MINUS.value) -&gt; Operation.MINUS</span><br><span class="line">        input.contains(Operation.MULTI.value) -&gt; Operation.MULTI</span><br><span class="line">        input.contains(Operation.DIVI.value) -&gt; Operation.DIVI</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然，这段代码运行起来没什么问题，逻辑也非常得清晰，但它看起来很丑陋。而且它还有一个坏处：随着枚举类型的增多，我们的逻辑分支也会增多，手动添加起来也特别麻烦。</p><p>因此这种情况，我们就应该充分借助 <strong>Kotlin 枚举</strong>的优势，通过遍历的方式来做：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseOperator</span><span class="params">(input: <span class="type">String</span>)</span></span>: Operation? &#123;</span><br><span class="line">    Operation.values().forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (input.contains(it.value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，优化后的代码中，我们不再需要手动地去写 when 的逻辑分支，也不必自己去枚举 Operation 的每一种情况，就连代码量也降低了很多，即使将来枚举种类增加了，我们也不必修改这部分代码了。</p><p>需要注意，以上的代码中，我们用到了集合遍历的语法“forEach”，你可以将它想象成强化版的 for 循环，它具体的用法我会在后面“Kotlin 集合”那一节中讲解。</p><p>现在，对于一个算式“1+2”，我们已经可以成功解析出操作符“+”了，接下来要做的，就是通过“+”来分割字符串，将左右两个数字取出来“1”“2”。这个逻辑就很简单了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseExpression</span><span class="params">(input: <span class="type">String</span>)</span></span>: Expression? &#123;</span><br><span class="line">    <span class="comment">// 解析操作符</span></span><br><span class="line">    <span class="keyword">val</span> operation = parseOperator(input) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 用操作符分割算式，拿到数字</span></span><br><span class="line">    <span class="keyword">val</span> list = input.split(operation.value)</span><br><span class="line">    <span class="keyword">if</span> (list.size != <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Expression(</span><br><span class="line">        <span class="comment">// 算式左边</span></span><br><span class="line">        left = list[<span class="number">0</span>].trim(),</span><br><span class="line">        <span class="keyword">operator</span> = operation,</span><br><span class="line">        <span class="comment">// 算式右边</span></span><br><span class="line">        right = list[<span class="number">1</span>].trim()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码大致分为三个步骤，我们以“1+2”为例：</p><ul><li>第一个步骤，调用 parseOperator() 方法解析操作符“+”；</li><li>第二个步骤，根据操作符分割算式的数字，分割之后得到的会是“1”“2”组成的列表；</li><li>第三个步骤，将操作符、数字组合成 Expression 对象。</li></ul><p>这里有一个细节需要注意，我们兼容的输入其实有两种情况，第一种是<strong>不包含空格“</strong>1+2”，那么我们解析出来的数字会是“1”“2”，这种情况下不会有问题；但还有第二种情况<strong>包含空格</strong>，对于原本正确的格式，我们更应该支持，比如“1 + 2”，被分隔之后的结果会是“1 ”“2”，这两个数字当中是包含空格符的。</p><p>所以，我们使用了list[0].trim()，这里的trim()方法就是用于去掉多余空格的。</p><p>让我们实际运行一下看看效果：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/9RytnW1QKT7J2MC.gif" alt="img"></p><p>至此，我们的计算器 2.0 版本就完成了。在 2.0 版本的实操过程中，我们其实是在原有的基础上，融入了面向对象的思想，将计算器功能收拢到了一个类当中，同时也对计算器内部的方法进行了细颗粒度的拆分。</p><p>在这个过程中，我们创建了三个类：“Calculator”类，代表整个计算器；“Operation”枚举类，代表加减乘除四种运算操作符；“Expression”数据类，代表我们算式当中的数字和操作符。之后，我们又对计算器的核心功能进行了更细颗粒度的拆分，提高了程序的灵活性，为我们的功能扩展打下了基础。</p><p>好了，现在让我们进入 3.0 版本的开发吧。</p><h3 id="计算器-3-0"><a href="#计算器-3-0" class="headerlink" title="计算器 3.0"></a>计算器 3.0</h3><p>针对 3.0 这个版本，我们也分为了两个阶段：</p><ul><li><p>第一阶段，<strong>增加单元测试</strong>。单元测试是软件工程当中的一个概念，它指的是对软件当中的最小可执行单元进行测试，以提高软件的稳定性。在 Java 当中，最小单元一般会认为是类，因此，我们一般会以类为单元，对类当中的方法进行一一测试。</p></li><li><p>第二阶段，<strong>支持大数的加法</strong>。我们知道 Java、Kotlin 当中的整型都是有范围限制的，如果我们输入两个特别大的数字进行计算，那么程序是无法正常工作的。因此，我们需要对特别大的数进行兼容。</p></li></ul><p>下面，我们先来搞定单元测试。</p><h3 id="第一阶段：单元测试"><a href="#第一阶段：单元测试" class="headerlink" title="第一阶段：单元测试"></a>第一阶段：单元测试</h3><p>在 Kotlin 当中，如果要使用单元测试，我们需要在 gradle 文件当中，添加 Kotlin 官方提供的依赖：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">testImplementation <span class="string">&#x27;org.jetbrains.kotlin:kotlin-test&#x27;</span></span><br></pre></td></tr></table></figure><p>这样，我们的工程就拥有单元测试的能力了。单元测试的代码，我们一般会放在工程的 test 目录下：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/rY2zej54yIOWsn3.png" alt="img"></p><p>我们可以从这个图中看出很多信息：</p><ul><li>第一，test 目录、main 目录，它们是平级的目录，内部拥有着相同的结构。main 目录下放的是功能代码，test 目录下放的则是测试代码。</li><li>第二，由于我们要开发 3.0 版本，所以我们在 main 目录下创建了 CalculatorV3 这个类；另外，由于我们需要在 3.0 版本加入单元测试，所以对应的，我们在 test 目录下相同的地方，创建了 TestCalculatorV3。这两个类的关系是一一对应的，CalculatorV3 是为了实现 3.0 版本的功能，TestCalculatorV3 是为了测试 3.0 版本的功能，确保功能正常。</li></ul><p>不过这里你要<strong>注意</strong>，虽然我们创建了 CalculatorV3 这个类，但其实它里面的代码还是用的 CalculatorV2 的代码。3.0 版本的功能，我们放到第二阶段才会去实现。</p><p>接下来，让我们来编写测试代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestCalculatorV3</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testCalculate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> calculator = CalculatorV3()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> res1 = calculator.calculate(<span class="string">&quot;1+2&quot;</span>)</span><br><span class="line">        assertEquals(<span class="string">&quot;3&quot;</span>, res1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们定义了一个方法 testCalculate()，并且使用了一个注解 @Test 来修饰它。因为这样做以后，IntelliJ 就会知道：哦，这是一个用来做测试的方法。</p><p>接着，我们在 testCalculate() 当中创建了一个 CalculatorV3 的对象，然后调用了它的 calculate() 方法，传入了“1+2”。我们知道，如果程序正常工作的话，返回的结果应该是“3”。因此，我们紧接着就执行了一个<strong>断言</strong>“assertEquals(“3”, res1)”，它的意思是“res1 一定等于 3”。如果 res1&#x3D;3，那么我们的单元测试就会成功，否则就会失败。</p><p>我们可以看看单元测试运行成功的效果：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/KEqwSMC3x2uLXr1.gif" alt="img"></p><p>如果这时候，我们将“1+2”改成大数的加法，比如“2333333333333332+1”，并且将断言也修改一下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> res1 = calculator.calculate(<span class="string">&quot;2333333333333332+1&quot;</span>)</span><br><span class="line">assertEquals(<span class="string">&quot;2333333333333333&quot;</span>, res1)</span><br></pre></td></tr></table></figure><p>那么，你觉得单元测试的结果会是怎么样的呢？</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/zmPv9j4BYRpMyno.png"></p><p>单元测试失败了！</p><p>具体原因相信你一定也能猜到，因为“2333333333333332”这个数实在太大了，已经远远超出了 Int 类型的范围，如果不做特殊处理的话，我们的程序是无法正常运行的。而这正好就是我们下一个阶段要做的事情：支持大数的加法。不论多大的两个数字相加，我们都要算出正确的结果。</p><p>这个单元测试的代码我们先留着，等我们实现“大数的加法”后，我们再重新运行一遍，这样一来，我们就可以借此验证代码是否正确。</p><h3 id="第二阶段：大数加法"><a href="#第二阶段：大数加法" class="headerlink" title="第二阶段：大数加法"></a>第二阶段：大数加法</h3><p>大数的加法，其实是我们程序员面试当中的一道高频题。它的解题思路也很简单，就是通过模拟我们手写加法竖式的方法，从个位、十位、百位、千位，一直累加，超过 10 的时候，我们需要进位。</p><p>我们以“135+99”为例：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/Xjqx1ZfTDisuRCB.gif" alt="img"></p><p>从上面的手写加法竖式的过程我们可以看出，这个计算其实就是分了三个步骤在进行，分别是个位、十位、百位：</p><ul><li>个位计算，“5+9&#x3D;14”，出现进位，这时候我们用 carry 来存储进位：carry&#x3D;1，个位结果为 4；</li><li>十位计算，十位相加“3+9&#x3D;12”，由于之前有过进位，所以应该是“3+9+1&#x3D;13”，十位结果为 3；</li><li>百位计算，由于 99 不存在百位，我们自动补零，所以就应该是“1+0+1&#x3D;2”，百位结果为 2。</li></ul><p>最终，我们将每一位的结果拼接起来，就得到了最终的结果。有了这样的思路后，我们的代码就很容易实现了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addString</span><span class="params">(leftNum: <span class="type">String</span>, rightNum: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">var</span> leftIndex = leftNum.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> rightIndex = rightNum.length - <span class="number">1</span></span><br><span class="line">    <span class="comment">// ③</span></span><br><span class="line">    <span class="keyword">var</span> carry = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ④</span></span><br><span class="line">    <span class="keyword">while</span> (leftIndex &gt;= <span class="number">0</span> || rightIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ⑤</span></span><br><span class="line">        <span class="keyword">val</span> leftVal = <span class="keyword">if</span> (leftIndex &gt;= <span class="number">0</span>) leftNum.<span class="keyword">get</span>(leftIndex).digitToInt() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> rightVal = <span class="keyword">if</span> (rightIndex &gt;= <span class="number">0</span>) rightNum.<span class="keyword">get</span>(rightIndex).digitToInt() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> sum = leftVal + rightVal + carry</span><br><span class="line">        <span class="comment">// ⑥</span></span><br><span class="line">        carry = sum / <span class="number">10</span></span><br><span class="line">        result.append(sum % <span class="number">10</span>)</span><br><span class="line">        leftIndex--</span><br><span class="line">        rightIndex--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⑦</span></span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">        result.append(carry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⑧</span></span><br><span class="line">    <span class="keyword">return</span> result.reverse().toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码一共有 8 处注释，代表了整体的程序流程，让我们一步步来分析：</p><ul><li>注释①，我们<strong>创建了一个 StringBuilder 对象</strong>，用于存储最终结果，由于我们的结果是一位位计算出来的，所以每一位结果都是慢慢拼接上去的，在这里，为了提高程序的性能，我们选择使用 StringBuilder。</li><li>注释②，我们定义了<strong>两个可变的变量 index</strong>，它们分别指向了两个数字的个位，这是因为我们的计算是从个位开始的。</li><li>注释③，<strong>carry</strong>，我们用它来存储每一位计算结果的进位。</li><li>注释④，这个 <strong>while 循环</strong>当中，我们会让两个 index 从低位一直到高位，直到遍历完它们所有的数字位。</li><li>注释⑤，这里的逻辑是<strong>取每一位上的数字</strong>，其中有个细节就是补零操作，比如当程序运行到百位的时候，99 没有百位，这时候 rightVal &#x3D; 0。</li><li>注释⑥，当我们的程序计算出结果后，我们要<strong>分别算出 carry，以及当前位的结果</strong>。这时候我们分别使用“除法”计算 carry，使用“取余”操作计算当前位的结果。</li><li>注释⑦，这里是为了<strong>兼容一个特殊的场景</strong>，在“99+1”的情况下，我们的 while 循环最多只会遍历到十位，如果不做特殊处理的话，结果将变成“99+1&#x3D;00”。这并不是我们想要的，所以，为了兼容这种特殊情况，我们在 <strong>while 循环结束后增加了一个判断</strong>，如果 carry&#x3D;1，那就说明在最大的那一位数计算完以后，仍然有进位，我们要手动添加。</li><li>注释⑧，对于一个算式“135+99”，我们的 result 拼接其实是倒叙的“432”，这时候我们需要将<strong>其翻转一下</strong>，才能得到正确的结果“135+99&#x3D;234”。</li></ul><p>到这里，我们的大数加法功能，就算实现了。让我们回过头，再去运行一次单元测试，来验证下我们的代码是否正确：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/mtXAl2vdCUMfQu5.gif" alt="img"></p><p>果然，在我们兼容了“大数加法”以后，单元测试就可以成功通过了。至此，我们的计算器 3.0 版本就算是完成了。</p><p>在这个版本的开发过程中，首先我们引入了单元测试，通过这种方式，我们可以测试代码逻辑是否正确，并可以辅助我们排查问题。接着，我们写了一个“2333333333333332+1”的测试用例，并且失败了，不过在完成大数加法的功能后，这个测试也最终通过了。</p><p>这里我需要特殊说明的是，为了不偏离本次实战课的目的，我们的单元测试只写了两个，但在实际的开发工作当中，单元测试是需要尽量覆盖所有情况的。换句话说，仅仅只是测试“1+2”“2333333333333332+1”这两种情况，是无法保证我们的计算器逻辑正确的。一般来说，一个应用于商业的计算器，它的单元测试用例数量会达到几百上千个。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，我们就通过完成三个不同版本的四则运算计算器，一起梳理了前面课程中，学习的那些重要的 Kotlin 的知识点，比如不可变的变量 val、when 表达式、数据类、枚举类，等等。并且也在实操过程中，一起思考了代码实现时可能会出现的问题。</p><p>你也可以在动手操作的过程中，具体感受下跟 Java 代码的不同，同时也看看自己的思路与课程的思路有什么不同，课程当中的代码还有哪些可以改进的地方。</p><p>最后我想让你注意的是，在 3.0 版本中，我们引入<strong>了单元测试功能</strong>。实际上，单元测试的作用，不仅仅可以验证新开发的功能，同时它还可以用于保证旧的功能不受影响。在实际开发工作中，我们很容易因为对功能 A 的改动，导致功能 B 出问题。然后往往由于时间限制，测试人员只测试了功能 A，忽略了功能 B，最终导致线上故障带来经济损失。</p><p>而借助单元测试，在每一次的开发工作完成以后，我们就统一跑一遍所有的单元测试，只要单元测试通过了，我们就能保证，新的功能没问题，而旧的功能也没问题。</p><h2 id="动手实操"><a href="#动手实操" class="headerlink" title="动手实操"></a>动手实操</h2><p>在 3.0 版本的开发当中，我们仅仅只实现了“大数的加法”，其余的“大数的减法”“大数的乘法”“大数的除法”都没有实现。请你挑其中一个功能，尝试自己实现，参考答案我会在之后放出来。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)03  Kotlin原理：编译器在幕后干了哪些“好事”？</title>
      <link href="/posts/e0b30b8/"/>
      <url>/posts/e0b30b8/</url>
      
        <content type="html"><![CDATA[<p>在前面两节课里，我们学了不少 Kotlin 的语法，其中有些语法是和 Java 类似的，比如数字类型、字符串；也有些语法是 Kotlin 所独有的，比如数据类、密封类。另外，我们还知道 Kotlin 和 Java 完全兼容，它们可以同时出现在一个代码工程当中，并且可以互相调用。</p><p>但是，这样就会引出一个问题<strong>：Java 是如何识别 Kotlin 的独有语法的呢？</strong>比如，Java 如何能够认识 Kotlin 里的“数据类”？</p><p>这就要从整个 Kotlin 的实现机制说起了。</p><p>所以，今天这节课，我会从 Kotlin 的编译流程出发，来带你探索这门语言的底层原理。在这个过程中，你会真正地理解，Kotlin 是如何在实现灵活、简洁的语法的同时，还做到了兼容 Java 语言的。并且你在日后的学习和工作中，也可以根据今天所学的内容，来快速理解 Kotlin 的其他新特性。</p><h2 id="Kotlin-的编译流程"><a href="#Kotlin-的编译流程" class="headerlink" title="Kotlin 的编译流程"></a>Kotlin 的编译流程</h2><p>在介绍 Kotlin 的原理细节之前，我们先从宏观上看看它是如何运行在电脑上的，这其实就涉及到它的编译流程。</p><p>那么首先，你需要知道一件事情：你写出的 Kotlin 代码，电脑是无法直接理解的。即使是最简单的println(“Hello world.”)，你将这行代码告诉电脑，它也是无法直接运行的。这是因为，Kotlin 的语法是基于人类语言设计的，电脑没有人的思维，它只能理解二进制的 0 和 1，不能理解 println 到底是什么东西。</p><p>因此，Kotlin 的代码在运行之前，要先经过编译（Compile）。举个例子，假如我们现在有一个简单的 Hello World 程序：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Hello world.&quot;</span>)</span><br></pre></td></tr></table></figure><p>经过编译以后，它会变成类似这样的东西：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">LDC <span class="string">&quot;Hello world.&quot;</span></span><br><span class="line">INVOKESTATIC kotlin/io/ConsoleKt.println (Ljava/lang/Object;)V</span><br></pre></td></tr></table></figure><p>上面两行代码，其实是 Java 的字节码。对，你没看错，<strong>Kotlin 代码经过编译后，最终会变成 Java 字节码</strong>。这给人的感觉就像是：我说了一句中文，编译器将其翻译成了英文。而 Kotlin 和 Java 能够兼容的原因也在于此，<strong>Java 和 Kotlin 本质上是在用同一种语言进行沟通</strong>。</p><p>英语被看作人类世界的通用语言，那么 Kotlin 和 Java 用的是什么语言呢？没错，它们用的就是 Java 字节码。Java 字节码并不是为人类设计的语言，它是专门给 JVM 执行的。</p><p>JVM，也被称作 Java 虚拟机，它拿到字节码后就可以解析出字节码的含义，并且在电脑里输出打印“Hello World.”。所以，你可以先把 Java 虚拟机理解为一种执行环境。回想我们在第一节课开头所安装的 JDK，就是为了安装 Java 的编译器和 Java 的运行环境。</p><p>不过现在，你可能会有点晕头转向，还是没有搞清楚 Kotlin 的这个编译流程具体是怎么回事儿，也不清楚 Kotlin 和 Java 之间到底是什么关系。别着急，我们一起来看看下面这张图：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/d6/0f/d67630808ee59a642b93d955ae8fa60f.jpg?wh=1920x1480" alt="img" style="zoom:50%;" /><p>这张图的内容其实非常直观，让我们从上到下，将整个过程再梳理一遍。</p><p>首先，我们写的 Kotlin 代码，编译器会以一定的规则将其翻译成 Java 字节码。这种字节码是专门为 JVM 而设计的，它的语法思想和汇编代码有点接近。</p><p>接着，JVM 拿到字节码以后，会根据特定的语法来解析其中的内容，理解其中的含义，并且让字节码运行起来。</p><p><strong>那么，JVM 到底是如何让字节码运行起来的呢</strong>？其实，JVM 是建立在操作系统之上的一层抽象运行环境。举个简单的例子，Windows 系统当中的程序是无法直接在 Mac 上面运行的。但是，我们写的 Java 程序却能同时在 Windows、Mac、Linux 系统上运行，这就是因为 JVM 在其中起了作用。</p><p>JVM 定义了一套字节码规范，只要是符合这种规范的，都可以在 JVM 当中运行。至于 JVM 是如何跟不同的操作系统打交道的，我们不管。</p><p>还有一个更形象的例子，<strong>JVM 就像是一个精通多国语言的翻译</strong>，我们只需要让 JVM 理解要做的事情，不管去哪个国家都不用关心，翻译会帮我们搞定剩下的事情。</p><p>最后，是计算机硬件。常见的计算机硬件包括台式机和笔记本电脑，这就是我们所熟知的东西了。</p><h2 id="如何研究-Kotlin？"><a href="#如何研究-Kotlin？" class="headerlink" title="如何研究 Kotlin？"></a>如何研究 Kotlin？</h2><p>在了解了 Kotlin 的编译流程之后，其实我们很容易就能想到办法了。</p><p>第一种思路，<strong>直接研究 Kotlin 编译后的字节码</strong>。如果我们能学会 Java 字节码的语法规则，那么就可以从字节码的层面去分析 Kotlin 的实现细节了。不过，这种方法明显吃力不讨好，即使我们学会了 Java 字节码的语法规则，对于一些稍微复杂一点的代码，我们分析起来也会十分吃力。</p><p>因此，我们可以尝试另一种思路：<strong>将 Kotlin 转换成字节码后，再将字节码反编译成等价的 Java 代码</strong>。最终，我们去分析等价的 Java 代码，通过这样的方式来理解 Kotlin 的实现细节。虽然这种方式不及字节码那样深入底层，但它的好处是足够直观，也方便我们去分析更复杂的代码逻辑。</p><p>这个过程看起来会有点绕，让我们用一个流程图来表示：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/fd/24/fdfbcf0b8a293acc91b5e435c99cb324.jpg?wh=2000x1074" alt="img" style="zoom: 50%;" /><p>我们将其分为两个部分来看。先看红色虚线框外面的图，这是一个典型的 Kotlin 编译流程，Kotlin 代码变成了字节码。另一个部分，是红色虚线框内部的图，我们用反编译器将 Java 字节码翻译成 Java 代码。经过这样一个流程后，我们就能得到和 Kotlin 等价的 Java 代码。</p><p>而这样，我们也可以得出这样一个结论，Kotlin 的“println”和 Java 的“System.out.println”是等价的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">println(<span class="string">&quot;Hello world.&quot;</span>) <span class="comment">/*</span></span><br><span class="line"><span class="comment">          编译</span></span><br><span class="line"><span class="comment">           ↓            */</span>    </span><br><span class="line">LDC <span class="string">&quot;Hello world.&quot;</span></span><br><span class="line">INVOKESTATIC kotlin/io/ConsoleKt.println (Ljava/lang/Object;)V  <span class="comment">/*</span></span><br><span class="line"><span class="comment">         反编译</span></span><br><span class="line"><span class="comment">           ↓            */</span></span><br><span class="line">String var0 = <span class="string">&quot;Hello world.&quot;</span>;</span><br><span class="line">System.<span class="keyword">out</span>.println(var0);</span><br></pre></td></tr></table></figure><p>好了，思想和流程我们都清楚了，具体我们应该要怎么做呢？有以下几个步骤。</p><p>第一步，打开我们要研究的 Kotlin 代码。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/54/5f/54b189024034ae24bba4a40d1082995f.png?wh=717x260" alt="img"></p><p>第二步，依次点击菜单栏：Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/3b/e0/3b3439996bc37e26c0f12fa943c726e0.png?wh=933x499" alt="img" style="zoom:50%;" /><p>这时候，我们在右边的窗口中就可以看见 Kotlin 对应的字节码了。但这并不是我们想要的，所以要继续操作，将字节码转换成 Java 代码。</p><p>第三步，点击画面右边的“Decompile”按钮。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/5e/be/5e7d2835867b19de523c266d39980fbe.png?wh=1194x552" alt="img" style="zoom:50%;" /><p>最后，我们就能看见反编译出来的 Java 文件“Test_decompiled.java”。显而易见，main 函数中的代码和我们前面所展示的是一致的：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/40/52/40f13a1277f35113cb968fa7cc464f52.png?wh=1177x940" alt="img" style="zoom:50%;" /><p>OK，在知道如何研究 Kotlin 原理后，让我们来看一些实际的例子吧！</p><h2 id="Kotlin-里到底有没有“原始类型”？"><a href="#Kotlin-里到底有没有“原始类型”？" class="headerlink" title="Kotlin 里到底有没有“原始类型”？"></a>Kotlin 里到底有没有“原始类型”？</h2><p>不知道你还记不记得，之前我在第 1 讲中给你留过一个思考题：</p><p><code>虽然 Kotlin 在语法层面摒弃了“原始类型”，但有的时候为了性能考虑，我们确实需要用“原始类型”。这时候我们应该怎么办？</code></p><p>那么现在，我们已经知道了 Kotlin 与 Java 直接存在某种对应关系，所以要弄清楚这个问题，我们只需要知道“Kotlin 的 Long”与“Java long&#x2F;Long”是否存在某种联系就可以了。</p><p><em><strong>注意：Java 当中的 long 是原始类型，而 Long 是对象类型（包装类型）。</strong></em></p><p>说做就做，我们以 Kotlin 的 Long 类型为例。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// kotlin 代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 val 定义可为空、不可为空的Long，并且赋值</span></span><br><span class="line"><span class="keyword">val</span> a: <span class="built_in">Long</span> = <span class="number">1L</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Long</span>? = <span class="number">2L</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 var 定义可为空、不可为空的Long，并且赋值</span></span><br><span class="line"><span class="keyword">var</span> c: <span class="built_in">Long</span> = <span class="number">3L</span></span><br><span class="line"><span class="keyword">var</span> d: <span class="built_in">Long</span>? = <span class="number">4L</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 var 定义可为空的Long，先赋值，然后改为null</span></span><br><span class="line"><span class="keyword">var</span> e: <span class="built_in">Long</span>? = <span class="number">5L</span></span><br><span class="line">e = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 val 定义可为空的Long，直接赋值null</span></span><br><span class="line"><span class="keyword">val</span> f: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 var 定义可为空的Long，先赋值null，然后赋值数字</span></span><br><span class="line"><span class="keyword">var</span> g: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line">g = <span class="number">6L</span></span><br></pre></td></tr></table></figure><p>这段代码的思路，其实就是将 Kotlin 的 Long 类型可能的使用情况都列举出来，然后去研究代码对应的 Java 反编译代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 反编译后的 Java 代码</span></span><br><span class="line"></span><br><span class="line">long a = <span class="number">1L</span>;</span><br><span class="line">long b = <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">long c = <span class="number">3L</span>;</span><br><span class="line">long d = <span class="number">4L</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Long</span> e = <span class="number">5L</span>;</span><br><span class="line">e = (<span class="built_in">Long</span>)<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Long</span> f = (<span class="built_in">Long</span>)<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Long</span> g = (<span class="built_in">Long</span>)<span class="literal">null</span>;</span><br><span class="line">g = <span class="number">6L</span>;</span><br></pre></td></tr></table></figure><p>可以看到，最终 a、b、c、d 被 Kotlin 转换成了 Java 的原始类型 long；而 e、f、g 被转换成了 Java 里的包装类型 Long。这里我们就来逐步分析一下：</p><ul><li>对于变量 a、c 来说，它们两个的类型是不可为空的，所以无论如何都不能为 null，对于这种情况，Kotlin 编译器会直接将它们优化成原始类型。</li><li>对于变量 b、d 来说，它们两个的类型虽然是可能为空的，但是它的值不为 null，并且，编译器对上下文分析后发现，这两个变量也没有在别的地方被修改。这种情况，Kotlin 编译器也会将它们优化成原始类型。</li><li>对于变量 e、f、g 来说，不论它们是 val 还是 var，只要它们被赋值过 null，那么，Kotlin 就无法对它们进行优化了。这背后的原因也很简单，Java 的原始类型不是对象，只有对象才能被赋值为 null。</li></ul><p>我们可以用以下两个规律，来总结下 Kotlin 对基础类型的转换规则：</p><ul><li>只要基础类型的变量可能为空，那么这个变量就会被转换成 Java 的包装类型。</li><li>反之，只要基础类型的变量不可能为空，那么这个变量就会被转换成 Java 的原始类型。</li></ul><p>好，接着我们再来看看另外一个例子。</p><h2 id="接口语法的局限性"><a href="#接口语法的局限性" class="headerlink" title="接口语法的局限性"></a>接口语法的局限性</h2><p>我在上节课，带你了解了 Kotlin 面向对象编程中的“接口”这个概念，其中我给你留了一个问题，就是：</p><p><code>接口的“成员属性”，是 Kotlin 独有的。请问它的局限性在哪？</code></p><p>那么在这里，我们就通过这个问题，来分析下 Kotlin 接口语法的实现原理，从而找出它的局限性。下面给出的，是一段接口代码示例：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Kotlin 代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Behavior</span> &#123;</span><br><span class="line">    <span class="comment">// 接口内可以有成员属性</span></span><br><span class="line">    <span class="keyword">val</span> canWalk: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口方法的默认实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (canWalk) &#123;</span><br><span class="line">            println(canWalk)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testInterface</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> man = Man()</span><br><span class="line">    man.walk()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，要解答这个问题，我们也要弄清楚 Kotlin 的这两个特性，转换成对应的 Java 代码是什么样的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 等价的 Java 代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Behavior</span> &#123;</span><br><span class="line">   <span class="comment">// 接口属性变成了方法</span></span><br><span class="line">   boolean getCanWalk();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方法默认实现消失了</span></span><br><span class="line">   void walk();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 多了一个静态内部类</span></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DefaultImpls</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> static void walk(Behavior $<span class="keyword">this</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> ($<span class="keyword">this</span>.getCanWalk()) &#123;</span><br><span class="line">            boolean var1 = $<span class="keyword">this</span>.getCanWalk();</span><br><span class="line">            System.<span class="keyword">out</span>.println(var1);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的 Java 代码中我们能看出来，Kotlin 接口的“默认属性”canWalk，本质上并不是一个真正的属性，当它转换成 Java 以后，就变成了一个普通的接口方法 getCanWalk()。</p><p>另外，Kotlin 接口的“方法默认实现”，它本质上也没有直接提供实现的代码。对应的，它只是在接口当中定义了一个静态内部类“DefaultImpls”，然后将默认实现的代码放到了静态内部类当中去了。</p><p><strong>我们能看到，Kotlin 的新特性，最终被转换成了一种 Java 能认识的语法。</strong></p><p>我们再具体来看看接口使用的细节：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Kotlin 代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>: <span class="type">Behavior</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> canWalk: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，我们定义了一个 Man 类，它实现了 Behavior 接口，与此同时它也重写了 canWalk 属性。另外，由于 Behavior 接口的 walk() 方法已经有了默认实现，所以 Man 可以不必实现 walk() 方法。</p><p>那么，<strong>Man 类反编译成 Java 后，会变成什么样子呢？</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 等价的 Java 代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">Behavior</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">canWalk</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getCanWalk</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 关键点 ①</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.canWalk;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 关键点 ②</span></span><br><span class="line">      Behavior.DefaultImpls.walk(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Man 类里的 getCanWalk() 实现了接口当中的方法，从注释①那里我们注意到，getCanWalk() 返回的还是它内部私有的 canWalk 属性，这就跟 Kotlin 当中的逻辑“override val canWalk: Boolean &#x3D; true”对应上了。</p><p>另外，对于 Man 类当中的 walk() 方法，它将执行流程交给了“Behavior.DefaultImpls.walk()”，并将 this 作为参数传了进去。这里的逻辑，就可以跟 Kotlin 接口当中的默认方法逻辑对应上来了。</p><p>看完这一堆的代码之后，你的脑子可能会有点乱，我们用一张图来总结一下前面的内容吧：</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/88/b9/886dc2d7a5d5ee47934c1003447412b9.png?wh=1770x1230" alt="img" style="zoom:50%;" /><p>以上图中一共有 5 个箭头，它们揭示了 Kotlin 接口新特性的实现原理，让我们一个个来分析：</p><ul><li>箭头①，代表 Kotlin 接口属性，实际上会被当中接口方法来看待。</li><li>箭头②，代表 Kotlin 接口默认实现，实际上还是一个普通的方法。</li><li>箭头③，代表 Kotlin 接口默认实现的逻辑是被放在 DefaultImpls 当中的，它成了静态内部类当中的一个静态方法 DefaultImpls.walk()。</li><li>箭头④，代表 Kotlin 接口的实现类必须要重写接口当中的属性，同时，它仍然还是一个方法。</li><li>箭头⑤，即使 Kotlin 里的 Man 类没有实现 walk() 方法，但是从 Java 的角度看，它仍然存在 walk() 方法，并且，walk() 方法将它的执行流程转交给了 DefaultImpls.walk()，并将 this 传入了进去。这样，接口默认方法的逻辑就可以成功执行了。</li></ul><p>到这里，我们的答案就呼之欲出了。Kotlin 接口当中的属性，在它被真正实现之前，本质上并不是一个真正的属性。因此，Kotlin 接口当中的属性，它既不能真正存储任何状态，也不能被赋予初始值，因为它<strong>本质上还是一个接口方法</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，你应该就明白了：你写的 Kotlin 代码，最终都会被 Kotlin 编译器进行一次统一的翻译，把它们变成 Java 能理解的格式。Kotlin 的编译器，在这个过程当中就像是一个藏在幕后的翻译官。</p><p>可以说，Kotlin 的每一个语法，最终都会被翻译成对应的 Java 字节码。但如果你不去反编译，你甚至感觉不到它在幕后做的那些事情。而正是因为 Kotlin 编译器在背后做的这些翻译工作，才可以让我们写出的 Kotlin 代码更加简洁、更加安全。</p><p>我们举一些更具体的例子：</p><ul><li>类型推导，我们写 Kotlin 代码的时候省略的变量类型，最终被编译器补充回来了。</li><li>原始类型，虽然 Kotlin 没有原始类型，但编译器会根据每一个变量的可空性将它们转换成“原始类型”或者“包装类型”。</li><li>字符串模板，编译器最终会将它们转换成 Java 拼接的形式。</li><li>when 表达式，编译器最终会将它们转换成类似 switch case 的语句。</li><li>类默认 public，Kotlin 当中被我们省略掉 public，最终会被编译器补充。</li><li>嵌套类默认 static，我们在 Kotlin 当中的嵌套类，默认会被添加 static 关键字，将其变成静态内部类，防止不必要的内存泄漏。</li><li>数据类，Kotlin 当中简单的一行代码“data class Person(val name: String, val age: Int)”，编译器帮我们自动生成很多方法：getter()、setter()、equals()、hashCode()、toString()、componentN()、copy()。</li></ul><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/02/34/02702d48a28378817ed1598849bfbb34.jpg?wh=1920x912" alt="img"></p><p>最后，我们还需要思考一个问题<strong>：Kotlin 编译器一直在幕后帮忙做着翻译的好事，那它有没有可能“好心办坏事”？</strong>这个悬念留着，我们在第 8 讲再探讨。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>在上节课当中，我们曾提到过，为 Person 类增加 isAdult 属性，我们要通过自定义 getter 来实现，比如说：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> isAdult</span><br><span class="line">        <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而下面这种写法则是错误的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> isAdult = age &gt;= <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请运用今天学到的知识来分析这个问题背后的原因。欢迎你在留言区分享你的答案和思路，我们下节课再见。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)02  面向对象：理解Kotlin设计者的良苦用心</title>
      <link href="/posts/25decd61/"/>
      <url>/posts/25decd61/</url>
      
        <content type="html"><![CDATA[<p>这节课，我们来学习 Kotlin 的面向对象编程：类、接口、继承、嵌套，以及 Kotlin 独有的数据类和密封类。</p><p>面向对象（Object Oriented）是软件开发方法，也是计算机界应用最广的一种编程范式。它是把程序的“数据”和“方法”作为一个整体来看待，将其抽象成了一个具体的模型，从而更贴近事物的自然运行模式。它的特点是简单易懂，符合人类的思维模式。</p><p>在“面向对象”的概念上，虽然 Kotlin 和 Java 之间有一定的语法差异，但底层的思想是没有变的。比如 Java 和 Kotlin 当中，都有类、接口、继承、嵌套、枚举的概念，唯一区别就在于这些概念在两种语言中的具体语法不同。<strong>我们需要做的，仅仅只是为我们脑海里已经熟知的概念，再增加一种语法规则而已</strong>。</p><p>而如果你没有 Java 基础也没关系，今天这节课要学习的内容，几乎是所有编程语言都需要掌握的概念。在掌握了 Kotlin 面向对象的编程思想后，如果你再去学习其他编程语言，你也照样可以快速迁移这些知识点。</p><p>当然，Kotlin 作为一门新的语言，它也创造了一些新的东西，比如数据类、密封类、密封接口等。这些 Kotlin 的新概念，会是我们需要着重学习的对象。<strong>实际上，也正是因为 Kotlin 的这些独有概念，使得它形成了一种独特的编程风格和编程思想。</strong></p><p>那么，在学习这节课的时候，我想请你注意一点，就是如果你已经有了 Java、C 的编程经验，一定要有意识地跳出从前的编程习惯，尝试去理解 Kotlin 的编程思想。只有这样，你才能写出地道的 Kotlin 代码，而不仅仅只是用 Kotlin 语法翻译 Java&#x2F;C 代码。</p><h2 id="怎么写出有-Kotlin-特点的类？"><a href="#怎么写出有-Kotlin-特点的类？" class="headerlink" title="怎么写出有 Kotlin 特点的类？"></a>怎么写出有 Kotlin 特点的类？</h2><p>Kotlin 当中的“类”，我们可以将其理解为对某种事物的“抽象模型”。比如说，我们可以在 Kotlin 当中定义一个类，它叫做 Person。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>计算机的世界里当然没有“人”的概念，但是这并不妨碍我们在代码当中定义一个人的“抽象模型”。上面的 Person 类当中，有一个属性，叫做“name”，每个人都会有名字，而名字也是属于人的一部分。这也很好理解，对吧。</p><p>不过，如果你以 Java 的角度来分析上面的代码的话，会发现它并没有表面上那么简单。如果我们将其翻译成等价的 Java 代码，它会变成很多行代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> int age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person(String name, int age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性 name 没有 setter</span></span><br><span class="line">    <span class="keyword">public</span> String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> int getAge() &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setAge(int age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，把 Kotlin 和 Java 的代码对比着来看，我们很快就会发现，Kotlin 当中，Person 类的 <strong>name 是用 val 修饰的</strong>，这意味着，它在初始化以后将无法被修改。这个逻辑对应到 Java 当中，就是该变量只有 getter 没有 setter。而 Kotlin 当中，Person 类的 <strong>age 是 var 修饰的</strong>，意味着它是可以被随意修改的。这个逻辑对应到 Java 当中，就是该变量既有 getter 也有 setter。</p><p>这下你应该就明白了，<strong>Kotlin 定义的类，在默认情况下是 public 的</strong>，编译器会帮我们生成“构造函数”，对于类当中的属性，Kotlin 编译器也会根据实际情况，自动生成 getter 和 setter。</p><p>到这里，我们不得不感叹 Kotlin 语言的简洁性。Kotlin 里简单到不能再简单的一行代码，在 Java 中却要写这么一大串。要注意，这里的差距并不仅仅是我们程序员敲代码的时间，还包括后续我们迭代维护的时间，或者说是读代码的时间。Kotlin 一行代码，我们轻松就能理解了，而对应的 Java 则完全不一样。并且，这还只是一个最简单的案例，真实的程序比这复杂千万倍。</p><h2 id="自定义属性-getter"><a href="#自定义属性-getter" class="headerlink" title="自定义属性 getter"></a>自定义属性 getter</h2><p>我们继续来看前面的 Person 类的例子。如果这时候，我们希望它增加一个功能，就是根据年龄的大小自动判断是不是成年人，也就是 age≥18。</p><p>如果按照我们从前的 Java 思维，一定会习以为常地写出下面这样的代码，也就是为 Person 类增加一个新的方法：isAdult()。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isAdult</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age &gt;= <span class="number">18</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又或者，我们可以充分发挥 Kotlin 的简洁语法特性，将 isAdult() 写得更加清爽一些：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isAdult</span><span class="params">()</span></span> = age &gt;= <span class="number">18</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码写成这样，已经算不错了。然而，我们还可以用另一种更符合直觉的写法，那就是将 isAdult() 定义成 Person 的属性。具体的做法，就是借助 Kotlin 属性的<strong>自定义 getter。</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> isAdult</span><br><span class="line">        <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line"><span class="comment">//        ↑</span></span><br><span class="line"><span class="comment">//    这就是isAdult属性的getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓 getter，就是<strong>获取属性值的方法</strong>。我们通过自定义这个 get() 方法，就可以改变返回值的规则。比如，这里的年龄大于等于 18，就是成年人，这个规则就是通过自定义来实现的。</p><p>以上的 isAdult 属性，我们省略了它的类型，因为编译器会自动推导它的类型是 Boolean（布尔）类型。另外，由于 get() 方法内部只有一行代码，我们使用了函数的“单一表达式”写法，直接用等号连接即可。</p><p>而如果 get() 方法内部的逻辑比较复杂，我们仍然可以像正常函数那样，带上花括号：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> isAdult: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="comment">// do something else</span></span><br><span class="line">            <span class="keyword">return</span> age &gt;= <span class="number">18</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过需要注意的是，在这种情况下，编译器的自动类型推导就会失效了，所以我们要为 isAdult 属性增加明确的类型：Boolean。</p><p>看到这里，也许你会觉得奇怪：判断一个人是否为成年人，我们只需要判断 age 这个属性即可，<strong>为什么还要引入一个新的属性 isAdult 呢？</strong>这不是凭空多占用了一个变量的内存吗？这么做是否有必要？</p><p>实际上，这里涉及到 Java 到 Kotlin 的一种思想转变。让我们来详细分解上面的问题：</p><ul><li>首先，从<strong>语法的角度</strong>上来说，是否为成年人，本来就是属于人身上的一种属性。我们在代码当中将其定义为属性，更符合直觉。而如果我们要给 Person 增加一个行为，比如 walk，那么这种情况下定义一个新的方法就是非常合适的。</li><li>其次，从<strong>实现层面</strong>来看，我们确实定义了一个新的属性 isAdult，但是 Kotlin 编译器能够分析出，我们这个属性实际是根据 age 来做逻辑判断的。在这种情况下，Kotlin 编译器可以在 JVM 层面，将其优化为一个方法。</li><li>通过以上两点，我们就成功在语法层面有了一个 isAdult 属性；但是在<strong>实现层面，isAdult 仍然还是个方法</strong>。这也就意味着，isAdult 本身不会占用内存，它的性能和我们用 Java 写的方法是一样的。而这在 Java 当中是无法实现的。</li></ul><p>所以，当你使用 Kotlin 来编写代码的时候，一定要注意其中引入的 Kotlin 属性的含义，并且理解它的底层实现逻辑。只有这样，你才能真正发挥 Kotlin 简洁语法的优势，而不必束缚在 Java 或者 C 的代码撰写思维里。</p><p>对了，也许你会突发奇想，想要将上面的代码进一步简化，比如写成这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> isAdult = age &gt;= <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，这种代码是无法正常工作的。由于它牵涉到 Kotlin 的原理，你可以在学完下一节“Kotlin 原理”之后，再回过头来看看这段代码为什么有问题。</p><h2 id="自定义属性-setter"><a href="#自定义属性-setter" class="headerlink" title="自定义属性 setter"></a>自定义属性 setter</h2><p>我们继续来看前面的 Person 案例，假设这时候我们又来了一个新的需求，希望在 age 被修改的时候，能够做一些日志统计工作。如果是 Java，那我们直接在 setAge() 方法当中加入一些逻辑就行了。</p><p>可是在 Kotlin 当中，我们要怎么办呢？答案也很容易想到，<strong>自定义 setter</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">//  这就是age属性的setter</span></span><br><span class="line"><span class="comment">//       ↓</span></span><br><span class="line">        <span class="keyword">set</span>(value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">            log(value)</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓 setter，就是可以<strong>对属性赋值的方法</strong>。当我们想要改变属性的赋值逻辑时，我们就可以通过自定义来实现了。需要注意的是，以上代码当中的 value，就是 set 方法传入的参数。而 set() 方法当中的 field 则是代表了 age，这是 Kotlin 编译器为我们提供的字段。field &#x3D; value，这一行代码就表示我们实现了对 age 的赋值操作。</p><p>有的时候，我们不希望属性的 set 方法在外部访问，那么我们可以给 set 方法加上可见性修饰符，比如这里，我们可以给 set 方法加上 private，限制它仅可以在类的内部访问：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span>(value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">            log(value)</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在了解了 Kotlin 中类的定义以后，我们再来看一种特殊的类：抽象类。</p><h2 id="抽象类与继承"><a href="#抽象类与继承" class="headerlink" title="抽象类与继承"></a>抽象类与继承</h2><p>面我们所创建的类，比如 Person，它是具体的、已经定型的类，我们可以直接用它来创建对象。而抽象类，则不是具体的类，它没有完全定型，我们也不能直接用它来创建对象。</p><p>在 Kotlin 当中，抽象类的定义和 Java 几乎一样，也就是在关键字“class”“fun”的前面加上 abstract 关键字即可。这里我们继续上面的例子，把 Person 定义成抽象类，然后为它添加一个抽象方法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，如果我们要创建 Person 类，就必须要使用匿名内部类的方式，或者使用 Person 的子类来创建变量。而这，就需要用到<strong>类的继承</strong>了。</p><p>从概念上讲，Kotlin 的继承和 Java 的并没有区别，它们只是在语法上有一点点不一样。Java 当中我们是使用 extends 表示继承，而 Kotlin 当中我们则使用冒号来表示继承。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                      Java 的继承</span></span><br><span class="line"><span class="comment">//                           ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="title">extends</span> <span class="title">Activity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    void onCreate()&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//              Kotlin 的继承</span></span><br><span class="line"><span class="comment">//                 ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了继承的语法不太一样，重写的表达方式也不太一样。Java 当中是使用 @Override 注解，而 Kotlin 当中直接将其定义为了 <strong>override 关键字</strong>。而除了抽象类以外，正常的类其实也是可以被继承的。不过，我们必须对这个类<strong>标记为 open</strong>。如果一个类不是抽象类，并且没有用 open 修饰的话，它是无法被继承的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>: <span class="type">Person</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上代码我们可以看到，Person 不是抽象类，同时它也没有被 open 修饰。Boy 这个类尝试继承 Person，会导致编译器报错。所以，我们必须为 Person 这个类加上 open 关键字：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>: <span class="type">Person</span>() &#123;</span><br><span class="line">    <span class="comment">// 省略重写逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，Kotlin 的类，默认是不允许继承的，除非这个类明确被 open 关键字修饰了。另外，对于被 open 修饰的普通类，它内部的方法和属性，默认也是不允许重写的，除非它们也被 open 修饰了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> canWalk: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>: <span class="type">Person</span>() &#123;</span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> canWalk: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，由于 Person 类当中的 canWalk 属性以及 walk() 方法，它们都没有使用 open 修饰，在这种情况下，即使 Person 可以被继承，但在继承之后的 Boy 类当中，我们是无法重写 canWalk 属性、walk() 方法的。</p><p>也就是说，在<strong>继承的行为上面，Kotlin 和 Java 完全相反</strong>。Java 当中，一个类如果没有被 final 明确修饰的话，它默认就是可以被继承的。而这同时也就导致了，在 Java 当中“继承”被过度使用。对于这一点，经典书籍<a href="https://book.douban.com/subject/1103015">《Effective Java》</a>也有提到过。</p><p>所以，<strong>Java 的继承是默认开放的，Kotlin 的继承是默认封闭的</strong>。Kotlin 的这个设计非常好，这样就不会出现 Java 中“继承被滥用”的情况。</p><p>好，下面，我们再来看看另一种常见的面向对象的编程方式，那就是“实现”。</p><h2 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h2><p>Kotlin 当中的接口（interface），和 Java 也是大同小异的，它们都是通过 <strong>interface</strong> 这个关键字来定义的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Behavior</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String): Behavior &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// walk</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在以上的代码中，我们定义了一个新的接口 Behavior，它里面有一个需要被实现的方法 walk，然后我们在 Person 类当中实现了这个接口。</p><p>而在这里，我们又会发现 Kotlin 和 Java 不同的小细节：<strong>Kotlin 的继承和接口实现语法是一样的</strong>。多么得贴心！</p><p>Kotlin 的接口，跟 Java 最大的差异就在于，接口的方法可以有默认实现，同时，它也可以有属性。比如，我们来看看下面这段代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Behavior</span> &#123;</span><br><span class="line">    <span class="comment">// 接口内的可以有属性</span></span><br><span class="line">    <span class="keyword">val</span> canWalk: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口方法的默认实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (canWalk) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String): Behavior &#123;</span><br><span class="line">    <span class="comment">// 重写接口的属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> canWalk: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在 Behavior 接口当中增加了一个属性 canWalk，代表是否可以行走。与此同时，我们在接口方法当中，为 walk() 方法提供了默认实现，这个实现的逻辑也很简单，如果 canWalk 为 true，才执行 walk 内部的具体行为。</p><p>需要特别注意的是，由于 walk 已经有了默认的实现，所以我们在 Person 类当中就可以不必实现 walk 方法了。而 Kotlin 的这一设计，就让“接口”和“抽象类”之间的界限越来越模糊了。</p><p>换句话说，Kotlin 当中的接口，被设计得更加强大了，<strong>它拥有了部分抽象类才有的特性，同时还可以灵活使用接口组合的特性</strong>。</p><p>另外你还需要知道一点，就是虽然在 Java 1.8 版本当中，接口也引入了类似的特性，但由于 Kotlin 是完全兼容 Java 1.6 版本的。因此为了实现这个特性，Kotlin 编译器在背后做了一些转换。这也就意味着，它是有一定局限性的。而具体的局限体现在哪里呢？这个我先不多讲，你可以自己回去思考思考。</p><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>Java 当中，最常见的嵌套类分为两种：非静态内部类、静态内部类。Kotlin 当中也有一样的概念。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，B 类，就是 A 类里面的嵌套类，这非常容易理解。不过我们需要注意的是，这种写法的嵌套类，我们无法在 B 类当中访问 A 类的属性和成员方法。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> a = name   <span class="comment">// 报错</span></span><br><span class="line">        <span class="keyword">val</span> b = foo()  <span class="comment">// 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们尝试在 B 类当中访问 A 类的成员时，编译器会报错。如果你有 Java 基础，应该马上就能反应过来：这种写法就对应了 Java 当中的静态内部类！</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 等价的Java代码如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> int foo() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        String a = name)   <span class="comment">// 报错</span></span><br><span class="line">        int b = foo()      <span class="comment">// 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，Kotlin 当中的普通嵌套类，它的本质是静态的。相应地，如果想在 Kotlin 当中定义一个普通的内部类，我们需要在嵌套类的前面加上 <strong>inner 关键字</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 增加了一个关键字</span></span><br><span class="line"><span class="comment">//    ↓</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> a = name   <span class="comment">// 通过</span></span><br><span class="line">        <span class="keyword">val</span> b = foo()  <span class="comment">// 通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inner 关键字，代表了 B 类是 A 类内部的类，这种情况下，我们在 B 类的内部是可以访问 A 类的成员属性和方法的。</p><p>Kotlin 的这种设计非常巧妙。如果你熟悉 Java 开发，你会知道，Java 当中的嵌套类，如果没有 static 关键字的话，它就是一个内部类，这样的内部类是会持有外部类的引用的。可是，这样的设计在 Java 当中会非常容易出现内存泄漏！而大部分 Java 开发者之所以会犯这样的错误，往往只是因为忘记加“static”关键字了。这是一个 Java 开发者默认情况下就容易犯的错。</p><p>Kotlin 则反其道而行之，在默认情况下，<strong>嵌套类变成了静态内部类</strong>，而这种情况下的嵌套类是不会持有外部类引用的。只有当我们真正需要访问外部类成员的时候，我们才会加上 inner 关键字。这样一来，默认情况下，开发者是不会犯错的，只有手动加上 inner 关键字之后，才可能会出现内存泄漏，而当我们加上 inner 之后，其实往往也就能够意识到内存泄漏的风险了。</p><p>也就是说，<strong>Kotlin 这样的设计，就将默认犯错的风险完全抹掉了！</strong></p><h2 id="Kotlin-中的特殊类"><a href="#Kotlin-中的特殊类" class="headerlink" title="Kotlin 中的特殊类"></a>Kotlin 中的特殊类</h2><p>好了，到目前为止，我们接触到的都是 Kotlin 与 Java 都有的概念。接下来，我们来看两个 Java 当中没有的概念，数据类和密封类。</p><h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>数据类（Data Class），顾名思义，就是用于<strong>存放数据的类</strong>。要定义一个数据类，我们只需要在普通的类前面加上一个关键字“data”即可。比如前面案例当中的 Person 类，我们只需要在它的前面加上 data，就可以将它变为一个“数据类”。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 数据类当中，最少要有一个属性</span></span><br><span class="line">                   ↓</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>在 Kotlin 当中，编译器会为数据类自动生成一些有用的方法。它们分别是：</p><ul><li>equals()；</li><li>hashCode()；</li><li>toString()；</li><li>componentN() 函数；</li><li>copy()。</li></ul><p>所以，即使我们的 Person 类只有一行 Kotlin 代码，我们仍然可以在其他地方调用编译器，为我们自动生成这些方法。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> tom = Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">val</span> jack = Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">println(tom.equals(jack)) <span class="comment">// 输出：false</span></span><br><span class="line">println(tom.hashCode())   <span class="comment">// 输出：对应的hash code</span></span><br><span class="line">println(tom.toString())   <span class="comment">// 输出：Person(name=Tom, age=18)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> (name, age) = tom     <span class="comment">// name=Tom, age=18</span></span><br><span class="line">println(<span class="string">&quot;name is <span class="variable">$name</span>, age is <span class="variable">$age</span> .&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> mike = tom.copy(name = <span class="string">&quot;Mike&quot;</span>)</span><br><span class="line">println(mike)             <span class="comment">// 输出：Person(name=Mike, age=18)</span></span><br></pre></td></tr></table></figure><p>这里你需要注意的是最后的四行代码。</p><p>“val (name, age) &#x3D; tom”这行代码，其实是使用了数据类的解构声明。这种方式，可以让我们快速通过数据类来创建一连串的变量。另外，就是 copy 方法。数据类为我们默认实现了 copy 方法，可以让我们非常方便地在创建一份拷贝的同时，修改某个属性。</p><h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>Kotlin 当中的密封类，常常用来表示某种受到限制的继承结构。这样说起来可能有点抽象，让我们换个说法：<strong>密封类，是更强大的枚举类</strong>。</p><p>首先，让我们看看枚举类是什么。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    MAN, WOMAN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isMan</span><span class="params">(<span class="keyword">data</span>: <span class="type">Human</span>)</span></span> = <span class="keyword">when</span>(<span class="keyword">data</span>) &#123;</span><br><span class="line">    Human.MAN -&gt; <span class="literal">true</span></span><br><span class="line">    Human.WOMAN -&gt; <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 这里不需要else分支，编译器自动推导出逻辑已完备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过 enum 就可以定义枚举类，<strong>所谓枚举，就是一组有限的数量的值</strong>。比如，人分为男人和女人。这样的分类是有限的，所以我们可以枚举出每一种情况。我们在 when 表达式当中使用枚举时，编译器甚至可以自动帮我们推导出逻辑是否完备。这是枚举的优势。</p><p>但是，枚举也有它的局限性。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">println(Human.MAN == Human.MAN)</span><br><span class="line">println(Human.MAN === Human.MAN)</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>比如在这里我们可以看到，当我们尝试去判断枚举的“结构相等”和“引用相等”时，结果始终都是 true。而这就代表了，每一个枚举的值，它在内存当中始终都是同一个对象引用。</p><p>那么万一，我们想要枚举的值拥有不一样的对象引用，我们该怎么办呢？这时候就需要“密封类”出场了！</p><p>想要定义密封类，我们需要使用 <strong>sealed 关键字</strong>，它的中文含义也代表着“密封”。在 Android 开发当中，我们会经常使用密封类对数据进行封装。比如我们可以来看一个代码例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;<span class="type">out R</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Success</span>&lt;<span class="type">out T</span>&gt;(<span class="keyword">val</span> <span class="keyword">data</span>: T, <span class="keyword">val</span> message: String = <span class="string">&quot;&quot;</span>) : Result&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> exception: Exception) : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Loading</span>(<span class="keyword">val</span> time: <span class="built_in">Long</span> = System.currentTimeMillis()) : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子是改造于我实际工作中用过的代码。首先，我们使用 sealed 关键字定义了一个 Result 类，并且它需要一个泛型参数 R，R 前面的 out 我们可以暂时先忽略。</p><p>这个密封类，我们是专门用于封装网络请求结果的。可以看到，在 Result 类当中，分别有三个数据类，分别是 Success、Error、Loading。我们将一个网络请求结果也分为了三大类，分别代表请求成功、请求失败、请求中。</p><p>这样，当网络请求有结果以后，我们的 UI 展示逻辑就会变得非常简单，也就是非常直白的三个逻辑分支：成功、失败、进行中。我们将其与 Kotlin 协程当中的 when 表达式相结合，就能很好地处理 UI 展示逻辑：如果是 Loading，我们就展示进度条；如果是 Success，我们就展示成功的数据；如果是 Error，我们就展示错误提示框。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">display</span><span class="params">(<span class="keyword">data</span>: <span class="type">Result</span>)</span></span> = <span class="keyword">when</span>(<span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="keyword">is</span> Result.Success -&gt; displaySuccessUI(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">is</span> Result.Error -&gt; showErrorMsg(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">is</span> Result.Loading -&gt; showLoading()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们的密封类只有这三种情况，所以我们的 when 表达式不需要 else 分支。可以看到，这样的代码风格，既实现了类似枚举类的逻辑完备性，还完美实现了数据结构的封装。</p><p>而且，在最新的 Kotlin 1.5 版本当中，sealed 不仅仅可以用于修饰类，还可以用于修饰接口。这就为我们的密封类实现多个接口，提供了可能。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在这节课当中，我们学习了面向对象常见的概念，包括类、继承、接口、实现、枚举，还有 Kotlin 独有的数据类、密封类。同时也进一步领略到了 Kotlin 语法在一些细节的良苦用心。比如说：</p><ul><li>Kotlin 的类，默认是 public 的。</li><li>Kotlin 的类继承语法、接口实现语法，是完全一样的。</li><li>Kotlin 当中的类默认是对继承封闭的，类当中的成员和方法，默认也是无法被重写的。这样的设计就很好地避免了继承被滥用。</li><li>Kotlin 接口可以有成员属性，还可以有默认实现。</li><li>Kotlin 的嵌套类默认是静态的，这种设计可以防止我们无意中出现内存泄漏问题。</li><li>Kotlin 独特的数据类，在语法简洁的同时，还给我们提供了丰富的功能。</li><li>密封类，作为枚举和对象的结合体，帮助我们很好地设计数据模型，支持 when 表达式完备性。</li></ul><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/21/bf/21080a921b3aa73872bfd55f7c1cddbf.jpg?wh=1920x911" alt="img"></p><p>看到这里，你一定会发现，我们上面提到的这些点，正好也是决定着 Kotlin 编程思想的关键。也正是 Kotlin 这样独特的设计，才形成了 Kotlin 迥然不同的编程风格。曾经有不少人问过我这样的问题：“如何才能拥有 Kotlin 编程思维，而不是用 Kotlin 写 Java 风格代码？如何才能写出优雅的 Kotlin 代码？”</p><p>答案其实很简单，我们先要掌握 Kotlin 的语法，然后透过这些语法细节去揣摩 Kotlin 设计者的意图，当我们理解 Kotlin 设计者为什么要设计某个语法时，我们就不可能用错这个语法了。而当我们能够用好 Kotlin 的每个语法的时候，我们自然而然地就可以写出优雅的 Kotlin 代码了。</p><p>比如，当我们知道数据类是为了解决冗余的 Java Bean 而设计的，那我们无论如何都不会在 Kotlin 当中再写一遍 Kotlin Bean 了。又或者，当我们知道 when 表达式可以自动判断逻辑分支是否完备的时候，我们自然就会想办法让 when 与枚举类 &#x2F; 密封类结合使用了。</p><p>正如课程开头我提到过的：入门 Kotlin 很容易，精通 Kotlin 很难。让我们一起努力吧！</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>在课程中，我提到了 Kotlin 接口的“成员属性”是存在一定的局限性的。那么，请问你能想到，它的局限性在哪里吗？</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin编程第一课--(基础篇)01  Kotlin基础语法：正式开启学习之旅</title>
      <link href="/posts/3dc00e96/"/>
      <url>/posts/3dc00e96/</url>
      
        <content type="html"><![CDATA[<p>从今天开始，我们就正式踏上 Kotlin 语言学习与实践的旅途了。这节课，我想先带你来学习下 Kotlin 的基础语法，包括变量、基础类型、函数和流程控制。这些基础语法是程序最基本的元素。</p><p>不过，如果你有使用 Java 的经验，可能会觉得今天的内容有点多余，毕竟 Kotlin 和 Java 的基础语法是比较相似的，它们都是基于 JVM 的语言。但其实不然，Kotlin 作为一门新的语言，它包含了许多新的特性，由此也决定着 Kotlin 的代码风格。<strong>如果你不够了解 Kotlin 的这些新特性，你会发现自己只是换了种方式在写 Java 而已。</strong></p><p>并且，在具备 Java 语言的知识基础上，这节课的内容也可以帮你快速将已有的经验迁移过来。这样的话，针对相似的语法，你可以直接建立 Kotlin 与 Java 的对应关系，进而加深理解。当然，即使你没有其他编程经验也没关系，从头学即可，Kotlin 的语法足够简洁，也非常适合作为第一门计算机语言来学习。</p><p>并且，在具备 Java 语言的知识基础上，这节课的内容也可以帮你快速将已有的经验迁移过来。这样的话，针对相似的语法，你可以直接建立 Kotlin 与 Java 的对应关系，进而加深理解。当然，即使你没有其他编程经验也没关系，从头学即可，Kotlin 的语法足够简洁，也非常适合作为第一门计算机语言来学习。</p><p>在课程中，我会用最通俗易懂的语言，来给你解释 Kotlin 的基础知识，并且会结合一些 Java 和 Kotlin 的代码案例，来帮助你直观地体会两种语言的异同点。而针对新的语法，我也会详细解释它存在的意义，以及都填补了 Java 的哪些短板，让你可以对 Kotlin 新语法的使用场景做到心中基本有数。</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>在正式开始学习基础语法之前，我们还需要配置一下 Kotlin 语言的环境，因为直接从代码开始学能给我们带来最直观的体验。</p><p>那么要运行 Kotlin 代码，最快的方式，就是使用 Kotlin 官方的<a href="https://play.kotlinlang.org/">PlayGround</a>。通过这个在线工具，我们可以非常方便地运行 Kotlin 代码片段。当然，这种方式用来临时测试一小段代码是没有问题的，但对于复杂的工程就有些力不从心了。</p><p>另一种方式，也是我个人比较推荐的方式，那就是安装IntelliJ IDEA。它是 Kotlin 官方提供的集成开发工具，也是世界上最好的 IDE 之一，如果你用过 Android Studio，你一定会对它很熟悉，因为 Android Studio 就是由 IntelliJ IDEA 改造的。</p><p>如果你的电脑没有 Java 环境，在安装完最新版的 IntelliJ IDEA 以后，通过“File -&gt; Project Structure -&gt; SDKs”，然后点击“加号按钮”就可以选择第三方提供的 OpenJDK 1.8 版本进行下载了。<img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/04/a7/04cf1b899574ceff2ecd099e41af1fa7.gif?wh=1000x770" alt="img"></p><p>当然，这里我更推荐你可以自己手动从Oracle 官网下载 JDK 1.6、1.7、1.8、11 这几个版本，然后再安装、配置 Java 多版本环境。这在实际工作中也是必备的。</p><p>需要注意的是，IntelliJ IDEA 分为 Ultimate 付费版和 Community 免费版，对于我们的 Kotlin 学习来说，免费版完全够用。</p><p>这样，在配置好了开发环境之后，我们就可以试着一边敲代码，一边体会、思考和学习 Kotlin 语言中这些最基础的语法知识了。那么下面我们就来看下，在 Kotlin 语言中是如何定义变量的吧。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在 Java&#x2F;C 当中，如果我们要声明变量，我们必须要声明它的类型，后面跟着变量的名称和对应的值，然后以分号结尾。就像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>而 Kotlin 则不一样，我们要使用“<strong>val</strong>”或者是“<strong>var</strong>”这样的关键字作为开头，后面跟“变量名称”，接着是“变量类型”和“赋值语句”，最后是分号结尾。就像这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关键字     变量类型</span></span><br><span class="line"><span class="comment"> ↓          ↓           */</span></span><br><span class="line"><span class="keyword">var</span> price: <span class="built_in">Int</span> = <span class="number">100</span>;   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     ↑            ↑</span></span><br><span class="line"><span class="comment">   变量名        变量值   */</span></span><br></pre></td></tr></table></figure><p>不过，像 Java 那样每写一行代码就写一个分号，其实也挺麻烦的。所以为了省事，在 Kotlin 里面，我们一般会把代码末尾的分号省略，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> price: <span class="built_in">Int</span> = <span class="number">100</span></span><br></pre></td></tr></table></figure><p>另外，由于 Kotlin 支持<strong>类型推导</strong>，大部分情况下，我们的变量类型可以省略不写，就像这样</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> price = <span class="number">100</span> <span class="comment">// 默认推导类型为： Int</span></span><br></pre></td></tr></table></figure><p>还有一点我们要注意，就是在 Kotlin 当中，我们应该尽可能避免使用 var，<strong>尽可能多地去使用 val</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> price = <span class="number">100</span></span><br><span class="line">price = <span class="number">101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> i = <span class="number">0</span></span><br><span class="line">i = <span class="number">1</span> <span class="comment">// 编译器报错</span></span><br></pre></td></tr></table></figure><p>原因其实很简单：</p><ul><li>val 声明的变量，我们叫做<strong>不可变变量</strong>，它的值在初始化以后就无法再次被修改，它相当于 Java 里面的 final 变量。</li><li>var 声明的变量，我们叫做<strong>可变变量</strong>，它对应 Java 里的普通变量。</li></ul><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>了解了变量类型如何声明之后，我们再来看下 Kotlin 中的基础类型。</p><p>基础类型，包括我们常见的数字类型、布尔类型、字符类型，以及前面这些类型组成的数组。这些类型是我们经常会遇到的概念，因此我们把它统一归为“基础类型”。</p><h2 id="一切都是对象"><a href="#一切都是对象" class="headerlink" title="一切都是对象"></a>一切都是对象</h2><p>在 Java 里面，基础类型分为原始类型（Primitive Types）和包装类型（Wrapper Type）。比如，整型会有对应的 int 和 Integer，前者是原始类型，后者是包装类型。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int i = <span class="number">0</span>; <span class="comment">// 原始类型</span></span><br><span class="line">Integer j = <span class="number">1</span>; <span class="comment">// 包装类型</span></span><br></pre></td></tr></table></figure><p>Java 之所以要这样做，是因为原始类型的开销小、性能高，但它不是对象，无法很好地融入到面向对象的系统中。而包装类型的开销大、性能相对较差，但它是对象，可以很好地发挥面向对象的特性。在 JDK 源码当中，我们可以看到 Integer 作为包装类型，它是有成员变量以及成员方法的，这就是它作为对象的优势。</p><p>然而，在 Kotlin 语言体系当中，是没有原始类型这个概念的。这也就意味着，<strong>在 Kotlin 里，一切都是对象</strong>。</p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/yy/3b/yyd95b04616943878351867c4d1e063b.jpg?wh=2000x1077" alt="img" style="zoom:50%;" /><p>实际上，从某种程度上讲，Java 的类型系统并不是完全面向对象的，因为它存在原始类型，而原始类型并不属于对象。而 Kotlin 则不一样，它从语言设计的层面上就规避了这个问题，类型系统则是完全面向对象的。</p><p>我们看一段代码，来更直观地感受 Kotlin 的独特之处：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Double</span> = <span class="number">1.</span>toDouble()</span><br></pre></td></tr></table></figure><p>可以发现，由于在 Kotlin 中，整型数字“1”被看作是对象了，所以我们可以调用它的成员方法 toDouble()，而这样的代码在 Java 中是无法实现的。</p><h2 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h2><p>既然 Kotlin 中的一切都是对象，那么对象就有可能为空。也许你会想到写这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Double</span> = <span class="literal">null</span> <span class="comment">// 编译器报错</span></span><br></pre></td></tr></table></figure><p>可事实上，以上的代码并不能通过 Kotlin 编译。这是因为 Kotlin 强制要求开发<strong>者在定义变量的时候，指定这个变量是否可能为 null</strong>。对于可能为 null 的变量，我们需要在声明的时候，在变量类型后面加一个问号“?”：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Double</span> = <span class="literal">null</span> <span class="comment">// 编译器报错</span></span><br><span class="line"><span class="keyword">val</span> j: <span class="built_in">Double</span>? = <span class="literal">null</span> <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><p>并且由于 Kotlin 对可能为空的变量类型做了强制区分，这就意味着，“可能为空的变量”无法直接赋值给“不可为空的变量”，当然，反向赋值是没有问题的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> i: <span class="built_in">Double</span> = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">var</span> j: <span class="built_in">Double</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">i = j  <span class="comment">// 编译器报错</span></span><br><span class="line">j = i  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><p>Kotlin 这么设计的原因也很简单，如果我们将“可能为空的变量”直接赋值给了“不可为空的变量”，这会跟它自身的定义产生冲突。而如果我们实在有这样的需求，也不难实现，只要做个判断即可：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> i: <span class="built_in">Double</span> = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">val</span> j: <span class="built_in">Double</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j != <span class="literal">null</span>) &#123;</span><br><span class="line">    i = j  <span class="comment">// 编译通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，在了解了 Kotlin 和 Java 这两种语言的主要区别后，下面就让我们来全面认识下 Kotlin 的基础类型。</p><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>首先，在数字类型上，Kotlin 和 Java 几乎是一致的，包括它们对数字“字面量”的定义方式。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> int = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> long = <span class="number">1234567L</span></span><br><span class="line"><span class="keyword">val</span> double = <span class="number">13.14</span></span><br><span class="line"><span class="keyword">val</span> float = <span class="number">13.14F</span></span><br><span class="line"><span class="keyword">val</span> hexadecimal = <span class="number">0xAF</span></span><br><span class="line"><span class="keyword">val</span> binary = <span class="number">0b01010101</span></span><br></pre></td></tr></table></figure><p>这里我也来给你具体介绍下：</p><ul><li>整数默认会被推导为“Int”类型；</li><li>Long 类型，我们则需要使用“L”后缀；</li><li>小数默认会被推导为“Double”，我们不需要使用“D”后缀；</li><li>Float 类型，我们需要使用“F”后缀；</li><li>使用“0x”，来代表十六进制字面量；</li><li>使用“0b”，来代表二进制字面量。</li></ul><p>但是，对于数字类型的转换，Kotlin 与 Java 的转换行为是不一样的。<strong>Java 可以隐式转换数字类型，而 Kotlin 更推崇显式转换。</strong></p><p>举个简单的例子，在 Java 和 C 当中，我们经常直接把 int 类型赋值给 long 类型，编译器会自动为我们做类型转换，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">int i = <span class="number">100</span>;</span><br><span class="line">long j = i;</span><br></pre></td></tr></table></figure><p>这段代码按照 Java 的编程思维方式来看，的确好像是 OK 的。但是你要注意，虽然 Java 编译器不会报错，可它仍然可能会带来问题，因为它们本质上不是一个类型，int、long、float、double 这些类型之间的互相转换是存在精度问题的。尤其是当这样的代码掺杂在复杂的逻辑中时，在碰到一些边界条件的情况下，即使出现了 Bug 也不容易排查出来。</p><p>所以，同样的代码，在 Kotlin 当中是行不通的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">100</span></span><br><span class="line"><span class="keyword">val</span> j: <span class="built_in">Long</span> = i <span class="comment">// 编译器报错</span></span><br></pre></td></tr></table></figure><p>在 Kotlin 里，这样的隐式转换被抛弃了。正确的做法应该是显式调用 Int 类型的 toLong() 函数：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">100</span></span><br><span class="line"><span class="keyword">val</span> j: <span class="built_in">Long</span> = i.toLong() <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><p>其实，如果我们仔细翻看 Kotlin 的源代码，会发现更多类似的函数，比如 toByte()、toShort()、toInt()、toLong()、toFloat()、toDouble()、toChar() 等等。Kotlin 这样设计的优势也是显而易见的，<strong>我们代码的可读性更强了，将来也更容易维护了。</strong></p><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>然后我们再来了解下 Kotlin 中布尔类型的变量，它只有两种值，分别是 <strong>true和false</strong>。布尔类型支持一些逻辑操作，比如说：</p><ul><li>“&amp;”代表“与运算”；</li><li>“|”代表“或运算”；</li><li>“!”代表“非运算”；</li><li>“&amp;&amp;”和“||”分别代表它们对应的“短路逻辑运算”。</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> j = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> isTrue: <span class="built_in">Boolean</span> = i &lt; j &amp;&amp; j &lt; k</span><br></pre></td></tr></table></figure><h2 id="字符：Char"><a href="#字符：Char" class="headerlink" title="字符：Char"></a>字符：Char</h2><p>Char 用于代表单个的字符，比如’A’、’B’、’C’，字符应该用单引号括起来。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> c: <span class="built_in">Char</span> = <span class="string">&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure><p>如果你有 Java 或 C 的使用经验，也许会写出这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> c: <span class="built_in">Char</span> = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = c <span class="comment">// 编译器报错</span></span><br></pre></td></tr></table></figure><p>这个问题其实跟前面 Java 的数字类型隐式转换的问题类似，所以针对这种情况，我们应该调用对应的函数来做类型转换。这一点我们一定要牢记在心。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> c: <span class="built_in">Char</span> = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = c.toInt() <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><h2 id="字符串：String"><a href="#字符串：String" class="headerlink" title="字符串：String"></a>字符串：String</h2><p>字符串（String），顾名思义，就是一连串的字符。和 Java 一样，Kotlin 中的字符串也是不可变的。在大部分情况下，我们会使用双引号来表示字符串的字面量，这一点跟 Java 也是一样的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;Hello Kotlin!&quot;</span></span><br></pre></td></tr></table></figure><p>不过与此同时，Kotlin 还为我们提供了非常简洁的<strong>字符串模板</strong>：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">print(<span class="string">&quot;Hello <span class="variable">$name</span>!&quot;</span>)</span><br><span class="line"><span class="comment">/*            ↑</span></span><br><span class="line"><span class="comment">    直接在字符串中访问变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line">Hello Kotlin!</span><br></pre></td></tr></table></figure><p>这样的特性，在 Java 当中是没有的，这是 Kotlin 提供的新特性。虽然说这个字符串模板功能，我们用 Java 也同样可以实现，但它远没有 Kotlin 这么简洁。在 Java 当中，我们必须使用两个“+”进行拼接，比如说(“Hello” + name + “!”)。这样一来，在字符串格式更复杂的情况下，代码就会很臃肿。</p><p>当然，如果我们需要在字符串当中引用更加复杂的变量，则需要使用花括号将变量括起来：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> array = arrayOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;Hello <span class="subst">$&#123;array.get(<span class="number">1</span>)&#125;</span>!&quot;</span>)</span><br><span class="line"><span class="comment">/*            ↑</span></span><br><span class="line"><span class="comment">      复杂的变量，使用$&#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line">Hello Kotlin!</span><br></pre></td></tr></table></figure><p>另外，Kotlin 还新增了一个<strong>原始字符串</strong>，是用三个引号来表示的。它可以用于存放复杂的多行文本，并且它定义的时候是什么格式，最终打印也会是对应的格式。所以当我们需要复杂文本的时候，就不需要像 Java 那样写一堆的加号和换行符了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       当我们的字符串有复杂的格式时</span></span><br><span class="line"><span class="string">       原始字符串非常的方便</span></span><br><span class="line"><span class="string">       因为它可以做到所见即所得。 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>最后，我们再来看看 Kotlin 中数组的一些改变。</p><p>在 Kotlin 当中，我们一般会使用 <strong>arrayOf()</strong> 来创建数组，括号当中可以用于传递数组元素进行初始化，同时，Kotlin 编译器也会根据传入的参数进行类型推导。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> arrayInt = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> arrayString = arrayOf(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>)</span><br></pre></td></tr></table></figure><p>比如说，针对这里的 arrayInt，由于我们赋值的时候传入了整数，所以它的类型会被推导为整型数组；对于 arrayString，它的类型会被推导为字符串数组。</p><p>而你应该也知道，在 Java 当中，数组和其他集合的操作是不一样的。举个例子，如果要获取数组的长度，Java 中应该使用“array.length”；但如果是获取 List 的大小，那么 Java 中则应该使用“list.size”。这主要是因为数组不属于 Java 集合。</p><p>不过，Kotlin 在这个问题的处理上并不一样。<strong>虽然 Kotlin 的数组仍然不属于集合，但它的一些操作是跟集合统一的</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> array = arrayOf(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;Size is <span class="subst">$&#123;array.size&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;First element is <span class="subst">$&#123;array[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line">Size <span class="keyword">is</span> <span class="number">2</span></span><br><span class="line">First element <span class="keyword">is</span> apple</span><br></pre></td></tr></table></figure><p>就比如说，以上代码中，我们直接使用 array.size 就能拿到数组的长度。</p><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>好，了解了 Kotlin 中变量和基础类型的相关概念之后，我们再来看看它的函数是如何定义的。</p><p>在 Kotlin 当中，函数的声明与 Java 不太一样，让我们看一段简单的 Kotlin 代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关键字    函数名          参数类型   返回值类型</span></span><br><span class="line"><span class="comment"> ↓        ↓                ↓       ↓      */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">helloFunction</span><span class="params">(name: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello <span class="variable">$name</span> !&quot;</span></span><br><span class="line">&#125;<span class="comment">/*   ↑</span></span><br><span class="line"><span class="comment">   花括号内为：函数体</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，在这段代码中：</p><ul><li>使用了 <strong>fun 关键字</strong>来定义函数；</li><li><strong>函数名称</strong>，使用的是驼峰命名法（大部分情况下）；</li><li><strong>函数参数</strong>，是以 (name: String) 这样的形式传递的，这代表了参数类型为 String 类型；</li><li><strong>返回值类型</strong>，紧跟在参数的后面；</li><li>最后是最后是花括号内的函数体，它代表了整个函数的逻辑。，它代表了整个函数的逻辑。</li></ul><p>另外你可以再注意一个地方，前面代码中的 helloFunction 函数，它的函数体实际上只有一行代码。那么针对这种情况，我们其实就可以省略函数体的花括号，直接使用“&#x3D;”来连接，将其变成一种类似变量赋值的函数形式：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">helloFunction</span><span class="params">(name: <span class="type">String</span>)</span></span>: String = <span class="string">&quot;Hello <span class="variable">$name</span> !&quot;</span></span><br></pre></td></tr></table></figure><p>这种写法，我们称之为<strong>单一表达式函数</strong>。需要注意的是，在这种情况下，表达式当中的“return”是需要去掉的。</p><p>另外，由于 Kotlin 支持类型推导，我们在使用单一表达式形式的时候，返回值的类型也可以省略：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">helloFunction</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="string">&quot;Hello <span class="variable">$name</span> !&quot;</span></span><br></pre></td></tr></table></figure><p>看到这里，你一定能体会到 Kotlin 的魅力。它的语法非常得简洁，并且是符合人类的阅读直觉的，我们读这样的代码，就跟读自然语言一样轻松。</p><p>然而，Kotlin 的优势不仅仅体现在函数声明上，在函数调用的地方，它也有很多独到之处。</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>以我们前面定义的函数为例子，如果我们想要调用它，代码的风格和 Java 基本一致：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">helloFunction(<span class="string">&quot;Kotlin&quot;</span>)</span><br></pre></td></tr></table></figure><p>让我们看一个更具体的使用场景：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    age: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    gender: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    friendCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    feedCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    likeCount: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    commentCount: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个包含了很多参数的函数，在 Kotlin 当中，针对参数较多的函数，我们一般会以<strong>纵向的方式排列</strong>，这样的代码更符合我们从上到下的阅读习惯，省去从左往右翻的麻烦。</p><p>但是，如果我们像 Java 那样调用 createUser，代码就会非常难以阅读：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">createUser(<span class="string">&quot;Tom&quot;</span>, <span class="number">30</span>, <span class="number">1</span>, <span class="number">78</span>, <span class="number">2093</span>, <span class="number">10937</span>, <span class="number">3285</span>)</span><br></pre></td></tr></table></figure><p>这里代码中的第一个参数，我们知道肯定是 name，但是到了后面那一堆的数字，就会让人迷惑了。这样的代码不仅难懂，同时还不好维护。</p><p>但如果我们这样写呢？</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">createUser(</span><br><span class="line">    name = <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    age = <span class="number">30</span>,</span><br><span class="line">    gender = <span class="number">1</span>,</span><br><span class="line">    friendCount = <span class="number">78</span>,</span><br><span class="line">    feedCount = <span class="number">2093</span>,</span><br><span class="line">    likeCount = <span class="number">10937</span>,</span><br><span class="line">    commentCount = <span class="number">3285</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到，在这段代码中，我们把函数的形参加了进来，形参和实参用“&#x3D;”连接，建立了两者的对应关系。对比前面 Java 风格的写法，这样的代码可读性更强了。如果将来你想修改 likeCount 这个参数，也可以轻松做到。这其实就体现出了 Kotlin 命名参数的<strong>可读性</strong>与<strong>易维护性</strong>两个优势。</p><p>而除了命名参数这个特性，Kotlin 还支持<strong>参数默认值</strong>，这个特性在参数较多的情况下同样有很大的优势：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    age: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    gender: <span class="type">Int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    friendCount: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    feedCount: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    likeCount: <span class="type">Long</span> = <span class="number">0</span>L,</span></span></span><br><span class="line"><span class="params"><span class="function">    commentCount: <span class="type">Int</span> = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，gender、friendCount、feedCount、likeCount、commentCount 这几个参数都被赋予了默认值。这样做的好处就在于，我们在调用的时候可以省很多事情。比如说，下面这段代码就只需要传 3 个参数，剩余的 4 个参数没有传，但是 Kotlin 编译器会自动帮我们填上默认值。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">createUser(</span><br><span class="line">    name = <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    age = <span class="number">30</span>,</span><br><span class="line">    commentCount = <span class="number">3285</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于无默认值的参数，编译器会强制要求我们在调用处传参；对于有默认值的参数，则可传可不传。Kotlin 这样的特性，在一些场景下就可以极大地提升我们的开发效率。</p><p>而如果是在 Java 当中要实现类似的事情，我们就必须手动定义“3 个参数的 createUser 函数”，或者是使用 Builder 设计模式。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>在 Kotlin 当中，流程控制主要有 if、when、for、 while，这些语句可以控制代码的执行流程。它们也是体现代码逻辑的关键。下面我们就来一一学习下。</p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if 语句，在程序当中主要是用于逻辑判断。Kotlin 当中的 if 与 Java 当中的基本一致：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    print(<span class="string">&quot;Big&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Small&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">Big</span><br></pre></td></tr></table></figure><p>可以看到，由于 i 大于 0，所以程序会输出“Big”，这很好理解。不过 Kotlin 的 if，并不是程序语句（Statement）那么简单，它还可以作为<strong>表达式</strong>（Expression）来使用。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> message = <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="string">&quot;Big&quot;</span> <span class="keyword">else</span> <span class="string">&quot;Small&quot;</span></span><br><span class="line"></span><br><span class="line">print(message)</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">Big</span><br></pre></td></tr></table></figure><p>以上的代码其实跟之前的代码差不多，它们做的是同一件事。不同的是，我们把 if 当作表达式在用，将 if 判断的结果，赋值给了一个变量。同时，Kotlin 编译会根据 if 表达式的结果自动推导出变量“message”的类型为“String”。这种方式就使得 Kotlin 的代码更加简洁。</p><p>而类似的逻辑，如果要用 Java 来实现的话，我们就必须先在 if 外面定义一个变量 message，然后分别在两个分支内对 message 赋值：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">int i = <span class="number">1</span></span><br><span class="line">String message = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    message = <span class="string">&quot;Big&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    message = <span class="string">&quot;Small&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure><p>这样两相对比下，我们会发现 Java 的实现方式明显丑陋一些：<strong>不仅代码行数更多，逻辑也松散了</strong>。</p><p>另外，由于 Kotlin 当中明确规定了类型分为“可空类型”“不可空类型”，因此，我们会经常遇到可空的变量，并且要判断它们是否为空。我们直接来看个例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getLength</span><span class="params">(text: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> (text != <span class="literal">null</span>) text.length <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子当中，我们把 if 当作表达式，如果 text 不为空，我们就算出它的长度；如果它为空，长度就取 0。</p><p>但是，如果你实际使用 Kotlin 写过代码，你会发现：在 Kotlin 中，类似这样的判断逻辑出现得非常频繁，如果每次都要写一个完整的 if else 分支，其实也很麻烦。</p><p>为此，Kotlin 针对这种情况就提供了一种简写，叫做 <strong>Elvis 表达式</strong>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getLength</span><span class="params">(text: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> text?.length ?: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，通过 Elvis 表达式，我们就再也不必写“if (xxx !&#x3D; null) xxx else xxx”这样的赋值代码了。它在提高代码可读性的同时，还能提高我们的编码效率。</p><h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p>when 语句，在程序当中主要也是用于逻辑判断的。当我们的代码逻辑只有两个分支的时候，我们一般会使用 if&#x2F;else，而在大于两个逻辑分支的情况下，我们使用 when。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">when</span>(i) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">&quot;一&quot;</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">&quot;二&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">&quot;i 不是一也不是二&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">一</span><br></pre></td></tr></table></figure><p>when 语句有点像 Java 里的 switch case 语句，不过 Kotlin 的 when 更加强大，它同时也可以<strong>作为表达式，为变量赋值</strong>，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> message = <span class="keyword">when</span>(i) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; <span class="string">&quot;一&quot;</span></span><br><span class="line">    <span class="number">2</span> -&gt; <span class="string">&quot;二&quot;</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">&quot;i 不是一也不是二&quot;</span> <span class="comment">// 如果去掉这行，会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure><p>另外，与 switch 不一样的是，when 表达式要求它里面的逻辑分支必须是完整的。举个例子，以上的代码，如果去掉 else 分支，编译器将报错，原因是：i 的值不仅仅只有 1 和 2，这两个分支并没有覆盖所有的情况，所以会报错。</p><h2 id="循环迭代：while-与-for"><a href="#循环迭代：while-与-for" class="headerlink" title="循环迭代：while 与 for"></a>循环迭代：while 与 for</h2><p>首先 while 循环，我们一般是用于重复执行某些代码，它在使用上和 Java 也没有什么区别：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    println(j)</span><br><span class="line">    j++</span><br><span class="line">&#125; <span class="keyword">while</span> (j &lt;= <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>但是对于 for 语句，Kotlin 和 Java 的用法就明显不一样了。</p><p>在 Java 当中，for 也会经常被用于循环，经常被用来替代 while。不过，<strong>Kotlin 的 for 语句更多的是用于“迭代”</strong>。比如，以下代码就代表了迭代 array 这个数组里的所有元素，程序会依次打印出：“1、2、3”。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> array = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而除了迭代数组和集合以外，Kotlin 还支持迭代一个“区间”。</p><p>首先，要定义一个区间，我们可以使用“..”来连接数值区间的两端，比如“1..3”就代表从 1 到 3 的闭区间，左闭右闭：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> oneToThree = <span class="number">1.</span><span class="number">.3</span> <span class="comment">// 代表 [1, 3]</span></span><br></pre></td></tr></table></figure><p>接着，我们就可以使用 for 语句，来对这个闭区间范围进行迭代：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> oneToThree) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>甚至，我们还可以<strong>逆序迭代</strong>一个区间，比如：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">6</span> downTo <span class="number">0</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>以上代码的含义就是逆序迭代一个区间，从 6 到 0，每次迭代的步长是 2，这意味着 6 迭代过后，到 4、2，最后到 0。<strong>需要特别注意的是</strong>，逆序区间我们不能使用“6..0”来定义，如果用这样的方式来定义的话，代码将无法正常运行。</p><p>好了，那么到目前为止，Kotlin 的变量、基础类型、函数、流程控制，我们就都已经介绍完了。掌握好这些知识点，我们就已经可以写出简单的程序了。当然，我们的 Kotlin 学习之路才刚刚开始，在下节课，我会带你来学习 Kotlin 面向对象相关的知识点。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>学完了这节课，现在我们知道虽然 Kotlin 和 Java 的语法很像，但在一些细节之处，Kotlin 总会有一些新的东西。如果你仔细琢磨这些不同点，你会发现它正是大部分程序员所需要的。举个例子，作为开发者，我们都讨厌写冗余的代码，喜欢简洁易懂的代码。那么在今天学完了基础语法之后，我们可以来看看 Kotlin 在这方面都做了哪些改进：</p><ul><li>支持类型推导；</li><li>代码末尾不需要分号；</li><li>字符串模板；</li><li>原始字符串，支持复杂文本格式；</li><li>单一表达式函数，简洁且符合直觉；</li><li>函数参数支持默认值，替代 Builder 模式的同时，可读性还很强；</li><li>if 和 when 可以作为表达式。</li></ul><p>同时，JetBrains 也非常清楚开发者在什么情况下容易出错，所以，它在语言层面也做了很多改进：</p><ul><li>强制区分“可为空变量类型”和“不可为空变量类型”，规避空指针异常；</li><li>推崇不可变性（val），对于没有修改需求的变量，IDE 会智能提示开发者将“var”改为“val”</li><li>基础类型不支持隐式类型转换，这能避免很多隐藏的问题；</li><li>数组访问行为与集合统一，不会出现 array.length、list.size 这种恼人的情况；</li><li>函数调用支持命名参数，提高可读性，在后续维护代码的时候不易出错；</li><li>when 表达式，强制要求逻辑分支完整，让你写出来的逻辑永远不会有漏洞。</li></ul><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://static001.geekbang.org/resource/image/32/67/32ab3d37cd7f9650f4cba17736305c67.jpg?wh=1920x1983" alt="img" style="zoom: 33%;" /><p>这些都是 Kotlin 的<strong>闪光点</strong>，也是它最珍贵的地方。</p><p>这一切，都得益于 Kotlin 的发明者 JetBrains。作为最负盛名的 IDE 创造者，JetBrains 能深刻捕捉到开发者的需求。它知道开发者喜欢什么、讨厌什么，它甚至知道开发者容易犯什么样的错误，从而在语言设计的层面规避错误。站在这个角度看，JetBrains 能够创造出炙手可热的 Kotlin 语言，就一点都不奇怪了。</p><p>以上这么多的“闪光点”还仅仅只是局限于我们这节课的内容，如果放眼全局，这样的例子更是数不胜数。<strong>Kotlin 对比 Java 的提升，如果独立去看其中的某一个点，都不足以让一个开发者心动。不过，一旦这样的改善积少成多，Kotlin 的优势就会显得尤为明显</strong>。这也是很多程序员表示“Kotlin 用过了就回不去”的原因。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>虽然 Kotlin 在语法层面摒弃了“原始类型”，但有时候为了性能考虑，我们确实需要用“原始类型”。这时候我们应该怎么办？</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
          <category> Kotlin编程第一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android发布开源库到JitPack</title>
      <link href="/posts/c3221099/"/>
      <url>/posts/c3221099/</url>
      
        <content type="html"><![CDATA[<p>最近在整合项目资料的时候，注意到项目中很多可以通用的module，每次新建项目都需要把这些module依赖进来，如果module发生了改变，那么所有的项目都需要手动更改代码，因此尝试把通用的组件提取出来，放到JitPack上，当然还有阿里云Maven，和MavenCentral，这个我们下篇在介绍。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>在Android Studio中创建一个名为<code>JitShare</code>的项目</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/rJKVaq5QAE1cdoP.png" alt="create project"></p><p>点击<code>Finish</code>完成工程创建。</p><h2 id="新建Module与依赖"><a href="#新建Module与依赖" class="headerlink" title="新建Module与依赖"></a>新建Module与依赖</h2><p><code>File --&gt; New --&gt; New Module</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/9TP4DuXk8jBKlwO.png" alt="create module"></p><p>输入<code>Module name</code>,点击Finish。</p><p>创建好module的工程目录结构如下</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/Ph5wy2m7J4rcj8G.png" alt="project structure"></p><p>可以看到<code>app</code>和<code>share</code>是不同的图标，<code>app</code>是可运行模块，<code>share</code>是可依赖模块。</p><p>下一步是配置<code>app</code>模块依赖<code>share</code>模块。在开始依赖之前，我们先看<code>app</code>module的<code>build.gradle</code>。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/lrIYAQNxcHqi37M.png" alt="module:app"></p><p>下面来添加<code>share</code>模块的依赖.</p><p>点击这个图标，或者使用快捷键<code>Ctrl + Alt + Shift + S</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/V3owUkK2Yrydlce.png" alt="project Structure"></p><p>在弹框中，按照下图所示操作(Dependencies –&gt; app –&gt; + –&gt; Module Dependency )。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/nuBQNG5iIO6ZtYv.png" alt="add dependencies"></p><p>勾选上<code>share</code>，点击OK</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/y9AXTl2rukZJg4c.png" alt="Add Module Dependency"></p><p>再看<code>Modoule</code>级别的<code>app</code>的<code>build.gradle</code>。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/4TnV6jRUg9YAxbX.png" alt="dependencies"></p><p>可以看到，<code>app</code>模块已经完成了对<code>share</code>模块的引用。</p><h2 id="测试依赖库"><a href="#测试依赖库" class="headerlink" title="测试依赖库"></a>测试依赖库</h2><p>因为<code>share</code>模块里面是空的，所以现在也无法判断是否正确引用了，因此我们在<code>share</code>模块中，添加一些测试代码.</p><p>我们在<code>share</code>模块中，新建一个<code>Logger</code>类</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.carl.demo.share</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Logger &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">e</span><span class="params">(message: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;share&quot;</span>, message )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>app</code>模块中添加测试代码</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/7eYzIW9k64FDZtm.png" alt="app.MainActivity"></p><p>可以发现，能够正常调用，运行模拟器，能够正常输出日志。</p><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><p>打开工程的<code>build.gradle</code>，添加如下代码:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">classpath &#x27;com.github.dcendents:android-maven-gradle-plugin:2.1&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">maven &#123; url <span class="string">&quot;https://jitpack.io&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>因为gradle 7.0之后工程结构发生了变化，因此需要修改的位置发生了变化。</strong>(如果不知道用的话，可以降低Android Studio的版本，还是沿用以前的配置)</p><p>对于仓库的引用，移到了<code>settings.gradle</code>中的<code>dependencyResolutionManagement</code>里面</p><p>完整配置如下：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">        maven &#123; url <span class="string">&#x27;https://jitpack.io&#x27;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>classpath</code>的引用，我们仍然可以按照之前的方法，在<code>Project</code>的<code>build.gradle</code>中，手动添加依赖，完整配置如下:</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&#x27;com.github.dcendents:android-maven-gradle-plugin:2.1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span> version <span class="string">&#x27;7.3.1&#x27;</span> apply <span class="literal">false</span></span><br><span class="line">    id <span class="string">&#x27;com.android.library&#x27;</span> version <span class="string">&#x27;7.3.1&#x27;</span> apply <span class="literal">false</span></span><br><span class="line">    id <span class="string">&#x27;org.jetbrains.kotlin.android&#x27;</span> version <span class="string">&#x27;1.7.20&#x27;</span> apply <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><blockquote><p>需要先安装<code>git</code></p></blockquote><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/3hs5wcGQqTkruLZ.png" alt="git config"></p><p>点击<code>File</code> –&gt; <code>Settings</code>，在<code>Version Control</code>里面找到<code>Github</code>这个选项,点击<code>+</code>，选择用Token或者用户名登录.</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/5CULNeIqSztQcj8.png" alt="login github"></p><p>登录完成后，会显示当前登录的用户</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/saNv7fItwhRXkOK.png" alt="github user"></p><p>登录完成后，我们将代码提交到Github。</p><p>在工具栏<code>CVS</code> –&gt; <code>Share Project on Github</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/cySCbe4qU79tdzA.png" alt="Share Project on Github"></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/pCV3WzmNc1hYGdF.png" alt="image-20230316152507216"></p><p>然后在弹出框中，输入提交信息</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/SK3xr8VLJYqp1l7.png" alt="image-20230316152601050"></p><p>等待代码发布到Github即可。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/yOBbmUL3Vwq4Fe1.png" alt="image-20230316152641977"></p><p>我们打开Github，查看刚才提交的仓库</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/SNZG34UVhiHsFlM.png" alt="image-20230316152740699"></p><h2 id="创建Releases-Tags版本"><a href="#创建Releases-Tags版本" class="headerlink" title="创建Releases&#x2F;Tags版本"></a>创建Releases&#x2F;Tags版本</h2><p>点击<code>tags</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/Ti4SLyhBoWDgIPM.png" alt="image-20230316152927054"></p><p>点击<code>Create a new release</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/4Mo9rTKeCIFAgHs.png" alt="image-20230316153001834"></p><p>输入版本号，这里建议用<code>v1.0.0</code>这样的格式，如果你勾选了<code>Set as a pre-release</code>可以用<code>v0.2.0-alpha</code>或者<code>v5.9-beta.3</code>这样的格式。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/PCSTHmzfRpVD12Q.png" alt="image-20230316153113471"></p><blockquote><p>注意： 这里输入完<code>v1.0.0</code>之后，需要按一下<code>Enter</code>，不然会创建失败(提示 We weren’t able to create the release for you. Make sure you have a valid tag.)，创建成功后，<code>Choose a tag</code>的文字就会变成<code>v1.0.0</code>了</p></blockquote><p>最后，我们点击<code>Publish release</code>，完成初次提交。出现类似下面的界面，就表示完成了。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/xXSvAOfFJ2t9cNh.png" alt="image-20230316153446087"></p><blockquote><p>注意：这里发布的版本，需要是能够编译通过正常构建的，不然下面的操作会失败。</p></blockquote><h2 id="提交到JitPack"><a href="#提交到JitPack" class="headerlink" title="提交到JitPack"></a>提交到JitPack</h2><p>打开<a href="https://www.jitpack.io/">Jitpack</a></p><p>在<code>Git repo url</code>中输入我们git仓库的地址(现在已经支持gitee,因此我们也可以把代码发布到gitee),点击<code>Look up</code>。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/aIrOcXRFb1ZVEw2.png" alt="image-20230316153809342"></p><p>点击<code>Get it</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/CmajDbEwn9JoF4x.png" alt="image-20230316154151995"></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/8P6g9WjYLvMxfah.png" alt="image-20230316154314814"></p><p>我们可以按照上面的提示，将svg的代码添加到<code>README.MD</code>中。</p><h2 id="测试JitPack依赖"><a href="#测试JitPack依赖" class="headerlink" title="测试JitPack依赖"></a>测试JitPack依赖</h2><p>按照上面的提示，我们新建一个工程，把仓库依赖添加到的<code>dependencies</code></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.github.winstone-su:JitShare:Tag&#x27;</span></span><br></pre></td></tr></table></figure><p>把上面的<code>Tag</code>换成最新的版本号即可，这里是<code>1.0.0</code></p><p>如果提示，找不到这个依赖，我们要可能需要等待它构建完成。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/hTCficpHvxLzOEV.png" alt="image-20230316154745901"></p><p>完成后如图</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/wOFXyLStmGo9jTK.png" alt="image-20230316154957884"></p><p>把鼠标悬浮在Log下报告中，如果显示<code>Status:ok</code>，那么表示构建成功了，重新再<code>sync project</code></p><p>在主工程的<code>MainActivity</code>中添加测试代码</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/DImuJnSTk7h19Kx.png" alt="image-20230316155445666"></p><p>能够正常引用，说明已经完成了依赖。</p><h2 id="依赖库升级"><a href="#依赖库升级" class="headerlink" title="依赖库升级"></a>依赖库升级</h2><p>在我们往<code>JitShare</code>中添加了一些新功能，这个时候我们需要升级我们的依赖库。</p><p>我们先把<code>JitShare</code>的代码push到github</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/eOGrb91Ico2WDnH.png" alt="image-20230316155847933"></p><p>打开仓库对应的地址,点击<code>Draft a new release</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/H7VdaAuBUmCSMNl.png" alt="image-20230316160029767"></p><p>然后选择一个新的<code>tag</code>，输入标题和说明，勾选上<code>Set as the latest release</code>,点击<code>Publish release</code></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/qw427hBISHfXJxj.png" alt="image-20230316160206249"></p><p>然后查看，可以看到这里成功了。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/6pVZn7j2B8IEzOx.png" alt="image-20230316160410365"></p><p>我们再进入JitPack，按照之前的步骤操作</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/16/dTvOF6mtVGrSlpB.png" alt="image-20230316160459486"></p><p>完成后，在Android Studio中更新依赖</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.github.winstone-su:JitShare:1.0.1&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="Could-not-resolve-com-android-tools-build-gradle-8-0-2"><a href="#Could-not-resolve-com-android-tools-build-gradle-8-0-2" class="headerlink" title="Could not resolve com.android.tools.build:gradle:8.0.2."></a>Could not resolve com.android.tools.build:gradle:8.0.2.</h3><p>错误日志参考: <a href="https://www.jitpack.io/com/github/winstone-su/EasyExcel/V1.0.2/build.log">https://www.jitpack.io/com/github/winstone-su/EasyExcel/V1.0.2/build.log</a></p><p>写这篇文章的时候，AS默认使用的Gradle版本还是<code>7.3.1</code> ，后面再去创建工程的时候，默认的<code>AGP</code>版本已经升级到了<code>8.0.2</code>，同时JDK要使用<code>JAVA 17</code>了</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// project build.gradle</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span> version <span class="string">&#x27;8.0.2&#x27;</span> apply <span class="literal">false</span></span><br><span class="line">    id <span class="string">&#x27;com.android.library&#x27;</span> version <span class="string">&#x27;8.0.2&#x27;</span> apply <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gradle-wrapper.properties</span></span><br><span class="line">distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-8.0-bin.zip</span></span><br></pre></td></tr></table></figure><p>我在使用这个配置的时候，发现报错找不到<code>gradle 8.0.2</code></p><p>因此需要把Gradle的版本降级到<code>7.3.1</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// project build.gradle</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span> version <span class="string">&#x27;7.3.1&#x27;</span> apply <span class="literal">false</span></span><br><span class="line">    id <span class="string">&#x27;com.android.library&#x27;</span> version <span class="string">&#x27;7.3.1&#x27;</span> apply <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gradle-wrapper.properties</span></span><br><span class="line">distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-7.4-bin.zip</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JitPack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fragment-onActivityCreated 废弃解决办法</title>
      <link href="/posts/4e24a5f6/"/>
      <url>/posts/4e24a5f6/</url>
      
        <content type="html"><![CDATA[<p>​在新版SDK中，Fragment废弃了<code>onActivityCreated</code>方法，解决办法</p><p>在<code>onAttach()</code>方法中，使用lifecycle监听状态</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttach</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(context)</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onAttach: &quot;</span>, )</span><br><span class="line">        requireActivity().lifecycle.addObserver(<span class="keyword">object</span> : LifecycleEventObserver &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;onStateChanged: &quot;</span> + event.targetState )</span><br><span class="line">                <span class="keyword">if</span> (event.targetState == Lifecycle.State.RESUMED)&#123; <span class="comment">//注意</span></span><br><span class="line">                    viewModel = ViewModelProvider(<span class="keyword">this</span><span class="symbol">@HelpFragment</span>)[MainViewModel::<span class="keyword">class</span>.java]</span><br><span class="line">                    viewModel.result.observe(viewLifecycleOwner) &#123; result -&gt;</span><br><span class="line">                        binding.message.text = result</span><br><span class="line">                    &#125;</span><br><span class="line">                    lifecycle.removeObserver(<span class="keyword">this</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，如果判断<code>event.targetState</code>的状态为<code>Lifecycle.State.CREATED</code>的话，里面就不能包含控件的引用</p><p>加了监听的生命周期为：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">onAttach --&gt; onCreate --&gt; onStateChanged: CREATED --&gt; onCreateView --&gt; onActivityCreated --&gt;  onStateChanged: STARTED --&gt; onStateChanged: RESUMED</span><br></pre></td></tr></table></figure><p>可以看到状态为<code>Lifecycle.State.CREATED</code>是在 onCrate之后，onCreateView之前，这个时候布局还没有完成</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hilt基本使用</title>
      <link href="/posts/aae49b39/"/>
      <url>/posts/aae49b39/</url>
      
        <content type="html"><![CDATA[<h2 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h2><p>首先，将<code>hilt-android-gradle-plugin</code>添加到项目的根级<code>build.gradle</code>文件中:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ...</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        ...</span><br><span class="line">         classpath <span class="string">&#x27;com.google.dagger:hilt-android-gradle-plugin:2.38.1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，应用Gradle插件并在<code>app/build.gradle</code>文件添加依赖：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">...</span><br><span class="line">    id &#x27;kotlin-kapt&#x27;</span><br><span class="line">    id &#x27;dagger.hilt.android.plugin&#x27; //老版本的gradle方式略有不同 apply plugin:&#x27;dagger.hilt.android.plugin&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &quot;com.google.dagger:hilt-android:2.38.1&quot;</span><br><span class="line">    kapt &quot;com.google.dagger:hilt-android-compiler:2.38.1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hilt使用<a href="https://developer.android.com/studio/write/java8-support">Java 8 功能</a> 。如果需要在项目中启用<code>Java 8</code>，请将以下代码添加到<code>app/build.gradle</code>文件中：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  compileOptions &#123;</span><br><span class="line">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hilt应用类"><a href="#Hilt应用类" class="headerlink" title="Hilt应用类"></a>Hilt应用类</h2><p>所有使用Hilt的应用都必须包含一个带有<code>@HiltAndroidApp</code>注释的<code>Application</code>类</p><p><code>@HiltAndroidApp</code>会触发Hilt的代码生成操作，生成的代码包括应用的一个基类，该基类充当应用级依赖项容器。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HiltAndroidApp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HiltApplication</span>: <span class="type">Application</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Build Project</code>后会生成一个<code>Hilt_HiltApplication</code>的抽象类</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Hilt_HiltApplication</span> <span class="title">extends</span> <span class="title">Application</span> <span class="title">implements</span> <span class="title">GeneratedComponentManagerHolder</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ApplicationComponentManager componentManager = new ApplicationComponentManager(new ComponentSupplier() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> DaggerHiltApplication_HiltComponents_SingletonC.builder()</span><br><span class="line">          .applicationContextModule(new ApplicationContextModule(Hilt_HiltApplication.<span class="keyword">this</span>))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> ApplicationComponentManager componentManager() &#123;</span><br><span class="line">    <span class="keyword">return</span> componentManager;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Object generatedComponent() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.componentManager().generatedComponent();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CallSuper</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> void onCreate() &#123;</span><br><span class="line">    <span class="comment">// This is a known unsafe cast, but is safe in the only correct use case:</span></span><br><span class="line">    <span class="comment">// HiltApplication extends Hilt_HiltApplication</span></span><br><span class="line">    ((HiltApplication_GeneratedInjector) generatedComponent()).injectHiltApplication(UnsafeCasts.&lt;HiltApplication&gt;unsafeCast(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将依赖注入Android类"><a href="#将依赖注入Android类" class="headerlink" title="将依赖注入Android类"></a>将依赖注入Android类</h2><p>在 <code>Application</code> 类中设置了 Hilt 且有了应用级组件后，Hilt 可以为带有 <code>@AndroidEntryPoint</code> 注释的其他 Android 类提供依赖项：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="title">extends</span> <span class="title">AppCompatActivity</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Hilt 目前支持以下Android类：</p><ul><li><code>Application</code>(通过使用<code>@HiltAndroidApp</code>)</li><li><code>Activity</code> (Hilt仅支持扩展<code>ComponentActivity</code>的Activity，如<code>AppCompactActivity</code>)</li><li><code>Fragment</code>(不支持保留的<code>Fragment</code>,仅支持扩展<code>androidx.Fragment</code>的Fragment)</li><li><code>View</code></li><li><code>Service</code></li><li><code>BroadcastReceiver</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS动画框架-Spring</title>
      <link href="/posts/d1046a59/"/>
      <url>/posts/d1046a59/</url>
      
        <content type="html"><![CDATA[<h3 id="框架地址"><a href="#框架地址" class="headerlink" title="框架地址"></a>框架地址</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">https://github.com/MengTo/Spring</span><br></pre></td></tr></table></figure><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><ul><li><p>Cocoapods: (推荐)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">use_frameworks!</span><br><span class="line">pod &#x27;Spring&#x27;, :git =&gt; &#x27;https://github.com/MengTo/Spring.git&#x27;</span><br></pre></td></tr></table></figure></li><li><p>手动安装：</p><p>将<code>Spring</code> 文件夹拖进Xcode工程,确保勾选了(<code>Copy Item if nedd </code> 和 <code>Create groups</code>)</p></li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li><p>代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">springView.animation <span class="operator">=</span> <span class="string">&quot;shake&quot;</span></span><br><span class="line">springView.animate()</span><br></pre></td></tr></table></figure></li><li><p>Storyboard</p><p>选择<code>View</code> 的类型</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/NQyfWhgmxMCLlE3.png" alt="img"></p><p>可以在<code>Attribute Inspector</code>中设置属性</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/15/NYf4uMZdka83S9G.png" alt="Attribute Inspector"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arcgis-Find Places(Swift)</title>
      <link href="/posts/bca267fc/"/>
      <url>/posts/bca267fc/</url>
      
        <content type="html"><![CDATA[<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.swift</span></span><br><span class="line"><span class="comment">//  ArcgissSampleFive</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by geowin on 2020/7/15.</span></span><br><span class="line"><span class="comment">//  Copyright © 2020 geowin. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> ArcGIS</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_ inherited__">UIViewController</span> ,<span class="title class_ inherited__">UIPickerViewDataSource</span>,<span class="title class_ inherited__">UIPickerViewDelegate</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">numberOfComponents</span>(<span class="params">in</span> <span class="params">pickerView</span>: <span class="type">UIPickerView</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">pickerView</span>(<span class="keyword">_</span> <span class="params">pickerView</span>: <span class="type">UIPickerView</span>, <span class="params">numberOfRowsInComponent</span> <span class="params">component</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="type">Category</span>.all.count</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">pickerView</span>(<span class="keyword">_</span> <span class="params">pickerView</span>: <span class="type">UIPickerView</span>, <span class="params">titleForRow</span> <span class="params">row</span>: <span class="type">Int</span>, <span class="params">forComponent</span> <span class="params">component</span>: <span class="type">Int</span>) -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="type">Category</span>.all[row].title</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">pickerView</span>(<span class="keyword">_</span> <span class="params">pickerView</span>: <span class="type">UIPickerView</span>, <span class="params">didSelectRow</span> <span class="params">row</span>: <span class="type">Int</span>, <span class="params">inComponent</span> <span class="params">component</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        findPlaces(forCategory: <span class="type">Category</span>.all[row])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> mapView: <span class="type">AGSMapView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> categoryPicker: <span class="type">UIPickerView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> placesOverlay <span class="operator">=</span> <span class="type">AGSGraphicsOverlay</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> locatorTask <span class="operator">=</span> <span class="type">AGSLocatorTask</span>(url: .locator)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentSearch: <span class="type">AGSCancelable</span>?</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isNavigatingObservation: <span class="type">NSKeyValueObservation</span>?</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> visibleAreaObservation: <span class="type">NSKeyValueObservation</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">        initialMap()</span><br><span class="line">        <span class="comment">/// Add Observe</span></span><br><span class="line">        observeChangesInMapViewIsNavigating()</span><br><span class="line">        observeChangesInMapViewVisibleArea()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">observeChangesInMapViewIsNavigating</span>() &#123;</span><br><span class="line">        <span class="comment">// The map view `.isNavigating` property determines if the map view&#x27;s visible area has changed.</span></span><br><span class="line">        isNavigatingObservation <span class="operator">=</span> mapView.observe(\.isNavigating) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (mapView, <span class="keyword">_</span>) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// Find places for a selected category when the map view stops navigating.</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="operator">!</span>mapView.isNavigating <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="comment">// Update results if the map view extent has moved.</span></span><br><span class="line">            <span class="keyword">self</span><span class="operator">?</span>.findPlacesForCategoryPickerSelection()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">observeChangesInMapViewVisibleArea</span>() &#123;</span><br><span class="line">        <span class="comment">// Use the map view `.visibleArea` property to observe when the view sets its visible area for the first time.</span></span><br><span class="line">        visibleAreaObservation <span class="operator">=</span> mapView.observe(\.visibleArea) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (mapView, <span class="keyword">_</span>) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="comment">// When the visible area is set for the first time, kick off the first find places query.</span></span><br><span class="line">            <span class="keyword">self</span>.findPlacesForCategoryPickerSelection()</span><br><span class="line">            <span class="comment">// Nullify (thus invalidating) the visible area observation because the first find places query is performed.</span></span><br><span class="line">            <span class="keyword">self</span>.visibleAreaObservation <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK:- 初始化地图</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">initialMap</span>()&#123;</span><br><span class="line"><span class="comment">//        let tiledLayer = `AGSArcGISTiledLayer`(url: URL(string: &quot;http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer&quot;)!)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        let map = AGSMap(basemap: AGSBasemap(baseLayer: tiledLayer))</span></span><br><span class="line"><span class="comment">//        let location = CLLocationCoordinate2D(latitude: 40.838096, longitude: 111.677914)</span></span><br><span class="line"><span class="comment">//        let center = AGSPoint(clLocationCoordinate2D: location)</span></span><br><span class="line"><span class="comment">//        map.initialViewpoint = AGSViewpoint(center: center, scale: 20000)</span></span><br><span class="line"><span class="comment">//        mapView.map = map</span></span><br><span class="line">        </span><br><span class="line">        mapView.map <span class="operator">=</span> <span class="type">AGSMap</span>(basemapType: .navigationVector, latitude: <span class="number">34.09042</span>, longitude: <span class="operator">-</span><span class="number">118.71511</span>, levelOfDetail: <span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">        mapView.graphicsOverlays.add(placesOverlay)</span><br><span class="line">        </span><br><span class="line">        mapView.touchDelegate <span class="operator">=</span> <span class="keyword">self</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">addPlacesGraphics</span>(<span class="keyword">_</span> <span class="params">results</span>: [<span class="type">AGSGeocodeResult</span>],<span class="params">for</span> <span class="params">category</span>: <span class="type">Category</span>)&#123;</span><br><span class="line">        <span class="comment">// Build place marker symbol.</span></span><br><span class="line">        <span class="keyword">let</span> symbol: <span class="type">AGSSimpleMarkerSymbol</span> <span class="operator">=</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> placeSymbol <span class="operator">=</span> <span class="type">AGSSimpleMarkerSymbol</span>(style: .circle, color: category.color, size: <span class="number">10.0</span>)</span><br><span class="line">            placeSymbol.outline <span class="operator">=</span> <span class="type">AGSSimpleLineSymbol</span>(style: .solid, color: .white, width: <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> placeSymbol</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="comment">// Represent each place as a dot on the map.</span></span><br><span class="line">        <span class="comment">// Each graphic symbol gets the place attributes and later shows them when the user taps the graphic.</span></span><br><span class="line">        <span class="keyword">let</span> places <span class="operator">=</span> results.map &#123; (result) <span class="keyword">in</span></span><br><span class="line">            <span class="type">AGSGraphic</span>(geometry: result.displayLocation, symbol: symbol, attributes: result.attributes)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        placesOverlay.graphics.addObjects(from: places)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">clearPlacesGraphics</span>()&#123;</span><br><span class="line">        placesOverlay.graphics.removeAllObjects()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">showCallout</span>(<span class="params">for</span> <span class="params">graphic</span>: <span class="type">AGSGraphic</span>)&#123;</span><br><span class="line">        mapView.callout.title <span class="operator">=</span> graphic.attributes[<span class="type">String</span>.placeName] <span class="keyword">as?</span> <span class="type">String</span> <span class="operator">??</span> <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">        mapView.callout.detail <span class="operator">=</span> graphic.attributes[<span class="type">String</span>.placeAddress] <span class="keyword">as?</span> <span class="type">String</span> <span class="operator">??</span> <span class="string">&quot;no address provided&quot;</span></span><br><span class="line">        mapView.callout.show(for: graphic, tapLocation: graphic.geometry <span class="keyword">as?</span> <span class="type">AGSPoint</span>, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">hideCallout</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> mapView <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            mapView.callout.dismiss()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">findPlaces</span>(<span class="params">forCategory</span> <span class="params">category</span>: <span class="type">Category</span>)&#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> visibleArea <span class="operator">=</span> mapView.visibleArea <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">        </span><br><span class="line">        hideCallout()</span><br><span class="line">        clearPlacesGraphics()</span><br><span class="line">        </span><br><span class="line">        currentSearch<span class="operator">?</span>.cancel()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> paramters: <span class="type">AGSGeocodeParameters</span> <span class="operator">=</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> geocodeParameters <span class="operator">=</span> <span class="type">AGSGeocodeParameters</span>()</span><br><span class="line">            geocodeParameters.maxResults <span class="operator">=</span> <span class="number">25</span></span><br><span class="line">            geocodeParameters.resultAttributeNames.append(contentsOf: [. placeAddress,.placeName])</span><br><span class="line">            geocodeParameters.preferredSearchLocation <span class="operator">=</span> visibleArea.extent.center</span><br><span class="line">            geocodeParameters.categories <span class="operator">=</span> [category.title]</span><br><span class="line">            <span class="keyword">return</span> geocodeParameters</span><br><span class="line">        &#125;()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        currentSearch <span class="operator">=</span> locatorTask.geocode(withSearchText: <span class="string">&quot;&quot;</span>, parameters: paramters, completion: &#123;</span><br><span class="line">            [<span class="keyword">weak</span> <span class="keyword">self</span>] (result, error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">            <span class="keyword">guard</span> error <span class="operator">==</span> <span class="literal">nil</span> <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Geocode error: &quot;</span>,error<span class="operator">!</span>.localizedDescription)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> result <span class="operator">=</span> result,result.count <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;No places found for category &quot;</span>,category.title)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.addPlacesGraphics(result, for: category)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">findPlacesForCategoryPickerSelection</span>()&#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;  [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">            <span class="keyword">let</span> categoryIndex <span class="operator">=</span> <span class="keyword">self</span>.categoryPicker.selectedRow(inComponent: <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">guard</span> categoryIndex <span class="operator">&lt;</span> <span class="type">Category</span>.all.count <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">            <span class="keyword">let</span> category <span class="operator">=</span> <span class="type">Category</span>.all[categoryIndex]</span><br><span class="line">            <span class="keyword">self</span>.findPlaces(forCategory: category)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">ViewController</span>: <span class="title class_ inherited__">AGSGeoViewTouchDelegate</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">geoView</span>(<span class="keyword">_</span> <span class="params">geoView</span>: <span class="type">AGSGeoView</span>, <span class="params">didTapAtScreenPoint</span> <span class="params">screenPoint</span>: <span class="type">CGPoint</span>, <span class="params">mapPoint</span>: <span class="type">AGSPoint</span>) &#123;</span><br><span class="line">        hideCallout()</span><br><span class="line">        </span><br><span class="line">        mapView.identify(placesOverlay, screenPoint: screenPoint, tolerance: <span class="number">10</span>, returnPopupsOnly: <span class="literal">false</span>, maximumResults: <span class="number">1</span>) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>](result) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> result.error&#123;</span><br><span class="line">                <span class="built_in">print</span>(error)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> graphic <span class="operator">=</span> result.graphics.first&#123;</span><br><span class="line">                <span class="keyword">self</span>.showCallout(for: graphic)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
          <category> Nativie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arcgis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewModel和ViewModelProvider</title>
      <link href="/posts/a9e2c3a3/"/>
      <url>/posts/a9e2c3a3/</url>
      
        <content type="html"><![CDATA[<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//ViewModel</span><br><span class="line">implementation &#x27;androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0&#x27;</span><br></pre></td></tr></table></figure><h2 id="创建ViewModel"><a href="#创建ViewModel" class="headerlink" title="创建ViewModel"></a>创建ViewModel</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">   <span class="keyword">init</span> &#123;</span><br><span class="line">       Log.i(<span class="string">&quot;GameViewModel&quot;</span>, <span class="string">&quot;GameViewModel created!&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联并初始化"><a href="#关联并初始化" class="headerlink" title="关联并初始化"></a>关联并初始化</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModel: GameViewModel</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel = ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(GameViewModel::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Important: Always use ViewModelProvider to create ViewModel objects rather than directly instantiating an instance of ViewModel.</span><br></pre></td></tr></table></figure><h2 id="使用ViewModelFactory"><a href="#使用ViewModelFactory" class="headerlink" title="使用ViewModelFactory"></a>使用ViewModelFactory</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScoreViewModel</span>(finalScore: <span class="built_in">Int</span>) : ViewModel() &#123;</span><br><span class="line">   <span class="comment">// The final score</span></span><br><span class="line">   <span class="keyword">var</span> score = finalScore</span><br><span class="line">   <span class="keyword">init</span> &#123;</span><br><span class="line">       Log.i(<span class="string">&quot;ScoreViewModel&quot;</span>, <span class="string">&quot;Final score is <span class="variable">$finalScore</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScoreViewModelFactory</span>(<span class="keyword">private</span> <span class="keyword">val</span> finalScore: <span class="built_in">Int</span>) : ViewModelProvider.Factory &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel?&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">if</span> (modelClass.isAssignableFrom(ScoreViewModel::<span class="keyword">class</span>.java)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ScoreViewModel(finalScore) <span class="keyword">as</span> T</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unknown ViewModel class&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
            <tag> ViewModel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Navigation错误</title>
      <link href="/posts/7b4995aa/"/>
      <url>/posts/7b4995aa/</url>
      
        <content type="html"><![CDATA[<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境:"></a>开发环境:</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Android Studio: 2020.3.1 Patch 1</span><br><span class="line">gradle: 7.0.1</span><br><span class="line">navigation 版本: 2.3.5</span><br></pre></td></tr></table></figure><p>eg1: 错误详情</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">API <span class="string">&#x27;BaseVariant.getApplicationIdTextResource&#x27;</span> is obsolete and has been replaced with <span class="string">&#x27;VariantProperties.applicationId&#x27;</span>.</span><br><span class="line">It will be removed <span class="keyword">in</span> version 7.0 of the Android Gradle plugin.</span><br><span class="line"></span><br><span class="line">e: /Users/XXX/workspace/Android/demo/NavigationKotlin/app/build/generated/source/navigation-args/debug/com/txh/samples/apps/navigation/LoginFragmentDirections.kt: (12, 16): Class <span class="string">&#x27;ActionLoginFragmentToHomeFragment&#x27;</span> is not abstract and does not implement abstract member public abstract val actionId: Int defined <span class="keyword">in</span> androidx.navigation.NavDirections</span><br></pre></td></tr></table></figure><p>解决办法： 修改所有配置<code>navigation</code>的版本为<code>2.4.0-alpha08</code> 或以上，应该是navigation和gradle版本匹配的原因</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NavigationLink隐藏右侧小箭头</title>
      <link href="/posts/f21d2a2b/"/>
      <url>/posts/f21d2a2b/</url>
      
        <content type="html"><![CDATA[<p>​在使用NavigationLink的时候发现，默认右侧会带上一个小箭头</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/13/GmEgPLbOaQAdt1C.png" alt="landmarks"></p><p>解决办法:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">List</span>(landmarkData) &#123; landmark <span class="keyword">in</span></span><br><span class="line">        <span class="type">ZStack</span>&#123;</span><br><span class="line">            <span class="type">LandmarkRow</span>(landmark: landmark)</span><br><span class="line">            <span class="type">NavigationLink</span>(destination: <span class="type">LandmarkDetail</span>(landmark: landmark)) &#123;</span><br><span class="line">                <span class="type">EmptyView</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .navigationBarTitle(<span class="type">Text</span>(<span class="string">&quot;Landmarks&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetpack --(四)ViewBinding</title>
      <link href="/posts/17befa99/"/>
      <url>/posts/17befa99/</url>
      
        <content type="html"><![CDATA[<h1 id="Jetpack–-四-ViewBinding优化封装"><a href="#Jetpack–-四-ViewBinding优化封装" class="headerlink" title="Jetpack–(四) ViewBinding优化封装"></a>Jetpack–(四) ViewBinding优化封装</h1><h2 id="基类BaseActivity封装"><a href="#基类BaseActivity封装" class="headerlink" title="基类BaseActivity封装"></a>基类BaseActivity封装</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseActivity</span>&lt;<span class="type">T: ViewBinding</span>&gt;: <span class="type">AppCompatActivity</span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?, persistentState: <span class="type">PersistableBundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState, persistentState)</span><br><span class="line">        binding = getViewBinding()</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        initWidgets()</span><br><span class="line">        initData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">initWidgets</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">initData</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">getViewBinding</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在子类中实现</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">BaseActivity</span>&lt;<span class="type">ActivityMainBinding</span>&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getViewBinding</span><span class="params">()</span></span>: ActivityMainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initWidgets</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.initWidgets()</span><br><span class="line">        binding.textView.apply &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.initData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BaseFragment实现"><a href="#BaseFragment实现" class="headerlink" title="BaseFragment实现"></a>BaseFragment实现</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseFragment</span>&lt;<span class="type">T: ViewBinding</span>&gt;: <span class="type">Fragment</span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">getViewBinding</span><span class="params">()</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        binding = getViewBinding()</span><br><span class="line">        initWidgets()</span><br><span class="line">        initData()</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化View</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">initWidgets</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">initData</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法和BaseActivity一样</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetpack -- (二)ViewModel</title>
      <link href="/posts/680bd56a/"/>
      <url>/posts/680bd56a/</url>
      
        <content type="html"><![CDATA[<p>ViewModel的诞生:</p><ul><li>瞬态数据丢失</li><li>异步调用的内存泄漏</li><li>类膨胀提高维护难度和测试难度</li></ul><p>添加依赖</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;androidx.lifecycle:lifecycle-viewmodel-ktx:2.5.1&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>不要向ViewModel中传入Context，会导致内存泄漏</li><li>如果要使用Context，请使用AndroidViewModel中的Application</li></ul><p>简单应用：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyViewModel</span>: <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> num:<span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModel: MyViewModel</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        viewModel = ViewModelProvider(<span class="keyword">this</span>)[MyViewModel::<span class="keyword">class</span>.java]</span><br><span class="line"><span class="comment">//        viewModel = ViewModelProvider(this,ViewModelProvider.AndroidViewModelFactory(this.application))[MyViewModel::class.java]</span></span><br><span class="line"></span><br><span class="line">        binding.textView.text = viewModel.num.toString()</span><br><span class="line"></span><br><span class="line">        binding.button.setOnClickListener&#123;</span><br><span class="line">            viewModel.num += <span class="number">1</span></span><br><span class="line">            binding.textView.text = viewModel.num.toString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Fragment中使用ViewModel</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> myViewModel: MyViewModel</span><br><span class="line">myViewModel = ViewModelProvider(<span class="keyword">this</span>)[MyViewModel::<span class="keyword">class</span>.java]</span><br></pre></td></tr></table></figure><h3 id="在Activity中使用委托"><a href="#在Activity中使用委托" class="headerlink" title="在Activity中使用委托"></a>在Activity中使用委托</h3><p>导入依赖:</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;androidx.activity:activity-ktx:1.6.0-alpha05&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="keyword">val</span> viewModel: MyViewModel <span class="keyword">by</span> viewModels()</span><br></pre></td></tr></table></figure><p>或者直接使用</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> viewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>)[MyViewModel::<span class="keyword">class</span>.java]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="在Fragment中使用委托"><a href="#在Fragment中使用委托" class="headerlink" title="在Fragment中使用委托"></a>在Fragment中使用委托</h3><p>添加依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation &quot;androidx.fragment:fragment-ktx:1.5.1&quot;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> myViewModel: MyViewModel <span class="keyword">by</span> activityViewModels()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetpack -- (三)LiveData</title>
      <link href="/posts/2f69bde1/"/>
      <url>/posts/2f69bde1/</url>
      
        <content type="html"><![CDATA[<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>场景： 定时修改 textView的值</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextViewModel</span>: <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _currentSecond = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> currentSecond: MutableLiveData&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _currentSecond</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        _currentSecond.value = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        _currentSecond.postValue(_currentSecond.value?.plus(<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModel: TextViewModel</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        viewModel = ViewModelProvider(<span class="keyword">this</span>)[TextViewModel::<span class="keyword">class</span>.java]</span><br><span class="line">        binding.textView.text = viewModel.currentSecond.value.toString()</span><br><span class="line">        <span class="comment">//添加观察</span></span><br><span class="line">        viewModel.currentSecond.observe(<span class="keyword">this</span>)&#123;</span><br><span class="line">            binding.textView.text = viewModel.currentSecond.value.toString()</span><br><span class="line">        &#125;</span><br><span class="line">        startTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startTimer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Timer().schedule(<span class="keyword">object</span>: TimerTask() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">                viewModel.addSecond()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1000L</span>,<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改livedata的值，需要注意</p><ul><li>postValue 非UI线程</li><li>setValue  UI线程</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">       <span class="type">boolean</span> postTask;</span><br><span class="line">       <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">           postTask = mPendingData == NOT_SET;</span><br><span class="line">           mPendingData = value;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到，其实postValue 最后还是回到主线程</p><h3 id="ViewModel-LiveData实现Fragment间通信"><a href="#ViewModel-LiveData实现Fragment间通信" class="headerlink" title="ViewModel + LiveData实现Fragment间通信"></a>ViewModel + LiveData实现Fragment间通信</h3><p>使用场景： 构建两个Fragment，里面都只包含一个SeekBar，拖动seekbar，另一个fragmetn的seekbar也随之拖动</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyViewModel</span>: <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _progress = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> progress: MutableLiveData&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _progress</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        _progress.value = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fragment</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _binding: FragmentFirstBinding? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding <span class="keyword">get</span>() = _binding!!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> myViewModel: MyViewModel <span class="keyword">by</span> activityViewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        <span class="comment">// Inflate the layout for this fragment</span></span><br><span class="line">        _binding = FragmentFirstBinding.inflate(inflater,container,<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO : 注意这里的owner</span></span><br><span class="line">        myViewModel.progress.observe(viewLifecycleOwner)&#123;</span><br><span class="line">            binding.seekBar.progress  = it</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onCreateView: <span class="variable">$myViewModel</span>&quot;</span> )</span><br><span class="line"></span><br><span class="line">        binding.seekBar.apply &#123;</span><br><span class="line">            setOnSeekBarChangeListener(<span class="keyword">object</span> : SeekBar.OnSeekBarChangeListener&#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onProgressChanged</span><span class="params">(p0: <span class="type">SeekBar</span>?, p1: <span class="type">Int</span>, p2: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">                    myViewModel.progress.value = p1</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartTrackingTouch</span><span class="params">(p0: <span class="type">SeekBar</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStopTrackingTouch</span><span class="params">(p0: <span class="type">SeekBar</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">        _binding = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetpack -- (一)Lifecycle</title>
      <link href="/posts/6ee0249e/"/>
      <url>/posts/6ee0249e/</url>
      
        <content type="html"><![CDATA[<h2 id="使用Lifecycle解耦页面与组件"><a href="#使用Lifecycle解耦页面与组件" class="headerlink" title="使用Lifecycle解耦页面与组件"></a>使用Lifecycle解耦页面与组件</h2><h3 id="场景：-Chronometer统计页面在前台时间"><a href="#场景：-Chronometer统计页面在前台时间" class="headerlink" title="场景： Chronometer统计页面在前台时间"></a>场景： Chronometer统计页面在前台时间</h3><p>使用Lifecycle之前：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> elapsedTime:<span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line">        binding.chronometer.apply &#123;</span><br><span class="line">            base = SystemClock.elapsedRealtime()</span><br><span class="line">            start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">        binding.chronometer.apply &#123;</span><br><span class="line">            elapsedTime = SystemClock.elapsedRealtime() - base</span><br><span class="line">            stop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用Lifecycle之后:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyChronometer</span>(context: Context, attrs: AttributeSet) : Chronometer(context, attrs),LifecycleEventObserver &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> elapsedTime: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startMeter</span><span class="params">()</span></span> &#123;</span><br><span class="line">        base = SystemClock.elapsedRealtime() - elapsedTime</span><br><span class="line">        start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">stopMeter</span><span class="params">()</span></span> &#123;</span><br><span class="line">        elapsedTime = SystemClock.elapsedRealtime() - <span class="keyword">this</span>.base</span><br><span class="line">        stop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (event) &#123;</span><br><span class="line">            Lifecycle.Event.ON_RESUME -&gt; startMeter()</span><br><span class="line">            Lifecycle.Event.ON_PAUSE -&gt; stopMeter()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时需要在Activity的<code>onCreate()</code>中添加:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lifecycle.addObserver(binding.chronometer)</span><br></pre></td></tr></table></figure><h2 id="使用LifecycleService解耦Service与组件"><a href="#使用LifecycleService解耦Service与组件" class="headerlink" title="使用LifecycleService解耦Service与组件"></a>使用LifecycleService解耦Service与组件</h2><p>添加依赖:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;androidx.lifecycle:lifecycle-extensions:2.2.0&#x27;</span></span><br></pre></td></tr></table></figure><p>Observer</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocationObserver</span>(serviceContext: Context) : DefaultLifecycleObserver &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;LocationObserver&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> context = serviceContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> locationManager: LocationManager? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> myLocationListener: LocationListener? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(owner)</span><br><span class="line">        startLocation()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy(owner)</span><br><span class="line">        stopLocation()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="string">&quot;MissingPermission&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startLocation</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;startLocation: &quot;</span>, )</span><br><span class="line">        locationManager = context.getSystemService(Context.LOCATION_SERVICE) <span class="keyword">as</span> LocationManager</span><br><span class="line">        myLocationListener = MyLocationListener()</span><br><span class="line">        myLocationListener?.let &#123;</span><br><span class="line">            locationManager?.requestLocationUpdates(</span><br><span class="line">                LocationManager.GPS_PROVIDER,</span><br><span class="line">                <span class="number">3000</span>,<span class="comment">//每三秒获取一次</span></span><br><span class="line">                <span class="number">10f</span>,<span class="comment">//每移动10米获取一次</span></span><br><span class="line">                it</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">stopLocation</span><span class="params">()</span></span> &#123;</span><br><span class="line">        myLocationListener?.let &#123;</span><br><span class="line">            locationManager?.removeUpdates(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyLocationListener</span> : <span class="type">LocationListener</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;LocationObserver&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLocationChanged</span><span class="params">(location: <span class="type">Location</span>)</span></span> &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;onLocationChanged: <span class="variable">$location</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义Service继承<code>LifecycleService</code></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocationLifecycleService</span>: <span class="type">LifecycleService</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;LocationLifecycleService&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;LocationLifecycleService init &quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> locationObserver = LocationObserver( <span class="keyword">this</span>)</span><br><span class="line">        lifecycle.addObserver(locationObserver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        initClick()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initClick</span><span class="params">()</span></span> &#123;</span><br><span class="line">        binding.start.setOnClickListener&#123;</span><br><span class="line">            startService(Intent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>,LocationLifecycleService::<span class="keyword">class</span>.java))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        binding.stop.setOnClickListener&#123;</span><br><span class="line">            stopService(Intent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>,LocationLifecycleService::<span class="keyword">class</span>.java))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AndroidManifest.xml中添加权限和注册Service</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_COARSE_LOCATION&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_FINE_LOCATION&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;.LocationLifecycleService&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用ProcesslifecycleOwner-监听应用程序生命周期"><a href="#使用ProcesslifecycleOwner-监听应用程序生命周期" class="headerlink" title="使用ProcesslifecycleOwner 监听应用程序生命周期"></a>使用ProcesslifecycleOwner 监听应用程序生命周期</h2><ul><li>针对整个应用程序的监听，与Activity数量无关</li><li>Lifecycle.Event.ON_CREATE只会被调用一次，Lifecycle.Event.ON_DESTROY永远不会被调用</li></ul><p>添加依赖:</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;androidx.lifecycle:lifecycle-process:2.6.0-alpha01&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationObserver</span>: <span class="type">LifecycleEventObserver</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;ApplicationObserver&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span>(event)&#123;</span><br><span class="line">            Lifecycle.Event.ON_CREATE -&gt; Log.e(TAG, <span class="string">&quot;onStateChanged: ON_CREATE&quot;</span>, )</span><br><span class="line">            Lifecycle.Event.ON_START -&gt; Log.e(TAG, <span class="string">&quot;onStateChanged: ON_START&quot;</span>, )</span><br><span class="line">            Lifecycle.Event.ON_RESUME -&gt; Log.e(TAG, <span class="string">&quot;onStateChanged: ON_RESUME&quot;</span>, )</span><br><span class="line">            Lifecycle.Event.ON_PAUSE -&gt; Log.e(TAG, <span class="string">&quot;onStateChanged: ON_PAUSE&quot;</span>, )</span><br><span class="line">            Lifecycle.Event.ON_STOP -&gt; Log.e(TAG, <span class="string">&quot;onStateChanged: ON_STOP&quot;</span>, )</span><br><span class="line">            Lifecycle.Event.ON_DESTROY -&gt; Log.e(TAG, <span class="string">&quot;onStateChanged: ON_DESTROY&quot;</span>, )</span><br><span class="line">            Lifecycle.Event.ON_ANY -&gt; Log.e(TAG, <span class="string">&quot;onStateChanged: &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Application中使用</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplication</span> : <span class="type">Application</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line"></span><br><span class="line">        ProcessLifecycleOwner.<span class="keyword">get</span>().lifecycle.addObserver(ApplicationObserver())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景:"></a>应用场景:</h2><h3 id="应用启动广告"><a href="#应用启动广告" class="headerlink" title="应用启动广告"></a>应用启动广告</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdvertisingManage</span>: <span class="type">LifecycleEventObserver</span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;AdvertisingManage&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> advertisingManagerListener: AdvertisingManagerListener? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> countDownTimer: CountDownTimer? = <span class="keyword">object</span> : CountDownTimer(<span class="number">5000</span>,<span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTick</span><span class="params">(p0: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;广告剩余<span class="subst">$&#123;(p0 / <span class="number">1000</span>).toInt()&#125;</span>秒&quot;</span>  )</span><br><span class="line">            advertisingManagerListener?.timing((p0 / <span class="number">1000</span>).toInt())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFinish</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;广告结束,准备进入主界面&quot;</span> )</span><br><span class="line">            advertisingManagerListener?.enterMainActivity()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;开始计时&quot;</span> )</span><br><span class="line">        countDownTimer?.start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;停止计时&quot;</span>, )</span><br><span class="line">        countDownTimer?.cancel()</span><br><span class="line">        countDownTimer = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">AdvertisingManagerListener</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">timing</span><span class="params">(second: <span class="type">Int</span>)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">enterMainActivity</span><span class="params">()</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span>(event)&#123;</span><br><span class="line">            Lifecycle.Event.ON_CREATE -&gt; start()</span><br><span class="line">            Lifecycle.Event.ON_DESTROY -&gt; stop()</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdvertisingActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityAdvertisingBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityAdvertisingBinding.inflate(layoutInflater)</span><br><span class="line"></span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> advertisingManage = AdvertisingManage()</span><br><span class="line">        advertisingManage.advertisingManagerListener = <span class="keyword">object</span> : AdvertisingManage.AdvertisingManagerListener&#123;</span><br><span class="line">            <span class="meta">@SuppressLint(<span class="string">&quot;SetTextI18n&quot;</span>)</span></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">timing</span><span class="params">(second: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">                binding.textView.apply &#123;</span><br><span class="line">                    text = <span class="string">&quot;广告剩余<span class="subst">$&#123;second&#125;</span>秒&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enterMainActivity</span><span class="params">()</span></span> &#123;</span><br><span class="line">                startActivity(Intent(<span class="keyword">this</span><span class="symbol">@AdvertisingActivity</span>,MainActivity::<span class="keyword">class</span>.java))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        binding.button.apply &#123;</span><br><span class="line">            setOnClickListener&#123;</span><br><span class="line">                startActivity(Intent(<span class="keyword">this</span><span class="symbol">@AdvertisingActivity</span>,MainActivity::<span class="keyword">class</span>.java))</span><br><span class="line">                finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在Activity注册Oberver</span></span><br><span class="line">        lifecycle.addObserver(advertisingManage)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打造一个防止内存泄漏的Dialog"><a href="#打造一个防止内存泄漏的Dialog" class="headerlink" title="打造一个防止内存泄漏的Dialog"></a>打造一个防止内存泄漏的Dialog</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TipDialog</span>(context: Context) : Dialog(context),LifecycleObserver&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">is</span> ComponentActivity)&#123;</span><br><span class="line">            context.lifecycle.addObserver(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.dialog_tip)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShowing)&#123;</span><br><span class="line">            dismiss()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打造一个支持Lifecycle的MapView"><a href="#打造一个支持Lifecycle的MapView" class="headerlink" title="打造一个支持Lifecycle的MapView"></a>打造一个支持Lifecycle的MapView</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeoMapView</span>(context: Context, attrs: AttributeSet?) : FrameLayout(context, attrs),LifecycleEventObserver &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mapView: MapView? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        mapView = MapView(context)</span><br><span class="line">        addView(mapView)</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">is</span> ComponentActivity)&#123;</span><br><span class="line">            context.lifecycle.addObserver(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Timber.e(<span class="string">&quot;constructor method invoked&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取真正的mapView</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMapView</span><span class="params">()</span></span>: MapView? &#123;</span><br><span class="line">        <span class="keyword">return</span> mapView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span>(event.targetState)&#123;</span><br><span class="line">            Lifecycle.State.CREATED -&gt; onCreate(source)</span><br><span class="line">            Lifecycle.State.DESTROYED -&gt; onDestroy()</span><br><span class="line">            Lifecycle.State.RESUMED -&gt; onResume()</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Timber.e(<span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">        mapView?.dispose()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mapView?.resume()</span><br><span class="line">        Timber.e(<span class="string">&quot;onResume&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(source: <span class="type">LifecycleOwner</span>)</span></span>&#123;</span><br><span class="line">        Timber.e(<span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android自定义View-04 属性动画进阶</title>
      <link href="/posts/ddcdc262/"/>
      <url>/posts/ddcdc262/</url>
      
        <content type="html"><![CDATA[<h2 id="属性动画进阶"><a href="#属性动画进阶" class="headerlink" title="属性动画进阶"></a>属性动画进阶</h2><h3 id="4-1-PropertyValuesHolder与Keyframe"><a href="#4-1-PropertyValuesHolder与Keyframe" class="headerlink" title="4.1 PropertyValuesHolder与Keyframe"></a>4.1 PropertyValuesHolder与Keyframe</h3><h4 id="4-1-1-PropertyValuesHolder"><a href="#4-1-1-PropertyValuesHolder" class="headerlink" title="4.1.1 PropertyValuesHolder"></a>4.1.1 PropertyValuesHolder</h4><p>PropertyValuesHolder的含义就是，它其中保存了动画过程中所需要操作的属性和对应的值。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 自定义View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android自定义View-03 属性动画</title>
      <link href="/posts/f8577dac/"/>
      <url>/posts/f8577dac/</url>
      
        <content type="html"><![CDATA[<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p><em><strong>视图动画仅能对指定的控件做动画，而属性动画是通过改变空间的某一属性值来做动画的</strong></em></p><p>补间动画虽然能够对控件做动画，但是并没有改变控件内部的属性值。</p><h3 id="3-1简单实现"><a href="#3-1简单实现" class="headerlink" title="3.1简单实现"></a>3.1简单实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ValueAnimator</span> <span class="variable">valueAnimator</span> <span class="operator">=</span> ValueAnimator.ofInt(<span class="number">0</span>,<span class="number">400</span>);</span><br><span class="line">valueAnimator.setDuration(<span class="number">1000L</span>);</span><br><span class="line"><span class="comment">//添加监听事件</span></span><br><span class="line">valueAnimator.addUpdateListener(<span class="keyword">new</span> <span class="title class_">ValueAnimator</span>.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationUpdate</span><span class="params">(ValueAnimator animator)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curValue</span> <span class="operator">=</span> (<span class="type">int</span>) animator.getAnimatedValue();</span><br><span class="line">      <span class="comment">//通过更改控件left、top、right、bottom这四个点的坐标来更改坐标位置</span></span><br><span class="line">      <span class="comment">//textView将从屏幕左上角点(0，0)运行到点(400，400)</span></span><br><span class="line">        textView.layout(curValue,curValue,curValue + textView.getWidth(), curValue + textView.getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//设置重复次数，ValueAnimator.INFINITE 表示无限循环</span></span><br><span class="line">valueAnimator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line"><span class="comment">//设置重复模式 RESTART 和 REVERSE</span></span><br><span class="line">valueAnimator.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line"><span class="comment">//开始动画</span></span><br><span class="line">valueAnimator.start();</span><br></pre></td></tr></table></figure><h4 id="3-1-1-ofInt和ofFloat"><a href="#3-1-1-ofInt和ofFloat" class="headerlink" title="3.1.1 ofInt和ofFloat"></a>3.1.1 ofInt和ofFloat</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ValueAnimator <span class="title function_">ofInt</span><span class="params">(<span class="type">int</span>... values)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ValueAnimator <span class="title function_">ofFloat</span><span class="params">(<span class="type">float</span>... values)</span></span><br></pre></td></tr></table></figure><p>接受类型都是可变长参数，所以我们可以传入任何数量的值；传进去的值列表就表示动画时的变化范围，如ofInt(0,400,200)就表示从数字0变化到400再变化到数字200，我们传进去的数字越多，动画变化就越复杂。ofInt和ofFloat唯一的区别就是参数类型不一样。</p><h4 id="3-1-2-常用函数"><a href="#3-1-2-常用函数" class="headerlink" title="3.1.2 常用函数"></a>3.1.2 常用函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">getAnimatedValue</span><span class="params">()</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pause</span><span class="params">()</span> <span class="comment">//暂停</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resume</span><span class="params">()</span> <span class="comment">//恢复</span></span><br></pre></td></tr></table></figure><p><em><strong>注意:重复次数为INFINITE（无限循环）的动画，当Activity结束的时候，必须调用cancel()函数取消动画，否则动画将无限循环，从而导致View无法释放，进一步导致整个Activity无法释放，引起内存泄漏</strong></em></p><h4 id="3-1-3-添加与移除监听器"><a href="#3-1-3-添加与移除监听器" class="headerlink" title="3.1.3 添加与移除监听器"></a>3.1.3 添加与移除监听器</h4><p>1.添加监听器</p><p>在前面已经添加了一个监听器 addUpdateListener，以监听动画过程中值的实时变化，在ValueAnimator中共有三个监听器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听器一：监听动画过程中值的变化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUpdateListener</span><span class="params">(ValueAnimator.AnimatorUpdateListener listener)</span></span><br><span class="line"><span class="comment">//监听动画变化时的4个状态</span></span><br><span class="line">valueAnimator.addListener(<span class="keyword">new</span> <span class="title class_">Animator</span>.AnimatorListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationStart</span><span class="params">(Animator animator)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationEnd</span><span class="params">(Animator animator)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationCancel</span><span class="params">(Animator animator)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationRepeat</span><span class="params">(Animator animator)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//监听动画暂停/恢复 的状态</span></span><br><span class="line">valueAnimator.addPauseListener(<span class="keyword">new</span> <span class="title class_">Animator</span>.AnimatorPauseListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationPause</span><span class="params">(Animator animator)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationResume</span><span class="params">(Animator animator)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>2.移除监听器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removePauseListener</span><span class="params">(Animator.AnimatorPauseListener listener)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeUpdateListener</span><span class="params">(ValueAnimator.AnimatorUpdateListener listener)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeUpdateListener</span><span class="params">(ValueAnimator.AnimatorUpdateListener listener)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeAllListeners</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>这部分比较简单，就不详细描述了。</p><h3 id="3-2-示例：弹跳加载中效果"><a href="#3-2-示例：弹跳加载中效果" class="headerlink" title="3.2 示例：弹跳加载中效果"></a>3.2 示例：弹跳加载中效果</h3><h3 id="3-3-自定义插值器与Evaluator"><a href="#3-3-自定义插值器与Evaluator" class="headerlink" title="3.3 自定义插值器与Evaluator"></a>3.3 自定义插值器与Evaluator</h3><h4 id="3-3-2-示例：抛物动画"><a href="#3-3-2-示例：抛物动画" class="headerlink" title="3.3.2 示例：抛物动画"></a>3.3.2 示例：抛物动画</h4><h3 id="3-4-ObjectAnimator"><a href="#3-4-ObjectAnimator" class="headerlink" title="3.4 ObjectAnimator"></a>3.4 ObjectAnimator</h3><h4 id="3-4-1-简单示例"><a href="#3-4-1-简单示例" class="headerlink" title="3.4.1 简单示例"></a>3.4.1 简单示例</h4><p>下例代码实现了将TextView透明度从0到1的变化过程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">objectAnimator</span> <span class="operator">=</span> ObjectAnimator.ofFloat(textView,<span class="string">&quot;alpha&quot;</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>);</span><br><span class="line">objectAnimator.setDuration(<span class="number">2000L</span>);</span><br><span class="line">objectAnimator.setRepeatCount(ObjectAnimator.INFINITE);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ObjectAnimator <span class="title function_">ofFloat</span><span class="params">(Object target, String propertyName, <span class="type">float</span>... values)</span></span><br></pre></td></tr></table></figure><ul><li>第一个参数用于指定这个动画要操作的是哪个控件</li><li>第二个参数用于指定这个动画要操作这个控件的哪个属性。</li><li>第三个参数时可变长按书，是指这个属性值如何变化。</li></ul><p>我们来看看如何实现旋转效果.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">rotateAnimator</span> <span class="operator">=</span> ObjectAnimator.ofFloat(button,<span class="string">&quot;rotation&quot;</span>,<span class="number">0</span>,<span class="number">270</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="3-4-2-set函数"><a href="#3-4-2-set函数" class="headerlink" title="3.4.2 set函数"></a>3.4.2 set函数</h4><p>我们通过查看<code>TextView</code>的源代码可以发现，它和它的父类<code>View</code>都没有<code>rotation</code>这个属性，那么它是怎么改变这个值的呢？其实<code>ObjectAnimator</code>做动画，并不是根据控件XML的属性来改变的，而是通过指定属性对应的<code>set</code>函数来改变的。比如上面的<code>rotation</code>属性值，<code>ObjectAnimator</code>在动画时就会到指定控件中去找对应的<code>setRotation()</code>函数来改变控件中对应的值。在View中，有关动画共有下面几组set函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.透明度 alpha</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAlpha</span><span class="params">(<span class="type">float</span> alpha)</span></span><br><span class="line"><span class="comment">//旋转度数: rotation、rotationX、rotationY</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRotation</span><span class="params">(<span class="type">float</span> rotation)</span>  <span class="comment">//围绕Z轴旋转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRotationY</span><span class="params">(<span class="type">float</span> rotationY)</span><span class="comment">//围绕Y轴旋转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRotationX</span><span class="params">(<span class="type">float</span> rotationX)</span><span class="comment">//围绕X轴旋转</span></span><br><span class="line"><span class="comment">//平移： translationX、translationY</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTranslationX</span><span class="params">(<span class="type">float</span> translationX)</span> <span class="comment">// X轴平移</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTranslationY</span><span class="params">(<span class="type">float</span> translationY)</span><span class="comment">//Y轴平移</span></span><br><span class="line"><span class="comment">//缩放： scaleX、scaleY</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScaleX</span><span class="params">(<span class="type">float</span> scaleX)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScaleY</span><span class="params">(<span class="type">float</span> scaleY)</span></span><br></pre></td></tr></table></figure><h4 id="3-4-3-自定义ObjectAnimator属性"><a href="#3-4-3-自定义ObjectAnimator属性" class="headerlink" title="3.4.3  自定义ObjectAnimator属性"></a>3.4.3  自定义ObjectAnimator属性</h4><p>同样实现小球抛物线效果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ObjectAnimator <span class="title function_">ofObject</span><span class="params">(Object target, String propertyName, TypeEvaluator evaluator, Object... values)</span> </span><br></pre></td></tr></table></figure><p>观察 ObjectAnimator的ofObject生成方法，需要实现自定义的TypeEvaluator，以及自定义propertyName属性</p><p>1.自定义ImageView</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FallingBallImageView</span> <span class="keyword">extends</span> <span class="title class_">androidx</span>.appcompat.widget.AppCompatImageView &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FallingBallImageView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFallingPos</span><span class="params">(Point point)</span>&#123;</span><br><span class="line">        layout(point.x,point.y , getWidth() + point.x, + getHeight() + point.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，只有一个<code>set</code>函数。注意点</p><ul><li>这个set函数对应的属性应该是<code>fallingPos</code>或者<code>FallingPos</code></li><li>在<code>setFallingPos()</code>函数中，参数类型时Point对象，所以我们在狗仔ObjectAnimator时，必须使用ofObject()函数。</li></ul><p>2:布局代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.carl.demo.customobjectanimator.FallingBallImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/image&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">&quot;@drawable/shape_circle&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>shape_circle.xml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;shape xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:shape=<span class="string">&quot;oval&quot;</span>&gt;</span><br><span class="line">    &lt;solid android:color=<span class="string">&quot;#FF4949&quot;</span>/&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure><p>3: 自定义TypeEvaluator</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FallingBallEvaluator</span> <span class="keyword">implements</span> <span class="title class_">TypeEvaluator</span>&lt;Point&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">evaluate</span><span class="params">(<span class="type">float</span> fraction, Point startValue, Point endValue)</span> &#123;</span><br><span class="line">        point.x = (<span class="type">int</span>) (startValue.x + fraction *(endValue.x - startValue.x));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fraction * <span class="number">2</span> &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            point.y = (<span class="type">int</span>)(startValue.y + fraction * <span class="number">2</span>*(endValue.y - startValue.y));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            point.y = endValue.y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">objectAnimator</span> <span class="operator">=</span> ObjectAnimator.ofObject(</span><br><span class="line">        ball,<span class="string">&quot;fallingPos&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FallingBallEvaluator</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">500</span>,<span class="number">500</span>));</span><br><span class="line">objectAnimator.setDuration(<span class="number">2000L</span>);</span><br><span class="line">objectAnimator.start();</span><br></pre></td></tr></table></figure><p>整体过程时：当点击按钮时开始动画， ObjectAnimator.ofObject() 函数会根据 FallingBallEvaluator 实时得到当前的 Point 值；然后到 ball_imageView 控件中去找 setFallingPos(Point point) 函数，它的参数就是 FallingBallEvaluator 返回的 Point 对象 ；在找到 setFallingPos(Point point) 函数后，通过反射调用他。在 setFallingPos(Point point)函数中，我们会根据参数值实时改变圆形的位置。</p><h3 id="3-5-组合动画"><a href="#3-5-组合动画" class="headerlink" title="3.5 组合动画"></a>3.5 组合动画</h3><h4 id="3-5-1-playSequentially-与playTogether-函数"><a href="#3-5-1-playSequentially-与playTogether-函数" class="headerlink" title="3.5.1 playSequentially()与playTogether()函数"></a>3.5.1 playSequentially()与playTogether()函数</h4><ul><li>playSequentially() 表示动画依次播放</li></ul><p>函数声明:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playSequentially</span><span class="params">(Animator... items)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playSequentially</span><span class="params">(List&lt;Animator&gt; items)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">ObjectAnimator</span> <span class="variable">colorAnimator</span> <span class="operator">=</span> ObjectAnimator.ofInt(textView1,<span class="string">&quot;BackgroundColor&quot;</span>,</span><br><span class="line">        getColor(R.color.color1),getColor(R.color.color2),getColor(R.color.color3));</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">translateAnimator</span> <span class="operator">=</span> ObjectAnimator.ofFloat(textView1,<span class="string">&quot;translationY&quot;</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">400</span>,<span class="number">0</span>)；</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">translateAnimator2</span> <span class="operator">=</span> ObjectAnimator.ofFloat(textView2,<span class="string">&quot;translationY&quot;</span>,<span class="number">0</span>,<span class="number">400</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">AnimatorSet</span> <span class="variable">animatorSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimatorSet</span>();</span><br><span class="line">animatorSet.setDuration(<span class="number">2000L</span>);</span><br><span class="line">animatorSet.playSequentially(colorAnimator,translateAnimator,translateAnimator2);</span><br><span class="line">animatorSet.start();</span><br></pre></td></tr></table></figure><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://raw.githubusercontent.com/winstone-su/imageHosting/main/img/playSequentially_anim.png" alt="布局"></p><ul><li>playTogether() 表示动画一起播放</li></ul><p>函数声明:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playTogether</span><span class="params">(Animator... items)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playTogether</span><span class="params">(Collection&lt;Animator&gt; items)</span></span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">colorAnimator</span> <span class="operator">=</span> ObjectAnimator.ofInt(textView1,<span class="string">&quot;BackgroundColor&quot;</span>,</span><br><span class="line">        getColor(R.color.color1),getColor(R.color.color2),getColor(R.color.color3));</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">translateAnimator</span> <span class="operator">=</span> ObjectAnimator.ofFloat(textView1,<span class="string">&quot;translationY&quot;</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">400</span>,<span class="number">0</span>);</span><br><span class="line">translateAnimator.setStartDelay(<span class="number">2000L</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">translateAnimator2</span> <span class="operator">=</span> ObjectAnimator.ofFloat(textView2,<span class="string">&quot;translationY&quot;</span>,<span class="number">0</span>,<span class="number">400</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">AnimatorSet</span> <span class="variable">animatorSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimatorSet</span>();</span><br><span class="line">animatorSet.setDuration(<span class="number">2000L</span>);</span><br><span class="line">animatorSet.playTogether(colorAnimator,translateAnimator,translateAnimator2);</span><br><span class="line">animatorSet.start();</span><br></pre></td></tr></table></figure><p>上述代码中： 在textView1 和textView2 平移动画上加了一个延时，所以在textView1颜色变化结束后，textview1和textview2会一起移动</p><h4 id="3-5-2-如何实现无限循环的组合动画"><a href="#3-5-2-如何实现无限循环的组合动画" class="headerlink" title="3.5.2 如何实现无限循环的组合动画"></a>3.5.2 如何实现无限循环的组合动画</h4><p>是否无限循环主要看动画本身，与playTogether()无关。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">colorAnimator</span> <span class="operator">=</span> ObjectAnimator.ofInt(textView1,<span class="string">&quot;BackgroundColor&quot;</span>,</span><br><span class="line">                getColor(R.color.color1),getColor(R.color.color2),getColor(R.color.color3));</span><br><span class="line">colorAnimator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">translateAnimator</span> <span class="operator">=</span> ObjectAnimator.ofFloat(textView1,<span class="string">&quot;translationY&quot;</span>,<span class="number">0</span>,<span class="number">400</span>,<span class="number">0</span>);</span><br><span class="line">translateAnimator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">translateAnimator2</span> <span class="operator">=</span> ObjectAnimator.ofFloat(textView2,<span class="string">&quot;translationY&quot;</span>,<span class="number">0</span>,<span class="number">400</span>,<span class="number">0</span>);</span><br><span class="line">translateAnimator2.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="3-5-3-AnimatorSet-Builder"><a href="#3-5-3-AnimatorSet-Builder" class="headerlink" title="3.5.3 AnimatorSet.Builder"></a>3.5.3 AnimatorSet.Builder</h4>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 自定义View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android自定义View-02 视图动画</title>
      <link href="/posts/d2fda48f/"/>
      <url>/posts/d2fda48f/</url>
      
        <content type="html"><![CDATA[<h2 id="动画类型"><a href="#动画类型" class="headerlink" title="动画类型"></a>动画类型</h2><h3 id="View-Animation-视图动画"><a href="#View-Animation-视图动画" class="headerlink" title="View Animation(视图动画)"></a>View Animation(视图动画)</h3><ul><li>Tween Animation(补间动画)</li><li>Frame Animation(逐帧动画)</li></ul><h3 id="Property-Animation-属性动画"><a href="#Property-Animation-属性动画" class="headerlink" title="Property Animation(属性动画)"></a>Property Animation(属性动画)</h3><ul><li>ValueAnimator</li><li>ObjectAnimator</li></ul><h2 id="一-视图动画标签"><a href="#一-视图动画标签" class="headerlink" title="一. 视图动画标签"></a>一. 视图动画标签</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>Android动画由5种类型组成：alpha、scale、translate、rotate、set</p><h3 id="1-1配置XML动画文件"><a href="#1-1配置XML动画文件" class="headerlink" title="1.1配置XML动画文件"></a>1.1配置XML动画文件</h3><p>常用标签：</p><ul><li>alpha：渐变透明度动画</li><li>scale：渐变尺寸伸缩动画</li><li>translate：画面变换位置移动动画</li><li>rotate：画面转移旋转动画</li><li>set：定义动画集</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scale</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromXScale</span>=<span class="string">&quot;0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toXScale</span>=<span class="string">&quot;1.4&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromYScale</span>=<span class="string">&quot;0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toYScale</span>=<span class="string">&quot;1.4&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span> = <span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scale</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-动画文件存放位置"><a href="#1-2-动画文件存放位置" class="headerlink" title="1.2 动画文件存放位置"></a>1.2 动画文件存放位置</h3><p>动画文件应该放于<code>res/anim</code>文件夹下，访问时使用<code>R.anim.XXX</code></p><h3 id="1-3-使用动画文件"><a href="#1-3-使用动画文件" class="headerlink" title="1.3 使用动画文件"></a>1.3 使用动画文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animation</span> <span class="variable">animation</span> <span class="operator">=</span> AnimationUtils.loadAnimation(MainActivity.<span class="built_in">this</span>,R.anim.scale_down_anim);</span><br><span class="line">textView.startAnimation(animation);</span><br><span class="line"><span class="comment">//textView.clearAnimation();</span></span><br></pre></td></tr></table></figure><p>动画开始时，会将TextView的高度、宽度都从0缩放到1.4倍大小</p><h3 id="1-4-scale标签"><a href="#1-4-scale标签" class="headerlink" title="1.4 scale标签"></a>1.4 scale标签</h3><p><code>scale</code>标签用于缩放动画，该标签有如下几个属性</p><ul><li><code>android:fromXScale</code>：动画起始时，控件在X轴方向相对自身的缩放比例，浮点值，比如，1.0代表自身无变化，0.5代表缩放1倍，2.0代表放大1倍</li><li><code>android:toXScale</code>：动画结束时，控件在X轴相对自身的缩放比例，浮点值。</li><li><code>android:fromYScale</code>：动画起始时，控件在Y轴方向相对自身的缩放比例，浮点值。</li><li><code>android:toYScale</code>：动画结束时，控件在Y轴方向相对自身的缩放比例，浮点值。</li><li><code>android:pivotX</code>：缩放起始点X轴坐标，可以是数值、百分数、百分数p 三种样式，如50、50% 、50%p 。如果是数值， 表示在当前视图的左上角 ，即原点处加 50px，作为缩放起始点X轴坐标；如果是 50% 则表示在当前控件的左上角加上自己宽度的50%作为缩放起点X轴坐标；如果是50%p，则表示在当前父控件的左上角加上父控件宽度的50%作为缩放起始点X轴坐标。</li><li><code>android:pivotY</code>：缩放起始点X轴坐标，取值及含义与 android:pivotX相同。</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scale</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromXScale</span>=<span class="string">&quot;0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toXScale</span>=<span class="string">&quot;1.4&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromYScale</span>=<span class="string">&quot;0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toYScale</span>=<span class="string">&quot;1.4&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillAfter</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;2000&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-Animation继承属性"><a href="#1-5-Animation继承属性" class="headerlink" title="1.5 Animation继承属性"></a>1.5 Animation继承属性</h3><p>所有的动画都继承<code>Animation</code>类</p><p>以 <code>scale</code>标签为例，讲述<code>Animation</code>类所具有的属性及其含义</p><ul><li><code>android:duration</code>：用于设置一次动画的持续时间，以毫秒为单位。</li><li><code>android:fillAfter</code>：如果设置为 true，则控件动画结束时，将保持动画结束时的状态。</li><li><code>android:fillBefore</code>：如果设置为 true，则控件动画结束时，将还原到初始化状态。</li><li><code>android fil!Enabed</code>：与android:fillBefore 效果相同，都是在控件动画结束时，将还原到初始化状态。</li><li><code>android:repeatCount</code>：用于指定动画的重复次数，当取值为<code>infinite</code> 时， 表示无限循环。</li><li><code>android:repeatMode</code>：用于设定重复的类型，有 reverse和restart两个值，其中reverse表示倒序回放： restart 表示重放，并且必须与- repeatCount 一起使用才能看到效果。</li><li><code>android:interpolator</code>：用于设定插值器，其实就是指定的动画效果，比如弹跳效果等。</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:fillAfter</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scale</span> <span class="attr">android:fromXScale</span>=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXScale</span>=<span class="string">&quot;0.4&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromYScale</span>=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toYScale</span>=<span class="string">&quot;0.6&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:repeatMode</span>=<span class="string">&quot;reverse&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:repeatCount</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">&quot;700&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-6-alpha标签"><a href="#1-6-alpha标签" class="headerlink" title="1.6 alpha标签"></a>1.6 alpha标签</h3><p>标签属性:</p><ul><li>android:fromAlpha: 动画开始时的透明度，取值范围为 0~ 1 .0, 0.0表示全透明， 1.0表示完全不透明。</li><li>android:toAlpha： 动画结束时的透明度</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;3000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillBefore</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alpha</span> <span class="attr">android:fromAlpha</span>=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toAlpha</span>=<span class="string">&quot;0.1&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-7-rotate标签"><a href="#1-7-rotate标签" class="headerlink" title="1.7 rotate标签"></a>1.7 rotate标签</h3><p><code>rotate</code>标签用于实现画面转移旋转动画效果，标签属性:</p><ul><li><code>android:fromDegress</code>：动画开始旋转时的角度位置，正值代表顺时针方向的度数，负值代表逆时针方向的度数</li><li><code>android:toDegress</code>：动画结束时旋转到的角度位 ，正值代表顺时针方向的度数，负值代表逆时针方向的度数</li><li><code>android:pivotX：</code>旋转中心点X轴坐标，默认旋转中心点是控件坐标原点。        可以是数值、百分数、 百分数p 三 种样式，比如 50 50% 50%p ，具体含义己在 scale 标签中讲述。</li><li><code>android:pivotY</code>：旋转中心点Y轴坐标。</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;6000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toDegrees</span>=<span class="string">&quot;1080&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    android:repeatCount=&quot;infinite&quot;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    android:repeatMode=&quot;restart&quot;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    以中心点顺时针旋转3圈--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-8-translate标签"><a href="#1-8-translate标签" class="headerlink" title="1.8 translate标签"></a>1.8 translate标签</h3><p><code>translate</code>标签用于实现画面变换位置移动动画效果。属性：</p><ul><li><code>android:fromXDelta</code>:起始点X轴坐标，可以是是数值、百分数、百分数p 三种样式。</li><li><code>android:fromYDelta</code>:起始点Y轴坐标</li><li><code>android:toXDelta</code>:终点X轴坐标</li><li><code>android:toYDelta</code>:终点Y轴坐标</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillAfter</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--控件从点(0,0)移动到(-80,-80)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">&quot;2000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXDelta</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromYDelta</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXDelta</span>=<span class="string">&quot;-80&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toYDelta</span>=<span class="string">&quot;-80&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-9-set标签"><a href="#1-9-set标签" class="headerlink" title="1.9 set标签"></a>1.9 set标签</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;3000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillAfter</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alpha</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromAlpha</span>=<span class="string">&quot;0.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toAlpha</span>=<span class="string">&quot;1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scale</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXScale</span>=<span class="string">&quot;0.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromYScale</span>=<span class="string">&quot;0.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXScale</span>=<span class="string">&quot;1.4&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toYScale</span>=<span class="string">&quot;1.4&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rotate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toDegrees</span>=<span class="string">&quot;720&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>控件完成了从小到大，旋转出场，透明度从0到1的组合效果。</p><p><em><strong>注意：在 set 标签中设直 repeateCount 属性是无效的，必须对每个动画单独设直才有作用</strong></em></p><h2 id="二、视图动画的代码实现"><a href="#二、视图动画的代码实现" class="headerlink" title="二、视图动画的代码实现"></a>二、视图动画的代码实现</h2><p>标签与所对应的类如下所示</p><table><thead><tr><th>scale</th><th>ScaleAnimation</th></tr></thead><tbody><tr><td>alpha</td><td>AlphaAnimation</td></tr><tr><td>rotate</td><td>RotateAnimation</td></tr><tr><td>translate</td><td>TranslateAnimation</td></tr><tr><td>set</td><td>AnimationSet</td></tr></tbody></table><h3 id="2-1-ScaleAnimation"><a href="#2-1-ScaleAnimation" class="headerlink" title="2.1 ScaleAnimation"></a>2.1 ScaleAnimation</h3><p>与1.4节XML对应的代码是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animation</span> <span class="variable">scaleAnimation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScaleAnimation</span>(</span><br><span class="line">           <span class="number">0</span>,<span class="number">1.4f</span>,<span class="number">0</span>,<span class="number">1.4f</span>,</span><br><span class="line">           Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>,</span><br><span class="line">           Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>);</span><br><span class="line">scaleAnimation.setDuration(<span class="number">2000</span>);</span><br><span class="line">scaleAnimation.setFillAfter(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-AlphaAnimation"><a href="#2-2-AlphaAnimation" class="headerlink" title="2.2 AlphaAnimation"></a>2.2 AlphaAnimation</h3><p>与1.6节对应的代码是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animation</span> <span class="variable">alphaAnimation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlphaAnimation</span>(<span class="number">0.0f</span>,<span class="number">1.0f</span>);</span><br><span class="line">alphaAnimation.setDuration(<span class="number">3000</span>);</span><br><span class="line">alphaAnimation.setFillBefore(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="2-3-RotateAnimation"><a href="#2-3-RotateAnimation" class="headerlink" title="2.3 RotateAnimation"></a>2.3 RotateAnimation</h3><p>与1.7节对应的代码是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animation</span> <span class="variable">rotateAnimation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RotateAnimation</span>(<span class="number">0</span>,<span class="number">1080</span>,</span><br><span class="line">                Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>,Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>);</span><br><span class="line">rotateAnimation.setDuration(<span class="number">6000</span>);</span><br></pre></td></tr></table></figure><h3 id="2-4-TranslateAnimation"><a href="#2-4-TranslateAnimation" class="headerlink" title="2.4 TranslateAnimation"></a>2.4 TranslateAnimation</h3><p>与1.8节对应的代码是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animation</span> <span class="variable">translateAnimation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TranslateAnimation</span>(<span class="number">0</span>,-<span class="number">80</span>,<span class="number">0</span>,-<span class="number">80</span>);</span><br><span class="line">translateAnimation.setDuration(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><h3 id="2-5-AnimationSet"><a href="#2-5-AnimationSet" class="headerlink" title="2.5 AnimationSet"></a>2.5 AnimationSet</h3><p>与1.9对应的代码是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建AnimationSet对象</span></span><br><span class="line"><span class="type">AnimationSet</span> <span class="variable">animationSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimationSet</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//创建动画对象</span></span><br><span class="line"><span class="type">Animation</span> <span class="variable">alphaAnimation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlphaAnimation</span>(<span class="number">0.0f</span>,<span class="number">1.0f</span>);</span><br><span class="line"><span class="type">Animation</span> <span class="variable">scaleAnimation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScaleAnimation</span>(<span class="number">0.0f</span>,<span class="number">1.4f</span>,<span class="number">0.0f</span>,<span class="number">1.4f</span>,</span><br><span class="line">          Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>,</span><br><span class="line">          Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>);</span><br><span class="line"><span class="type">Animation</span> <span class="variable">rotateAnimation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RotateAnimation</span>(<span class="number">0</span>,<span class="number">720</span>,</span><br><span class="line">          Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>,</span><br><span class="line">          Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>);</span><br><span class="line"><span class="comment">//添加动画到AnimationSet</span></span><br><span class="line">animationSet.addAnimation(alphaAnimation);</span><br><span class="line">animationSet.addAnimation(scaleAnimation);</span><br><span class="line">animationSet.addAnimation(rotateAnimation);</span><br><span class="line"><span class="comment">//设置属性</span></span><br><span class="line">animationSet.setDuration(<span class="number">3000</span>);</span><br><span class="line">animationSet.setFillAfter(<span class="literal">true</span>);</span><br><span class="line">binding.textView.startAnimation(animationSet);</span><br></pre></td></tr></table></figure><h3 id="2-7-Animation"><a href="#2-7-Animation" class="headerlink" title="2.7 Animation"></a>2.7 Animation</h3><p>其他函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> <span class="comment">//取消动画</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span>  <span class="comment">//将控件重置到动画开始前状态</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setAnimationListener</span><span class="params">(Animation.AnimationListener listener)</span> <span class="comment">//设置动画监听</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">animationSet.setAnimationListener(<span class="keyword">new</span> <span class="title class_">Animation</span>.AnimationListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationStart</span><span class="params">(Animation animation)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationEnd</span><span class="params">(Animation animation)</span> &#123;</span><br><span class="line">                animationSet.reset();</span><br><span class="line">                showTranslateAnimation(); <span class="comment">//展示移动动画 2.4节</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationRepeat</span><span class="params">(Animation animation)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h2 id="三、-插值器"><a href="#三、-插值器" class="headerlink" title="三、 插值器"></a>三、 插值器</h2><p>插值器是在 XML 中定义的动画修改器，它会影响动画的变化率。插值器可对现有的动画效果执行加速、减速、重复、退回等。</p><p>插值器通过 <code>android:interpolator</code> 属性应用于动画元素，该属性的值是对插值器资源的引用。</p><p>Android 中提供的所有插值器都是 <code>Interpolator</code> 类的子类。为便于您使用 <code>android:interpolator</code> 属性将插值器应用于动画，Android 针对每个插值器类包含了一个可供您引用的公共资源。下表指定了每个插值器要使用的资源：</p><table><thead><tr><th>插值器类</th><th>资源 ID</th></tr></thead><tbody><tr><td><a href="https://developer.android.com/reference/android/view/animation/AccelerateDecelerateInterpolator?hl=zh-cn">AccelerateDecelerateInterpolator</a></td><td>@android:anim&#x2F;accelerate_decelerate_interpolator</td></tr><tr><td><a href="https://developer.android.com/reference/android/view/animation/AccelerateInterpolator?hl=zh-cn">AccelerateInterpolator</a></td><td>@android:anim&#x2F;accelerate_interpolator</td></tr><tr><td><a href="https://developer.android.com/reference/android/view/animation/AnticipateInterpolator?hl=zh-cn">AnticipateInterpolator</a></td><td>@android:anim&#x2F;anticipate_interpolator</td></tr><tr><td><a href="https://developer.android.com/reference/android/view/animation/AnticipateOvershootInterpolator?hl=zh-cn">AnticipateOvershootInterpolator</a></td><td>@android:anim&#x2F;anticipate_overshoot_interpolator</td></tr><tr><td><a href="https://developer.android.com/reference/android/view/animation/BounceInterpolator?hl=zh-cn">BounceInterpolator</a></td><td>@android:anim&#x2F;bounce_interpolator</td></tr><tr><td><a href="https://developer.android.com/reference/android/view/animation/CycleInterpolator?hl=zh-cn">CycleInterpolator</a></td><td>@android:anim&#x2F;cycle_interpolator</td></tr><tr><td><a href="https://developer.android.com/reference/android/view/animation/DecelerateInterpolator?hl=zh-cn">DecelerateInterpolator</a></td><td>@android:anim&#x2F;decelerate_interpolator</td></tr><tr><td><a href="https://developer.android.com/reference/android/view/animation/LinearInterpolator?hl=zh-cn">LinearInterpolator</a></td><td>@android:anim&#x2F;linear_interpolator</td></tr><tr><td><a href="https://developer.android.com/reference/android/view/animation/OvershootInterpolator?hl=zh-cn">OvershootInterpolator</a></td><td>@android:anim&#x2F;overshoot_interpolator</td></tr></tbody></table><p>您可以通过以下方式使用 <code>android:interpolator</code> 属性应用上述某个插值器：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">android:interpolator</span>=<span class="string">&quot;@android:anim/accelerate_interpolator&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自定义插值器"><a href="#自定义插值器" class="headerlink" title="自定义插值器"></a>自定义插值器</h3><p>如果您对平台提供的插值器（在上表中列出）不满意，则可以使用修改过的属性创建自定义插值器资源。例如，您可以调整 <code>AnticipateInterpolator</code> 的加速率或调整 <code>CycleInterpolator</code> 的循环次数。为此，您需要在 XML 文件中创建自己的插值器资源。</p><p>文件位置：</p><p><code>res/anim/*filename*.xml</code><br>该文件名将用作资源 ID。</p><p>编译后的资源数据类型：</p><p>指向相应插值器对象的资源指针。</p><p>资源引用：</p><p>在 XML 中：<code>@[*package*:]anim/*filename*</code></p><p>语法：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">InterpolatorName</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:attribute_name</span>=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><p>如果您不应用任何属性，则您的插值器的运作方式将与平台提供的插值器（在上表中列出）完全相同。</p><p>元素：</p><p>请注意，在 XML 中定义的每个 <code>Interpolator</code> 实现的名称都以小写字母开头。</p><ul><li><p><code>&lt;accelerateDecelerateInterpolator&gt;</code></p><p>变化率在开始和结束时缓慢，但在中间会加快。无属性。</p></li><li><p><code>&lt;accelerateInterpolator&gt;</code></p><p>变化率在开始时较为缓慢，然后会加快。属性：<code>android:factor</code>浮点数。加速率（默认为 1）。</p></li><li><p><code>&lt;anticipateInterpolator&gt;</code></p><p>先反向变化，然后再急速正向变化。属性：<code>android:tension</code>浮点数。要应用的张力（默认为 2）。</p></li><li><p><code>&lt;anticipateOvershootInterpolator&gt;</code></p><p>先反向变化，再急速正向变化并超过目标值，然后以最终值结束。属性：<code>android:tension</code>浮点数。要应用的张力（默认为 2）。<code>android:extraTension</code>浮点数。张力要乘以的倍数（默认值为 1.5）。</p></li><li><p><code>&lt;bounceInterpolator&gt;</code></p><p>变化会在结束时退回。无属性。</p></li><li><p><code>&lt;cycleInterpolator&gt;</code></p><p>按指定的循环次数重复动画。变化率符合正弦曲线图。属性：<code>android:cycles</code>整数。循环次数（默认值为 1）。</p></li><li><p><code>&lt;decelerateInterpolator&gt;</code></p><p>变化率开始时很快，然后减慢。属性：<code>android:factor</code>浮点数。减速率（默认值为 1）。</p></li><li><p><code>&lt;linearInterpolator&gt;</code></p><p>变化率恒定不变。无属性。</p></li><li><p><code>&lt;overshootInterpolator&gt;</code></p><p>先急速正向变化，再超过最终值，然后回到最终值。属性：<code>android:tension</code>浮点数。要应用的张力（默认为 2）。</p></li></ul><p>示例：</p><p>保存在 <code>res/anim/my_overshoot_interpolator.xml</code> 的 XML 文件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">overshootInterpolator</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tension</span>=<span class="string">&quot;7.0&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><p>此动画 XML 将应用插值器：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scale</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">&quot;@anim/my_overshoot_interpolator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromXScale</span>=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toXScale</span>=<span class="string">&quot;3.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromYScale</span>=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toYScale</span>=<span class="string">&quot;3.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;700&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、动画示例"><a href="#四、动画示例" class="headerlink" title="四、动画示例"></a>四、动画示例</h2><h3 id="4-1-镜头由远及近效果"><a href="#4-1-镜头由远及近效果" class="headerlink" title="4.1 镜头由远及近效果"></a>4.1 镜头由远及近效果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScaleAnimation</span> <span class="variable">scaleAnimation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScaleAnimation</span>(<span class="number">1f</span>,<span class="number">1.1f</span>,<span class="number">1f</span>,<span class="number">1.1f</span>,</span><br><span class="line">Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>,Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>);</span><br><span class="line">scaleAnimation.setDuration(<span class="number">3</span>*<span class="number">1000L</span>);</span><br><span class="line">scaleAnimation.setFillAfter(<span class="literal">true</span>);</span><br><span class="line">binding.imageView.setAnimation(scaleAnimation);</span><br><span class="line"></span><br><span class="line"><span class="type">AlphaAnimation</span> <span class="variable">alphaAnimation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlphaAnimation</span>(<span class="number">0.5f</span>,<span class="number">1.0f</span>);</span><br><span class="line">alphaAnimation.setDuration(<span class="number">3</span> * <span class="number">1000L</span>);</span><br><span class="line">alphaAnimation.setFillAfter(<span class="literal">true</span>);</span><br><span class="line">binding.ivSlogan.setAnimation(alphaAnimation);</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.SplashActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/bg_splash&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:contentDescription</span>=<span class="string">&quot;@string/app_name&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/slogan_bottom&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;44dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/slogan_txt&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/white&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;18sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/slogan_top&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/slogan_top_text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/white&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;18sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/slogan_bottom&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/ivSlogan&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;80dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:srcCompat</span>=<span class="string">&quot;@drawable/ic_logo_slogan&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>动画效果</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/28/eVJMkoiKzYaPqSN.gif" alt="动画效果"></p><h3 id="4-2-Loading动画效果"><a href="#4-2-Loading动画效果" class="headerlink" title="4.2 Loading动画效果"></a>4.2 Loading动画效果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RotateAnimation</span> <span class="variable">rotateAnimation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RotateAnimation</span>(<span class="number">0</span>,<span class="number">360f</span>,</span><br><span class="line">        Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>,Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>);</span><br><span class="line">rotateAnimation.setDuration(<span class="number">1500</span>);</span><br><span class="line">rotateAnimation.setRepeatCount(-<span class="number">1</span>);</span><br><span class="line">rotateAnimation.setRepeatMode(Animation.RESTART);</span><br><span class="line">rotateAnimation.setInterpolator(<span class="keyword">new</span> <span class="title class_">LinearInterpolator</span>());</span><br></pre></td></tr></table></figure><h3 id="4-3-扫描动画"><a href="#4-3-扫描动画" class="headerlink" title="4.3 扫描动画"></a>4.3 扫描动画</h3><p>动画文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;3000&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scale</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXScale</span>=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromYScale</span>=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:repeatCount</span>=<span class="string">&quot;infinite&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXScale</span>=<span class="string">&quot;3.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toYScale</span>=<span class="string">&quot;3.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alpha</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromAlpha</span>=<span class="string">&quot;0.4&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:repeatCount</span>=<span class="string">&quot;infinite&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toAlpha</span>=<span class="string">&quot;0.0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animation</span> <span class="variable">animationSet1</span> <span class="operator">=</span> getScanAnimation();</span><br><span class="line"><span class="type">Animation</span> <span class="variable">animationSet2</span> <span class="operator">=</span> getScanAnimation();</span><br><span class="line">animationSet2.setStartOffset(<span class="number">750</span>);</span><br><span class="line"><span class="type">Animation</span> <span class="variable">animationSet3</span> <span class="operator">=</span> getScanAnimation();</span><br><span class="line">animationSet3.setStartOffset(<span class="number">1500</span>);</span><br><span class="line"><span class="type">Animation</span> <span class="variable">animationSet4</span> <span class="operator">=</span> getScanAnimation();</span><br><span class="line">animationSet4.setStartOffset(<span class="number">2250</span>);</span><br><span class="line"></span><br><span class="line">binding.startScan.setOnClickListener(view -&gt; &#123;</span><br><span class="line">    binding.circle1.startAnimation(animationSet1);</span><br><span class="line">    binding.circle2.startAnimation(animationSet2);</span><br><span class="line">    binding.circle3.startAnimation(animationSet3);</span><br><span class="line">    binding.circle4.startAnimation(animationSet4);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Animation <span class="title function_">getScanAnimation</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AnimationUtils.loadAnimation(<span class="built_in">this</span>,R.anim.scan_anim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、逐帧动画"><a href="#五、逐帧动画" class="headerlink" title="五、逐帧动画"></a>五、逐帧动画</h2><p>示例：</p><p>在<code>res/Drawable</code>文件下新建动画文件:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/a1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">&quot;80&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/a2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">&quot;80&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/a3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">&quot;80&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在代码中使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AnimationDrawable</span> <span class="variable">animationDrawable</span> <span class="operator">=</span> (AnimationDrawable) imageView.getBackground();</span><br><span class="line">animationDrawable.start();</span><br></pre></td></tr></table></figure><p><strong>android:oneshot 如果是false，表示无限循环，true表示只展示一次</strong></p><h3 id="5-1-AnimationDrawable类"><a href="#5-1-AnimationDrawable类" class="headerlink" title="5.1 AnimationDrawable类"></a>5.1 AnimationDrawable类</h3><p>在Android中，逐帧动画需要得到AnimationDrawable类的支持，它位于<code>android.graphics.drawable</code>包下，是<code>Drawable</code>的间接子类。它主要用来创建一个逐帧动画，并且可以对帧进行拉伸，把它设置为View的背景。</p><p>AnimationDrawable的常用函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="comment">//开始播放逐帧动画</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> <span class="comment">//停止播放逐帧动画</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getDuration</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//得到指定index帧的持续时间</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getNumberOfFrames</span><span class="params">()</span> <span class="comment">//得到当前AnimationDrawable所有的帧的数量</span></span><br><span class="line">Drawable <span class="title function_">getFrame</span><span class="params">(<span class="type">int</span> index)</span> <span class="comment">//得到指定index的帧对应的Drawable对象</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">()</span><span class="comment">//判断当前AnimationDrawable是否正在播放</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setOneShot</span><span class="params">(<span class="type">boolean</span> oneShot)</span> <span class="comment">//设置AnimationDrawable是否执行一次，返回true，表示执行一次，返回false，表示无限循环</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isOneShot</span><span class="params">()</span><span class="comment">//判断AnimationDrawable是否执行一次，返回true，表示执行一次，返回false，表示无限循环</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addFrame</span><span class="params">(<span class="meta">@NonNull</span> Drawable frame, <span class="type">int</span> duration)</span> <span class="comment">//为AnimationDrawable添加一帧，并设置持续时间</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 自定义View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android自定义View-01 绘图基础</title>
      <link href="/posts/febb5061/"/>
      <url>/posts/febb5061/</url>
      
        <content type="html"><![CDATA[<h2 id="基本图形绘制"><a href="#基本图形绘制" class="headerlink" title="基本图形绘制"></a><strong>基本图形绘制</strong></h2><ul><li><code>Paint</code> 画笔，设置 画笔大小、粗细、画笔颜色、透明度、字体等样式</li><li><code>Canvas</code> 画布，画出成品的东西，如圆形、矩形、文字等。</li></ul><h3 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h3><p>基础使用：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.<span class="keyword">annotation</span>.SuppressLint</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color</span><br><span class="line"><span class="keyword">import</span> android.graphics.Paint</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasicView</span>: <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context): <span class="keyword">super</span>(context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, atts: AttributeSet): <span class="keyword">super</span>(context,atts)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, atts: AttributeSet, defStyle: <span class="built_in">Int</span>): <span class="keyword">super</span>(context,atts,defStyle)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="string">&quot;DrawAllocation&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">        <span class="comment">//设置画笔的基本属性</span></span><br><span class="line">        <span class="keyword">val</span> paint = Paint()</span><br><span class="line">        paint.run &#123;</span><br><span class="line">            <span class="comment">//设置画笔颜色</span></span><br><span class="line">            color = Color.RED</span><br><span class="line">            <span class="comment">//设置画笔填充样式</span></span><br><span class="line">            style = Paint.Style.STROKE</span><br><span class="line">            <span class="comment">//设置画笔宽度</span></span><br><span class="line">            strokeWidth = <span class="number">50f</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//画圆 cx: 圆心x坐标，cy: 圆心y坐标</span></span><br><span class="line">        canvas?.drawCircle(<span class="number">190f</span>,<span class="number">200f</span>,<span class="number">150f</span>,paint)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体代码见<a href="https://github.com/winstone-su/CustomView/blob/master/basicdrawing/src/main/java/com/carl/sample/basicdrawing/BasicView.kt">Github</a>： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Paint</span> <span class="variable">paint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">paint.setColor(Color.GREEN); <span class="comment">//设置画笔颜色</span></span><br><span class="line">paint.setStyle(Paint.Style.FILL);<span class="comment">//设置画笔样式 FILL : 填充, STROKE : 描边, FILL_AND_STROKE : 填充和描边</span></span><br><span class="line">paint.setStrokeWidth(<span class="number">5</span>); <span class="comment">//画笔宽度 px</span></span><br></pre></td></tr></table></figure><p>下面绘制一大一小两个圆，并且将这两个圆叠加起来，上方的圆半透明，代码如下:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> paint = Paint()</span><br><span class="line">paint.run &#123;</span><br><span class="line">    <span class="comment">//设置画笔颜色</span></span><br><span class="line">    color = Color.RED</span><br><span class="line">    <span class="comment">//设置画笔填充样式</span></span><br><span class="line">    style = Paint.Style.FILL</span><br><span class="line">    <span class="comment">//设置画笔宽度</span></span><br><span class="line">    strokeWidth = <span class="number">50f</span></span><br><span class="line">&#125;</span><br><span class="line">canvas?.drawCircle(<span class="number">190f</span>,<span class="number">200f</span>,<span class="number">150f</span>,paint)</span><br><span class="line">paint.color = <span class="number">0x7EFFFF00</span></span><br><span class="line">canvas?.drawCircle(<span class="number">190f</span>,<span class="number">200f</span>,<span class="number">100f</span>,paint)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/29/dyVXM2egIHL31xl.png" alt="paint1-1"></p><p><strong>paint.style</strong></p><p>完整的函数生命如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStyle</span><span class="params">(Style style)</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>该函数用于设置填充样式，对于文字和集合图形都有效。style的取值如下：</p><ul><li>Paint.Style.FILL仅填充内部</li><li>Paint.Style.FILL_AND_STROKE    填充内部和描边</li><li>Paint.Style.STROKE    仅描边</li></ul><p>下面以绘制圆形为例，看一下这三个不同的类型，效果图如下（代码见<a href="https://github.com/winstone-su/CustomView/blob/master/basicdrawing/src/main/java/com/carl/sample/basicdrawing/BasicView2.kt">Github</a>）</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/29/edZHyrLGwmDXV9W.png" alt="Paint.Style"></p><p>明显可见，<code>FILL_AND_STROKE</code>是<code>FILL</code>和<code>STROKE</code>叠加在一起的效果，<code>FILL_AND_STROKE</code>比<code>FILL</code>多了一个描边的宽度。</p><p><strong>paint.strokeWidth</strong></p><p>完整的函数声明如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrokeWidth</span><span class="params">(<span class="type">float</span> width)</span></span><br></pre></td></tr></table></figure><p>设置用于描边宽度，单位是px。当画笔的<code>Style</code>是<code>FILL</code>、<code>STROKE</code>、<code>FILL_AND_STROKE</code>时有效。</p><p>此外，<code>paint</code>还有一些属性和方法</p><ul><li><p><strong>paint.isAntiAlias</strong>  标识是否开启抗锯齿功能。抗锯齿是依赖算法的，一般在绘制不规则的图形时使用，比如圆形、文字等。在绘制棱角分明的图像，比如一个矩形，一张位图，是不需要打开抗锯齿功能的。</p></li><li><p><strong>paint.color</strong>  设置画笔的颜色</p></li></ul><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><h4 id="设置画布背景"><a href="#设置画布背景" class="headerlink" title="设置画布背景"></a>设置画布背景</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">canvas.drawColor(Color.GREEN);  <span class="comment">// drawColor(@ColorInt int color)</span></span><br><span class="line">canvas.drawRGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">255</span>);      <span class="comment">//drawRGB(int r, int g, int b) </span></span><br><span class="line">canvas.drawARGB(<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//drawARGB(int a, int r, int g, int b)</span></span><br></pre></td></tr></table></figure><p>其中<code>drawColor()</code>函数中参数<code>color</code>的取值必须是8位的0xAARRGGBB样式颜色值。</p><p><code>drawARGB()</code>函数允许分别传入A、R、G、B分量，每个颜色值得取值范围都是0<del>255(对应十六进制数0x00</del>0xFF)，内部会通过这些颜色分量构造出对应的颜色值。</p><p><code>drawRGB()</code>函数只允许传入R、G、B分量，透明度Alpha的取值为<code>255</code>。</p><p>比如将画布默认颜色填充为蓝色。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">canvas?.run &#123;</span><br><span class="line">    drawColor(Color.BLUE)</span><br><span class="line">    <span class="comment">//这两种写法也可以</span></span><br><span class="line">    <span class="comment">// drawARGB(0xFF,0x00,0x00,0xFF)</span></span><br><span class="line">    <span class="comment">// drawRGB(0x00,0x00,0xFF)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/29/Kch2Bb71TJ3Ruxj.png" alt="canvas"></p><h4 id="画直线"><a href="#画直线" class="headerlink" title="画直线"></a>画直线</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">drawLine</span><span class="params">(<span class="type">float</span> startX, <span class="type">float</span> startY, <span class="type">float</span> stopX, <span class="type">float</span> stopY, <span class="meta">@NonNull</span> Paint paint)</span></span><br></pre></td></tr></table></figure><p>参数含义:</p><ul><li>startX：起始点X坐标</li><li>startY：起始点Y坐标</li><li>stopX：终点X坐标</li><li>stopY：终点Y坐标</li></ul><p>示例如下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">paint.run &#123;</span><br><span class="line">    color = Color.RED</span><br><span class="line">    style = Paint.Style.FILL_AND_STROKE</span><br><span class="line">    strokeWidth = <span class="number">50f</span></span><br><span class="line">&#125;</span><br><span class="line">canvas?.run &#123;</span><br><span class="line">    drawLine(<span class="number">100f</span>,<span class="number">100f</span>,<span class="number">200f</span>,<span class="number">200f</span>,paint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当设置不同的<code>Style</code>类型时，效果如下图所示。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/29/1FEilmgY4yRGrZB.png" alt="image-20230329171700360"></p><p>可以看到，直线的粗细和笔画的<code>Style</code>是没有关系的。</p><p>当设置不同的<code>strokeWidth</code>时，效果如下：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/29/GXqFEfJmSvkPbL6.png" alt="canvas-strokeWidth"></p><p>可见，直线的粗细与<code>paint.strokeWidth</code>有直接关系。所以，一般而言，<code>paint.strokeWidth</code>在<code>Style</code>起作用时，用于设置描边宽度；在Style不起作用时，用于设置笔画宽度。</p><h4 id="画点"><a href="#画点" class="headerlink" title="画点"></a>画点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">drawPoint</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="meta">@NonNull</span> Paint paint)</span></span><br></pre></td></tr></table></figure><ul><li>float x：点的X坐标</li><li>float y：点的Y坐标</li></ul><p>示例如下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> paint = Paint()</span><br><span class="line">paint.run &#123;</span><br><span class="line">color = Color.CYAN</span><br><span class="line">    strokeWidth = <span class="number">15f</span></span><br><span class="line">&#125;</span><br><span class="line">canvas?.drawPoint(<span class="number">100f</span>,<span class="number">100f</span>,paint)</span><br></pre></td></tr></table></figure><p>代码很简单，就是在(100,100)的位置画了一个点。同样点的大小只与<code>paint.strokeWidth</code>有关，而与<code>paint.style</code>无关</p><h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><p><strong>工具类介绍</strong></p><p><code>Rect</code>F和<code>Rect</code>区别：<code>RectF</code>里面参数是float类型，<code>Rect</code>里面参数是int类型&#96;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RectF</span><span class="params">()</span> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RectF</span><span class="params">(<span class="type">float</span> left, <span class="type">float</span> top, <span class="type">float</span> right, <span class="type">float</span> bottom)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RectF</span><span class="params">(<span class="meta">@Nullable</span> RectF r)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RectF</span><span class="params">(<span class="meta">@Nullable</span> Rect r)</span> </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Rect</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Rect</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Rect</span><span class="params">(<span class="meta">@Nullable</span> Rect r)</span></span><br></pre></td></tr></table></figure><p>可以看到<code>RectF</code>和<code>Rect</code>的构造函数基本相同，不同的只是<code>RectF</code>所保存的数值类型是float类型，而<code>Rect</code>所保存的数值类型是int类型。</p><p>一般而言，要构造一个矩形结构，可以通过以下两种方式来实现。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接构造</span></span><br><span class="line"><span class="keyword">val</span> rect = Rect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment">//间接构造</span></span><br><span class="line"><span class="keyword">val</span> rect1 = Rect()</span><br><span class="line">rect1.<span class="keyword">set</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>看完了矩形的存储结构<code>RectF</code>、<code>Rect</code>之后，再来看看矩形的绘制方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRect</span><span class="params">(<span class="type">float</span> left, <span class="type">float</span> top, <span class="type">float</span> right, <span class="type">float</span> bottom, <span class="meta">@NonNull</span> Paint paint)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRect</span><span class="params">(<span class="meta">@NonNull</span> RectF rect, <span class="meta">@NonNull</span> Paint paint)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRect</span><span class="params">(<span class="meta">@NonNull</span> Rect r, <span class="meta">@NonNull</span> Paint paint)</span>  </span><br></pre></td></tr></table></figure><p>第一个函数是通过直接传入矩形的4个点来绘制的，第二、三个是通过根据传入的Rect或者RectF的矩形变量来指定所绘制的矩形的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">paint.run &#123;</span><br><span class="line">    color = Color.CYAN</span><br><span class="line">    strokeWidth = <span class="number">10f</span></span><br><span class="line">    style = Paint.Style.STROKE</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接构造</span></span><br><span class="line">canvas?.drawRect(<span class="number">10f</span>,<span class="number">10f</span>,<span class="number">100f</span>,<span class="number">100f</span>,paint)</span><br><span class="line"><span class="comment">//使用RectF构造</span></span><br><span class="line">paint.style = Paint.Style.FILL</span><br><span class="line"><span class="keyword">val</span> rectF = RectF(<span class="number">210f</span>,<span class="number">10f</span>,<span class="number">300f</span>,<span class="number">100f</span>)</span><br><span class="line">canvas?.drawRect(rectF,paint)</span><br></pre></td></tr></table></figure><p>这里绘制了两个同样大小的矩形，第一个直接用4个点来绘制矩形，并且填充为描边类型；第二个通过RectF来绘制矩形，并且填充内容。</p><p>效果图如下：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/30/Gmd4woz1ZOYyWuR.png" alt="rect"></p><p><strong>圆角矩形</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* rect: 要绘制的图形</span></span><br><span class="line"><span class="comment">* rx：生成圆角的椭圆X轴半径</span></span><br><span class="line"><span class="comment">* ry: 生成圆角的椭圆Y轴半径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">drawRoundRect</span><span class="params">(<span class="meta">@NonNull</span> RectF rect, <span class="type">float</span> rx, <span class="type">float</span> ry, <span class="meta">@NonNull</span> Paint paint)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">drawRoundRect</span><span class="params">(<span class="type">float</span> left, <span class="type">float</span> top, <span class="type">float</span> right, <span class="type">float</span> bottom, <span class="type">float</span> rx, <span class="type">float</span> ry,<span class="meta">@NonNull</span> Paint paint)</span></span><br></pre></td></tr></table></figure><p><code>shape</code>标签也可以设置矩形的圆角，与<code>shape</code>不同的是，<code>drawRoundRect()</code>函数不能针对每个角设置对应的椭圆，而只能统一设置4个角对应的椭圆。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> paint: Paint = Paint()</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">    paint.color = Color.GREEN</span><br><span class="line">    paint.strokeWidth = <span class="number">10f</span></span><br><span class="line">    paint.style = Paint.Style.FILL</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> rectF = RectF(<span class="number">100f</span>,<span class="number">10f</span>,<span class="number">300f</span>,<span class="number">100f</span>)</span><br><span class="line">canvas?.drawRoundRect(rectF,<span class="number">20f</span>,<span class="number">10f</span>,paint)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/31/fEFlJY3u74CaxG2.png" alt="drawRoundRect"></p><p><strong>圆形</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">float</span> cx, <span class="type">float</span> cy, <span class="type">float</span> radius, <span class="meta">@NonNull</span> Paint paint)</span> </span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><strong>cx</strong>   圆心点的X轴半径</li><li><strong>cy</strong>   圆心点的Y轴半径</li><li><strong>radius</strong>  圆的半径</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> paint: Paint = Paint()</span><br><span class="line">paint.color = Color.GREEN</span><br><span class="line">paint.strokeWidth = <span class="number">10f</span></span><br><span class="line">paint.style = Paint.Style.STROKE</span><br><span class="line">canvas?.drawCircle(<span class="number">150f</span>,<span class="number">150f</span>,<span class="number">100f</span>,paint)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/31/JW9HBQaowu73SCE.png" alt="drawCircle"></p><p><strong>椭圆</strong></p><p>椭圆是根据矩形生成的，以矩形的长为椭圆的X轴，以矩形的宽为椭圆的Y轴。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawOval</span><span class="params">(<span class="meta">@NonNull</span> RectF oval, <span class="meta">@NonNull</span> Paint paint)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawOval</span><span class="params">(<span class="type">float</span> left, <span class="type">float</span> top, <span class="type">float</span> right, <span class="type">float</span> bottom, <span class="meta">@NonNull</span> Paint paint)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">rect</span> <span class="operator">=</span> RectF(<span class="number">300f</span>,<span class="number">10f</span>,<span class="number">600f</span>,<span class="number">100f</span>)</span><br><span class="line">canvas?.drawOval(rect,paint)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/31/I8dLeFk6nN1SiX5.png" alt="oval"></p><p><strong>弧</strong></p><p>弧是椭圆的一部分，而椭圆是根据矩形来生成的，所以弧也是根据矩形来生成的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawArc</span><span class="params">(<span class="meta">@NonNull</span> RectF oval, <span class="type">float</span> startAngle, <span class="type">float</span> sweepAngle, <span class="type">boolean</span> useCenter,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> Paint paint)</span> &#123;</span><br></pre></td></tr></table></figure><h3 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h3><p>前面提到，除手动组合颜色的方法外，系统还提供了一个专门用来解析颜色的类：<code>Color</code>。<code>Color</code>是Android中与颜色处理有关的类。</p><h4 id="常量颜色"><a href="#常量颜色" class="headerlink" title="常量颜色"></a>常量颜色</h4><p>首先，它定义了很多常亮的颜色值，可以直接使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ColorInt</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BLACK</span>       <span class="operator">=</span> <span class="number">0xFF000000</span>;</span><br><span class="line"><span class="meta">@ColorInt</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DKGRAY</span>      <span class="operator">=</span> <span class="number">0xFF444444</span>;</span><br><span class="line"><span class="meta">@ColorInt</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GRAY</span>        <span class="operator">=</span> <span class="number">0xFF888888</span>;</span><br><span class="line"><span class="meta">@ColorInt</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LTGRAY</span>      <span class="operator">=</span> <span class="number">0xFFCCCCCC</span>;</span><br><span class="line"><span class="meta">@ColorInt</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WHITE</span>       <span class="operator">=</span> <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"><span class="meta">@ColorInt</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RED</span>         <span class="operator">=</span> <span class="number">0xFFFF0000</span>;</span><br><span class="line"><span class="meta">@ColorInt</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GREEN</span>       <span class="operator">=</span> <span class="number">0xFF00FF00</span>;</span><br><span class="line"><span class="meta">@ColorInt</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BLUE</span>        <span class="operator">=</span> <span class="number">0xFF0000FF</span>;</span><br><span class="line"><span class="meta">@ColorInt</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">YELLOW</span>      <span class="operator">=</span> <span class="number">0xFFFFFF00</span>;</span><br><span class="line"><span class="meta">@ColorInt</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CYAN</span>        <span class="operator">=</span> <span class="number">0xFF00FFFF</span>;</span><br><span class="line"><span class="meta">@ColorInt</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAGENTA</span>     <span class="operator">=</span> <span class="number">0xFFFF00FF</span>;</span><br></pre></td></tr></table></figure><p>可以通过<code>Color.XXX</code>来直接使用这些颜色。</p><h4 id="构造颜色"><a href="#构造颜色" class="headerlink" title="构造颜色"></a>构造颜色</h4><ol><li>带有透明度的颜色</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">argb</span><span class="params">(<span class="type">int</span> alpha,<span class="type">int</span> red,<span class="type">int</span> green, <span class="type">int</span> blue)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">argb</span><span class="params">(<span class="type">float</span> alpha,<span class="type">float</span> red,<span class="type">float</span> green, <span class="type">float</span> blue)</span></span><br></pre></td></tr></table></figure><p>这个函数允许我们传入A、R、G、B 4个颜色分量，然后合并一个颜色。其中，alpha、red、green、blue 4个色彩分量的取值范围都是0~255</p><ol start="2"><li>不带透明度的颜色</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rgb</span><span class="params">(<span class="type">float</span> red, <span class="type">float</span> green, <span class="type">float</span> blue)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">argb</span><span class="params">(<span class="type">int</span> alpha,<span class="type">int</span> red,<span class="type">int</span> green,<span class="type">int</span> blue)</span> </span><br></pre></td></tr></table></figure><p>类似上面的带透明度的颜色，只是不需要传入alpha</p><ol start="3"><li>提取颜色分量</li></ol><p>我们不仅能通过Color类来合并颜色分量，而且能从一个颜色中提取指定的颜色分量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">alpha</span><span class="params">(<span class="type">int</span> color)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">red</span><span class="params">(<span class="type">int</span> color)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">green</span><span class="params">(<span class="type">int</span> color)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">blue</span><span class="params">(<span class="type">int</span> color)</span></span><br></pre></td></tr></table></figure><p>我们能通过上面的4个函数提取出颜色对应的A、R、G、B颜色分量。</p><p>比如：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> green = Color.green(<span class="number">0xFF000F00</span>)</span><br></pre></td></tr></table></figure><p>得到的结果green的值就是<code>0x0F</code>。</p><blockquote><p>前面的示例中创建Paint对象和其他对象都是在onDraw()函数中实现的，这个实际开发是不被允许的。因为当需要重绘时，就会调用onDraw()函数，所以onDraw()中的变量会被重复创建，可能引发GC问题。一般在自定义控件的构造函数中创建变量，即在初始化时一次性创建。</p></blockquote><h2 id="路径-Path"><a href="#路径-Path" class="headerlink" title="路径 (Path)"></a>路径 (Path)</h2><p>在Android中，<code>Path</code>类就代表路径。</p><p>在Canvas中绘制路径的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawPath</span><span class="params">(<span class="meta">@NonNull</span> Path path, <span class="meta">@NonNull</span> Paint paint)</span></span><br></pre></td></tr></table></figure><h4 id="直线路径"><a href="#直线路径" class="headerlink" title="直线路径"></a>直线路径</h4><p>画一条直线路径，一般设计下面三个函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveTo</span><span class="params">(<span class="type">float</span> x1, <span class="type">float</span> y1)</span></span><br></pre></td></tr></table></figure><p>(x1,y1)是直线的起始点，即将直线路径的绘制点定在(x1,y1)位置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lineTo</span><span class="params">(<span class="type">float</span> x2, <span class="type">float</span> y2)</span> </span><br></pre></td></tr></table></figure><p>(x2,y2)是直线的终点，又是下一次绘制直线路径的起始点；lineTo()函数可以一直使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>如果连续画了几条直线，但是没有形成闭环，那么调用close()函数会将路径收尾连接起来，形成闭环。</p><p>示例: 画一个三角形</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 自定义View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-07-14-iOS本地化(Swift)</title>
      <link href="/posts/98025dc/"/>
      <url>/posts/98025dc/</url>
      
        <content type="html"><![CDATA[<h2 id="1-项目配置"><a href="#1-项目配置" class="headerlink" title="1. 项目配置"></a>1. 项目配置</h2><ul><li><p>如下图为项目添加不同语种</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/hj5JWYuGnRPNAKb.png" alt="0714-1"></p></li><li><p>弹框中显示要为显示的文件添加语种信息</p></li><li><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/CodvkwshMcXm45E.png" alt="0714-2">添加完多语种后，相关需要本地化的文件会产生一组文件</p></li></ul><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/7eU4ywRIkPC3Tjd.png" alt="0714-3">实际在目录结构中是根据不同语言生成不同的<code>*.lproj</code>目录，再在<code>*.lproj</code>目录中生成了不同的<code>.strings</code>文件。</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/w74VTnAGYvWi5pE.png" alt="0714-4"></p><h2 id="2-应用名称本地化"><a href="#2-应用名称本地化" class="headerlink" title="2. 应用名称本地化"></a>2. 应用名称本地化</h2><ul><li>新建一个<code>.strings</code>文件，名为<code>InfoPlist.strings</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基础用法</title>
      <link href="/posts/4ce13562/"/>
      <url>/posts/4ce13562/</url>
      
        <content type="html"><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>​Markdown 支持无序列表和有序列表。</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>​无序列表使用星号(<code>*</code>)、加号(<code>+</code>)或者减号(<code>-</code>)作为列表标记，这些列表要加一个空格，然后再填写内容。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项</span><br><span class="line"><span class="bullet">*</span> 第二项</span><br><span class="line"><span class="bullet">*</span> 第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> 第一项</span><br><span class="line"><span class="bullet">+</span> 第二项</span><br><span class="line"><span class="bullet">+</span> 第三项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 第一项</span><br><span class="line"><span class="bullet">-</span> 第二项</span><br><span class="line"><span class="bullet">-</span> 第三项</span><br></pre></td></tr></table></figure><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/13/zLjXWC9tOx6pVwE.png" alt="无序列表"></p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="bullet">3.</span> 第三项</span><br></pre></td></tr></table></figure><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/13/suAQlZ6rChbwjtN.png" alt="有序列表"></p><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>​列表嵌套只需在子列表中的选项前面添加四个空格即可:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一项：</span><br><span class="line">    - 第一项嵌套的第一个元素</span><br><span class="line">    - 第一项嵌套的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">    - 第二项嵌套的第一个元素</span><br><span class="line">    - 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/13/wADjpOcU2ImWrsR.png" alt="嵌套列表"></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中使用MJExtension处理OC里的id关键字</title>
      <link href="/posts/1e867d3c/"/>
      <url>/posts/1e867d3c/</url>
      
        <content type="html"><![CDATA[<p>利用<code>MJExtension</code> 解析json -&gt; model 遇到OC关键字<code>id</code>,处理方法:</p><p>在 Model 中使用方法:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+(NSDictionary *)mj_replacedKeyFromPropertyName</span><br><span class="line">&#123;</span><br><span class="line">    return @&#123;@&quot;ID&quot;:@&quot;id&quot;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者写个统一的类处理相同的请求:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Xxx mj_setupReplacedKeyFromPropertyName:^NSDictionary *&#123;</span><br><span class="line">       return @&#123;</span><br><span class="line">                  @&quot;ID&quot; : @&quot;id&quot;,</span><br><span class="line">              &#125;;</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下显示隐藏文件</title>
      <link href="/posts/6bbdb753/"/>
      <url>/posts/6bbdb753/</url>
      
        <content type="html"><![CDATA[<p> Mac OS X 10.9 Mavericks版本之后:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder //显示隐藏文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder //不显示隐藏文件</span><br></pre></td></tr></table></figure><p>快捷键:</p><p>在 macOS Sierra及以上版本，可以使用快捷键<code>⌘⇧.(Command + Shift + .)</code> 来快速（在<code> Finder</code> 中）显示和隐藏文件了</p>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac终端走代理的方法</title>
      <link href="/posts/af6fd79/"/>
      <url>/posts/af6fd79/</url>
      
        <content type="html"><![CDATA[<p>​在终端输入:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export &#123;http,https&#125;_proxy=&#x27;http://ip:port&#x27;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export &#123;http,https&#125;_proxy=&#x27;http://127.0.0.1:1087&#x27;</span><br></pre></td></tr></table></figure><p>发现一个小问题：通过<code>Cisco</code>的<code>Any Connect</code> 连接的<code>vpn</code> 终端还是没办法使用</p>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jekyll错误汇总</title>
      <link href="/posts/e36339c4/"/>
      <url>/posts/e36339c4/</url>
      
        <content type="html"><![CDATA[<p><code>目前已经不用Jekyll，改用Hexo</code></p><h2 id="Jekyll-启动错误cannot-load-such-file-–-webrick"><a href="#Jekyll-启动错误cannot-load-such-file-–-webrick" class="headerlink" title="Jekyll 启动错误cannot load such file – webrick"></a>Jekyll 启动错误cannot load such file – webrick</h2><p>在windows在安装jekyll,在执行<code> bundle exec jekyll serve</code>的时候发现错误</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cannot load such file -- webrick</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve/servlet.rb:3:in `require&#x27;: cannot load such file -- webrick (LoadError)</span><br><span class="line">        from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve/servlet.rb:3:in `&lt;top (required)&gt;&#x27;</span><br><span class="line">        from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:179:in `require_relative&#x27;</span><br><span class="line">        from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:179:in `setup&#x27;</span><br><span class="line">        from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:100:in `process&#x27;</span><br><span class="line">        from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `block in process_with_graceful_fail&#x27;</span><br><span class="line">        from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `each&#x27;</span><br><span class="line">        from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `process_with_graceful_fail&#x27;</span><br><span class="line">        from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:86:in `block (2 levels) in init_with_program&#x27;</span><br><span class="line">        from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `block in execute&#x27;</span><br><span class="line">        from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `each&#x27;</span><br><span class="line">        from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `execute&#x27;</span><br><span class="line">        from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/program.rb:44:in `go&#x27;</span><br><span class="line">        from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary.rb:21:in `program&#x27;</span><br><span class="line">        from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/exe/jekyll:15:in `&lt;top (required)&gt;&#x27;</span><br><span class="line">        from C:/Ruby31-x64/bin/jekyll:25:in `load&#x27;</span><br><span class="line">        from C:/Ruby31-x64/bin/jekyll:25:in `</span><br></pre></td></tr></table></figure><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>Ruby版本太高，默认不支持<code>webrick</code></p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p><a href="https://jekyllrb.com/docs/">https://jekyllrb.com/docs/</a> </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">If you are using Ruby version 3.0.0 or higher, step 5 may fail. You may fix it by adding webrick to your dependencies: bundle add webrick</span><br></pre></td></tr></table></figure><p>在启动Jekyll之前,先执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bundle add webrick</span><br></pre></td></tr></table></figure><p>再执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bundle exec jekyll serve</span><br></pre></td></tr></table></figure><h2 id="Jekyll-运行时错误：-check-for-activated-spec"><a href="#Jekyll-运行时错误：-check-for-activated-spec" class="headerlink" title="Jekyll 运行时错误： check_for_activated_spec!"></a><code>Jekyll</code> 运行时错误： check_for_activated_spec!</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/Library/Ruby/Gems/2.6.0/gems/bundler-2.1.4/lib/bundler/runtime.rb:312:in `check_for_activated_spec!&#x27;:</span><br><span class="line">You have already activated i18n 1.8.3, but your Gemfile requires i18n 0.9.5.</span><br><span class="line">Prepending `bundle exec` to your command may solve this. (Gem::LoadError)</span><br></pre></td></tr></table></figure><p>​解决办法:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bundle update</span><br></pre></td></tr></table></figure><p> 修改 <code>Gemfile.lock</code> 将 <code>i18n</code> 配置升级为<code>1.8.3</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bundle exec jekyll serve</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> jekyll </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jekyll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode导出IPA包四个选项的含义</title>
      <link href="/posts/88e6fe20/"/>
      <url>/posts/88e6fe20/</url>
      
        <content type="html"><![CDATA[<p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/09/opZQNR3MPDmClbr.png" alt="img" title="ipa"></p><h3 id="1-Save-for-iOS-App-Store-Deployment"><a href="#1-Save-for-iOS-App-Store-Deployment" class="headerlink" title="1.Save for iOS App Store Deployment"></a>1.Save for iOS App Store Deployment</h3><p>保存到本地 准备上传App Store 或者在越狱的iOS设备上使用</p><h3 id="2-Save-for-Ad-Hoc-Deployment"><a href="#2-Save-for-Ad-Hoc-Deployment" class="headerlink" title="2.Save for Ad Hoc Deployment"></a>2.Save for Ad Hoc Deployment</h3><p>保存到本地 准备在账号添加的可使用设备上使用（具体为在开发者账户下添加可用设备的udid），该app包是发布证书编译的（The app will be code signed with the distribution certificate.）</p><h3 id="3-Save-for-Enterprise-Deployment"><a href="#3-Save-for-Enterprise-Deployment" class="headerlink" title="3.Save for Enterprise Deployment"></a>3.Save for Enterprise Deployment</h3><p>企业级分发</p><h3 id="4-Save-for-Development-Deployment"><a href="#4-Save-for-Development-Deployment" class="headerlink" title="4. Save for Development Deployment"></a>4. Save for Development Deployment</h3><p>针对内部测试使用，主要给开发者的设备(具体也为在开发者账户下添加可用设备的udid)。该app包是开发证书编译的（The app will be code signed with your development certificate）</p><p><strong>2与4的区别就在于，一个是用发布证书打包，一个是用开发证书打包</strong></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSLog格式化输出</title>
      <link href="/posts/345144e5/"/>
      <url>/posts/345144e5/</url>
      
        <content type="html"><![CDATA[<ul><li>%@ 对象 </li><li>%d, %i 整数 </li><li>%u 无符整形 </li><li>%f 浮点&#x2F;双字 </li><li>%x, %X 二进制整数 </li><li>%o 八进制整数 </li><li>%zu size_t </li><li>%p 指针 </li><li>%e 浮点&#x2F;双字 （科学计算） </li><li>%g 浮点&#x2F;双字 </li><li>%s C 字符串 </li><li>%.*s Pascal字符串 </li><li>%c 字符 </li><li>%C unichar </li><li>%lld 64位长整数（long long） </li><li>%llu 无符64位长整数 </li><li>%Lf 64位双字</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度iOS面试题</title>
      <link href="/posts/eea0d40d/"/>
      <url>/posts/eea0d40d/</url>
      
        <content type="html"><![CDATA[<p>1.请解释一下KVO、KVC的含义.</p><p>2.怎么实现多重继承 </p><p>3.GCD死锁产生以解决方案？ </p><p>4.iOS事件传递机制 </p><p>5.UITableView重用机制 </p><p>6.NSString用copy是深拷贝还是浅拷贝？ </p><p>7.UIViewController声明周期 </p><p>8.loadView和viewDidload的区别 </p><p>9.iOS App的几种状态，双击Home键是什么状态，可以相应用户输入吗？ </p><p>10.viewDidUnLoad这个方法还在使用吗？ </p><p>11.frame和bounds的区别</p><p>大概就记得这么多。。。 </p><p>8、10 题答案参考 </p><p><a href="http://blog.csdn.net/q199109106q/article/details/8614044">http://blog.csdn.net/q199109106q/article/details/8614044 </a></p><p>2参考   <a href="http://ios.jobbole.com/82622/">http://ios.jobbole.com/82622/</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS WebView不响应input标签</title>
      <link href="/posts/c762ae2b/"/>
      <url>/posts/c762ae2b/</url>
      
        <content type="html"><![CDATA[<p>遇到一个超级坑的问题，一个普通的HTML里面有一个上传图片的功能，用了这个标签，点击标签可以弹出选择图片的actionsheet.</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/09/TvEDebL9fJoPNgu.jpg" alt="ActionSheet" title="Photo Library"></p><p>但是点了选项只有没有任何反应，还会关闭当前的webview </p><p>在点了标签后，调试会报出以下错误</p><pre><code>Passed in type public.item doesn&#39;t conform to either public.content or public.data. If you are exporting a new type, please ensure that it conforms to an appropriate parent type.the behavior of the UICollectionViewFlowLayout is not defined because:the item width must be less than the width of the UICollectionView minus the section insets left and right values, minus the content insets left and right values.The relevant UICollectionViewFlowLayout instance is &lt;_UIAlertControllerCollectionViewFlowLayout: 0x7fd0585c9fb0&gt;, and it is attached to &lt;UICollectionView: 0x7fd058837800; frame = (0 44; 10 0); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7fd0585cacf0&gt;; animations = &#123; bounds.origin=&lt;CASpringAnimation: 0x7fd05a83daf0&gt;; bounds.size=&lt;CASpringAnimation: 0x7fd05a83e2c0&gt;; position=&lt;CASpringAnimation: 0x7fd05a83e450&gt;; &#125;; layer = &lt;CALayer: 0x7fd0585ca830&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt; collection view layout: &lt;_UIAlertControllerCollectionViewFlowLayout: 0x7fd0585c9fb0&gt;.Make a symbolic breakpoint at UICollectionViewFlowLayoutBreakForInvalidSizes to catch this in the debugger.</code></pre><p>然后各种查看这个错误，发现我的这个webviewController是present进来的，然后把进入方式改成pushviewController就可以了</p><p>参考链接: <a href="http://stackoverflow.com/questions/25942676/ios-8-sdk-modal-uiwebview-and-camera-image-picker">http://stackoverflow.com/questions/25942676/ios-8-sdk-modal-uiwebview-and-camera-image-picker</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio 主工程 无法引用子Module中的依赖问题</title>
      <link href="/posts/b62bc126/"/>
      <url>/posts/b62bc126/</url>
      
        <content type="html"><![CDATA[<p>最近在构建Android项目的时候发现，主工程无法引用子Module中的依赖。</p><p>处理方法： 在子<code>module</code>的<code>build.gradle</code>中对第三方库得依赖方式从<code>implementation</code>为<code>api</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">implementation &quot;com.squareup.retrofit2:retrofit:2.9.0&quot;</span><br><span class="line">//改为</span><br><span class="line">api &quot;com.squareup.retrofit2:retrofit:2.9.0&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Studio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode 使用 TODO、FIXME、!!!、???、MARK标记用法</title>
      <link href="/posts/4e994fde/"/>
      <url>/posts/4e994fde/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h2><ul><li><code>MARK</code>: 标记，和#pragma mark效果类似，使用方法 <code>// MARK:</code></li><li>TODO<code>: 标示处有功能代码待编写，使用方法  </code>&#x2F;&#x2F; TODO:</li><li><code>FIXME</code>: 标示处代码需要修正，使用方法： <code>//FIXME</code>:</li><li><code>!!!</code>: 标示处代码需要注意，使用方法: <code>//!!!</code> </li><li>???<code>: 标示处代码有疑问，使用方法： </code>&#x2F;&#x2F;???&#96;</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法:"></a>基本用法:</h2><ul><li>单独使用:</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//MARK: 追攀更觉相逢晚，谈笑难忘欲别前</span><br></pre></td></tr></table></figure><ul><li>组合使用： 添加 <code>-</code> ，两个 <code>-</code> 之间的就会被算做一组</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// MARK: - 井底点灯深烛伊,共郎长行莫围棋</span><br><span class="line">// TODO:   玲珑骰子安红豆,入骨相思知不知</span><br><span class="line">// TODO:   愿我如星君如月,夜夜流光相皎洁</span><br><span class="line">// MARK: - 妾弄青梅凭短墙,君骑白马傍垂杨</span><br><span class="line">// FIXME:  愿得红罗千万匹,漫天匝地绣鸳鸯</span><br><span class="line">// MARK: - 独来独往银粟地,一行一步玉沙声</span><br><span class="line">// !!!:    无人与我立黄昏,无人问我粥可温</span><br><span class="line">// ???:    寒夜读书忘却眠，锦衾香尽炉无烟</span><br></pre></td></tr></table></figure><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/furMmA87gJWPaKX.png" alt="0811-1"></p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/ZPi2od7aC4zTwl6.png" alt="0811-2"></p><h2 id="子标注"><a href="#子标注" class="headerlink" title="子标注"></a>子标注</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//MARK: 追攀更觉相逢晚，谈笑难忘欲别前</span><br><span class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;</span><br><span class="line">    //TODO: 夜深忽梦少年事，梦啼妆泪红阑干</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //TODO:  春风得意马蹄疾,一日看尽长安花</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/14/8lY2ZwWLqikJByU.png" alt="0811-3"></p>]]></content>
      
      
      <categories>
          
          <category> Xcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用github作iOS企业分发App</title>
      <link href="/posts/758d9e1c/"/>
      <url>/posts/758d9e1c/</url>
      
        <content type="html"><![CDATA[<p>iOS7.0以后安装企业分发App需要HTTPS证书，如果网站没有CA受信用的HTTPS证书,可以利用github来实现。</p><p>首先在Github上面新建一个Repository,然后把已经制作好的Plist文件上传上去,点开plist找到Raw</p><p><img src= "https://s2.loli.net/2023/03/09/dog2qQY83iTIvHM.gif" data-lazy-src="https://s2.loli.net/2023/03/09/n3d5Bg1H6rUZsA9.jpg" alt="img" title="carl"></p><p>看到别人用七牛(<a href="http://www.qiniu.com/">http://www.qiniu.com</a>)也可以实现企业分发,不过这个网站需要上传身份证正反照片,手上暂时没有,下次再做测试。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mobileprovision文件位置</title>
      <link href="/posts/a64d03b5/"/>
      <url>/posts/a64d03b5/</url>
      
        <content type="html"><![CDATA[<p>总是忘了描述文件的位置，这次还是记下来，已备查用</p><pre><code>/Users/XXX/Library/MobileDevice/Provisioning Profiles</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
